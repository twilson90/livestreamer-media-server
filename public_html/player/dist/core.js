var core = (function (exports) {
  'use strict';

  var top = 'top';
  var bottom = 'bottom';
  var right = 'right';
  var left = 'left';
  var auto = 'auto';
  var basePlacements = [top, bottom, right, left];
  var start = 'start';
  var end = 'end';
  var clippingParents = 'clippingParents';
  var viewport = 'viewport';
  var popper = 'popper';
  var reference = 'reference';
  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []); // modifiers that need to read the DOM

  var beforeRead = 'beforeRead';
  var read = 'read';
  var afterRead = 'afterRead'; // pure-logic modifiers

  var beforeMain = 'beforeMain';
  var main = 'main';
  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

  var beforeWrite = 'beforeWrite';
  var write = 'write';
  var afterWrite = 'afterWrite';
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
  }

  function getWindow(node) {
    if (node == null) {
      return window;
    }

    if (node.toString() !== '[object Window]') {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }

    return node;
  }

  function isElement$2(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }

  function isHTMLElement$1(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }

  function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === 'undefined') {
      return false;
    }

    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // and applies them to the HTMLElements such as popper and arrow

  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name]; // arrow is optional + virtual elements

      if (!isHTMLElement$1(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe[cannot-write]


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];

        if (value === false) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value === true ? '' : value);
        }
      });
    });
  }

  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;

    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }

    return function () {
      Object.keys(state.elements).forEach(function (name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

        var style = styleProperties.reduce(function (style, property) {
          style[property] = '';
          return style;
        }, {}); // arrow is optional + virtual elements

        if (!isHTMLElement$1(element) || !getNodeName(element)) {
          return;
        }

        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  } // eslint-disable-next-line import/no-unused-modules


  var applyStyles$1 = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: effect$2,
    requires: ['computeStyles']
  };

  function getBasePlacement$1(placement) {
    return placement.split('-')[0];
  }

  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  function getUAString() {
    var uaData = navigator.userAgentData;

    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function (item) {
        return item.brand + "/" + item.version;
      }).join(' ');
    }

    return navigator.userAgent;
  }

  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  function getBoundingClientRect$1(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }

    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }

    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;

    if (includeScale && isHTMLElement$1(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }

    var _ref = isElement$2(element) ? getWindow(element) : window,
        visualViewport = _ref.visualViewport;

    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x: x,
      y: y
    };
  }

  // means it doesn't take into account transforms.

  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect$1(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223

    var width = element.offsetWidth;
    var height = element.offsetHeight;

    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }

    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }

    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width,
      height: height
    };
  }

  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

    if (parent.contains(child)) {
      return true;
    } // then fallback to custom implementation with Shadow DOM support
    else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;

        do {
          if (next && parent.isSameNode(next)) {
            return true;
          } // $FlowFixMe[prop-missing]: need a better way to handle this...


          next = next.parentNode || next.host;
        } while (next);
      } // Give up, the result is false


    return false;
  }

  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }

  function isTableElement(element) {
    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
  }

  function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return ((isElement$2(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
    element.document) || window.document).documentElement;
  }

  function getParentNode(element) {
    if (getNodeName(element) === 'html') {
      return element;
    }

    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || ( // DOM Element detected
      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element) // fallback

    );
  }

  function getTrueOffsetParent(element) {
    if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle$1(element).position === 'fixed') {
      return null;
    }

    return element.offsetParent;
  } // `.offsetParent` reports `null` for fixed elements, while absolute elements
  // return the containing block


  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());

    if (isIE && isHTMLElement$1(element)) {
      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
      var elementCss = getComputedStyle$1(element);

      if (elementCss.position === 'fixed') {
        return null;
      }
    }

    var currentNode = getParentNode(element);

    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }

    while (isHTMLElement$1(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
      // create a containing block.
      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }

    return null;
  } // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.


  function getOffsetParent(element) {
    var window = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);

    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
      offsetParent = getTrueOffsetParent(offsetParent);
    }

    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
      return window;
    }

    return offsetParent || getContainingBlock(element) || window;
  }

  function getMainAxisFromPlacement(placement) {
    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
  }

  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }
  function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
  }

  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  };

  function arrow(_ref) {
    var _state$modifiersData$;

    var state = _ref.state,
        name = _ref.name,
        options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement$1(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';

    if (!arrowElement || !popperOffsets) {
      return;
    }

    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === 'y' ? top : left;
    var maxProp = axis === 'y' ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds

    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = within(min, center, max); // Prevents breaking syntax highlighting...

    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
  }

  function effect$1(_ref2) {
    var state = _ref2.state,
        options = _ref2.options;
    var _options$element = options.element,
        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

    if (arrowElement == null) {
      return;
    } // CSS selector


    if (typeof arrowElement === 'string') {
      arrowElement = state.elements.popper.querySelector(arrowElement);

      if (!arrowElement) {
        return;
      }
    }

    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }

    state.elements.arrow = arrowElement;
  } // eslint-disable-next-line import/no-unused-modules


  var arrow$1 = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: effect$1,
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow']
  };

  function getVariation(placement) {
    return placement.split('-')[1];
  }

  var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
  }; // Round the offsets to the nearest suitable subpixel based on the DPR.
  // Zooming can change the DPR, but it seems to report a value that will
  // cleanly divide the values into the appropriate subpixels.

  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x,
        y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }

  function mapToStyles(_ref2) {
    var _Object$assign2;

    var popper = _ref2.popper,
        popperRect = _ref2.popperRect,
        placement = _ref2.placement,
        variation = _ref2.variation,
        offsets = _ref2.offsets,
        position = _ref2.position,
        gpuAcceleration = _ref2.gpuAcceleration,
        adaptive = _ref2.adaptive,
        roundOffsets = _ref2.roundOffsets,
        isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x,
        x = _offsets$x === void 0 ? 0 : _offsets$x,
        _offsets$y = offsets.y,
        y = _offsets$y === void 0 ? 0 : _offsets$y;

    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
      x: x,
      y: y
    }) : {
      x: x,
      y: y
    };

    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = left;
    var sideY = top;
    var win = window;

    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = 'clientHeight';
      var widthProp = 'clientWidth';

      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);

        if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
          heightProp = 'scrollHeight';
          widthProp = 'scrollWidth';
        }
      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


      offsetParent = offsetParent;

      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
        offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }

      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
        offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }

    var commonStyles = Object.assign({
      position: position
    }, adaptive && unsetSides);

    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x,
      y: y
    }, getWindow(popper)) : {
      x: x,
      y: y
    };

    x = _ref4.x;
    y = _ref4.y;

    if (gpuAcceleration) {
      var _Object$assign;

      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }

    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
  }

  function computeStyles(_ref5) {
    var state = _ref5.state,
        options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
        _options$adaptive = options.adaptive,
        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
        _options$roundOffsets = options.roundOffsets,
        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement$1(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration: gpuAcceleration,
      isFixed: state.options.strategy === 'fixed'
    };

    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
      })));
    }

    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets: roundOffsets
      })));
    }

    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-placement': state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var computeStyles$1 = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {}
  };

  var passive = {
    passive: true
  };

  function effect(_ref) {
    var state = _ref.state,
        instance = _ref.instance,
        options = _ref.options;
    var _options$scroll = options.scroll,
        scroll = _options$scroll === void 0 ? true : _options$scroll,
        _options$resize = options.resize,
        resize = _options$resize === void 0 ? true : _options$resize;
    var window = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.addEventListener('resize', instance.update, passive);
    }

    return function () {
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.removeEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.removeEventListener('resize', instance.update, passive);
      }
    };
  } // eslint-disable-next-line import/no-unused-modules


  var eventListeners = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {},
    effect: effect,
    data: {}
  };

  var hash$1 = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash$1[matched];
    });
  }

  var hash$2 = {
    start: 'end',
    end: 'start'
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
      return hash$2[matched];
    });
  }

  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft: scrollLeft,
      scrollTop: scrollTop
    };
  }

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return getBoundingClientRect$1(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;

    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();

      if (layoutViewport || !layoutViewport && strategy === 'fixed') {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }

    return {
      width: width,
      height: height,
      x: x + getWindowScrollBarX(element),
      y: y
    };
  }

  // of the `<html>` and `<body>` rect bounds if horizontally scrollable

  function getDocumentRect(element) {
    var _element$ownerDocumen;

    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;

    if (getComputedStyle$1(body || html).direction === 'rtl') {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }

    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  }

  function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle$1(element),
        overflow = _getComputedStyle.overflow,
        overflowX = _getComputedStyle.overflowX,
        overflowY = _getComputedStyle.overflowY;

    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  function getScrollParent(node) {
    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return node.ownerDocument.body;
    }

    if (isHTMLElement$1(node) && isScrollParent(node)) {
      return node;
    }

    return getScrollParent(getParentNode(node));
  }

  /*
  given a DOM element, return the list of all scroll parents, up the list of ancesors
  until we get to the top window object. This list is what we attach scroll listeners
  to, because if any of these parent elements scroll, we'll need to re-calculate the
  reference element's position.
  */

  function listScrollParents(element, list) {
    var _element$ownerDocumen;

    if (list === void 0) {
      list = [];
    }

    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)));
  }

  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect$1(element, false, strategy === 'fixed');
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }

  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$2(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  } // A "clipping parent" is an overflowable container with the characteristic of
  // clipping (or hiding) overflowing elements with a position different from
  // `initial`


  function getClippingParents(element) {
    var clippingParents = listScrollParents(getParentNode(element));
    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;

    if (!isElement$2(clipperElement)) {
      return [];
    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


    return clippingParents.filter(function (clippingParent) {
      return isElement$2(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
    });
  } // Gets the maximum area that the element is visible in due to any number of
  // clipping parents


  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  function computeOffsets(_ref) {
    var reference = _ref.reference,
        element = _ref.element,
        placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement$1(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;

    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;

      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;

      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;

      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;

      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }

    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

    if (mainAxis != null) {
      var len = mainAxis === 'y' ? 'height' : 'width';

      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;

        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;
      }
    }

    return offsets;
  }

  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$placement = _options.placement,
        placement = _options$placement === void 0 ? state.placement : _options$placement,
        _options$strategy = _options.strategy,
        strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
        _options$boundary = _options.boundary,
        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
        _options$rootBoundary = _options.rootBoundary,
        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
        _options$elementConte = _options.elementContext,
        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
        _options$altBoundary = _options.altBoundary,
        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
        _options$padding = _options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement$2(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect$1(state.elements.reference);
    var popperOffsets = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: 'absolute',
      placement: placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect

    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

    if (elementContext === popper && offsetData) {
      var offset = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function (key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
        overflowOffsets[key] += offset[axis] * multiply;
      });
    }

    return overflowOffsets;
  }

  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        placement = _options.placement,
        boundary = _options.boundary,
        rootBoundary = _options.rootBoundary,
        padding = _options.padding,
        flipVariations = _options.flipVariations,
        _options$allowedAutoP = _options.allowedAutoPlacements,
        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
      return getVariation(placement) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function (placement) {
      return allowedAutoPlacements.indexOf(placement) >= 0;
    });

    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


    var overflows = allowedPlacements.reduce(function (acc, placement) {
      acc[placement] = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding
      })[getBasePlacement$1(placement)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b) {
      return overflows[a] - overflows[b];
    });
  }

  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement$1(placement) === auto) {
      return [];
    }

    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }

  function flip(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;

    if (state.modifiersData[name]._skip) {
      return;
    }

    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
        specifiedFallbackPlacements = options.fallbackPlacements,
        padding = options.padding,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        _options$flipVariatio = options.flipVariations,
        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
        allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement$1(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
      return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        flipVariations: flipVariations,
        allowedAutoPlacements: allowedAutoPlacements
      }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];

    for (var i = 0; i < placements.length; i++) {
      var placement = placements[i];

      var _basePlacement = getBasePlacement$1(placement);

      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? 'width' : 'height';
      var overflow = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        altBoundary: altBoundary,
        padding: padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }

      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];

      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }

      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }

      if (checks.every(function (check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }

      checksMap.set(placement, checks);
    }

    if (makeFallbackChecks) {
      // `2` may be desired in some cases – research later
      var numberOfChecks = flipVariations ? 3 : 1;

      var _loop = function _loop(_i) {
        var fittingPlacement = placements.find(function (placement) {
          var checks = checksMap.get(placement);

          if (checks) {
            return checks.slice(0, _i).every(function (check) {
              return check;
            });
          }
        });

        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };

      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);

        if (_ret === "break") break;
      }
    }

    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  } // eslint-disable-next-line import/no-unused-modules


  var flip$1 = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: ['offset'],
    data: {
      _skip: false
    }
  };

  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }

    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }

  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function (side) {
      return overflow[side] >= 0;
    });
  }

  function hide(_ref) {
    var state = _ref.state,
        name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: 'reference'
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets: referenceClippingOffsets,
      popperEscapeOffsets: popperEscapeOffsets,
      isReferenceHidden: isReferenceHidden,
      hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-reference-hidden': isReferenceHidden,
      'data-popper-escaped': hasPopperEscaped
    });
  } // eslint-disable-next-line import/no-unused-modules


  var hide$1 = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: ['preventOverflow'],
    fn: hide
  };

  function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = getBasePlacement$1(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
        skidding = _ref[0],
        distance = _ref[1];

    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }

  function offset(_ref2) {
    var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
    var _options$offset = options.offset,
        offset = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function (acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement],
        x = _data$state$placement.x,
        y = _data$state$placement.y;

    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var offset$1 = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: ['popperOffsets'],
    fn: offset
  };

  function popperOffsets(_ref) {
    var state = _ref.state,
        name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: 'absolute',
      placement: state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var popperOffsets$1 = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
  };

  function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  function preventOverflow(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        padding = options.padding,
        _options$tether = options.tether,
        tether = _options$tether === void 0 ? true : _options$tether,
        _options$tetherOffset = options.tetherOffset,
        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      altBoundary: altBoundary
    });
    var basePlacement = getBasePlacement$1(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };

    if (!popperOffsets) {
      return;
    }

    if (checkMainAxis) {
      var _offsetModifierState$;

      var mainSide = mainAxis === 'y' ? top : left;
      var altSide = mainAxis === 'y' ? bottom : right;
      var len = mainAxis === 'y' ? 'height' : 'width';
      var offset = popperOffsets[mainAxis];
      var min$1 = offset + overflow[mainSide];
      var max$1 = offset - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
      // outside the reference bounds

      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
      // to include its full size in the calculation. If the reference is small
      // and near the edge of a boundary, the popper can overflow even if the
      // reference is not overflowing as well (e.g. virtual elements with no
      // width or height)

      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _offsetModifierState$2;

      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _len = altAxis === 'y' ? 'height' : 'width';

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var preventOverflow$1 = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: ['offset']
  };

  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement$1(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  } // Returns the composite rect of an element relative to its offsetParent.
  // Composite means it takes into account transforms as well as layout.


  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }

    var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
    var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };

    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }

      if (isHTMLElement$1(offsetParent)) {
        offsets = getBoundingClientRect$1(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }

    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively

    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);

          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }

    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        // check for visited object
        sort(modifier);
      }
    });
    return result;
  }

  function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase

    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  function debounce$3(fn) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve) {
          Promise.resolve().then(function () {
            pending = undefined;
            resolve(fn());
          });
        });
      }

      return pending;
    };
  }

  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged, current) {
      var existing = merged[current.name];
      merged[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged;
    }, {}); // IE11 does not support Object.values

    return Object.keys(merged).map(function (key) {
      return merged[key];
    });
  }

  var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
  };

  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return !args.some(function (element) {
      return !(element && typeof element.getBoundingClientRect === 'function');
    });
  }

  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }

    var _generatorOptions = generatorOptions,
        _generatorOptions$def = _generatorOptions.defaultModifiers,
        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
        _generatorOptions$def2 = _generatorOptions.defaultOptions,
        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var state = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference,
          popper: popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state: state,
        setOptions: function setOptions(setOptionsAction) {
          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options);
          state.scrollParents = {
            reference: isElement$2(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          }; // Orders the modifiers based on their dependencies and `phase`
          // properties

          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

          state.orderedModifiers = orderedModifiers.filter(function (m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }

          var _state$elements = state.elements,
              reference = _state$elements.reference,
              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
          // anymore

          if (!areValidElements(reference, popper)) {
            return;
          } // Store the reference and popper rects to be read by modifiers


          state.rects = {
            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
            popper: getLayoutRect(popper)
          }; // Modifiers have the ability to reset the current update cycle. The
          // most common use case for this is the `flip` modifier changing the
          // placement, which then needs to re-run all the modifiers, because the
          // logic was previously ran for the previous placement and is therefore
          // stale/incorrect

          state.reset = false;
          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
          // is filled with the initial data specified by the modifier. This means
          // it doesn't persist and is fresh on each update.
          // To ensure persistent data, use `${name}#persistent`

          state.orderedModifiers.forEach(function (modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });

          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }

            var _state$orderedModifie = state.orderedModifiers[index],
                fn = _state$orderedModifie.fn,
                _state$orderedModifie2 = _state$orderedModifie.options,
                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                name = _state$orderedModifie.name;

            if (typeof fn === 'function') {
              state = fn({
                state: state,
                options: _options,
                name: name,
                instance: instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce$3(function () {
          return new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };

      if (!areValidElements(reference, popper)) {
        return instance;
      }

      instance.setOptions(options).then(function (state) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state);
        }
      }); // Modifiers have the ability to execute arbitrary code before the first
      // update cycle runs. They will be executed in the same order as the update
      // cycle. This is useful when a modifier adds some persistent data that
      // other modifiers need to use, but the modifier is run after the dependent
      // one.

      function runModifierEffects() {
        state.orderedModifiers.forEach(function (_ref) {
          var name = _ref.name,
              _ref$options = _ref.options,
              options = _ref$options === void 0 ? {} : _ref$options,
              effect = _ref.effect;

          if (typeof effect === 'function') {
            var cleanupFn = effect({
              state: state,
              name: name,
              instance: instance,
              options: options
            });

            var noopFn = function noopFn() {};

            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }

      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function (fn) {
          return fn();
        });
        effectCleanupFns = [];
      }

      return instance;
    };
  }

  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers
  }); // eslint-disable-next-line import/no-unused-modules

  /**!
  * tippy.js v6.3.7
  * (c) 2017-2021 atomiks
  * MIT License
  */
  var BOX_CLASS = "tippy-box";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var SVG_ARROW_CLASS = "tippy-svg-arrow";
  var TOUCH_OPTIONS = {
    passive: true,
    capture: true
  };
  var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
    return document.body;
  };
  function getValueAtIndexOrReturn(value, index, defaultValue) {
    if (Array.isArray(value)) {
      var v = value[index];
      return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
    }

    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === 'function' ? value.apply(void 0, args) : value;
  }
  function debounce$2(fn, ms) {
    // Avoid wrapping in `setTimeout` if ms is 0 anyway
    if (ms === 0) {
      return fn;
    }

    var timeout;
    return function (arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        fn(arg);
      }, ms);
    };
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function (item, index) {
      return arr.indexOf(item) === index;
    });
  }
  function getBasePlacement(placement) {
    return placement.split('-')[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function (acc, key) {
      if (obj[key] !== undefined) {
        acc[key] = obj[key];
      }

      return acc;
    }, {});
  }

  function div() {
    return document.createElement('div');
  }
  function isElement$1(value) {
    return ['Element', 'Fragment'].some(function (type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, 'NodeList');
  }
  function isMouseEvent(value) {
    return isType(value, 'MouseEvent');
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement$1(value)) {
      return [value];
    }

    if (isNodeList(value)) {
      return arrayFrom(value);
    }

    if (Array.isArray(value)) {
      return value;
    }

    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function (el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function (el) {
      if (el) {
        el.setAttribute('data-state', state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;

    var _normalizeToArray = normalizeToArray(elementOrElements),
        element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body


    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX,
        clientY = event.clientY;
    return popperTreeData.every(function (_ref) {
      var popperRect = _ref.popperRect,
          popperState = _ref.popperState,
          props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement(popperState.placement);
      var offsetData = popperState.modifiersData.offset;

      if (!offsetData) {
        return true;
      }

      var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
      var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
    // `webkitTransitionEnd`...

    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
      box[method](event, listener);
    });
  }
  /**
   * Compared to xxx.contains, this function works for dom structures with shadow
   * dom
   */

  function actualContains(parent, child) {
    var target = child;

    while (target) {
      var _target$getRootNode;

      if (parent.contains(target)) {
        return true;
      }

      target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
    }

    return false;
  }

  var currentInput = {
    isTouch: false
  };
  var lastMouseMoveTime = 0;
  /**
   * When a `touchstart` event is fired, it's assumed the user is using touch
   * input. We'll bind a `mousemove` event listener to listen for mouse input in
   * the future. This way, the `isTouch` property is fully dynamic and will handle
   * hybrid devices that use a mix of touch + mouse input.
   */

  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }

    currentInput.isTouch = true;

    if (window.performance) {
      document.addEventListener('mousemove', onDocumentMouseMove);
    }
  }
  /**
   * When two `mousemove` event are fired consecutively within 20ms, it's assumed
   * the user is using mouse input again. `mousemove` can fire on touch devices as
   * well, but very rarely that quickly.
   */

  function onDocumentMouseMove() {
    var now = performance.now();

    if (now - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener('mousemove', onDocumentMouseMove);
    }

    lastMouseMoveTime = now;
  }
  /**
   * When an element is in focus and has a tippy, leaving the tab/window and
   * returning causes it to show again. For mouse users this is unexpected, but
   * for keyboard use it makes sense.
   * TODO: find a better technique to solve this problem
   */

  function onWindowBlur() {
    var activeElement = document.activeElement;

    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy;

      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener('blur', onWindowBlur);
  }

  var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined';
  var isIE11 = isBrowser$1 ? // @ts-ignore
  !!window.msCrypto : false;

  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  };
  var renderProps = {
    allowHTML: false,
    animation: 'fade',
    arrow: true,
    content: '',
    inertia: false,
    maxWidth: 350,
    role: 'tooltip',
    theme: '',
    zIndex: 9999
  };
  var defaultProps = Object.assign({
    appendTo: TIPPY_DEFAULT_APPEND_TO,
    aria: {
      content: 'auto',
      expanded: 'auto'
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: '',
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {},
    onBeforeUpdate: function onBeforeUpdate() {},
    onCreate: function onCreate() {},
    onDestroy: function onDestroy() {},
    onHidden: function onHidden() {},
    onHide: function onHide() {},
    onMount: function onMount() {},
    onShow: function onShow() {},
    onShown: function onShown() {},
    onTrigger: function onTrigger() {},
    onUntrigger: function onUntrigger() {},
    onClickOutside: function onClickOutside() {},
    placement: 'top',
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: 'mouseenter focus',
    triggerTarget: null
  }, pluginProps, renderProps);
  var defaultKeys = Object.keys(defaultProps);
  var setDefaultProps = function setDefaultProps(partialProps) {

    var keys = Object.keys(partialProps);
    keys.forEach(function (key) {
      defaultProps[key] = partialProps[key];
    });
  };
  function getExtendedPassedProps(passedProps) {
    var plugins = passedProps.plugins || [];
    var pluginProps = plugins.reduce(function (acc, plugin) {
      var name = plugin.name,
          defaultValue = plugin.defaultValue;

      if (name) {
        var _name;

        acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
      }

      return acc;
    }, {});
    return Object.assign({}, passedProps, pluginProps);
  }
  function getDataAttributeProps(reference, plugins) {
    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins: plugins
    }))) : defaultKeys;
    var props = propKeys.reduce(function (acc, key) {
      var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

      if (!valueAsString) {
        return acc;
      }

      if (key === 'content') {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key] = valueAsString;
        }
      }

      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, out.aria);
    out.aria = {
      expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
      content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
    };
    return out;
  }

  var innerHTML = function innerHTML() {
    return 'innerHTML';
  };

  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }

  function createArrowElement(value) {
    var arrow = div();

    if (value === true) {
      arrow.className = ARROW_CLASS;
    } else {
      arrow.className = SVG_ARROW_CLASS;

      if (isElement$1(value)) {
        arrow.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow, value);
      }
    }

    return arrow;
  }

  function setContent(content, props) {
    if (isElement$1(props.content)) {
      dangerouslySetInnerHTML(content, '');
      content.appendChild(props.content);
    } else if (typeof props.content !== 'function') {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content, props.content);
      } else {
        content.textContent = props.content;
      }
    }
  }
  function getChildren(popper) {
    var box = popper.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box: box,
      content: boxChildren.find(function (node) {
        return node.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function (node) {
        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function (node) {
        return node.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute('data-state', 'hidden');
    box.setAttribute('tabindex', '-1');
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute('data-state', 'hidden');
    setContent(content, instance.props);
    popper.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);

    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper),
          box = _getChildren.box,
          content = _getChildren.content,
          arrow = _getChildren.arrow;

      if (nextProps.theme) {
        box.setAttribute('data-theme', nextProps.theme);
      } else {
        box.removeAttribute('data-theme');
      }

      if (typeof nextProps.animation === 'string') {
        box.setAttribute('data-animation', nextProps.animation);
      } else {
        box.removeAttribute('data-animation');
      }

      if (nextProps.inertia) {
        box.setAttribute('data-inertia', '');
      } else {
        box.removeAttribute('data-inertia');
      }

      box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

      if (nextProps.role) {
        box.setAttribute('role', nextProps.role);
      } else {
        box.removeAttribute('role');
      }

      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent(content, instance.props);
      }

      if (nextProps.arrow) {
        if (!arrow) {
          box.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box.removeChild(arrow);
          box.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow) {
        box.removeChild(arrow);
      }
    }

    return {
      popper: popper,
      onUpdate: onUpdate
    };
  } // Runtime check to identify if the render function is the default one; this
  // way we can apply default CSS transitions logic and it can be tree-shaken away

  render.$$tippy = true;

  var idCounter = 1;
  var mouseMoveListeners = []; // Used by `hideAll()`

  var mountedInstances = [];
  function createTippy(reference, passedProps) {
    var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
    // 🔒 Private members
    // ===========================================================================

    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce$2(onMouseMove, props.interactiveDebounce);
    var currentTarget; // ===========================================================================
    // 🔑 Public members
    // ===========================================================================

    var id = idCounter++;
    var popperInstance = null;
    var plugins = unique(props.plugins);
    var state = {
      // Is the instance currently enabled?
      isEnabled: true,
      // Is the tippy currently showing and not transitioning out?
      isVisible: false,
      // Has the instance been destroyed?
      isDestroyed: false,
      // Is the tippy currently mounted to the DOM?
      isMounted: false,
      // Has the tippy finished transitioning in?
      isShown: false
    };
    var instance = {
      // properties
      id: id,
      reference: reference,
      popper: div(),
      popperInstance: popperInstance,
      props: props,
      state: state,
      plugins: plugins,
      // methods
      clearDelayTimeouts: clearDelayTimeouts,
      setProps: setProps,
      setContent: setContent,
      show: show,
      hide: hide,
      hideWithInteractivity: hideWithInteractivity,
      enable: enable,
      disable: disable,
      unmount: unmount,
      destroy: destroy
    }; // TODO: Investigate why this early return causes a TDZ error in the tests —
    // it doesn't seem to happen in the browser

    /* istanbul ignore if */

    if (!props.render) {

      return instance;
    } // ===========================================================================
    // Initial mutations
    // ===========================================================================


    var _props$render = props.render(instance),
        popper = _props$render.popper,
        onUpdate = _props$render.onUpdate;

    popper.setAttribute('data-tippy-root', '');
    popper.id = "tippy-" + instance.id;
    instance.popper = popper;
    reference._tippy = instance;
    popper._tippy = instance;
    var pluginsHooks = plugins.map(function (plugin) {
      return plugin.fn(instance);
    });
    var hasAriaExpanded = reference.hasAttribute('aria-expanded');
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook('onCreate', [instance]);

    if (props.showOnCreate) {
      scheduleShow();
    } // Prevent a tippy with a delay from hiding if the cursor left then returned
    // before it started hiding


    popper.addEventListener('mouseenter', function () {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper.addEventListener('mouseleave', function () {
      if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
        getDocument().addEventListener('mousemove', debouncedOnMouseMove);
      }
    });
    return instance; // ===========================================================================
    // 🔒 Private methods
    // ===========================================================================

    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }

    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === 'hold';
    }

    function getIsDefaultRenderFn() {
      var _instance$props$rende;

      // @ts-ignore
      return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
    }

    function getCurrentTarget() {
      return currentTarget || reference;
    }

    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }

    function getDefaultTemplateChildren() {
      return getChildren(popper);
    }

    function getDelay(isShow) {
      // For touch or keyboard input, force `0` delay for UX reasons
      // Also if the instance is mounted but not visible (transitioning out),
      // ignore delay
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
        return 0;
      }

      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }

    function handleStyles(fromHide) {
      if (fromHide === void 0) {
        fromHide = false;
      }

      popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';
      popper.style.zIndex = "" + instance.props.zIndex;
    }

    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }

      pluginsHooks.forEach(function (pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(pluginHooks, args);
        }
      });

      if (shouldInvokePropsHook) {
        var _instance$props;

        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }

    function handleAriaContentAttribute() {
      var aria = instance.props.aria;

      if (!aria.content) {
        return;
      }

      var attr = "aria-" + aria.content;
      var id = popper.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function (node) {
        var currentValue = node.getAttribute(attr);

        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
        } else {
          var nextValue = currentValue && currentValue.replace(id, '').trim();

          if (nextValue) {
            node.setAttribute(attr, nextValue);
          } else {
            node.removeAttribute(attr);
          }
        }
      });
    }

    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }

      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function (node) {
        if (instance.props.interactive) {
          node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
        } else {
          node.removeAttribute('aria-expanded');
        }
      });
    }

    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
        return listener !== debouncedOnMouseMove;
      });
    }

    function onDocumentPress(event) {
      // Moved finger to scroll instead of an intentional tap outside
      if (currentInput.isTouch) {
        if (didTouchMove || event.type === 'mousedown') {
          return;
        }
      }

      var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper

      if (instance.props.interactive && actualContains(popper, actualTarget)) {
        return;
      } // Clicked on the event listeners target


      if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {
        return actualContains(el, actualTarget);
      })) {
        if (currentInput.isTouch) {
          return;
        }

        if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
          return;
        }
      } else {
        invokeHook('onClickOutside', [instance, event]);
      }

      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
        // currentTarget. This lets a tippy with `focus` trigger know that it
        // should not show

        didHideDueToDocumentMouseDown = true;
        setTimeout(function () {
          didHideDueToDocumentMouseDown = false;
        }); // The listener gets added in `scheduleShow()`, but this may be hiding it
        // before it shows, and hide()'s early bail-out behavior can prevent it
        // from being cleaned up

        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }

    function onTouchMove() {
      didTouchMove = true;
    }

    function onTouchStart() {
      didTouchMove = false;
    }

    function addDocumentPress() {
      var doc = getDocument();
      doc.addEventListener('mousedown', onDocumentPress, true);
      doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
      doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
      doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
    }

    function removeDocumentPress() {
      var doc = getDocument();
      doc.removeEventListener('mousedown', onDocumentPress, true);
      doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
      doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
      doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
    }

    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function () {
        if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
          callback();
        }
      });
    }

    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }

    function onTransitionEnd(duration, callback) {
      var box = getDefaultTemplateChildren().box;

      function listener(event) {
        if (event.target === box) {
          updateTransitionEndListener(box, 'remove', listener);
          callback();
        }
      } // Make callback synchronous if duration is 0
      // `transitionend` won't fire otherwise


      if (duration === 0) {
        return callback();
      }

      updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
      updateTransitionEndListener(box, 'add', listener);
      currentTransitionEndListener = listener;
    }

    function on(eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }

      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function (node) {
        node.addEventListener(eventType, handler, options);
        listeners.push({
          node: node,
          eventType: eventType,
          handler: handler,
          options: options
        });
      });
    }

    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on('touchstart', onTrigger, {
          passive: true
        });
        on('touchend', onMouseLeave, {
          passive: true
        });
      }

      splitBySpaces(instance.props.trigger).forEach(function (eventType) {
        if (eventType === 'manual') {
          return;
        }

        on(eventType, onTrigger);

        switch (eventType) {
          case 'mouseenter':
            on('mouseleave', onMouseLeave);
            break;

          case 'focus':
            on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);
            break;

          case 'focusin':
            on('focusout', onBlurOrFocusOut);
            break;
        }
      });
    }

    function removeListeners() {
      listeners.forEach(function (_ref) {
        var node = _ref.node,
            eventType = _ref.eventType,
            handler = _ref.handler,
            options = _ref.options;
        node.removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }

    function onTrigger(event) {
      var _lastTriggerEvent;

      var shouldScheduleClickHide = false;

      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return;
      }

      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
      lastTriggerEvent = event;
      currentTarget = event.currentTarget;
      handleAriaExpandedAttribute();

      if (!instance.state.isVisible && isMouseEvent(event)) {
        // If scrolling, `mouseenter` events can be fired if the cursor lands
        // over a new target, but `mousemove` events don't get fired. This
        // causes interactive tooltips to get stuck open until the cursor is
        // moved
        mouseMoveListeners.forEach(function (listener) {
          return listener(event);
        });
      } // Toggle show/hide when clicking click-triggered tooltips


      if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event);
      }

      if (event.type === 'click') {
        isVisibleFromClick = !shouldScheduleClickHide;
      }

      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event);
      }
    }

    function onMouseMove(event) {
      var target = event.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

      if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
        return;
      }

      var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
        var _instance$popperInsta;

        var instance = popper._tippy;
        var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

        if (state) {
          return {
            popperRect: popper.getBoundingClientRect(),
            popperState: state,
            props: props
          };
        }

        return null;
      }).filter(Boolean);

      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }

    function onMouseLeave(event) {
      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

      if (shouldBail) {
        return;
      }

      if (instance.props.interactive) {
        instance.hideWithInteractivity(event);
        return;
      }

      scheduleHide(event);
    }

    function onBlurOrFocusOut(event) {
      if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
        return;
      } // If focus was moved to within the popper


      if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
        return;
      }

      scheduleHide(event);
    }

    function isEventListenerStopped(event) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
    }

    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props,
          popperOptions = _instance$props2.popperOptions,
          placement = _instance$props2.placement,
          offset = _instance$props2.offset,
          getReferenceClientRect = _instance$props2.getReferenceClientRect,
          moveTransition = _instance$props2.moveTransition;
      var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference;
      var tippyModifier = {
        name: '$$tippy',
        enabled: true,
        phase: 'beforeWrite',
        requires: ['computeStyles'],
        fn: function fn(_ref2) {
          var state = _ref2.state;

          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(),
                box = _getDefaultTemplateCh.box;

            ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
              if (attr === 'placement') {
                box.setAttribute('data-placement', state.placement);
              } else {
                if (state.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, '');
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state.attributes.popper = {};
          }
        }
      };
      var modifiers = [{
        name: 'offset',
        options: {
          offset: offset
        }
      }, {
        name: 'preventOverflow',
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: 'flip',
        options: {
          padding: 5
        }
      }, {
        name: 'computeStyles',
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];

      if (getIsDefaultRenderFn() && arrow) {
        modifiers.push({
          name: 'arrow',
          options: {
            element: arrow,
            padding: 3
          }
        });
      }

      modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
        placement: placement,
        onFirstUpdate: onFirstUpdate,
        modifiers: modifiers
      }));
    }

    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }

    function mount() {
      var appendTo = instance.props.appendTo;
      var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
      // it's directly after the reference element so the elements inside the
      // tippy can be tabbed to
      // If there are clipping issues, the user can specify a different appendTo
      // and ensure focus management is handled correctly manually

      var node = getCurrentTarget();

      if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {
        parentNode = node.parentNode;
      } else {
        parentNode = invokeWithArgsOrReturn(appendTo, [node]);
      } // The popper element needs to exist on the DOM before its position can be
      // updated as Popper needs to read its dimensions


      if (!parentNode.contains(popper)) {
        parentNode.appendChild(popper);
      }

      instance.state.isMounted = true;
      createPopperInstance();
    }

    function getNestedPopperTree() {
      return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
    }

    function scheduleShow(event) {
      instance.clearDelayTimeouts();

      if (event) {
        invokeHook('onTrigger', [instance, event]);
      }

      addDocumentPress();
      var delay = getDelay(true);

      var _getNormalizedTouchSe = getNormalizedTouchSettings(),
          touchValue = _getNormalizedTouchSe[0],
          touchDelay = _getNormalizedTouchSe[1];

      if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
        delay = touchDelay;
      }

      if (delay) {
        showTimeout = setTimeout(function () {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }

    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      invokeHook('onUntrigger', [instance, event]);

      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      } // For interactive tippies, scheduleHide is added to a document.body handler
      // from onMouseLeave so must intercept scheduled hides from mousemove/leave
      // events when trigger contains mouseenter and click, and the tip is
      // currently shown as a result of a click.


      if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
        return;
      }

      var delay = getDelay(false);

      if (delay) {
        hideTimeout = setTimeout(function () {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        // Fixes a `transitionend` problem when it fires 1 frame too
        // late sometimes, we don't want hide() to be called.
        scheduleHideAnimationFrame = requestAnimationFrame(function () {
          instance.hide();
        });
      }
    } // ===========================================================================
    // 🔑 Public methods
    // ===========================================================================


    function enable() {
      instance.state.isEnabled = true;
    }

    function disable() {
      // Disabling the instance should also hide it
      // https://github.com/atomiks/tippy.js-react/issues/106
      instance.hide();
      instance.state.isEnabled = false;
    }

    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }

    function setProps(partialProps) {

      if (instance.state.isDestroyed) {
        return;
      }

      invokeHook('onBeforeUpdate', [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();

      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce$2(onMouseMove, nextProps.interactiveDebounce);
      } // Ensure stale aria-expanded attributes are removed


      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
          node.removeAttribute('aria-expanded');
        });
      } else if (nextProps.triggerTarget) {
        reference.removeAttribute('aria-expanded');
      }

      handleAriaExpandedAttribute();
      handleStyles();

      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }

      if (instance.popperInstance) {
        createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
        // and the nested ones get re-rendered first.
        // https://github.com/atomiks/tippyjs-react/issues/177
        // TODO: find a cleaner / more efficient solution(!)

        getNestedPopperTree().forEach(function (nestedPopper) {
          // React (and other UI libs likely) requires a rAF wrapper as it flushes
          // its work in one
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }

      invokeHook('onAfterUpdate', [instance, partialProps]);
    }

    function setContent(content) {
      instance.setProps({
        content: content
      });
    }

    function show() {


      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      } // Normalize `disabled` behavior across browsers.
      // Firefox allows events on disabled elements, but Chrome doesn't.
      // Using a wrapper element (i.e. <span>) is recommended.


      if (getCurrentTarget().hasAttribute('disabled')) {
        return;
      }

      invokeHook('onShow', [instance], false);

      if (instance.props.onShow(instance) === false) {
        return;
      }

      instance.state.isVisible = true;

      if (getIsDefaultRenderFn()) {
        popper.style.visibility = 'visible';
      }

      handleStyles();
      addDocumentPress();

      if (!instance.state.isMounted) {
        popper.style.transition = 'none';
      } // If flipping to the opposite side after hiding at least once, the
      // animation will use the wrong placement without resetting the duration


      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
            box = _getDefaultTemplateCh2.box,
            content = _getDefaultTemplateCh2.content;

        setTransitionDuration([box, content], 0);
      }

      onFirstUpdate = function onFirstUpdate() {
        var _instance$popperInsta2;

        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }

        ignoreOnFirstUpdate = true; // reflow

        void popper.offsetHeight;
        popper.style.transition = instance.props.moveTransition;

        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
              _box = _getDefaultTemplateCh3.box,
              _content = _getDefaultTemplateCh3.content;

          setTransitionDuration([_box, _content], duration);
          setVisibilityState([_box, _content], 'visible');
        }

        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
        // popper has been positioned for the first time

        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        invokeHook('onMount', [instance]);

        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration, function () {
            instance.state.isShown = true;
            invokeHook('onShown', [instance]);
          });
        }
      };

      mount();
    }

    function hide() {


      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }

      invokeHook('onHide', [instance], false);

      if (instance.props.onHide(instance) === false) {
        return;
      }

      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;

      if (getIsDefaultRenderFn()) {
        popper.style.visibility = 'hidden';
      }

      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles(true);

      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
            box = _getDefaultTemplateCh4.box,
            content = _getDefaultTemplateCh4.content;

        if (instance.props.animation) {
          setTransitionDuration([box, content], duration);
          setVisibilityState([box, content], 'hidden');
        }
      }

      handleAriaContentAttribute();
      handleAriaExpandedAttribute();

      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }

    function hideWithInteractivity(event) {

      getDocument().addEventListener('mousemove', debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }

    function unmount() {

      if (instance.state.isVisible) {
        instance.hide();
      }

      if (!instance.state.isMounted) {
        return;
      }

      destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
      // tree by default. This seems mainly for interactive tippies, but we should
      // find a workaround if possible

      getNestedPopperTree().forEach(function (nestedPopper) {
        nestedPopper._tippy.unmount();
      });

      if (popper.parentNode) {
        popper.parentNode.removeChild(popper);
      }

      mountedInstances = mountedInstances.filter(function (i) {
        return i !== instance;
      });
      instance.state.isMounted = false;
      invokeHook('onHidden', [instance]);
    }

    function destroy() {

      if (instance.state.isDestroyed) {
        return;
      }

      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference._tippy;
      instance.state.isDestroyed = true;
      invokeHook('onDestroy', [instance]);
    }
  }

  function tippy(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }

    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);

    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins: plugins
    });
    var elements = getArrayOfElements(targets);

    var instances = elements.reduce(function (acc, reference) {
      var instance = reference && createTippy(reference, passedProps);

      if (instance) {
        acc.push(instance);
      }

      return acc;
    }, []);
    return isElement$1(targets) ? instances[0] : instances;
  }

  tippy.defaultProps = defaultProps;
  tippy.setDefaultProps = setDefaultProps;
  tippy.currentInput = currentInput;

  // every time the popper is destroyed (i.e. a new target), removing the styles
  // and causing transitions to break for singletons when the console is open, but
  // most notably for non-transform styles being used, `gpuAcceleration: false`.

  Object.assign({}, applyStyles$1, {
    effect: function effect(_ref) {
      var state = _ref.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      } // intentionally return no cleanup function
      // return () => { ... }

    }
  });

  tippy.setDefaultProps({
    render: render
  });

  /*! js-cookie v3.0.5 | MIT */
  /* eslint-disable no-var */
  function assign (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        target[key] = source[key];
      }
    }
    return target
  }
  /* eslint-enable no-var */

  /* eslint-disable no-var */
  var defaultConverter = {
    read: function (value) {
      if (value[0] === '"') {
        value = value.slice(1, -1);
      }
      return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
    },
    write: function (value) {
      return encodeURIComponent(value).replace(
        /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
        decodeURIComponent
      )
    }
  };
  /* eslint-enable no-var */

  /* eslint-disable no-var */

  function init (converter, defaultAttributes) {
    function set (name, value, attributes) {
      if (typeof document === 'undefined') {
        return
      }

      attributes = assign({}, defaultAttributes, attributes);

      if (typeof attributes.expires === 'number') {
        attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
      }
      if (attributes.expires) {
        attributes.expires = attributes.expires.toUTCString();
      }

      name = encodeURIComponent(name)
        .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
        .replace(/[()]/g, escape);

      var stringifiedAttributes = '';
      for (var attributeName in attributes) {
        if (!attributes[attributeName]) {
          continue
        }

        stringifiedAttributes += '; ' + attributeName;

        if (attributes[attributeName] === true) {
          continue
        }

        // Considers RFC 6265 section 5.2:
        // ...
        // 3.  If the remaining unparsed-attributes contains a %x3B (";")
        //     character:
        // Consume the characters of the unparsed-attributes up to,
        // not including, the first %x3B (";") character.
        // ...
        stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
      }

      return (document.cookie =
        name + '=' + converter.write(value, name) + stringifiedAttributes)
    }

    function get (name) {
      if (typeof document === 'undefined' || (arguments.length && !name)) {
        return
      }

      // To prevent the for loop in the first place assign an empty array
      // in case there are no cookies at all.
      var cookies = document.cookie ? document.cookie.split('; ') : [];
      var jar = {};
      for (var i = 0; i < cookies.length; i++) {
        var parts = cookies[i].split('=');
        var value = parts.slice(1).join('=');

        try {
          var found = decodeURIComponent(parts[0]);
          jar[found] = converter.read(value, found);

          if (name === found) {
            break
          }
        } catch (e) {}
      }

      return name ? jar[name] : jar
    }

    return Object.create(
      {
        set,
        get,
        remove: function (name, attributes) {
          set(
            name,
            '',
            assign({}, attributes, {
              expires: -1
            })
          );
        },
        withAttributes: function (attributes) {
          return init(this.converter, assign({}, this.attributes, attributes))
        },
        withConverter: function (converter) {
          return init(assign({}, this.converter, converter), this.attributes)
        }
      },
      {
        attributes: { value: Object.freeze(defaultAttributes) },
        converter: { value: Object.freeze(converter) }
      }
    )
  }

  var api = init(defaultConverter, { path: '/' });

  /**
   * A collection of shims that provide minimal functionality of the ES6 collections.
   *
   * These implementations are not meant to be used outside of the ResizeObserver
   * modules as they cover only a limited range of use cases.
   */
  /* eslint-disable require-jsdoc, valid-jsdoc */
  var MapShim = (function () {
      if (typeof Map !== 'undefined') {
          return Map;
      }
      /**
       * Returns index in provided array that matches the specified key.
       *
       * @param {Array<Array>} arr
       * @param {*} key
       * @returns {number}
       */
      function getIndex(arr, key) {
          var result = -1;
          arr.some(function (entry, index) {
              if (entry[0] === key) {
                  result = index;
                  return true;
              }
              return false;
          });
          return result;
      }
      return /** @class */ (function () {
          function class_1() {
              this.__entries__ = [];
          }
          Object.defineProperty(class_1.prototype, "size", {
              /**
               * @returns {boolean}
               */
              get: function () {
                  return this.__entries__.length;
              },
              enumerable: true,
              configurable: true
          });
          /**
           * @param {*} key
           * @returns {*}
           */
          class_1.prototype.get = function (key) {
              var index = getIndex(this.__entries__, key);
              var entry = this.__entries__[index];
              return entry && entry[1];
          };
          /**
           * @param {*} key
           * @param {*} value
           * @returns {void}
           */
          class_1.prototype.set = function (key, value) {
              var index = getIndex(this.__entries__, key);
              if (~index) {
                  this.__entries__[index][1] = value;
              }
              else {
                  this.__entries__.push([key, value]);
              }
          };
          /**
           * @param {*} key
           * @returns {void}
           */
          class_1.prototype.delete = function (key) {
              var entries = this.__entries__;
              var index = getIndex(entries, key);
              if (~index) {
                  entries.splice(index, 1);
              }
          };
          /**
           * @param {*} key
           * @returns {void}
           */
          class_1.prototype.has = function (key) {
              return !!~getIndex(this.__entries__, key);
          };
          /**
           * @returns {void}
           */
          class_1.prototype.clear = function () {
              this.__entries__.splice(0);
          };
          /**
           * @param {Function} callback
           * @param {*} [ctx=null]
           * @returns {void}
           */
          class_1.prototype.forEach = function (callback, ctx) {
              if (ctx === void 0) { ctx = null; }
              for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                  var entry = _a[_i];
                  callback.call(ctx, entry[1], entry[0]);
              }
          };
          return class_1;
      }());
  })();

  /**
   * Detects whether window and document objects are available in current environment.
   */
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

  // Returns global object of a current environment.
  var global$1 = (function () {
      if (typeof global !== 'undefined' && global.Math === Math) {
          return global;
      }
      if (typeof self !== 'undefined' && self.Math === Math) {
          return self;
      }
      if (typeof window !== 'undefined' && window.Math === Math) {
          return window;
      }
      // eslint-disable-next-line no-new-func
      return Function('return this')();
  })();

  /**
   * A shim for the requestAnimationFrame which falls back to the setTimeout if
   * first one is not supported.
   *
   * @returns {number} Requests' identifier.
   */
  var requestAnimationFrame$1 = (function () {
      if (typeof requestAnimationFrame === 'function') {
          // It's required to use a bounded function because IE sometimes throws
          // an "Invalid calling object" error if rAF is invoked without the global
          // object on the left hand side.
          return requestAnimationFrame.bind(global$1);
      }
      return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
  })();

  // Defines minimum timeout before adding a trailing call.
  var trailingTimeout = 2;
  /**
   * Creates a wrapper function which ensures that provided callback will be
   * invoked only once during the specified delay period.
   *
   * @param {Function} callback - Function to be invoked after the delay period.
   * @param {number} delay - Delay after which to invoke callback.
   * @returns {Function}
   */
  function throttle$2 (callback, delay) {
      var leadingCall = false, trailingCall = false, lastCallTime = 0;
      /**
       * Invokes the original callback function and schedules new invocation if
       * the "proxy" was called during current request.
       *
       * @returns {void}
       */
      function resolvePending() {
          if (leadingCall) {
              leadingCall = false;
              callback();
          }
          if (trailingCall) {
              proxy();
          }
      }
      /**
       * Callback invoked after the specified delay. It will further postpone
       * invocation of the original function delegating it to the
       * requestAnimationFrame.
       *
       * @returns {void}
       */
      function timeoutCallback() {
          requestAnimationFrame$1(resolvePending);
      }
      /**
       * Schedules invocation of the original function.
       *
       * @returns {void}
       */
      function proxy() {
          var timeStamp = Date.now();
          if (leadingCall) {
              // Reject immediately following calls.
              if (timeStamp - lastCallTime < trailingTimeout) {
                  return;
              }
              // Schedule new call to be in invoked when the pending one is resolved.
              // This is important for "transitions" which never actually start
              // immediately so there is a chance that we might miss one if change
              // happens amids the pending invocation.
              trailingCall = true;
          }
          else {
              leadingCall = true;
              trailingCall = false;
              setTimeout(timeoutCallback, delay);
          }
          lastCallTime = timeStamp;
      }
      return proxy;
  }

  // Minimum delay before invoking the update of observers.
  var REFRESH_DELAY = 20;
  // A list of substrings of CSS properties used to find transition events that
  // might affect dimensions of observed elements.
  var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
  // Check if MutationObserver is available.
  var mutationObserverSupported = typeof MutationObserver !== 'undefined';
  /**
   * Singleton controller class which handles updates of ResizeObserver instances.
   */
  var ResizeObserverController = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserverController.
       *
       * @private
       */
      function ResizeObserverController() {
          /**
           * Indicates whether DOM listeners have been added.
           *
           * @private {boolean}
           */
          this.connected_ = false;
          /**
           * Tells that controller has subscribed for Mutation Events.
           *
           * @private {boolean}
           */
          this.mutationEventsAdded_ = false;
          /**
           * Keeps reference to the instance of MutationObserver.
           *
           * @private {MutationObserver}
           */
          this.mutationsObserver_ = null;
          /**
           * A list of connected observers.
           *
           * @private {Array<ResizeObserverSPI>}
           */
          this.observers_ = [];
          this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
          this.refresh = throttle$2(this.refresh.bind(this), REFRESH_DELAY);
      }
      /**
       * Adds observer to observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be added.
       * @returns {void}
       */
      ResizeObserverController.prototype.addObserver = function (observer) {
          if (!~this.observers_.indexOf(observer)) {
              this.observers_.push(observer);
          }
          // Add listeners if they haven't been added yet.
          if (!this.connected_) {
              this.connect_();
          }
      };
      /**
       * Removes observer from observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be removed.
       * @returns {void}
       */
      ResizeObserverController.prototype.removeObserver = function (observer) {
          var observers = this.observers_;
          var index = observers.indexOf(observer);
          // Remove observer if it's present in registry.
          if (~index) {
              observers.splice(index, 1);
          }
          // Remove listeners if controller has no connected observers.
          if (!observers.length && this.connected_) {
              this.disconnect_();
          }
      };
      /**
       * Invokes the update of observers. It will continue running updates insofar
       * it detects changes.
       *
       * @returns {void}
       */
      ResizeObserverController.prototype.refresh = function () {
          var changesDetected = this.updateObservers_();
          // Continue running updates if changes have been detected as there might
          // be future ones caused by CSS transitions.
          if (changesDetected) {
              this.refresh();
          }
      };
      /**
       * Updates every observer from observers list and notifies them of queued
       * entries.
       *
       * @private
       * @returns {boolean} Returns "true" if any observer has detected changes in
       *      dimensions of it's elements.
       */
      ResizeObserverController.prototype.updateObservers_ = function () {
          // Collect observers that have active observations.
          var activeObservers = this.observers_.filter(function (observer) {
              return observer.gatherActive(), observer.hasActive();
          });
          // Deliver notifications in a separate cycle in order to avoid any
          // collisions between observers, e.g. when multiple instances of
          // ResizeObserver are tracking the same element and the callback of one
          // of them changes content dimensions of the observed target. Sometimes
          // this may result in notifications being blocked for the rest of observers.
          activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
          return activeObservers.length > 0;
      };
      /**
       * Initializes DOM listeners.
       *
       * @private
       * @returns {void}
       */
      ResizeObserverController.prototype.connect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already added.
          if (!isBrowser || this.connected_) {
              return;
          }
          // Subscription to the "Transitionend" event is used as a workaround for
          // delayed transitions. This way it's possible to capture at least the
          // final state of an element.
          document.addEventListener('transitionend', this.onTransitionEnd_);
          window.addEventListener('resize', this.refresh);
          if (mutationObserverSupported) {
              this.mutationsObserver_ = new MutationObserver(this.refresh);
              this.mutationsObserver_.observe(document, {
                  attributes: true,
                  childList: true,
                  characterData: true,
                  subtree: true
              });
          }
          else {
              document.addEventListener('DOMSubtreeModified', this.refresh);
              this.mutationEventsAdded_ = true;
          }
          this.connected_ = true;
      };
      /**
       * Removes DOM listeners.
       *
       * @private
       * @returns {void}
       */
      ResizeObserverController.prototype.disconnect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already removed.
          if (!isBrowser || !this.connected_) {
              return;
          }
          document.removeEventListener('transitionend', this.onTransitionEnd_);
          window.removeEventListener('resize', this.refresh);
          if (this.mutationsObserver_) {
              this.mutationsObserver_.disconnect();
          }
          if (this.mutationEventsAdded_) {
              document.removeEventListener('DOMSubtreeModified', this.refresh);
          }
          this.mutationsObserver_ = null;
          this.mutationEventsAdded_ = false;
          this.connected_ = false;
      };
      /**
       * "Transitionend" event handler.
       *
       * @private
       * @param {TransitionEvent} event
       * @returns {void}
       */
      ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
          var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
          // Detect whether transition may affect dimensions of an element.
          var isReflowProperty = transitionKeys.some(function (key) {
              return !!~propertyName.indexOf(key);
          });
          if (isReflowProperty) {
              this.refresh();
          }
      };
      /**
       * Returns instance of the ResizeObserverController.
       *
       * @returns {ResizeObserverController}
       */
      ResizeObserverController.getInstance = function () {
          if (!this.instance_) {
              this.instance_ = new ResizeObserverController();
          }
          return this.instance_;
      };
      /**
       * Holds reference to the controller's instance.
       *
       * @private {ResizeObserverController}
       */
      ResizeObserverController.instance_ = null;
      return ResizeObserverController;
  }());

  /**
   * Defines non-writable/enumerable properties of the provided target object.
   *
   * @param {Object} target - Object for which to define properties.
   * @param {Object} props - Properties to be defined.
   * @returns {Object} Target object.
   */
  var defineConfigurable = (function (target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
          var key = _a[_i];
          Object.defineProperty(target, key, {
              value: props[key],
              enumerable: false,
              writable: false,
              configurable: true
          });
      }
      return target;
  });

  /**
   * Returns the global object associated with provided element.
   *
   * @param {Object} target
   * @returns {Object}
   */
  var getWindowOf = (function (target) {
      // Assume that the element is an instance of Node, which means that it
      // has the "ownerDocument" property from which we can retrieve a
      // corresponding global object.
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      // Return the local global object if it's not possible extract one from
      // provided element.
      return ownerGlobal || global$1;
  });

  // Placeholder of an empty content rectangle.
  var emptyRect = createRectInit(0, 0, 0, 0);
  /**
   * Converts provided string to a number.
   *
   * @param {number|string} value
   * @returns {number}
   */
  function toFloat(value) {
      return parseFloat(value) || 0;
  }
  /**
   * Extracts borders size from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @param {...string} positions - Borders positions (top, right, ...)
   * @returns {number}
   */
  function getBordersSize(styles) {
      var positions = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          positions[_i - 1] = arguments[_i];
      }
      return positions.reduce(function (size, position) {
          var value = styles['border-' + position + '-width'];
          return size + toFloat(value);
      }, 0);
  }
  /**
   * Extracts paddings sizes from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @returns {Object} Paddings box.
   */
  function getPaddings(styles) {
      var positions = ['top', 'right', 'bottom', 'left'];
      var paddings = {};
      for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position = positions_1[_i];
          var value = styles['padding-' + position];
          paddings[position] = toFloat(value);
      }
      return paddings;
  }
  /**
   * Calculates content rectangle of provided SVG element.
   *
   * @param {SVGGraphicsElement} target - Element content rectangle of which needs
   *      to be calculated.
   * @returns {DOMRectInit}
   */
  function getSVGContentRect(target) {
      var bbox = target.getBBox();
      return createRectInit(0, 0, bbox.width, bbox.height);
  }
  /**
   * Calculates content rectangle of provided HTMLElement.
   *
   * @param {HTMLElement} target - Element for which to calculate the content rectangle.
   * @returns {DOMRectInit}
   */
  function getHTMLElementContentRect(target) {
      // Client width & height properties can't be
      // used exclusively as they provide rounded values.
      var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
      // By this condition we can catch all non-replaced inline, hidden and
      // detached elements. Though elements with width & height properties less
      // than 0.5 will be discarded as well.
      //
      // Without it we would need to implement separate methods for each of
      // those cases and it's not possible to perform a precise and performance
      // effective test for hidden elements. E.g. even jQuery's ':visible' filter
      // gives wrong results for elements with width & height less than 0.5.
      if (!clientWidth && !clientHeight) {
          return emptyRect;
      }
      var styles = getWindowOf(target).getComputedStyle(target);
      var paddings = getPaddings(styles);
      var horizPad = paddings.left + paddings.right;
      var vertPad = paddings.top + paddings.bottom;
      // Computed styles of width & height are being used because they are the
      // only dimensions available to JS that contain non-rounded values. It could
      // be possible to utilize the getBoundingClientRect if only it's data wasn't
      // affected by CSS transformations let alone paddings, borders and scroll bars.
      var width = toFloat(styles.width), height = toFloat(styles.height);
      // Width & height include paddings and borders when the 'border-box' box
      // model is applied (except for IE).
      if (styles.boxSizing === 'border-box') {
          // Following conditions are required to handle Internet Explorer which
          // doesn't include paddings and borders to computed CSS dimensions.
          //
          // We can say that if CSS dimensions + paddings are equal to the "client"
          // properties then it's either IE, and thus we don't need to subtract
          // anything, or an element merely doesn't have paddings/borders styles.
          if (Math.round(width + horizPad) !== clientWidth) {
              width -= getBordersSize(styles, 'left', 'right') + horizPad;
          }
          if (Math.round(height + vertPad) !== clientHeight) {
              height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
          }
      }
      // Following steps can't be applied to the document's root element as its
      // client[Width/Height] properties represent viewport area of the window.
      // Besides, it's as well not necessary as the <html> itself neither has
      // rendered scroll bars nor it can be clipped.
      if (!isDocumentElement(target)) {
          // In some browsers (only in Firefox, actually) CSS width & height
          // include scroll bars size which can be removed at this step as scroll
          // bars are the only difference between rounded dimensions + paddings
          // and "client" properties, though that is not always true in Chrome.
          var vertScrollbar = Math.round(width + horizPad) - clientWidth;
          var horizScrollbar = Math.round(height + vertPad) - clientHeight;
          // Chrome has a rather weird rounding of "client" properties.
          // E.g. for an element with content width of 314.2px it sometimes gives
          // the client width of 315px and for the width of 314.7px it may give
          // 314px. And it doesn't happen all the time. So just ignore this delta
          // as a non-relevant.
          if (Math.abs(vertScrollbar) !== 1) {
              width -= vertScrollbar;
          }
          if (Math.abs(horizScrollbar) !== 1) {
              height -= horizScrollbar;
          }
      }
      return createRectInit(paddings.left, paddings.top, width, height);
  }
  /**
   * Checks whether provided element is an instance of the SVGGraphicsElement.
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  var isSVGGraphicsElement = (function () {
      // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
      // interface.
      if (typeof SVGGraphicsElement !== 'undefined') {
          return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
      }
      // If it's so, then check that element is at least an instance of the
      // SVGElement and that it has the "getBBox" method.
      // eslint-disable-next-line no-extra-parens
      return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
          typeof target.getBBox === 'function'); };
  })();
  /**
   * Checks whether provided element is a document element (<html>).
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  function isDocumentElement(target) {
      return target === getWindowOf(target).document.documentElement;
  }
  /**
   * Calculates an appropriate content rectangle for provided html or svg element.
   *
   * @param {Element} target - Element content rectangle of which needs to be calculated.
   * @returns {DOMRectInit}
   */
  function getContentRect(target) {
      if (!isBrowser) {
          return emptyRect;
      }
      if (isSVGGraphicsElement(target)) {
          return getSVGContentRect(target);
      }
      return getHTMLElementContentRect(target);
  }
  /**
   * Creates rectangle with an interface of the DOMRectReadOnly.
   * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
   *
   * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
   * @returns {DOMRectReadOnly}
   */
  function createReadOnlyRect(_a) {
      var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
      // If DOMRectReadOnly is available use it as a prototype for the rectangle.
      var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
      var rect = Object.create(Constr.prototype);
      // Rectangle's properties are not writable and non-enumerable.
      defineConfigurable(rect, {
          x: x, y: y, width: width, height: height,
          top: y,
          right: x + width,
          bottom: height + y,
          left: x
      });
      return rect;
  }
  /**
   * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
   * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   * @param {number} width - Rectangle's width.
   * @param {number} height - Rectangle's height.
   * @returns {DOMRectInit}
   */
  function createRectInit(x, y, width, height) {
      return { x: x, y: y, width: width, height: height };
  }

  /**
   * Class that is responsible for computations of the content rectangle of
   * provided DOM element and for keeping track of it's changes.
   */
  var ResizeObservation = /** @class */ (function () {
      /**
       * Creates an instance of ResizeObservation.
       *
       * @param {Element} target - Element to be observed.
       */
      function ResizeObservation(target) {
          /**
           * Broadcasted width of content rectangle.
           *
           * @type {number}
           */
          this.broadcastWidth = 0;
          /**
           * Broadcasted height of content rectangle.
           *
           * @type {number}
           */
          this.broadcastHeight = 0;
          /**
           * Reference to the last observed content rectangle.
           *
           * @private {DOMRectInit}
           */
          this.contentRect_ = createRectInit(0, 0, 0, 0);
          this.target = target;
      }
      /**
       * Updates content rectangle and tells whether it's width or height properties
       * have changed since the last broadcast.
       *
       * @returns {boolean}
       */
      ResizeObservation.prototype.isActive = function () {
          var rect = getContentRect(this.target);
          this.contentRect_ = rect;
          return (rect.width !== this.broadcastWidth ||
              rect.height !== this.broadcastHeight);
      };
      /**
       * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
       * from the corresponding properties of the last observed content rectangle.
       *
       * @returns {DOMRectInit} Last observed content rectangle.
       */
      ResizeObservation.prototype.broadcastRect = function () {
          var rect = this.contentRect_;
          this.broadcastWidth = rect.width;
          this.broadcastHeight = rect.height;
          return rect;
      };
      return ResizeObservation;
  }());

  var ResizeObserverEntry$1 = /** @class */ (function () {
      /**
       * Creates an instance of ResizeObserverEntry.
       *
       * @param {Element} target - Element that is being observed.
       * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
       */
      function ResizeObserverEntry(target, rectInit) {
          var contentRect = createReadOnlyRect(rectInit);
          // According to the specification following properties are not writable
          // and are also not enumerable in the native implementation.
          //
          // Property accessors are not being used as they'd require to define a
          // private WeakMap storage which may cause memory leaks in browsers that
          // don't support this type of collections.
          defineConfigurable(this, { target: target, contentRect: contentRect });
      }
      return ResizeObserverEntry;
  }());

  var ResizeObserverSPI = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback function that is invoked
       *      when one of the observed elements changes it's content dimensions.
       * @param {ResizeObserverController} controller - Controller instance which
       *      is responsible for the updates of observer.
       * @param {ResizeObserver} callbackCtx - Reference to the public
       *      ResizeObserver instance which will be passed to callback function.
       */
      function ResizeObserverSPI(callback, controller, callbackCtx) {
          /**
           * Collection of resize observations that have detected changes in dimensions
           * of elements.
           *
           * @private {Array<ResizeObservation>}
           */
          this.activeObservations_ = [];
          /**
           * Registry of the ResizeObservation instances.
           *
           * @private {Map<Element, ResizeObservation>}
           */
          this.observations_ = new MapShim();
          if (typeof callback !== 'function') {
              throw new TypeError('The callback provided as parameter 1 is not a function.');
          }
          this.callback_ = callback;
          this.controller_ = controller;
          this.callbackCtx_ = callbackCtx;
      }
      /**
       * Starts observing provided element.
       *
       * @param {Element} target - Element to be observed.
       * @returns {void}
       */
      ResizeObserverSPI.prototype.observe = function (target) {
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          // Do nothing if current environment doesn't have the Element interface.
          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          // Do nothing if element is already being observed.
          if (observations.has(target)) {
              return;
          }
          observations.set(target, new ResizeObservation(target));
          this.controller_.addObserver(this);
          // Force the update of observations.
          this.controller_.refresh();
      };
      /**
       * Stops observing provided element.
       *
       * @param {Element} target - Element to stop observing.
       * @returns {void}
       */
      ResizeObserverSPI.prototype.unobserve = function (target) {
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          // Do nothing if current environment doesn't have the Element interface.
          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          // Do nothing if element is not being observed.
          if (!observations.has(target)) {
              return;
          }
          observations.delete(target);
          if (!observations.size) {
              this.controller_.removeObserver(this);
          }
      };
      /**
       * Stops observing all elements.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.disconnect = function () {
          this.clearActive();
          this.observations_.clear();
          this.controller_.removeObserver(this);
      };
      /**
       * Collects observation instances the associated element of which has changed
       * it's content rectangle.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.gatherActive = function () {
          var _this = this;
          this.clearActive();
          this.observations_.forEach(function (observation) {
              if (observation.isActive()) {
                  _this.activeObservations_.push(observation);
              }
          });
      };
      /**
       * Invokes initial callback function with a list of ResizeObserverEntry
       * instances collected from active resize observations.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.broadcastActive = function () {
          // Do nothing if observer doesn't have active observations.
          if (!this.hasActive()) {
              return;
          }
          var ctx = this.callbackCtx_;
          // Create ResizeObserverEntry instance for every active observation.
          var entries = this.activeObservations_.map(function (observation) {
              return new ResizeObserverEntry$1(observation.target, observation.broadcastRect());
          });
          this.callback_.call(ctx, entries, ctx);
          this.clearActive();
      };
      /**
       * Clears the collection of active observations.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.clearActive = function () {
          this.activeObservations_.splice(0);
      };
      /**
       * Tells whether observer has active observations.
       *
       * @returns {boolean}
       */
      ResizeObserverSPI.prototype.hasActive = function () {
          return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI;
  }());

  // Registry of internal observers. If WeakMap is not available use current shim
  // for the Map collection as it has all required methods and because WeakMap
  // can't be fully polyfilled anyway.
  var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
  /**
   * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
   * exposing only those methods and properties that are defined in the spec.
   */
  var ResizeObserver = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback that is invoked when
       *      dimensions of the observed elements change.
       */
      function ResizeObserver(callback) {
          if (!(this instanceof ResizeObserver)) {
              throw new TypeError('Cannot call a class as a function.');
          }
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          var controller = ResizeObserverController.getInstance();
          var observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
      }
      return ResizeObserver;
  }());
  // Expose public methods of ResizeObserver.
  [
      'observe',
      'unobserve',
      'disconnect'
  ].forEach(function (method) {
      ResizeObserver.prototype[method] = function () {
          var _a;
          return (_a = observers.get(this))[method].apply(_a, arguments);
      };
  });

  ((function () {
      // Export existing implementation if available.
      if (typeof global$1.ResizeObserver !== 'undefined') {
          return global$1.ResizeObserver;
      }
      return ResizeObserver;
  }))();

  /*!
   * OverlayScrollbars
   * Version: 2.10.0
   *
   * Copyright (c) Rene Haas | KingSora.
   * https://github.com/KingSora
   *
   * Released under the MIT license.
   */
  const createCache = (t, n) => {
    const {o: o, i: s, u: e} = t;
    let c = o;
    let r;
    const cacheUpdateContextual = (t, n) => {
      const o = c;
      const l = t;
      const i = n || (s ? !s(o, l) : o !== l);
      if (i || e) {
        c = l;
        r = o;
      }
      return [ c, i, r ];
    };
    const cacheUpdateIsolated = t => cacheUpdateContextual(n(c, r), t);
    const getCurrentCache = t => [ c, !!t, r ];
    return [ n ? cacheUpdateIsolated : cacheUpdateContextual, getCurrentCache ];
  };

  const t = typeof window !== "undefined" && typeof HTMLElement !== "undefined" && !!window.document;

  const n = t ? window : {};

  const o = Math.max;

  const s$1 = Math.min;

  const e = Math.round;

  const c = Math.abs;

  const r = Math.sign;

  const l = n.cancelAnimationFrame;

  const i$1 = n.requestAnimationFrame;

  const a = n.setTimeout;

  const u = n.clearTimeout;

  const getApi = t => typeof n[t] !== "undefined" ? n[t] : void 0;

  const _ = getApi("MutationObserver");

  const d = getApi("IntersectionObserver");

  const f = getApi("ResizeObserver");

  const v = getApi("ScrollTimeline");

  const isUndefined = t => t === void 0;

  const isNull = t => t === null;

  const isNumber = t => typeof t === "number";

  const isString = t => typeof t === "string";

  const isBoolean = t => typeof t === "boolean";

  const isFunction$2 = t => typeof t === "function";

  const isArray = t => Array.isArray(t);

  const isObject$1 = t => typeof t === "object" && !isArray(t) && !isNull(t);

  const isArrayLike = t => {
    const n = !!t && t.length;
    const o = isNumber(n) && n > -1 && n % 1 == 0;
    return isArray(t) || !isFunction$2(t) && o ? n > 0 && isObject$1(t) ? n - 1 in t : true : false;
  };

  const isPlainObject = t => !!t && t.constructor === Object;

  const isHTMLElement = t => t instanceof HTMLElement;

  const isElement = t => t instanceof Element;

  const animationCurrentTime = () => performance.now();

  const animateNumber = (t, n, s, e, c) => {
    let r = 0;
    const a = animationCurrentTime();
    const u = o(0, s);
    const frame = s => {
      const l = animationCurrentTime();
      const _ = l - a;
      const d = _ >= u;
      const f = s ? 1 : 1 - (o(0, a + u - l) / u || 0);
      const v = (n - t) * (isFunction$2(c) ? c(f, f * u, 0, 1, u) : f) + t;
      const p = d || f === 1;
      e && e(v, f, p);
      r = p ? 0 : i$1((() => frame()));
    };
    frame();
    return t => {
      l(r);
      t && frame(t);
    };
  };

  function each$1(t, n) {
    if (isArrayLike(t)) {
      for (let o = 0; o < t.length; o++) {
        if (n(t[o], o, t) === false) {
          break;
        }
      }
    } else if (t) {
      each$1(Object.keys(t), (o => n(t[o], o, t)));
    }
    return t;
  }

  const inArray = (t, n) => t.indexOf(n) >= 0;

  const concat = (t, n) => t.concat(n);

  const push$1 = (t, n, o) => {
    !isString(n) && isArrayLike(n) ? Array.prototype.push.apply(t, n) : t.push(n);
    return t;
  };

  const from = t => Array.from(t || []);

  const createOrKeepArray = t => {
    if (isArray(t)) {
      return t;
    }
    return !isString(t) && isArrayLike(t) ? from(t) : [ t ];
  };

  const isEmptyArray = t => !!t && !t.length;

  const deduplicateArray = t => from(new Set(t));

  const runEachAndClear = (t, n, o) => {
    const runFn = t => t ? t.apply(void 0, n || []) : true;
    each$1(t, runFn);
    !o && (t.length = 0);
  };

  const p = "paddingTop";

  const h = "paddingRight";

  const g = "paddingLeft";

  const b = "paddingBottom";

  const w = "marginLeft";

  const y = "marginRight";

  const S = "marginBottom";

  const m = "overflowX";

  const O = "overflowY";

  const $$1 = "width";

  const C = "height";

  const x$1 = "visible";

  const H = "hidden";

  const E = "scroll";

  const capitalizeFirstLetter = t => {
    const n = String(t || "");
    return n ? n[0].toUpperCase() + n.slice(1) : "";
  };

  const equal = (t, n, o, s) => {
    if (t && n) {
      let e = true;
      each$1(o, (o => {
        const c = t[o];
        const r = n[o];
        if (c !== r) {
          e = false;
        }
      }));
      return e;
    }
    return false;
  };

  const equalWH = (t, n) => equal(t, n, [ "w", "h" ]);

  const equalXY = (t, n) => equal(t, n, [ "x", "y" ]);

  const equalTRBL = (t, n) => equal(t, n, [ "t", "r", "b", "l" ]);

  const noop$2 = () => {};

  const bind = (t, ...n) => t.bind(0, ...n);

  const selfClearTimeout = t => {
    let n;
    const o = t ? a : i$1;
    const s = t ? u : l;
    return [ e => {
      s(n);
      n = o((() => e()), isFunction$2(t) ? t() : t);
    }, () => s(n) ];
  };

  const debounce$1$1 = (t, n) => {
    const {_: o, v: s, p: e, S: c} = n || {};
    let r;
    let _;
    let d;
    let f;
    let v = noop$2;
    const p = function invokeFunctionToDebounce(n) {
      v();
      u(r);
      f = r = _ = void 0;
      v = noop$2;
      t.apply(this, n);
    };
    const mergeParms = t => c && _ ? c(_, t) : t;
    const flush = () => {
      if (v !== noop$2) {
        p(mergeParms(d) || d);
      }
    };
    const h = function debouncedFn() {
      const t = from(arguments);
      const n = isFunction$2(o) ? o() : o;
      const c = isNumber(n) && n >= 0;
      if (c) {
        const o = isFunction$2(s) ? s() : s;
        const c = isNumber(o) && o >= 0;
        const h = n > 0 ? a : i$1;
        const g = n > 0 ? u : l;
        const b = mergeParms(t);
        const w = b || t;
        const y = p.bind(0, w);
        let S;
        v();
        if (e && !f) {
          y();
          f = true;
          S = h((() => f = void 0), n);
        } else {
          S = h(y, n);
          if (c && !r) {
            r = a(flush, o);
          }
        }
        v = () => g(S);
        _ = d = w;
      } else {
        p(t);
      }
    };
    h.m = flush;
    return h;
  };

  const hasOwnProperty = (t, n) => Object.prototype.hasOwnProperty.call(t, n);

  const keys$1 = t => t ? Object.keys(t) : [];

  const assignDeep = (t, n, o, s, e, c, r) => {
    const l = [ n, o, s, e, c, r ];
    if ((typeof t !== "object" || isNull(t)) && !isFunction$2(t)) {
      t = {};
    }
    each$1(l, (n => {
      each$1(n, ((o, s) => {
        const e = n[s];
        if (t === e) {
          return true;
        }
        const c = isArray(e);
        if (e && isPlainObject(e)) {
          const n = t[s];
          let o = n;
          if (c && !isArray(n)) {
            o = [];
          } else if (!c && !isPlainObject(n)) {
            o = {};
          }
          t[s] = assignDeep(o, e);
        } else {
          t[s] = c ? e.slice() : e;
        }
      }));
    }));
    return t;
  };

  const removeUndefinedProperties = (t, n) => each$1(assignDeep({}, t), ((t, o, s) => {
    if (t === void 0) {
      delete s[o];
    } else if (t && isPlainObject(t)) {
      s[o] = removeUndefinedProperties(t);
    }
  }));

  const isEmptyObject = t => !keys$1(t).length;

  const capNumber = (t, n, e) => o(t, s$1(n, e));

  const getDomTokensArray = t => deduplicateArray((isArray(t) ? t : (t || "").split(" ")).filter((t => t)));

  const getAttr = (t, n) => t && t.getAttribute(n);

  const hasAttr = (t, n) => t && t.hasAttribute(n);

  const setAttrs = (t, n, o) => {
    each$1(getDomTokensArray(n), (n => {
      t && t.setAttribute(n, String(o || ""));
    }));
  };

  const removeAttrs = (t, n) => {
    each$1(getDomTokensArray(n), (n => t && t.removeAttribute(n)));
  };

  const domTokenListAttr = (t, n) => {
    const o = getDomTokensArray(getAttr(t, n));
    const s = bind(setAttrs, t, n);
    const domTokenListOperation = (t, n) => {
      const s = new Set(o);
      each$1(getDomTokensArray(t), (t => {
        s[n](t);
      }));
      return from(s).join(" ");
    };
    return {
      O: t => s(domTokenListOperation(t, "delete")),
      $: t => s(domTokenListOperation(t, "add")),
      C: t => {
        const n = getDomTokensArray(t);
        return n.reduce(((t, n) => t && o.includes(n)), n.length > 0);
      }
    };
  };

  const removeAttrClass = (t, n, o) => {
    domTokenListAttr(t, n).O(o);
    return bind(addAttrClass, t, n, o);
  };

  const addAttrClass = (t, n, o) => {
    domTokenListAttr(t, n).$(o);
    return bind(removeAttrClass, t, n, o);
  };

  const addRemoveAttrClass = (t, n, o, s) => (s ? addAttrClass : removeAttrClass)(t, n, o);

  const hasAttrClass = (t, n, o) => domTokenListAttr(t, n).C(o);

  const createDomTokenListClass = t => domTokenListAttr(t, "class");

  const removeClass$1 = (t, n) => {
    createDomTokenListClass(t).O(n);
  };

  const addClass$1 = (t, n) => {
    createDomTokenListClass(t).$(n);
    return bind(removeClass$1, t, n);
  };

  const find$1 = (t, n) => {
    const o = n ? isElement(n) && n : document;
    return o ? from(o.querySelectorAll(t)) : [];
  };

  const findFirst = (t, n) => {
    const o = n ? isElement(n) && n : document;
    return o && o.querySelector(t);
  };

  const is = (t, n) => isElement(t) && t.matches(n);

  const isBodyElement = t => is(t, "body");

  const contents = t => t ? from(t.childNodes) : [];

  const parent = t => t && t.parentElement;

  const closest$1 = (t, n) => isElement(t) && t.closest(n);

  const getFocusedElement = t => (document).activeElement;

  const liesBetween = (t, n, o) => {
    const s = closest$1(t, n);
    const e = t && findFirst(o, s);
    const c = closest$1(e, n) === s;
    return s && e ? s === t || e === t || c && closest$1(closest$1(t, o), n) !== s : false;
  };

  const removeElements = t => {
    each$1(createOrKeepArray(t), (t => {
      const n = parent(t);
      t && n && n.removeChild(t);
    }));
  };

  const appendChildren = (t, n) => bind(removeElements, t && n && each$1(createOrKeepArray(n), (n => {
    n && t.appendChild(n);
  })));

  const createDiv = t => {
    const n = document.createElement("div");
    setAttrs(n, "class", t);
    return n;
  };

  const createDOM = t => {
    const n = createDiv();
    n.innerHTML = t.trim();
    return each$1(contents(n), (t => removeElements(t)));
  };

  const getCSSVal = (t, n) => t.getPropertyValue(n) || t[n] || "";

  const validFiniteNumber = t => {
    const n = t || 0;
    return isFinite(n) ? n : 0;
  };

  const parseToZeroOrNumber = t => validFiniteNumber(parseFloat(t || ""));

  const roundCssNumber = t => Math.round(t * 1e4) / 1e4;

  const numberToCssPx = t => `${roundCssNumber(validFiniteNumber(t))}px`;

  function setStyles(t, n) {
    t && n && each$1(n, ((n, o) => {
      try {
        const s = t.style;
        const e = isNull(n) || isBoolean(n) ? "" : isNumber(n) ? numberToCssPx(n) : n;
        if (o.indexOf("--") === 0) {
          s.setProperty(o, e);
        } else {
          s[o] = e;
        }
      } catch (s) {}
    }));
  }

  function getStyles(t, o, s) {
    const e = isString(o);
    let c = e ? "" : {};
    if (t) {
      const r = n.getComputedStyle(t, s) || t.style;
      c = e ? getCSSVal(r, o) : from(o).reduce(((t, n) => {
        t[n] = getCSSVal(r, n);
        return t;
      }), c);
    }
    return c;
  }

  const topRightBottomLeft = (t, n, o) => {
    const s = n ? `${n}-` : "";
    const e = o ? `-${o}` : "";
    const c = `${s}top${e}`;
    const r = `${s}right${e}`;
    const l = `${s}bottom${e}`;
    const i = `${s}left${e}`;
    const a = getStyles(t, [ c, r, l, i ]);
    return {
      t: parseToZeroOrNumber(a[c]),
      r: parseToZeroOrNumber(a[r]),
      b: parseToZeroOrNumber(a[l]),
      l: parseToZeroOrNumber(a[i])
    };
  };

  const getTrasformTranslateValue = (t, n) => `translate${isObject$1(t) ? `(${t.x},${t.y})` : `${"Y"}(${t})`}`;

  const elementHasDimensions = t => !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length);

  const z = {
    w: 0,
    h: 0
  };

  const getElmWidthHeightProperty = (t, n) => n ? {
    w: n[`${t}Width`],
    h: n[`${t}Height`]
  } : z;

  const getWindowSize = t => getElmWidthHeightProperty("inner", t || n);

  const I = bind(getElmWidthHeightProperty, "offset");

  const A = bind(getElmWidthHeightProperty, "client");

  const D = bind(getElmWidthHeightProperty, "scroll");

  const getFractionalSize = t => {
    const n = parseFloat(getStyles(t, $$1)) || 0;
    const o = parseFloat(getStyles(t, C)) || 0;
    return {
      w: n - e(n),
      h: o - e(o)
    };
  };

  const getBoundingClientRect$2 = t => t.getBoundingClientRect();

  const hasDimensions = t => !!t && elementHasDimensions(t);

  const domRectHasDimensions = t => !!(t && (t[C] || t[$$1]));

  const domRectAppeared = (t, n) => {
    const o = domRectHasDimensions(t);
    const s = domRectHasDimensions(n);
    return !s && o;
  };

  const removeEventListener$3 = (t, n, o, s) => {
    each$1(getDomTokensArray(n), (n => {
      t && t.removeEventListener(n, o, s);
    }));
  };

  const addEventListener$3 = (t, n, o, s) => {
    var e;
    const c = (e = s && s.H) != null ? e : true;
    const r = s && s.I || false;
    const l = s && s.A || false;
    const i = {
      passive: c,
      capture: r
    };
    return bind(runEachAndClear, getDomTokensArray(n).map((n => {
      const s = l ? e => {
        removeEventListener$3(t, n, s, r);
        o && o(e);
      } : o;
      t && t.addEventListener(n, s, i);
      return bind(removeEventListener$3, t, n, s, r);
    })));
  };

  const stopPropagation = t => t.stopPropagation();

  const preventDefault = t => t.preventDefault();

  const stopAndPrevent = t => stopPropagation(t) || preventDefault(t);

  const scrollElementTo = (t, n) => {
    const {x: o, y: s} = isNumber(n) ? {
      x: n,
      y: n
    } : n || {};
    isNumber(o) && (t.scrollLeft = o);
    isNumber(s) && (t.scrollTop = s);
  };

  const getElementScroll = t => ({
    x: t.scrollLeft,
    y: t.scrollTop
  });

  const getZeroScrollCoordinates = () => ({
    D: {
      x: 0,
      y: 0
    },
    M: {
      x: 0,
      y: 0
    }
  });

  const sanitizeScrollCoordinates = (t, n) => {
    const {D: o, M: s} = t;
    const {w: e, h: l} = n;
    const sanitizeAxis = (t, n, o) => {
      let s = r(t) * o;
      let e = r(n) * o;
      if (s === e) {
        const o = c(t);
        const r = c(n);
        e = o > r ? 0 : e;
        s = o < r ? 0 : s;
      }
      s = s === e ? 0 : s;
      return [ s + 0, e + 0 ];
    };
    const [i, a] = sanitizeAxis(o.x, s.x, e);
    const [u, _] = sanitizeAxis(o.y, s.y, l);
    return {
      D: {
        x: i,
        y: u
      },
      M: {
        x: a,
        y: _
      }
    };
  };

  const isDefaultDirectionScrollCoordinates = ({D: t, M: n}) => {
    const getAxis = (t, n) => t === 0 && t <= n;
    return {
      x: getAxis(t.x, n.x),
      y: getAxis(t.y, n.y)
    };
  };

  const getScrollCoordinatesPercent = ({D: t, M: n}, o) => {
    const getAxis = (t, n, o) => capNumber(0, 1, (t - o) / (t - n) || 0);
    return {
      x: getAxis(t.x, n.x, o.x),
      y: getAxis(t.y, n.y, o.y)
    };
  };

  const focusElement = t => {
    if (t && t.focus) {
      t.focus({
        preventScroll: true
      });
    }
  };

  const manageListener = (t, n) => {
    each$1(createOrKeepArray(n), t);
  };

  const createEventListenerHub = t => {
    const n = new Map;
    const removeEvent = (t, o) => {
      if (t) {
        const s = n.get(t);
        manageListener((t => {
          if (s) {
            s[t ? "delete" : "clear"](t);
          }
        }), o);
      } else {
        n.forEach((t => {
          t.clear();
        }));
        n.clear();
      }
    };
    const addEvent = (t, o) => {
      if (isString(t)) {
        const s = n.get(t) || new Set;
        n.set(t, s);
        manageListener((t => {
          isFunction$2(t) && s.add(t);
        }), o);
        return bind(removeEvent, t, o);
      }
      if (isBoolean(o) && o) {
        removeEvent();
      }
      const s = keys$1(t);
      const e = [];
      each$1(s, (n => {
        const o = t[n];
        o && push$1(e, addEvent(n, o));
      }));
      return bind(runEachAndClear, e);
    };
    const triggerEvent = (t, o) => {
      each$1(from(n.get(t)), (t => {
        if (o && !isEmptyArray(o)) {
          t.apply(0, o);
        } else {
          t();
        }
      }));
    };
    addEvent(t || {});
    return [ addEvent, removeEvent, triggerEvent ];
  };

  const opsStringify = t => JSON.stringify(t, ((t, n) => {
    if (isFunction$2(n)) {
      throw 0;
    }
    return n;
  }));

  const getPropByPath = (t, n) => t ? `${n}`.split(".").reduce(((t, n) => t && hasOwnProperty(t, n) ? t[n] : void 0), t) : void 0;

  const M = {
    paddingAbsolute: false,
    showNativeOverlaidScrollbars: false,
    update: {
      elementEvents: [ [ "img", "load" ] ],
      debounce: [ 0, 33 ],
      attributes: null,
      ignoreMutation: null
    },
    overflow: {
      x: "scroll",
      y: "scroll"
    },
    scrollbars: {
      theme: "os-theme-dark",
      visibility: "auto",
      autoHide: "never",
      autoHideDelay: 1300,
      autoHideSuspend: false,
      dragScroll: true,
      clickScroll: false,
      pointers: [ "mouse", "touch", "pen" ]
    }
  };

  const getOptionsDiff = (t, n) => {
    const o = {};
    const s = concat(keys$1(n), keys$1(t));
    each$1(s, (s => {
      const e = t[s];
      const c = n[s];
      if (isObject$1(e) && isObject$1(c)) {
        assignDeep(o[s] = {}, getOptionsDiff(e, c));
        if (isEmptyObject(o[s])) {
          delete o[s];
        }
      } else if (hasOwnProperty(n, s) && c !== e) {
        let t = true;
        if (isArray(e) || isArray(c)) {
          try {
            if (opsStringify(e) === opsStringify(c)) {
              t = false;
            }
          } catch (r) {}
        }
        if (t) {
          o[s] = c;
        }
      }
    }));
    return o;
  };

  const createOptionCheck = (t, n, o) => s => [ getPropByPath(t, s), o || getPropByPath(n, s) !== void 0 ];

  const T = `data-overlayscrollbars`;

  const k = "os-environment";

  const R = `${k}-scrollbar-hidden`;

  const V = `${T}-initialize`;

  const L = "noClipping";

  const U = `${T}-body`;

  const P = T;

  const N = "host";

  const q = `${T}-viewport`;

  const B = m;

  const F = O;

  const j = "arrange";

  const X = "measuring";

  const Y = "scrolling";

  const W = "scrollbarHidden";

  const J = "noContent";

  const G = `${T}-padding`;

  const K = `${T}-content`;

  const Q = "os-size-observer";

  const Z = `${Q}-appear`;

  const tt = `${Q}-listener`;

  const nt = `${tt}-scroll`;

  const ot = `${tt}-item`;

  const st = `${ot}-final`;

  const et = "os-trinsic-observer";

  const ct = "os-theme-none";

  const rt = "os-scrollbar";

  const lt = `${rt}-rtl`;

  const it = `${rt}-horizontal`;

  const at = `${rt}-vertical`;

  const ut = `${rt}-track`;

  const _t = `${rt}-handle`;

  const dt = `${rt}-visible`;

  const ft = `${rt}-cornerless`;

  const vt = `${rt}-interaction`;

  const pt = `${rt}-unusable`;

  const ht = `${rt}-auto-hide`;

  const gt = `${ht}-hidden`;

  const bt = `${rt}-wheel`;

  const wt = `${ut}-interactive`;

  const yt = `${_t}-interactive`;

  let St;

  const getNonce = () => St;

  const setNonce = t => {
    St = t;
  };

  let mt;

  const createEnvironment = () => {
    const getNativeScrollbarSize = (t, n, o) => {
      appendChildren(document.body, t);
      appendChildren(document.body, t);
      const s = A(t);
      const e = I(t);
      const c = getFractionalSize(n);
      o && removeElements(t);
      return {
        x: e.h - s.h + c.h,
        y: e.w - s.w + c.w
      };
    };
    const getNativeScrollbarsHiding = t => {
      let n = false;
      const o = addClass$1(t, R);
      try {
        n = getStyles(t, "scrollbar-width") === "none" || getStyles(t, "display", "::-webkit-scrollbar") === "none";
      } catch (s) {}
      o();
      return n;
    };
    const t = `.${k}{scroll-behavior:auto!important;position:fixed;opacity:0;visibility:hidden;overflow:scroll;height:200px;width:200px;z-index:-1}.${k} div{width:200%;height:200%;margin:10px 0}.${R}{scrollbar-width:none!important}.${R}::-webkit-scrollbar,.${R}::-webkit-scrollbar-corner{appearance:none!important;display:none!important;width:0!important;height:0!important}`;
    const o = createDOM(`<div class="${k}"><div></div><style>${t}</style></div>`);
    const s = o[0];
    const e = s.firstChild;
    const c = s.lastChild;
    const r = getNonce();
    if (r) {
      c.nonce = r;
    }
    const [l, , i] = createEventListenerHub();
    const [a, u] = createCache({
      o: getNativeScrollbarSize(s, e),
      i: equalXY
    }, bind(getNativeScrollbarSize, s, e, true));
    const [_] = u();
    const d = getNativeScrollbarsHiding(s);
    const f = {
      x: _.x === 0,
      y: _.y === 0
    };
    const p = {
      elements: {
        host: null,
        padding: !d,
        viewport: t => d && isBodyElement(t) && t,
        content: false
      },
      scrollbars: {
        slot: true
      },
      cancel: {
        nativeScrollbarsOverlaid: false,
        body: null
      }
    };
    const h = assignDeep({}, M);
    const g = bind(assignDeep, {}, h);
    const b = bind(assignDeep, {}, p);
    const w = {
      T: _,
      k: f,
      R: d,
      V: !!v,
      L: bind(l, "r"),
      U: b,
      P: t => assignDeep(p, t) && b(),
      N: g,
      q: t => assignDeep(h, t) && g(),
      B: assignDeep({}, p),
      F: assignDeep({}, h)
    };
    removeAttrs(s, "style");
    removeElements(s);
    addEventListener$3(n, "resize", (() => {
      i("r", []);
    }));
    if (isFunction$2(n.matchMedia) && !d && (!f.x || !f.y)) {
      const addZoomListener = t => {
        const o = n.matchMedia(`(resolution: ${n.devicePixelRatio}dppx)`);
        addEventListener$3(o, "change", (() => {
          t();
          addZoomListener(t);
        }), {
          A: true
        });
      };
      addZoomListener((() => {
        const [t, n] = a();
        assignDeep(w.T, t);
        i("r", [ n ]);
      }));
    }
    return w;
  };

  const getEnvironment = () => {
    if (!mt) {
      mt = createEnvironment();
    }
    return mt;
  };

  const resolveInitialization = (t, n) => isFunction$2(n) ? n.apply(0, t) : n;

  const staticInitializationElement = (t, n, o, s) => {
    const e = isUndefined(s) ? o : s;
    const c = resolveInitialization(t, e);
    return c || n.apply(0, t);
  };

  const dynamicInitializationElement = (t, n, o, s) => {
    const e = isUndefined(s) ? o : s;
    const c = resolveInitialization(t, e);
    return !!c && (isHTMLElement(c) ? c : n.apply(0, t));
  };

  const cancelInitialization = (t, n) => {
    const {nativeScrollbarsOverlaid: o, body: s} = n || {};
    const {k: e, R: c, U: r} = getEnvironment();
    const {nativeScrollbarsOverlaid: l, body: i} = r().cancel;
    const a = o != null ? o : l;
    const u = isUndefined(s) ? i : s;
    const _ = (e.x || e.y) && a;
    const d = t && (isNull(u) ? !c : u);
    return !!_ || !!d;
  };

  const Ot = new WeakMap;

  const addInstance = (t, n) => {
    Ot.set(t, n);
  };

  const removeInstance = t => {
    Ot.delete(t);
  };

  const getInstance = t => Ot.get(t);

  const createEventContentChange = (t, n, o) => {
    let s = false;
    const e = o ? new WeakMap : false;
    const destroy = () => {
      s = true;
    };
    const updateElements = c => {
      if (e && o) {
        const r = o.map((n => {
          const [o, s] = n || [];
          const e = s && o ? (c || find$1)(o, t) : [];
          return [ e, s ];
        }));
        each$1(r, (o => each$1(o[0], (c => {
          const r = o[1];
          const l = e.get(c) || [];
          const i = t.contains(c);
          if (i && r) {
            const t = addEventListener$3(c, r, (o => {
              if (s) {
                t();
                e.delete(c);
              } else {
                n(o);
              }
            }));
            e.set(c, push$1(l, t));
          } else {
            runEachAndClear(l);
            e.delete(c);
          }
        }))));
      }
    };
    updateElements();
    return [ destroy, updateElements ];
  };

  const createDOMObserver = (t, n, o, s) => {
    let e = false;
    const {j: c, X: r, Y: l, W: i, J: a, G: u} = s || {};
    const d = debounce$1$1((() => e && o(true)), {
      _: 33,
      v: 99
    });
    const [f, v] = createEventContentChange(t, d, l);
    const p = c || [];
    const h = r || [];
    const g = concat(p, h);
    const observerCallback = (e, c) => {
      if (!isEmptyArray(c)) {
        const r = a || noop$2;
        const l = u || noop$2;
        const _ = [];
        const d = [];
        let f = false;
        let p = false;
        each$1(c, (o => {
          const {attributeName: e, target: c, type: a, oldValue: u, addedNodes: v, removedNodes: g} = o;
          const b = a === "attributes";
          const w = a === "childList";
          const y = t === c;
          const S = b && e;
          const m = S && getAttr(c, e || "");
          const O = isString(m) ? m : null;
          const $ = S && u !== O;
          const C = inArray(h, e) && $;
          if (n && (w || !y)) {
            const n = b && $;
            const a = n && i && is(c, i);
            const d = a ? !r(c, e, u, O) : !b || n;
            const f = d && !l(o, !!a, t, s);
            each$1(v, (t => push$1(_, t)));
            each$1(g, (t => push$1(_, t)));
            p = p || f;
          }
          if (!n && y && $ && !r(c, e, u, O)) {
            push$1(d, e);
            f = f || C;
          }
        }));
        v((t => deduplicateArray(_).reduce(((n, o) => {
          push$1(n, find$1(t, o));
          return is(o, t) ? push$1(n, o) : n;
        }), [])));
        if (n) {
          !e && p && o(false);
          return [ false ];
        }
        if (!isEmptyArray(d) || f) {
          const t = [ deduplicateArray(d), f ];
          !e && o.apply(0, t);
          return t;
        }
      }
    };
    const b = new _(bind(observerCallback, false));
    return [ () => {
      b.observe(t, {
        attributes: true,
        attributeOldValue: true,
        attributeFilter: g,
        subtree: n,
        childList: n,
        characterData: n
      });
      e = true;
      return () => {
        if (e) {
          f();
          b.disconnect();
          e = false;
        }
      };
    }, () => {
      if (e) {
        d.m();
        return observerCallback(true, b.takeRecords());
      }
    } ];
  };

  const $t = {};

  const Ct = {};

  const addPlugins = t => {
    each$1(t, (t => each$1(t, ((n, o) => {
      $t[o] = t[o];
    }))));
  };

  const registerPluginModuleInstances = (t, n, o) => keys$1(t).map((s => {
    const {static: e, instance: c} = t[s];
    const [r, l, i] = o || [];
    const a = o ? c : e;
    if (a) {
      const t = o ? a(r, l, n) : a(n);
      return (i || Ct)[s] = t;
    }
  }));

  const getStaticPluginModuleInstance = t => Ct[t];

  const xt = "__osOptionsValidationPlugin";

  const Ht = "__osSizeObserverPlugin";

  const Et = /* @__PURE__ */ (() => ({
    [Ht]: {
      static: () => (t, n, o) => {
        const s = 3333333;
        const e = "scroll";
        const c = createDOM(`<div class="${ot}" dir="ltr"><div class="${ot}"><div class="${st}"></div></div><div class="${ot}"><div class="${st}" style="width: 200%; height: 200%"></div></div></div>`);
        const r = c[0];
        const a = r.lastChild;
        const u = r.firstChild;
        const _ = u == null ? void 0 : u.firstChild;
        let d = I(r);
        let f = d;
        let v = false;
        let p;
        const reset = () => {
          scrollElementTo(u, s);
          scrollElementTo(a, s);
        };
        const onResized = t => {
          p = 0;
          if (v) {
            d = f;
            n(t === true);
          }
        };
        const onScroll = t => {
          f = I(r);
          v = !t || !equalWH(f, d);
          if (t) {
            stopPropagation(t);
            if (v && !p) {
              l(p);
              p = i$1(onResized);
            }
          } else {
            onResized(t === false);
          }
          reset();
        };
        const h = [ appendChildren(t, c), addEventListener$3(u, e, onScroll), addEventListener$3(a, e, onScroll) ];
        addClass$1(t, nt);
        setStyles(_, {
          [$$1]: s,
          [C]: s
        });
        i$1(reset);
        return [ o ? bind(onScroll, false) : reset, h ];
      }
    }
  }))();

  const getShowNativeOverlaidScrollbars = (t, n) => {
    const {k: o} = n;
    const [s, e] = t("showNativeOverlaidScrollbars");
    return [ s && o.x && o.y, e ];
  };

  const overflowIsVisible = t => t.indexOf(x$1) === 0;

  const createViewportOverflowState = (t, n) => {
    const getAxisOverflowStyle = (t, n, o, s) => {
      const e = t === x$1 ? H : t.replace(`${x$1}-`, "");
      const c = overflowIsVisible(t);
      const r = overflowIsVisible(o);
      if (!n && !s) {
        return H;
      }
      if (c && r) {
        return x$1;
      }
      if (c) {
        const t = n ? x$1 : H;
        return n && s ? e : t;
      }
      const l = r && s ? x$1 : H;
      return n ? e : l;
    };
    const o = {
      x: getAxisOverflowStyle(n.x, t.x, n.y, t.y),
      y: getAxisOverflowStyle(n.y, t.y, n.x, t.x)
    };
    return {
      K: o,
      Z: {
        x: o.x === E,
        y: o.y === E
      }
    };
  };

  const zt = "__osScrollbarsHidingPlugin";

  const It = /* @__PURE__ */ (() => ({
    [zt]: {
      static: () => ({
        tt: (t, n, o, s, e) => {
          const {nt: c, ot: r} = t;
          const {R: l, k: i, T: a} = s;
          const u = !c && !l && (i.x || i.y);
          const [_] = getShowNativeOverlaidScrollbars(e, s);
          const readViewportOverflowState = () => {
            const getStatePerAxis = t => {
              const n = getStyles(r, t);
              const o = n === E;
              return [ n, o ];
            };
            const [t, n] = getStatePerAxis(m);
            const [o, s] = getStatePerAxis(O);
            return {
              K: {
                x: t,
                y: o
              },
              Z: {
                x: n,
                y: s
              }
            };
          };
          const _getViewportOverflowHideOffset = t => {
            const {Z: n} = t;
            const o = l || _ ? 0 : 42;
            const getHideOffsetPerAxis = (t, n, s) => {
              const e = t ? o : s;
              const c = n && !l ? e : 0;
              const r = t && !!o;
              return [ c, r ];
            };
            const [s, e] = getHideOffsetPerAxis(i.x, n.x, a.x);
            const [c, r] = getHideOffsetPerAxis(i.y, n.y, a.y);
            return {
              st: {
                x: s,
                y: c
              },
              et: {
                x: e,
                y: r
              }
            };
          };
          const _hideNativeScrollbars = (t, {ct: o}, s) => {
            if (!c) {
              const e = assignDeep({}, {
                [y]: 0,
                [S]: 0,
                [w]: 0
              });
              const {st: c, et: r} = _getViewportOverflowHideOffset(t);
              const {x: l, y: i} = r;
              const {x: a, y: u} = c;
              const {rt: _} = n;
              const d = o ? w : y;
              const f = o ? g : h;
              const v = _[d];
              const p = _[S];
              const m = _[f];
              const O = _[b];
              e[$$1] = `calc(100% + ${u + v * -1}px)`;
              e[d] = -u + v;
              e[S] = -a + p;
              if (s) {
                e[f] = m + (i ? u : 0);
                e[b] = O + (l ? a : 0);
              }
              return e;
            }
          };
          const _arrangeViewport = (t, s, e) => {
            if (u) {
              const {rt: c} = n;
              const {st: l, et: i} = _getViewportOverflowHideOffset(t);
              const {x: a, y: u} = i;
              const {x: _, y: d} = l;
              const {ct: f} = o;
              const v = f ? h : g;
              const p = c[v];
              const b = c.paddingTop;
              const w = s.w + e.w;
              const y = s.h + e.h;
              const S = {
                w: d && u ? `${d + w - p}px` : "",
                h: _ && a ? `${_ + y - b}px` : ""
              };
              setStyles(r, {
                "--os-vaw": S.w,
                "--os-vah": S.h
              });
            }
            return u;
          };
          const _undoViewportArrange = t => {
            if (u) {
              const s = t || readViewportOverflowState();
              const {rt: e} = n;
              const {et: c} = _getViewportOverflowHideOffset(s);
              const {x: l, y: i} = c;
              const a = {};
              const assignProps = t => each$1(t, (t => {
                a[t] = e[t];
              }));
              if (l) {
                assignProps([ S, p, b ]);
              }
              if (i) {
                assignProps([ w, y, g, h ]);
              }
              const _ = getStyles(r, keys$1(a));
              const d = removeAttrClass(r, q, j);
              setStyles(r, a);
              return [ () => {
                setStyles(r, assignDeep({}, _, _hideNativeScrollbars(s, o, u)));
                d();
              }, s ];
            }
            return [ noop$2 ];
          };
          return {
            lt: _getViewportOverflowHideOffset,
            it: _arrangeViewport,
            ut: _undoViewportArrange,
            _t: _hideNativeScrollbars
          };
        }
      })
    }
  }))();

  const At = "__osClickScrollPlugin";

  const Dt = /* @__PURE__ */ (() => ({
    [At]: {
      static: () => (t, n, o, s) => {
        let e = false;
        let c = noop$2;
        const r = 133;
        const l = 222;
        const [i, a] = selfClearTimeout(r);
        const u = Math.sign(n);
        const _ = o * u;
        const d = _ / 2;
        const easing = t => 1 - (1 - t) * (1 - t);
        const easedEndPressAnimation = (n, o) => animateNumber(n, o, l, t, easing);
        const linearPressAnimation = (o, s) => animateNumber(o, n - _, r * s, ((o, s, e) => {
          t(o);
          if (e) {
            c = easedEndPressAnimation(o, n);
          }
        }));
        const f = animateNumber(0, _, l, ((r, l, a) => {
          t(r);
          if (a) {
            s(e);
            if (!e) {
              const t = n - r;
              const s = Math.sign(t - d) === u;
              s && i((() => {
                const s = t - _;
                const e = Math.sign(s) === u;
                c = e ? linearPressAnimation(r, Math.abs(s) / o) : easedEndPressAnimation(r, n);
              }));
            }
          }
        }), easing);
        return t => {
          e = true;
          if (t) {
            f();
          }
          a();
          c();
        };
      }
    }
  }))();

  const createSizeObserver = (t, n, o) => {
    const {dt: s} = o || {};
    const e = getStaticPluginModuleInstance(Ht);
    const [c] = createCache({
      o: false,
      u: true
    });
    return () => {
      const o = [];
      const r = createDOM(`<div class="${Q}"><div class="${tt}"></div></div>`);
      const l = r[0];
      const i = l.firstChild;
      const onSizeChangedCallbackProxy = t => {
        const o = t instanceof ResizeObserverEntry;
        let s = false;
        let e = false;
        if (o) {
          const [n, , o] = c(t.contentRect);
          const r = domRectHasDimensions(n);
          e = domRectAppeared(n, o);
          s = !e && !r;
        } else {
          e = t === true;
        }
        if (!s) {
          n({
            ft: true,
            dt: e
          });
        }
      };
      if (f) {
        const t = new f((t => onSizeChangedCallbackProxy(t.pop())));
        t.observe(i);
        push$1(o, (() => {
          t.disconnect();
        }));
      } else if (e) {
        const [t, n] = e(i, onSizeChangedCallbackProxy, s);
        push$1(o, concat([ addClass$1(l, Z), addEventListener$3(l, "animationstart", t) ], n));
      } else {
        return noop$2;
      }
      return bind(runEachAndClear, push$1(o, appendChildren(t, l)));
    };
  };

  const createTrinsicObserver = (t, n) => {
    let o;
    const isHeightIntrinsic = t => t.h === 0 || t.isIntersecting || t.intersectionRatio > 0;
    const s = createDiv(et);
    const [e] = createCache({
      o: false
    });
    const triggerOnTrinsicChangedCallback = (t, o) => {
      if (t) {
        const s = e(isHeightIntrinsic(t));
        const [, c] = s;
        return c && !o && n(s) && [ s ];
      }
    };
    const intersectionObserverCallback = (t, n) => triggerOnTrinsicChangedCallback(n.pop(), t);
    return [ () => {
      const n = [];
      if (d) {
        o = new d(bind(intersectionObserverCallback, false), {
          root: t
        });
        o.observe(s);
        push$1(n, (() => {
          o.disconnect();
        }));
      } else {
        const onSizeChanged = () => {
          const t = I(s);
          triggerOnTrinsicChangedCallback(t);
        };
        push$1(n, createSizeObserver(s, onSizeChanged)());
        onSizeChanged();
      }
      return bind(runEachAndClear, push$1(n, appendChildren(t, s)));
    }, () => o && intersectionObserverCallback(true, o.takeRecords()) ];
  };

  const createObserversSetup = (t, n, o, s) => {
    let e;
    let c;
    let r;
    let l;
    let i;
    let a;
    const u = `[${P}]`;
    const _ = `[${q}]`;
    const d = [ "id", "class", "style", "open", "wrap", "cols", "rows" ];
    const {vt: v, ht: p, ot: h, gt: g, bt: b, nt: w, wt: y, yt: S, St: m, Ot: O} = t;
    const getDirectionIsRTL = t => getStyles(t, "direction") === "rtl";
    const $ = {
      $t: false,
      ct: getDirectionIsRTL(v)
    };
    const C = getEnvironment();
    const x = getStaticPluginModuleInstance(zt);
    const [H] = createCache({
      i: equalWH,
      o: {
        w: 0,
        h: 0
      }
    }, (() => {
      const s = x && x.tt(t, n, $, C, o).ut;
      const e = y && w;
      const c = !e && hasAttrClass(p, P, L);
      const r = !w && S(j);
      const l = r && getElementScroll(g);
      const i = l && O();
      const a = m(X, c);
      const u = r && s && s()[0];
      const _ = D(h);
      const d = getFractionalSize(h);
      u && u();
      scrollElementTo(g, l);
      i && i();
      c && a();
      return {
        w: _.w + d.w,
        h: _.h + d.h
      };
    }));
    const E = debounce$1$1(s, {
      _: () => e,
      v: () => c,
      S(t, n) {
        const [o] = t;
        const [s] = n;
        return [ concat(keys$1(o), keys$1(s)).reduce(((t, n) => {
          t[n] = o[n] || s[n];
          return t;
        }), {}) ];
      }
    });
    const setDirection = t => {
      const n = getDirectionIsRTL(v);
      assignDeep(t, {
        Ct: a !== n
      });
      assignDeep($, {
        ct: n
      });
      a = n;
    };
    const onTrinsicChanged = (t, n) => {
      const [o, e] = t;
      const c = {
        xt: e
      };
      assignDeep($, {
        $t: o
      });
      !n && s(c);
      return c;
    };
    const onSizeChanged = ({ft: t, dt: n}) => {
      const o = t && !n;
      const e = !o && C.R ? E : s;
      const c = {
        ft: t || n,
        dt: n
      };
      setDirection(c);
      e(c);
    };
    const onContentMutation = (t, n) => {
      const [, o] = H();
      const e = {
        Ht: o
      };
      setDirection(e);
      const c = t ? s : E;
      o && !n && c(e);
      return e;
    };
    const onHostMutation = (t, n, o) => {
      const s = {
        Et: n
      };
      setDirection(s);
      if (n && !o) {
        E(s);
      }
      return s;
    };
    const [z, I] = b ? createTrinsicObserver(p, onTrinsicChanged) : [];
    const A = !w && createSizeObserver(p, onSizeChanged, {
      dt: true
    });
    const [M, T] = createDOMObserver(p, false, onHostMutation, {
      X: d,
      j: d
    });
    const k = w && f && new f((t => {
      const n = t[t.length - 1].contentRect;
      onSizeChanged({
        ft: true,
        dt: domRectAppeared(n, i)
      });
      i = n;
    }));
    const R = debounce$1$1((() => {
      const [, t] = H();
      s({
        Ht: t
      });
    }), {
      _: 222,
      p: true
    });
    return [ () => {
      k && k.observe(p);
      const t = A && A();
      const n = z && z();
      const o = M();
      const s = C.L((t => {
        if (t) {
          E({
            zt: t
          });
        } else {
          R();
        }
      }));
      return () => {
        k && k.disconnect();
        t && t();
        n && n();
        l && l();
        o();
        s();
      };
    }, ({It: t, At: n, Dt: o}) => {
      const s = {};
      const [i] = t("update.ignoreMutation");
      const [a, f] = t("update.attributes");
      const [v, p] = t("update.elementEvents");
      const [g, y] = t("update.debounce");
      const S = p || f;
      const m = n || o;
      const ignoreMutationFromOptions = t => isFunction$2(i) && i(t);
      if (S) {
        r && r();
        l && l();
        const [t, n] = createDOMObserver(b || h, true, onContentMutation, {
          j: concat(d, a || []),
          Y: v,
          W: u,
          G: (t, n) => {
            const {target: o, attributeName: s} = t;
            const e = !n && s && !w ? liesBetween(o, u, _) : false;
            return e || !!closest$1(o, `.${rt}`) || !!ignoreMutationFromOptions(t);
          }
        });
        l = t();
        r = n;
      }
      if (y) {
        E.m();
        if (isArray(g)) {
          const t = g[0];
          const n = g[1];
          e = isNumber(t) && t;
          c = isNumber(n) && n;
        } else if (isNumber(g)) {
          e = g;
          c = false;
        } else {
          e = false;
          c = false;
        }
      }
      if (m) {
        const t = T();
        const n = I && I();
        const o = r && r();
        t && assignDeep(s, onHostMutation(t[0], t[1], m));
        n && assignDeep(s, onTrinsicChanged(n[0], m));
        o && assignDeep(s, onContentMutation(o[0], m));
      }
      setDirection(s);
      return s;
    }, $ ];
  };

  const createScrollbarsSetupElements = (t, n, o, s) => {
    const e = "--os-viewport-percent";
    const c = "--os-scroll-percent";
    const r = "--os-scroll-direction";
    const {U: l} = getEnvironment();
    const {scrollbars: i} = l();
    const {slot: a} = i;
    const {vt: u, ht: _, ot: d, Mt: f, gt: p, wt: h, nt: g} = n;
    const {scrollbars: b} = f ? {} : t;
    const {slot: w} = b || {};
    const y = [];
    const S = [];
    const m = [];
    const O = dynamicInitializationElement([ u, _, d ], (() => g && h ? u : _), a, w);
    const initScrollTimeline = t => {
      if (v) {
        const n = new v({
          source: p,
          axis: t
        });
        const _addScrollPercentAnimation = t => {
          const o = t.Tt.animate({
            clear: [ "left" ],
            [c]: [ 0, 1 ]
          }, {
            timeline: n
          });
          return () => o.cancel();
        };
        return {
          kt: _addScrollPercentAnimation
        };
      }
    };
    const $ = {
      x: initScrollTimeline("x"),
      y: initScrollTimeline("y")
    };
    const getViewportPercent = () => {
      const {Rt: t, Vt: n} = o;
      const getAxisValue = (t, n) => capNumber(0, 1, t / (t + n) || 0);
      return {
        x: getAxisValue(n.x, t.x),
        y: getAxisValue(n.y, t.y)
      };
    };
    const scrollbarStructureAddRemoveClass = (t, n, o) => {
      const s = o ? addClass$1 : removeClass$1;
      each$1(t, (t => {
        s(t.Tt, n);
      }));
    };
    const scrollbarStyle = (t, n) => {
      each$1(t, (t => {
        const [o, s] = n(t);
        setStyles(o, s);
      }));
    };
    const scrollbarsAddRemoveClass = (t, n, o) => {
      const s = isBoolean(o);
      const e = s ? o : true;
      const c = s ? !o : true;
      e && scrollbarStructureAddRemoveClass(S, t, n);
      c && scrollbarStructureAddRemoveClass(m, t, n);
    };
    const refreshScrollbarsHandleLength = () => {
      const t = getViewportPercent();
      const createScrollbarStyleFn = t => n => [ n.Tt, {
        [e]: roundCssNumber(t) + ""
      } ];
      scrollbarStyle(S, createScrollbarStyleFn(t.x));
      scrollbarStyle(m, createScrollbarStyleFn(t.y));
    };
    const refreshScrollbarsHandleOffset = () => {
      if (!v) {
        const {Lt: t} = o;
        const n = getScrollCoordinatesPercent(t, getElementScroll(p));
        const createScrollbarStyleFn = t => n => [ n.Tt, {
          [c]: roundCssNumber(t) + ""
        } ];
        scrollbarStyle(S, createScrollbarStyleFn(n.x));
        scrollbarStyle(m, createScrollbarStyleFn(n.y));
      }
    };
    const refreshScrollbarsScrollCoordinates = () => {
      const {Lt: t} = o;
      const n = isDefaultDirectionScrollCoordinates(t);
      const createScrollbarStyleFn = t => n => [ n.Tt, {
        [r]: t ? "0" : "1"
      } ];
      scrollbarStyle(S, createScrollbarStyleFn(n.x));
      scrollbarStyle(m, createScrollbarStyleFn(n.y));
    };
    const refreshScrollbarsScrollbarOffset = () => {
      if (g && !h) {
        const {Rt: t, Lt: n} = o;
        const s = isDefaultDirectionScrollCoordinates(n);
        const e = getScrollCoordinatesPercent(n, getElementScroll(p));
        const styleScrollbarPosition = n => {
          const {Tt: o} = n;
          const c = parent(o) === d && o;
          const getTranslateValue = (t, n, o) => {
            const s = n * t;
            return numberToCssPx(o ? s : -s);
          };
          return [ c, c && {
            transform: getTrasformTranslateValue({
              x: getTranslateValue(e.x, t.x, s.x),
              y: getTranslateValue(e.y, t.y, s.y)
            })
          } ];
        };
        scrollbarStyle(S, styleScrollbarPosition);
        scrollbarStyle(m, styleScrollbarPosition);
      }
    };
    const generateScrollbarDOM = t => {
      const n = t ? "x" : "y";
      const o = t ? it : at;
      const e = createDiv(`${rt} ${o}`);
      const c = createDiv(ut);
      const r = createDiv(_t);
      const l = {
        Tt: e,
        Ut: c,
        Pt: r
      };
      const i = $[n];
      push$1(t ? S : m, l);
      push$1(y, [ appendChildren(e, c), appendChildren(c, r), bind(removeElements, e), i && i.kt(l), s(l, scrollbarsAddRemoveClass, t) ]);
      return l;
    };
    const C = bind(generateScrollbarDOM, true);
    const x = bind(generateScrollbarDOM, false);
    const appendElements = () => {
      appendChildren(O, S[0].Tt);
      appendChildren(O, m[0].Tt);
      return bind(runEachAndClear, y);
    };
    C();
    x();
    return [ {
      Nt: refreshScrollbarsHandleLength,
      qt: refreshScrollbarsHandleOffset,
      Bt: refreshScrollbarsScrollCoordinates,
      Ft: refreshScrollbarsScrollbarOffset,
      jt: scrollbarsAddRemoveClass,
      Xt: {
        Yt: S,
        Wt: C,
        Jt: bind(scrollbarStyle, S)
      },
      Gt: {
        Yt: m,
        Wt: x,
        Jt: bind(scrollbarStyle, m)
      }
    }, appendElements ];
  };

  const createScrollbarsSetupEvents = (t, n, o, s) => (r, l, i) => {
    const {ht: u, ot: _, nt: d, gt: f, Kt: v, Ot: p} = n;
    const {Tt: h, Ut: g, Pt: b} = r;
    const [w, y] = selfClearTimeout(333);
    const [S, m] = selfClearTimeout(444);
    const scrollOffsetElementScrollBy = t => {
      isFunction$2(f.scrollBy) && f.scrollBy({
        behavior: "smooth",
        left: t.x,
        top: t.y
      });
    };
    const createInteractiveScrollEvents = () => {
      const n = "pointerup pointercancel lostpointercapture";
      const s = `client${i ? "X" : "Y"}`;
      const r = i ? $$1 : C;
      const l = i ? "left" : "top";
      const a = i ? "w" : "h";
      const u = i ? "x" : "y";
      const createRelativeHandleMove = (t, n) => s => {
        const {Rt: e} = o;
        const c = I(g)[a] - I(b)[a];
        const r = n * s / c;
        const l = r * e[u];
        scrollElementTo(f, {
          [u]: t + l
        });
      };
      const _ = [];
      return addEventListener$3(g, "pointerdown", (o => {
        const i = closest$1(o.target, `.${_t}`) === b;
        const d = i ? b : g;
        const h = t.scrollbars;
        const w = h[i ? "dragScroll" : "clickScroll"];
        const {button: y, isPrimary: O, pointerType: $} = o;
        const {pointers: C} = h;
        const x = y === 0 && O && w && (C || []).includes($);
        if (x) {
          runEachAndClear(_);
          m();
          const t = !i && (o.shiftKey || w === "instant");
          const h = bind(getBoundingClientRect$2, b);
          const y = bind(getBoundingClientRect$2, g);
          const getHandleOffset = (t, n) => (t || h())[l] - (n || y())[l];
          const O = e(getBoundingClientRect$2(f)[r]) / I(f)[a] || 1;
          const $ = createRelativeHandleMove(getElementScroll(f)[u], 1 / O);
          const C = o[s];
          const x = h();
          const H = y();
          const E = x[r];
          const z = getHandleOffset(x, H) + E / 2;
          const A = C - H[l];
          const D = i ? 0 : A - z;
          const releasePointerCapture = t => {
            runEachAndClear(k);
            d.releasePointerCapture(t.pointerId);
          };
          const M = i || t;
          const T = p();
          const k = [ addEventListener$3(v, n, releasePointerCapture), addEventListener$3(v, "selectstart", (t => preventDefault(t)), {
            H: false
          }), addEventListener$3(g, n, releasePointerCapture), M && addEventListener$3(g, "pointermove", (t => $(D + (t[s] - C)))), M && (() => {
            const t = getElementScroll(f);
            T();
            const n = getElementScroll(f);
            const o = {
              x: n.x - t.x,
              y: n.y - t.y
            };
            if (c(o.x) > 3 || c(o.y) > 3) {
              p();
              scrollElementTo(f, t);
              scrollOffsetElementScrollBy(o);
              S(T);
            }
          }) ];
          d.setPointerCapture(o.pointerId);
          if (t) {
            $(D);
          } else if (!i) {
            const t = getStaticPluginModuleInstance(At);
            if (t) {
              const n = t($, D, E, (t => {
                if (t) {
                  T();
                } else {
                  push$1(k, T);
                }
              }));
              push$1(k, n);
              push$1(_, bind(n, true));
            }
          }
        }
      }));
    };
    let O = true;
    return bind(runEachAndClear, [ addEventListener$3(b, "pointermove pointerleave", s), addEventListener$3(h, "pointerenter", (() => {
      l(vt, true);
    })), addEventListener$3(h, "pointerleave pointercancel", (() => {
      l(vt, false);
    })), !d && addEventListener$3(h, "mousedown", (() => {
      const t = getFocusedElement();
      if (hasAttr(t, q) || hasAttr(t, P) || t === document.body) {
        a(bind(focusElement, _), 25);
      }
    })), addEventListener$3(h, "wheel", (t => {
      const {deltaX: n, deltaY: o, deltaMode: s} = t;
      if (O && s === 0 && parent(h) === u) {
        scrollOffsetElementScrollBy({
          x: n,
          y: o
        });
      }
      O = false;
      l(bt, true);
      w((() => {
        O = true;
        l(bt);
      }));
      preventDefault(t);
    }), {
      H: false,
      I: true
    }), addEventListener$3(h, "pointerdown", bind(addEventListener$3, v, "click", stopAndPrevent, {
      A: true,
      I: true,
      H: false
    }), {
      I: true
    }), createInteractiveScrollEvents(), y, m ]);
  };

  const createScrollbarsSetup = (t, n, o, s, e, c) => {
    let r;
    let l;
    let i;
    let a;
    let u;
    let _ = noop$2;
    let d = 0;
    const isHoverablePointerType = t => t.pointerType === "mouse";
    const [f, v] = selfClearTimeout();
    const [p, h] = selfClearTimeout(100);
    const [g, b] = selfClearTimeout(100);
    const [w, y] = selfClearTimeout((() => d));
    const [S, m] = createScrollbarsSetupElements(t, e, s, createScrollbarsSetupEvents(n, e, s, (t => isHoverablePointerType(t) && manageScrollbarsAutoHideInstantInteraction())));
    const {ht: O, Qt: $, wt: C} = e;
    const {jt: H, Nt: z, qt: I, Bt: A, Ft: D} = S;
    const manageScrollbarsAutoHide = (t, n) => {
      y();
      if (t) {
        H(gt);
      } else {
        const t = bind(H, gt, true);
        if (d > 0 && !n) {
          w(t);
        } else {
          t();
        }
      }
    };
    const manageScrollbarsAutoHideInstantInteraction = () => {
      if (i ? !r : !a) {
        manageScrollbarsAutoHide(true);
        p((() => {
          manageScrollbarsAutoHide(false);
        }));
      }
    };
    const manageAutoHideSuspension = t => {
      H(ht, t, true);
      H(ht, t, false);
    };
    const onHostMouseEnter = t => {
      if (isHoverablePointerType(t)) {
        r = i;
        i && manageScrollbarsAutoHide(true);
      }
    };
    const M = [ y, h, b, v, () => _(), addEventListener$3(O, "pointerover", onHostMouseEnter, {
      A: true
    }), addEventListener$3(O, "pointerenter", onHostMouseEnter), addEventListener$3(O, "pointerleave", (t => {
      if (isHoverablePointerType(t)) {
        r = false;
        i && manageScrollbarsAutoHide(false);
      }
    })), addEventListener$3(O, "pointermove", (t => {
      isHoverablePointerType(t) && l && manageScrollbarsAutoHideInstantInteraction();
    })), addEventListener$3($, "scroll", (t => {
      f((() => {
        I();
        manageScrollbarsAutoHideInstantInteraction();
      }));
      c(t);
      D();
    })) ];
    return [ () => bind(runEachAndClear, push$1(M, m())), ({It: t, Dt: n, Zt: e, tn: c}) => {
      const {nn: r, sn: f, en: v, cn: p} = c || {};
      const {Ct: h, dt: b} = e || {};
      const {ct: w} = o;
      const {k: y} = getEnvironment();
      const {K: S, rn: m} = s;
      const [O, M] = t("showNativeOverlaidScrollbars");
      const [T, k] = t("scrollbars.theme");
      const [R, V] = t("scrollbars.visibility");
      const [L, U] = t("scrollbars.autoHide");
      const [P, N] = t("scrollbars.autoHideSuspend");
      const [q] = t("scrollbars.autoHideDelay");
      const [B, F] = t("scrollbars.dragScroll");
      const [j, X] = t("scrollbars.clickScroll");
      const [Y, W] = t("overflow");
      const J = b && !n;
      const G = m.x || m.y;
      const K = r || f || p || h || n;
      const Q = v || V || W;
      const Z = O && y.x && y.y;
      const setScrollbarVisibility = (t, n, o) => {
        const s = t.includes(E) && (R === x$1 || R === "auto" && n === E);
        H(dt, s, o);
        return s;
      };
      d = q;
      if (J) {
        if (P && G) {
          manageAutoHideSuspension(false);
          _();
          g((() => {
            _ = addEventListener$3($, "scroll", bind(manageAutoHideSuspension, true), {
              A: true
            });
          }));
        } else {
          manageAutoHideSuspension(true);
        }
      }
      if (M) {
        H(ct, Z);
      }
      if (k) {
        H(u);
        H(T, true);
        u = T;
      }
      if (N && !P) {
        manageAutoHideSuspension(true);
      }
      if (U) {
        l = L === "move";
        i = L === "leave";
        a = L === "never";
        manageScrollbarsAutoHide(a, true);
      }
      if (F) {
        H(yt, B);
      }
      if (X) {
        H(wt, !!j);
      }
      if (Q) {
        const t = setScrollbarVisibility(Y.x, S.x, true);
        const n = setScrollbarVisibility(Y.y, S.y, false);
        const o = t && n;
        H(ft, !o);
      }
      if (K) {
        I();
        z();
        D();
        p && A();
        H(pt, !m.x, true);
        H(pt, !m.y, false);
        H(lt, w && !C);
      }
    }, {}, S ];
  };

  const createStructureSetupElements = t => {
    const o = getEnvironment();
    const {U: s, R: e} = o;
    const {elements: c} = s();
    const {padding: r, viewport: l, content: i} = c;
    const a = isHTMLElement(t);
    const u = a ? {} : t;
    const {elements: _} = u;
    const {padding: d, viewport: f, content: v} = _ || {};
    const p = a ? t : u.target;
    const h = isBodyElement(p);
    const g = p.ownerDocument;
    const b = g.documentElement;
    const getDocumentWindow = () => g.defaultView || n;
    const w = bind(staticInitializationElement, [ p ]);
    const y = bind(dynamicInitializationElement, [ p ]);
    const S = bind(createDiv, "");
    const $ = bind(w, S, l);
    const C = bind(y, S, i);
    const elementHasOverflow = t => {
      const n = I(t);
      const o = D(t);
      const s = getStyles(t, m);
      const e = getStyles(t, O);
      return o.w - n.w > 0 && !overflowIsVisible(s) || o.h - n.h > 0 && !overflowIsVisible(e);
    };
    const x = $(f);
    const H = x === p;
    const E = H && h;
    const z = !H && C(v);
    const A = !H && x === z;
    const M = E ? b : x;
    const T = E ? M : p;
    const k = !H && y(S, r, d);
    const R = !A && z;
    const L = [ R, M, k, T ].map((t => isHTMLElement(t) && !parent(t) && t));
    const elementIsGenerated = t => t && inArray(L, t);
    const B = !elementIsGenerated(M) && elementHasOverflow(M) ? M : p;
    const F = E ? b : M;
    const j = E ? g : M;
    const X = {
      vt: p,
      ht: T,
      ot: M,
      ln: k,
      bt: R,
      gt: F,
      Qt: j,
      an: h ? b : B,
      Kt: g,
      wt: h,
      Mt: a,
      nt: H,
      un: getDocumentWindow,
      yt: t => hasAttrClass(M, q, t),
      St: (t, n) => addRemoveAttrClass(M, q, t, n),
      Ot: () => addRemoveAttrClass(F, q, Y, true)
    };
    const {vt: J, ht: Q, ln: Z, ot: tt, bt: nt} = X;
    const ot = [ () => {
      removeAttrs(Q, [ P, V ]);
      removeAttrs(J, V);
      if (h) {
        removeAttrs(b, [ V, P ]);
      }
    } ];
    let st = contents([ nt, tt, Z, Q, J ].find((t => t && !elementIsGenerated(t))));
    const et = E ? J : nt || tt;
    const ct = bind(runEachAndClear, ot);
    const appendElements = () => {
      const t = getDocumentWindow();
      const n = getFocusedElement();
      const unwrap = t => {
        appendChildren(parent(t), contents(t));
        removeElements(t);
      };
      const prepareWrapUnwrapFocus = t => addEventListener$3(t, "focusin focusout focus blur", stopAndPrevent, {
        I: true,
        H: false
      });
      const o = "tabindex";
      const s = getAttr(tt, o);
      const c = prepareWrapUnwrapFocus(n);
      setAttrs(Q, P, H ? "" : N);
      setAttrs(Z, G, "");
      setAttrs(tt, q, "");
      setAttrs(nt, K, "");
      if (!H) {
        setAttrs(tt, o, s || "-1");
        h && setAttrs(b, U, "");
      }
      appendChildren(et, st);
      appendChildren(Q, Z);
      appendChildren(Z || Q, !H && tt);
      appendChildren(tt, nt);
      push$1(ot, [ c, () => {
        const t = getFocusedElement();
        const n = elementIsGenerated(tt);
        const e = n && t === tt ? J : t;
        const c = prepareWrapUnwrapFocus(e);
        removeAttrs(Z, G);
        removeAttrs(nt, K);
        removeAttrs(tt, q);
        h && removeAttrs(b, U);
        s ? setAttrs(tt, o, s) : removeAttrs(tt, o);
        elementIsGenerated(nt) && unwrap(nt);
        n && unwrap(tt);
        elementIsGenerated(Z) && unwrap(Z);
        focusElement(e);
        c();
      } ]);
      if (e && !H) {
        addAttrClass(tt, q, W);
        push$1(ot, bind(removeAttrs, tt, q));
      }
      focusElement(!H && h && n === J && t.top === t ? tt : n);
      c();
      st = 0;
      return ct;
    };
    return [ X, appendElements, ct ];
  };

  const createTrinsicUpdateSegment = ({bt: t}) => ({Zt: n, _n: o, Dt: s}) => {
    const {xt: e} = n || {};
    const {$t: c} = o;
    const r = t && (e || s);
    if (r) {
      setStyles(t, {
        [C]: c && "100%"
      });
    }
  };

  const createPaddingUpdateSegment = ({ht: t, ln: n, ot: o, nt: s}, e) => {
    const [c, r] = createCache({
      i: equalTRBL,
      o: topRightBottomLeft()
    }, bind(topRightBottomLeft, t, "padding", ""));
    return ({It: t, Zt: l, _n: i, Dt: a}) => {
      let [u, _] = r(a);
      const {R: d} = getEnvironment();
      const {ft: f, Ht: v, Ct: m} = l || {};
      const {ct: O} = i;
      const [C, x] = t("paddingAbsolute");
      const H = a || v;
      if (f || _ || H) {
        [u, _] = c(a);
      }
      const E = !s && (x || m || _);
      if (E) {
        const t = !C || !n && !d;
        const s = u.r + u.l;
        const c = u.t + u.b;
        const r = {
          [y]: t && !O ? -s : 0,
          [S]: t ? -c : 0,
          [w]: t && O ? -s : 0,
          top: t ? -u.t : 0,
          right: t ? O ? -u.r : "auto" : 0,
          left: t ? O ? "auto" : -u.l : 0,
          [$$1]: t && `calc(100% + ${s}px)`
        };
        const l = {
          [p]: t ? u.t : 0,
          [h]: t ? u.r : 0,
          [b]: t ? u.b : 0,
          [g]: t ? u.l : 0
        };
        setStyles(n || o, r);
        setStyles(o, l);
        assignDeep(e, {
          ln: u,
          dn: !t,
          rt: n ? l : assignDeep({}, r, l)
        });
      }
      return {
        fn: E
      };
    };
  };

  const createOverflowUpdateSegment = (t, s) => {
    const e = getEnvironment();
    const {ht: c, ln: r, ot: l, nt: a, Qt: u, gt: _, wt: d, St: f, un: v} = t;
    const {R: p} = e;
    const h = d && a;
    const g = bind(o, 0);
    const b = {
      display: () => false,
      direction: t => t !== "ltr",
      flexDirection: t => t.endsWith("-reverse"),
      writingMode: t => t !== "horizontal-tb"
    };
    const w = keys$1(b);
    const y = {
      i: equalWH,
      o: {
        w: 0,
        h: 0
      }
    };
    const S = {
      i: equalXY,
      o: {}
    };
    const setMeasuringMode = t => {
      f(X, !h && t);
    };
    const getMeasuredScrollCoordinates = t => {
      const n = w.some((n => {
        const o = t[n];
        return o && b[n](o);
      }));
      if (!n) {
        return {
          D: {
            x: 0,
            y: 0
          },
          M: {
            x: 1,
            y: 1
          }
        };
      }
      setMeasuringMode(true);
      const o = getElementScroll(_);
      const s = f(J, true);
      const e = addEventListener$3(u, E, (t => {
        const n = getElementScroll(_);
        if (t.isTrusted && n.x === o.x && n.y === o.y) {
          stopPropagation(t);
        }
      }), {
        I: true,
        A: true
      });
      scrollElementTo(_, {
        x: 0,
        y: 0
      });
      s();
      const c = getElementScroll(_);
      const r = D(_);
      scrollElementTo(_, {
        x: r.w,
        y: r.h
      });
      const l = getElementScroll(_);
      scrollElementTo(_, {
        x: l.x - c.x < 1 && -r.w,
        y: l.y - c.y < 1 && -r.h
      });
      const a = getElementScroll(_);
      scrollElementTo(_, o);
      i$1((() => e()));
      return {
        D: c,
        M: a
      };
    };
    const getOverflowAmount = (t, o) => {
      const s = n.devicePixelRatio % 1 !== 0 ? 1 : 0;
      const e = {
        w: g(t.w - o.w),
        h: g(t.h - o.h)
      };
      return {
        w: e.w > s ? e.w : 0,
        h: e.h > s ? e.h : 0
      };
    };
    const [m, O] = createCache(y, bind(getFractionalSize, l));
    const [$, C] = createCache(y, bind(D, l));
    const [z, I] = createCache(y);
    const [M] = createCache(S);
    const [T, k] = createCache(y);
    const [R] = createCache(S);
    const [V] = createCache({
      i: (t, n) => equal(t, n, w),
      o: {}
    }, (() => hasDimensions(l) ? getStyles(l, w) : {}));
    const [U, N] = createCache({
      i: (t, n) => equalXY(t.D, n.D) && equalXY(t.M, n.M),
      o: getZeroScrollCoordinates()
    });
    const q = getStaticPluginModuleInstance(zt);
    const createViewportOverflowStyleClassName = (t, n) => {
      const o = n ? B : F;
      return `${o}${capitalizeFirstLetter(t)}`;
    };
    const setViewportOverflowStyle = t => {
      const createAllOverflowStyleClassNames = t => [ x$1, H, E ].map((n => createViewportOverflowStyleClassName(n, t)));
      const n = createAllOverflowStyleClassNames(true).concat(createAllOverflowStyleClassNames()).join(" ");
      f(n);
      f(keys$1(t).map((n => createViewportOverflowStyleClassName(t[n], n === "x"))).join(" "), true);
    };
    return ({It: n, Zt: o, _n: i, Dt: a}, {fn: u}) => {
      const {ft: _, Ht: d, Ct: b, dt: w, zt: y} = o || {};
      const S = q && q.tt(t, s, i, e, n);
      const {it: x, ut: H, _t: E} = S || {};
      const [D, B] = getShowNativeOverlaidScrollbars(n, e);
      const [F, j] = n("overflow");
      const X = overflowIsVisible(F.x);
      const Y = overflowIsVisible(F.y);
      const J = true;
      let K = O(a);
      let Q = C(a);
      let Z = I(a);
      let tt = k(a);
      if (B && p) {
        f(W, !D);
      }
      {
        if (hasAttrClass(c, P, L)) {
          setMeasuringMode(true);
        }
        const [t] = H ? H() : [];
        const [n] = K = m(a);
        const [o] = Q = $(a);
        const s = A(l);
        const e = h && getWindowSize(v());
        const r = {
          w: g(o.w + n.w),
          h: g(o.h + n.h)
        };
        const i = {
          w: g((e ? e.w : s.w + g(s.w - o.w)) + n.w),
          h: g((e ? e.h : s.h + g(s.h - o.h)) + n.h)
        };
        t && t();
        tt = T(i);
        Z = z(getOverflowAmount(r, i), a);
      }
      const [nt, ot] = tt;
      const [st, et] = Z;
      const [ct, rt] = Q;
      const [lt, it] = K;
      const [at, ut] = M({
        x: st.w > 0,
        y: st.h > 0
      });
      const _t = X && Y && (at.x || at.y) || X && at.x && !at.y || Y && at.y && !at.x;
      const dt = u || b || y || it || rt || ot || et || j || B || J;
      const ft = createViewportOverflowState(at, F);
      const [vt, pt] = R(ft.K);
      const [ht, gt] = V(a);
      const bt = b || w || gt || ut || a;
      const [wt, yt] = bt ? U(getMeasuredScrollCoordinates(ht), a) : N();
      if (dt) {
        pt && setViewportOverflowStyle(ft.K);
        if (E && x) {
          setStyles(l, E(ft, i, x(ft, ct, lt)));
        }
      }
      setMeasuringMode(false);
      addRemoveAttrClass(c, P, L, _t);
      addRemoveAttrClass(r, G, L, _t);
      assignDeep(s, {
        K: vt,
        Vt: {
          x: nt.w,
          y: nt.h
        },
        Rt: {
          x: st.w,
          y: st.h
        },
        rn: at,
        Lt: sanitizeScrollCoordinates(wt, st)
      });
      return {
        en: pt,
        nn: ot,
        sn: et,
        cn: yt || et,
        vn: bt
      };
    };
  };

  const createStructureSetup = t => {
    const [n, o, s] = createStructureSetupElements(t);
    const e = {
      ln: {
        t: 0,
        r: 0,
        b: 0,
        l: 0
      },
      dn: false,
      rt: {
        [y]: 0,
        [S]: 0,
        [w]: 0,
        [p]: 0,
        [h]: 0,
        [b]: 0,
        [g]: 0
      },
      Vt: {
        x: 0,
        y: 0
      },
      Rt: {
        x: 0,
        y: 0
      },
      K: {
        x: H,
        y: H
      },
      rn: {
        x: false,
        y: false
      },
      Lt: getZeroScrollCoordinates()
    };
    const {vt: c, gt: r, nt: l, Ot: i} = n;
    const {R: a, k: u} = getEnvironment();
    const _ = !a && (u.x || u.y);
    const d = [ createTrinsicUpdateSegment(n), createPaddingUpdateSegment(n, e), createOverflowUpdateSegment(n, e) ];
    return [ o, t => {
      const n = {};
      const o = _;
      const s = o && getElementScroll(r);
      const e = s && i();
      each$1(d, (o => {
        assignDeep(n, o(t, n) || {});
      }));
      scrollElementTo(r, s);
      e && e();
      !l && scrollElementTo(c, 0);
      return n;
    }, e, n, s ];
  };

  const createSetups = (t, n, o, s, e) => {
    let c = false;
    const r = createOptionCheck(n, {});
    const [l, i, a, u, _] = createStructureSetup(t);
    const [d, f, v] = createObserversSetup(u, a, r, (t => {
      update({}, t);
    }));
    const [p, h, , g] = createScrollbarsSetup(t, n, v, a, u, e);
    const updateHintsAreTruthy = t => keys$1(t).some((n => !!t[n]));
    const update = (t, e) => {
      if (o()) {
        return false;
      }
      const {pn: r, Dt: l, At: a, hn: u} = t;
      const _ = r || {};
      const d = !!l || !c;
      const p = {
        It: createOptionCheck(n, _, d),
        pn: _,
        Dt: d
      };
      if (u) {
        h(p);
        return false;
      }
      const g = e || f(assignDeep({}, p, {
        At: a
      }));
      const b = i(assignDeep({}, p, {
        _n: v,
        Zt: g
      }));
      h(assignDeep({}, p, {
        Zt: g,
        tn: b
      }));
      const w = updateHintsAreTruthy(g);
      const y = updateHintsAreTruthy(b);
      const S = w || y || !isEmptyObject(_) || d;
      c = true;
      S && s(t, {
        Zt: g,
        tn: b
      });
      return S;
    };
    return [ () => {
      const {an: t, gt: n, Ot: o} = u;
      const s = getElementScroll(t);
      const e = [ d(), l(), p() ];
      const c = o();
      scrollElementTo(n, s);
      c();
      return bind(runEachAndClear, e);
    }, update, () => ({
      gn: v,
      bn: a
    }), {
      wn: u,
      yn: g
    }, _ ];
  };

  const OverlayScrollbars = (t, n, o) => {
    const {N: s} = getEnvironment();
    const e = isHTMLElement(t);
    const c = e ? t : t.target;
    const r = getInstance(c);
    if (n && !r) {
      let r = false;
      const l = [];
      const i = {};
      const validateOptions = t => {
        const n = removeUndefinedProperties(t);
        const o = getStaticPluginModuleInstance(xt);
        return o ? o(n, true) : n;
      };
      const a = assignDeep({}, s(), validateOptions(n));
      const [u, _, d] = createEventListenerHub();
      const [f, v, p] = createEventListenerHub(o);
      const triggerEvent = (t, n) => {
        p(t, n);
        d(t, n);
      };
      const [h, g, b, w, y] = createSetups(t, a, (() => r), (({pn: t, Dt: n}, {Zt: o, tn: s}) => {
        const {ft: e, Ct: c, xt: r, Ht: l, Et: i, dt: a} = o;
        const {nn: u, sn: _, en: d, cn: f} = s;
        triggerEvent("updated", [ S, {
          updateHints: {
            sizeChanged: !!e,
            directionChanged: !!c,
            heightIntrinsicChanged: !!r,
            overflowEdgeChanged: !!u,
            overflowAmountChanged: !!_,
            overflowStyleChanged: !!d,
            scrollCoordinatesChanged: !!f,
            contentMutation: !!l,
            hostMutation: !!i,
            appear: !!a
          },
          changedOptions: t || {},
          force: !!n
        } ]);
      }), (t => triggerEvent("scroll", [ S, t ])));
      const destroy = t => {
        removeInstance(c);
        runEachAndClear(l);
        r = true;
        triggerEvent("destroyed", [ S, t ]);
        _();
        v();
      };
      const S = {
        options(t, n) {
          if (t) {
            const o = n ? s() : {};
            const e = getOptionsDiff(a, assignDeep(o, validateOptions(t)));
            if (!isEmptyObject(e)) {
              assignDeep(a, e);
              g({
                pn: e
              });
            }
          }
          return assignDeep({}, a);
        },
        on: f,
        off: (t, n) => {
          t && n && v(t, n);
        },
        state() {
          const {gn: t, bn: n} = b();
          const {ct: o} = t;
          const {Vt: s, Rt: e, K: c, rn: l, ln: i, dn: a, Lt: u} = n;
          return assignDeep({}, {
            overflowEdge: s,
            overflowAmount: e,
            overflowStyle: c,
            hasOverflow: l,
            scrollCoordinates: {
              start: u.D,
              end: u.M
            },
            padding: i,
            paddingAbsolute: a,
            directionRTL: o,
            destroyed: r
          });
        },
        elements() {
          const {vt: t, ht: n, ln: o, ot: s, bt: e, gt: c, Qt: r} = w.wn;
          const {Xt: l, Gt: i} = w.yn;
          const translateScrollbarStructure = t => {
            const {Pt: n, Ut: o, Tt: s} = t;
            return {
              scrollbar: s,
              track: o,
              handle: n
            };
          };
          const translateScrollbarsSetupElement = t => {
            const {Yt: n, Wt: o} = t;
            const s = translateScrollbarStructure(n[0]);
            return assignDeep({}, s, {
              clone: () => {
                const t = translateScrollbarStructure(o());
                g({
                  hn: true
                });
                return t;
              }
            });
          };
          return assignDeep({}, {
            target: t,
            host: n,
            padding: o || s,
            viewport: s,
            content: e || s,
            scrollOffsetElement: c,
            scrollEventElement: r,
            scrollbarHorizontal: translateScrollbarsSetupElement(l),
            scrollbarVertical: translateScrollbarsSetupElement(i)
          });
        },
        update: t => g({
          Dt: t,
          At: true
        }),
        destroy: bind(destroy, false),
        plugin: t => i[keys$1(t)[0]]
      };
      push$1(l, [ y ]);
      addInstance(c, S);
      registerPluginModuleInstances($t, OverlayScrollbars, [ S, u, i ]);
      if (cancelInitialization(w.wn.wt, !e && t.cancel)) {
        destroy(true);
        return S;
      }
      push$1(l, h());
      triggerEvent("initialized", [ S ]);
      S.update();
      return S;
    }
    return r;
  };

  OverlayScrollbars.plugin = t => {
    const n = isArray(t);
    const o = n ? t : [ t ];
    const s = o.map((t => registerPluginModuleInstances(t, OverlayScrollbars)[0]));
    addPlugins(o);
    return n ? s : s[0];
  };

  OverlayScrollbars.valid = t => {
    const n = t && t.elements;
    const o = isFunction$2(n) && n();
    return isPlainObject(o) && !!getInstance(o.target);
  };

  OverlayScrollbars.env = () => {
    const {T: t, k: n, R: o, V: s, B: e, F: c, U: r, P: l, N: i, q: a} = getEnvironment();
    return assignDeep({}, {
      scrollbarsSize: t,
      scrollbarsOverlaid: n,
      scrollbarsHiding: o,
      scrollTimeline: s,
      staticDefaultInitialization: e,
      staticDefaultOptions: c,
      getDefaultInitialization: r,
      setDefaultInitialization: l,
      getDefaultOptions: i,
      setDefaultOptions: a
    });
  };

  OverlayScrollbars.nonce = setNonce;

  var commonjsGlobal$2 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var lib$2 = {exports: {}};

  (function (module, exports) {
  	!function(r,n){module.exports=n();}("undefined"!=typeof self?self:commonjsGlobal$2,(function(){return function(r){var n={};function e(t){if(n[t])return n[t].exports;var o=n[t]={i:t,l:!1,exports:{}};return r[t].call(o.exports,o,o.exports,e),o.l=!0,o.exports}return e.m=r,e.c=n,e.d=function(r,n,t){e.o(r,n)||Object.defineProperty(r,n,{enumerable:!0,get:t});},e.r=function(r){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0});},e.t=function(r,n){if(1&n&&(r=e(r)),8&n)return r;if(4&n&&"object"==typeof r&&r&&r.__esModule)return r;var t=Object.create(null);if(e.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:r}),2&n&&"string"!=typeof r)for(var o in r)e.d(t,o,function(n){return r[n]}.bind(null,o));return t},e.n=function(r){var n=r&&r.__esModule?function(){return r.default}:function(){return r};return e.d(n,"a",n),n},e.o=function(r,n){return Object.prototype.hasOwnProperty.call(r,n)},e.p="",e(e.s=0)}([function(r,n,e){e.r(n),e.d(n,"md5",(function(){return p}));var t="0123456789abcdef".split("");var o=function(r){for(var n="",e=0;e<4;e++)n+=t[r>>8*e+4&15]+t[r>>8*e&15];return n};var u=function(r){for(var n=r.length,e=0;e<n;e++)r[e]=o(r[e]);return r.join("")};var f=function(r,n){return r+n&4294967295};var i=function(r,n,e,t,o,u,i){return function(r,n,e){return f(r<<n|r>>>32-n,e)}(n=function(r,n,e,t){return n=f(f(n,r),f(e,t))}(r,n,t,u),o,e)};var a=function(r,n,e,t,o,u,f,a){return i(e&t|~e&o,n,e,u,f,a)};var c=function(r,n,e,t,o,u,f,a){return i(e&o|t&~o,n,e,u,f,a)};var l=function(r,n,e,t,o,u,f,a){return i(e^t^o,n,e,u,f,a)};var d=function(r,n,e,t,o,u,f,a){return i(t^(e|~o),n,e,u,f,a)};var v=function(r,n,e){void 0===e&&(e=f);var t=r[0],o=r[1],u=r[2],i=r[3],v=a.bind(null,e);t=v(t,o,u,i,n[0],7,-680876936),i=v(i,t,o,u,n[1],12,-389564586),u=v(u,i,t,o,n[2],17,606105819),o=v(o,u,i,t,n[3],22,-1044525330),t=v(t,o,u,i,n[4],7,-176418897),i=v(i,t,o,u,n[5],12,1200080426),u=v(u,i,t,o,n[6],17,-1473231341),o=v(o,u,i,t,n[7],22,-45705983),t=v(t,o,u,i,n[8],7,1770035416),i=v(i,t,o,u,n[9],12,-1958414417),u=v(u,i,t,o,n[10],17,-42063),o=v(o,u,i,t,n[11],22,-1990404162),t=v(t,o,u,i,n[12],7,1804603682),i=v(i,t,o,u,n[13],12,-40341101),u=v(u,i,t,o,n[14],17,-1502002290),o=v(o,u,i,t,n[15],22,1236535329);var s=c.bind(null,e);t=s(t,o,u,i,n[1],5,-165796510),i=s(i,t,o,u,n[6],9,-1069501632),u=s(u,i,t,o,n[11],14,643717713),o=s(o,u,i,t,n[0],20,-373897302),t=s(t,o,u,i,n[5],5,-701558691),i=s(i,t,o,u,n[10],9,38016083),u=s(u,i,t,o,n[15],14,-660478335),o=s(o,u,i,t,n[4],20,-405537848),t=s(t,o,u,i,n[9],5,568446438),i=s(i,t,o,u,n[14],9,-1019803690),u=s(u,i,t,o,n[3],14,-187363961),o=s(o,u,i,t,n[8],20,1163531501),t=s(t,o,u,i,n[13],5,-1444681467),i=s(i,t,o,u,n[2],9,-51403784),u=s(u,i,t,o,n[7],14,1735328473),o=s(o,u,i,t,n[12],20,-1926607734);var b=l.bind(null,e);t=b(t,o,u,i,n[5],4,-378558),i=b(i,t,o,u,n[8],11,-2022574463),u=b(u,i,t,o,n[11],16,1839030562),o=b(o,u,i,t,n[14],23,-35309556),t=b(t,o,u,i,n[1],4,-1530992060),i=b(i,t,o,u,n[4],11,1272893353),u=b(u,i,t,o,n[7],16,-155497632),o=b(o,u,i,t,n[10],23,-1094730640),t=b(t,o,u,i,n[13],4,681279174),i=b(i,t,o,u,n[0],11,-358537222),u=b(u,i,t,o,n[3],16,-722521979),o=b(o,u,i,t,n[6],23,76029189),t=b(t,o,u,i,n[9],4,-640364487),i=b(i,t,o,u,n[12],11,-421815835),u=b(u,i,t,o,n[15],16,530742520),o=b(o,u,i,t,n[2],23,-995338651);var p=d.bind(null,e);t=p(t,o,u,i,n[0],6,-198630844),i=p(i,t,o,u,n[7],10,1126891415),u=p(u,i,t,o,n[14],15,-1416354905),o=p(o,u,i,t,n[5],21,-57434055),t=p(t,o,u,i,n[12],6,1700485571),i=p(i,t,o,u,n[3],10,-1894986606),u=p(u,i,t,o,n[10],15,-1051523),o=p(o,u,i,t,n[1],21,-2054922799),t=p(t,o,u,i,n[8],6,1873313359),i=p(i,t,o,u,n[15],10,-30611744),u=p(u,i,t,o,n[6],15,-1560198380),o=p(o,u,i,t,n[13],21,1309151649),t=p(t,o,u,i,n[4],6,-145523070),i=p(i,t,o,u,n[11],10,-1120210379),u=p(u,i,t,o,n[2],15,718787259),o=p(o,u,i,t,n[9],21,-343485551),r[0]=e(t,r[0]),r[1]=e(o,r[1]),r[2]=e(u,r[2]),r[3]=e(i,r[3]);};var s=function(r){for(var n=[],e=0;e<64;e+=4)n[e>>2]=r.charCodeAt(e)+(r.charCodeAt(e+1)<<8)+(r.charCodeAt(e+2)<<16)+(r.charCodeAt(e+3)<<24);return n};var b=function(r,n){var e,t=r.length,o=[1732584193,-271733879,-1732584194,271733878];for(e=64;e<=t;e+=64)v(o,s(r.substring(e-64,e)),n);var u=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],f=(r=r.substring(e-64)).length;for(e=0;e<f;e++)u[e>>2]|=r.charCodeAt(e)<<(e%4<<3);if(u[e>>2]|=128<<(e%4<<3),e>55)for(v(o,u,n),e=16;e--;)u[e]=0;return u[14]=8*t,v(o,u,n),o};function p(r){var n;return "5d41402abc4b2a76b9719d911017c592"!==u(b("hello"))&&(n=function(r,n){var e=(65535&r)+(65535&n);return (r>>16)+(n>>16)+(e>>16)<<16|65535&e}),u(b(r,n))}}])}));
  	
  } (lib$2));

  function _createForOfIteratorHelper$1(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$1$1(r)) || e) { t && (r = t); var _n2 = 0, F = function F() {}; return { s: F, n: function n() { return _n2 >= r.length ? { done: !0 } : { done: !1, value: r[_n2++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
  function _toConsumableArray$1(r) { return _arrayWithoutHoles$1(r) || _iterableToArray$1(r) || _unsupportedIterableToArray$1$1(r) || _nonIterableSpread$1(); }
  function _nonIterableSpread$1() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArray$1(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
  function _arrayWithoutHoles$1(r) { if (Array.isArray(r)) return _arrayLikeToArray$1$1(r); }
  function _typeof$1(o) { "@babel/helpers - typeof"; return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$1(o); }
  function _defineProperty$1$1(e, r, t) { return (r = _toPropertyKey$1$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
  function _unsupportedIterableToArray$1$1(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$1$1(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1$1(r, a) : void 0; } }
  function _arrayLikeToArray$1$1(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  function _defineProperties$1(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey$1$1(o.key), o); } }
  function _createClass$1(e, r, t) { return r && _defineProperties$1(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
  function _toPropertyKey$1$1(t) { var i = _toPrimitive$1$1(t, "string"); return "symbol" == _typeof$1(i) ? i : i + ""; }
  function _toPrimitive$1$1(t, r) { if ("object" != _typeof$1(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof$1(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
  function _classCallCheck$1(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
  function _callSuper$1(t, o, e) { return o = _getPrototypeOf$1(o), _possibleConstructorReturn$1(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e)); }
  function _possibleConstructorReturn$1(t, e) { if (e && ("object" == _typeof$1(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized$1(t); }
  function _assertThisInitialized$1(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
  function _inherits$1(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$1(t, e); }
  function _wrapNativeSuper$1(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper$1 = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction$1(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct$1(t, arguments, _getPrototypeOf$1(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf$1(Wrapper, t); }, _wrapNativeSuper$1(t); }
  function _construct$1(t, e, r) { if (_isNativeReflectConstruct$1()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf$1(p, r.prototype), p; }
  function _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }
  function _isNativeFunction$1(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
  function _setPrototypeOf$1(t, e) { return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf$1(t, e); }
  function _getPrototypeOf$1(t) { return _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf$1(t); }
  var RefException$1 = /*#__PURE__*/function (_Error) {
    function RefException(str) {
      _classCallCheck$1(this, RefException);
      return _callSuper$1(this, RefException, ["Invalid reference : ".concat(str)]);
    }
    _inherits$1(RefException, _Error);
    return _createClass$1(RefException);
  }(/*#__PURE__*/_wrapNativeSuper$1(Error));
  var EventEmitter$2 = /*#__PURE__*/function () {
    function EventEmitter() {
      _classCallCheck$1(this, EventEmitter);
      _defineProperty$1$1(this, "_events", {});
      this.addEventListener = this.on;
      this.addListener = this.on;
      this.removeEventListener = this.off;
      this.removeListener = this.off;
    }
    return _createClass$1(EventEmitter, [{
      key: "on",
      value: function on(event, listener) {
        if (_typeof$1(this._events[event]) !== 'object') this._events[event] = [];
        this._events[event].push(listener);
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        clear$1(this._events);
      }
    }, {
      key: "off",
      value: function off(event, listener) {
        if (!event) {
          this.removeAllListeners();
          return;
        }
        if (_typeof$1(this._events[event]) !== 'object') return;
        if (listener) array_remove$1(this._events[event], listener);else clear$1(this._events[event]);
      }
    }, {
      key: "emit",
      value: function emit(event) {
        if (_typeof$1(this._events[event]) !== 'object') return;
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        for (var _i = 0, _arr = _toConsumableArray$1(this._events[event]); _i < _arr.length; _i++) {
          var l = _arr[_i];
          l.apply(this, args);
        }
      }
    }, {
      key: "once",
      value: function once(event, listener) {
        var _this4 = this;
        var _listener_wrapped = function listener_wrapped() {
          _this4.removeListener(event, _listener_wrapped);
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          listener.apply(_this4, args);
        };
        this.on(event, _listener_wrapped);
      }
    }]);
  }();
  var Timer$1 = /*#__PURE__*/function (_EventEmitter2) {
    function Timer() {
      var _this5;
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var autostart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      _classCallCheck$1(this, Timer);
      _this5 = _callSuper$1(this, Timer);
      _this5._total_time = time;
      _this5._interval_id;
      _this5._last_seconds_left;
      _this5._stopwatch = new StopWatch$1();
      _this5._stopwatch.on("pause", function () {
        clearInterval(_this5._interval_id);
        _this5.emit("pause");
      });
      _this5._stopwatch.on("start", function () {
        _this5._interval_id = setInterval(function () {
          return _this5.tick();
        }, Timer.TICK_INTERVAL);
        _this5.emit("start");
      });
      _this5._stopwatch.on("reset", function () {
        _this5._last_seconds_left = _this5.seconds_left;
        _this5.emit("reset");
        _this5.emit("second", _this5._last_seconds_left);
      });
      if (autostart) _this5.restart();
      return _this5;
    }
    _inherits$1(Timer, _EventEmitter2);
    return _createClass$1(Timer, [{
      key: "time_left",
      get: function get() {
        return Math.max(0, this._total_time - this._stopwatch.time);
      }
    }, {
      key: "seconds_left",
      get: function get() {
        return Math.ceil(this.time_left / 1000);
      }
    }, {
      key: "finished",
      get: function get() {
        return this.time_left <= 0;
      }
    }, {
      key: "paused",
      get: function get() {
        return this._stopwatch.paused;
      }
    }, {
      key: "restart",
      value: function restart(time) {
        if (time !== undefined) this._total_time = time;
        this._stopwatch.reset();
        this.resume();
      }
    }, {
      key: "tick",
      value: function tick() {
        var seconds_left = this.seconds_left;
        for (var i = this._last_seconds_left - 1; i >= seconds_left; i--) {
          this.emit("second", i);
        }
        this._last_seconds_left = seconds_left;
        this.emit("tick");
        if (this.finished) {
          this.pause();
          this.emit("finish");
        }
      }
    }, {
      key: "pause",
      value: function pause() {
        this._stopwatch.pause();
      }
    }, {
      key: "resume",
      value: function resume() {
        this._stopwatch.resume();
      }
    }, {
      key: "reset",
      value: function reset() {
        this._stopwatch.reset();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this._stopwatch.destroy();
        this.removeAllListeners();
      }
    }]);
  }(EventEmitter$2);
  Timer$1.TICK_INTERVAL = 1000 / 60;
  var StopWatch$1 = /*#__PURE__*/function (_EventEmitter3) {
    function StopWatch() {
      var _this6;
      _classCallCheck$1(this, StopWatch);
      _this6 = _callSuper$1(this, StopWatch);
      _this6._start_time = 0;
      _this6._pause_time = 0;
      _this6._paused = true;
      return _this6;
    }
    _inherits$1(StopWatch, _EventEmitter3);
    return _createClass$1(StopWatch, [{
      key: "time",
      get: function get() {
        return (this._paused ? this._pause_time : Date.now()) - this._start_time;
      }
    }, {
      key: "paused",
      get: function get() {
        return this._paused;
      }
    }, {
      key: "start",
      value: function start() {
        var now = Date.now();
        if (!this._start_time) this._start_time = now;
        if (this._paused) {
          this._paused = false;
          this._start_time += now - this._pause_time;
          this._pause_time = 0;
          this.emit("start");
        }
      }
    }, {
      key: "resume",
      value: function resume() {
        this.start();
      }
    }, {
      key: "pause",
      value: function pause() {
        if (this._paused) return;
        this._paused = true;
        this._pause_time = Date.now();
        this.emit("pause");
      }
    }, {
      key: "reset",
      value: function reset() {
        this._start_time = Date.now();
        if (this._paused) this._pause_time = this._start_time;
        this.emit("reset");
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.removeAllListeners();
      }
    }]);
  }(EventEmitter$2);
  var Diff$1 = /*#__PURE__*/_createClass$1(function Diff(old_value, new_value) {
    _classCallCheck$1(this, Diff);
    if (old_value === new_value) this.type = 0;
    if (old_value === undefined) this.type = Diff.CREATED;else if (new_value === undefined) this.type = Diff.DELETED;else this.type = Diff.CHANGED;
    this.old_value = old_value;
    this.new_value = new_value;
    Object.freeze(this);
  });
  Diff$1.CREATED = 1;
  Diff$1.DELETED = 2;
  Diff$1.CHANGED = 3;
  var Point$1 = /*#__PURE__*/_createClass$1(function Point(x, y) {
    _classCallCheck$1(this, Point);
    this.x = x;
    this.y = y;
  });
  Point$1.distance = function (x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2), Math.pow(y2 - y1, 2));
  };
  var Rectangle$1 = /*#__PURE__*/function () {
    function Rectangle() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      _classCallCheck$1(this, Rectangle);
      args = function () {
        if (args.length == 4) return args;
        if (args.length == 2) return [0, 0].concat(_toConsumableArray$1(args));
        if (args.length == 1) {
          if (Array.isArray(args[0])) return args[0];
          if (_typeof$1(args[0]) === "object") {
            var _args$ = args[0],
              x = _args$.x,
              y = _args$.y,
              width = _args$.width,
              height = _args$.height,
              left = _args$.left,
              right = _args$.right,
              bottom = _args$.bottom,
              top = _args$.top;
            if (x == undefined) x = left;
            if (y == undefined) y = top;
            if (width == undefined) width = right - left;
            if (height == undefined) height = bottom - top;
            return [x, y, width, height];
          }
        }
        if (args.length == 0) return [0, 0, 0, 0];
      }();
      this.x = +args[0] || 0;
      this.y = +args[1] || 0;
      this.width = +args[2] || 0;
      this.height = +args[3] || 0;
    }
    return _createClass$1(Rectangle, [{
      key: "left",
      get: function get() {
        return this.x;
      },
      set: function set(value) {
        var d = value - this.x;
        this.x += d;
        this.width -= d;
      }
    }, {
      key: "top",
      get: function get() {
        return this.y;
      },
      set: function set(value) {
        var d = value - this.y;
        this.y += d;
        this.height -= d;
      }
    }, {
      key: "right",
      get: function get() {
        return this.x + this.width;
      },
      set: function set(value) {
        this.width += value - this.right;
      }
    }, {
      key: "bottom",
      get: function get() {
        return this.y + this.height;
      },
      set: function set(value) {
        this.height += value - this.bottom;
      }
    }, {
      key: "center",
      get: function get() {
        return {
          x: this.x + this.width / 2,
          y: this.y + this.height / 2
        };
      }
    }, {
      key: "contains",
      value: function contains(obj) {
        if (!obj.width && !obj.height) return obj.x > this.left && obj.x < this.right && obj.y > this.top && obj.y < this.bottom;
        return obj.x > this.left && obj.x + obj.width < this.right && obj.y > this.top && obj.y + obj.height < this.bottom;
      }
    }, {
      key: "intersects",
      value: function intersects(obj) {
        return obj.x + obj.width > this.left && obj.x < this.right && obj.y + obj.height > this.top && obj.y < this.bottom;
      }
    }, {
      key: "union",
      value: function union(obj) {
        var x = Math.min(obj.x, this.x);
        var y = Math.min(obj.y, this.y);
        var right = Math.max(obj.x + (obj.width || 0), this.right);
        var bottom = Math.max(obj.y + (obj.height || 0), this.bottom);
        return new Rectangle(x, y, right - x, bottom - y);
      }
    }, {
      key: "intersection",
      value: function intersection(obj) {
        var x = Math.max(obj.x, this.x);
        var y = Math.max(obj.y, this.y);
        var right = Math.min(obj.x + obj.width, this.right);
        var bottom = Math.min(obj.y + obj.height, this.bottom);
        return new Rectangle(x, y, right - x, bottom - y);
      }
    }, {
      key: "scale",
      value: function scale(x, y) {
        if (y === undefined) y = x;
        this.x *= x;
        this.y *= y;
        this.width *= x;
        this.height *= y;
        return this;
      }
    }, {
      key: "expand",
      value: function expand(x, y) {
        if (y === undefined) y = x;
        this.x -= x / 2;
        this.y -= y / 2;
        this.width += x;
        this.height += y;
        return this;
      }
    }, {
      key: "fix",
      value: function fix() {
        if (this.width < 0) {
          this.x += this.width;
          this.width *= -1;
        }
        if (this.height < 0) {
          this.y += this.height;
          this.height *= -1;
        }
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
      }
    }, {
      key: "equals",
      value: function equals(obj) {
        try {
          return this.x === obj.x && this.y === obj.y && this.width === obj.width && this.height === obj.height;
        } catch (_unused) {
          return false;
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        return "[Rectangle x:".concat(this.x, " y:").concat(this.y, " width:").concat(this.width, " height:").concat(this.height, "]");
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height
        };
      }
    }]);
  }();
  Rectangle$1.union = function () {
    for (var _len4 = arguments.length, rects = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      rects[_key4] = arguments[_key4];
    }
    var x = Math.min.apply(Math, _toConsumableArray$1(rects.map(function (r) {
      return r.x;
    })));
    var y = Math.min.apply(Math, _toConsumableArray$1(rects.map(function (r) {
      return r.y;
    })));
    var right = Math.max.apply(Math, _toConsumableArray$1(rects.map(function (r) {
      return r.x + r.width;
    })));
    var bottom = Math.max.apply(Math, _toConsumableArray$1(rects.map(function (r) {
      return r.y + r.height;
    })));
    return new Rectangle$1(x, y, right - x, bottom - y);
  };
  Rectangle$1.intersection = function () {
    for (var _len5 = arguments.length, rects = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      rects[_key5] = arguments[_key5];
    }
    var x = Math.max.apply(Math, _toConsumableArray$1(rects.map(function (r) {
      return r.x;
    })));
    var y = Math.max.apply(Math, _toConsumableArray$1(rects.map(function (r) {
      return r.y;
    })));
    var right = Math.min.apply(Math, _toConsumableArray$1(rects.map(function (r) {
      return r.x + r.width;
    })));
    var bottom = Math.min.apply(Math, _toConsumableArray$1(rects.map(function (r) {
      return r.y + r.height;
    })));
    return new Rectangle$1(x, y, right - x, bottom - y);
  };
  var Color$1 = /*#__PURE__*/function () {
    function Color() {
      for (var _len6 = arguments.length, components = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        components[_key6] = arguments[_key6];
      }
      _classCallCheck$1(this, Color);
      this._r = 0;
      this._g = 0;
      this._b = 0;
      this._h = 0;
      this._s = 0;
      this._l = 0;
      this._a = 1.0;
      if (components.length == 1) {
        var c = components[0];
        if (Array.isArray(c)) {
          s;
          components = _toConsumableArray$1(c);
        } else if (_typeof$1(c) === "object") {
          components = [c.r || c.red || 0, c.g || c.green || 0, c.b || c.blue || 0, c.a || c.alpha || 1];
        } else if (typeof c === "string") {
          if (c.charAt(0) === "#") c = c.slice(1);else if (c.substring(0, 2) === "0x") c = c.slice(2);
          if (c.length < 6) components = c.split("").map(function (a) {
            return a + a;
          });else components = c.match(/.{1,2}/g);
        }
      }
      components = components.map(function (c) {
        if (typeof c === "string" && c.match(/^[0-9a-f]{2}$/)) return parseInt(c, 16);
        return +c;
      });
      this.from_rgba.apply(this, _toConsumableArray$1(components));
    }
    return _createClass$1(Color, [{
      key: "r",
      get: function get() {
        return this._r;
      }
    }, {
      key: "g",
      get: function get() {
        return this._g;
      }
    }, {
      key: "b",
      get: function get() {
        return this._b;
      }
    }, {
      key: "h",
      get: function get() {
        return this._h;
      }
    }, {
      key: "s",
      get: function get() {
        return this._s;
      }
    }, {
      key: "l",
      get: function get() {
        return this._l;
      }
    }, {
      key: "a",
      get: function get() {
        return this._a;
      }
    }, {
      key: "from_hsl",
      value: function from_hsl() {
        var h = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var l = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return this.from_hsla(h, s, l, 1);
      }
    }, {
      key: "from_hsla",
      value: function from_hsla() {
        var h = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var l = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        this._h = h = clamp$2(h, 0, 1);
        this._s = s = clamp$2(s, 0, 1);
        this._l = l = clamp$2(l, 0, 1);
        this._a = a = clamp$2(a, 0, 1);
        var r, g, b;
        if (s == 0) {
          r = g = b = l;
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = Color.hue2rgb(p, q, h + 1 / 3);
          g = Color.hue2rgb(p, q, h);
          b = Color.hue2rgb(p, q, h - 1 / 3);
        }
        this._r = Math.round(r * 255);
        this._g = Math.round(g * 255);
        this._b = Math.round(b * 255);
        return this;
      }
    }, {
      key: "from_rgb",
      value: function from_rgb() {
        var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return this.from_rgba(r, g, b, 1);
      }
    }, {
      key: "from_rgba",
      value: function from_rgba() {
        var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        this._r = r = Math.round(clamp$2(r, 0, 255));
        this._g = g = Math.round(clamp$2(g, 0, 255));
        this._b = b = Math.round(clamp$2(b, 0, 255));
        this._a = a = Math.round(clamp$2(a, 0, 1));
        r /= 255;
        g /= 255;
        b /= 255;
        var cMax = Math.max(r, g, b);
        var cMin = Math.min(r, g, b);
        var delta = cMax - cMin;
        var l = (cMax + cMin) / 2;
        var h = 0;
        var s = 0;
        if (delta == 0) h = 0;else if (cMax == r) h = 60 * ((g - b) / delta % 6);else if (cMax == g) h = 60 * ((b - r) / delta + 2);else h = 60 * ((r - g) / delta + 4);
        s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
        this._h = h;
        this._s = s;
        this._l = l;
        return this;
      }
    }, {
      key: "rgb_mix",
      value: function rgb_mix(c) {
        var m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
        return this.rgba_mix(c, m);
      }
    }, {
      key: "rgba_mix",
      value: function rgba_mix(c) {
        var m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
        c = Color.from(c);
        return new Color(lerp$1(this._r, c.r, m), lerp$1(this._g, c.g, m), lerp$1(this._b, c.b, m), lerp$1(this._a, c.a, m));
      }
    }, {
      key: "hsl_mix",
      value: function hsl_mix(c) {
        var m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
        return this.hsla_mix(c, m);
      }
    }, {
      key: "hsla_mix",
      value: function hsla_mix(c) {
        var m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
        c = Color.from(c);
        return new Color(lerp$1(this._h, c.h, m), lerp$1(this._s, c.s, m), lerp$1(this._l, c.l, m), lerp$1(this._a, c.a, m));
      }
    }, {
      key: "to_hsl_array",
      value: function to_hsl_array() {
        return [this._h, this._s, this._l];
      }
    }, {
      key: "to_rgb_array",
      value: function to_rgb_array() {
        return [this._r, this._g, this._b];
      }
    }, {
      key: "to_hsla_array",
      value: function to_hsla_array() {
        return [this._h, this._s, this._l, this._a];
      }
    }, {
      key: "to_rgba_array",
      value: function to_rgba_array() {
        return [this._r, this._g, this._b, this._a];
      }
    }, {
      key: "to_hsl_string",
      value: function to_hsl_string() {
        return "hsl(".concat(this._h, ", ").concat(this._s, ", ").concat(this._l, ")");
      }
    }, {
      key: "to_rgb_string",
      value: function to_rgb_string() {
        return "rgb(".concat(this._r, ", ").concat(this._g, ", ").concat(this._b, ")");
      }
    }, {
      key: "to_hsla_string",
      value: function to_hsla_string() {
        return "hsla(".concat(this._h, ", ").concat(this._s, ", ").concat(this._l, ", ").concat(this._a, ")");
      }
    }, {
      key: "to_rgba_string",
      value: function to_rgba_string() {
        return "rgba(".concat(this._r, ", ").concat(this._g, ", ").concat(this._b, ", ").concat(this._a, ")");
      }
    }, {
      key: "to_rgb_hex",
      value: function to_rgb_hex() {
        return "#".concat(this._r.toString(16)).concat(this._g.toString(16)).concat(this._b.toString(16));
      }
    }, {
      key: "to_rgba_hex",
      value: function to_rgba_hex() {
        return "#".concat(this._r.toString(16)).concat(this._g.toString(16)).concat(this._b.toString(16)).concat(this._a.toString(16));
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.to_rgba_string();
      }
    }, {
      key: "copy",
      value: function copy() {
        var c = new Color();
        c._r = this._r;
        c._g = this._g;
        c._b = this._b;
        c._h = this._h;
        c._s = this._s;
        c._l = this._l;
        c._a = this._a;
        return c;
      }
    }]);
  }();
  Color$1.from = function () {
    for (var _len7 = arguments.length, components = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      components[_key7] = arguments[_key7];
    }
    if (components.length === 1 && components[0] instanceof Color$1) {
      return components[0];
    }
    return _construct$1(Color$1, components);
  };
  Color$1.mix = function (c1, c2) {
    var m = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
    return Color$1.from(c1).mix(c2, m);
  };
  Color$1.hue_to_rgb = function (p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  };
  function is_valid_url$1(str) {
    return /(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})/i.test(str);
  }
  function is_valid_rtmp_url$1(str) {
    return /^rtmps?\:\/\//i.test(str);
  }
  function debounce$4(func) {
    var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var timeout, previous, args, result, context;
    var _later = function later() {
      var passed = Date.now() - previous;
      if (wait > passed) {
        timeout = setTimeout(_later, wait - passed);
      } else {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
        if (!timeout) args = context = null;
      }
    };
    var debounced = function debounced() {
      context = this;
      for (var _len10 = arguments.length, p = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        p[_key10] = arguments[_key10];
      }
      args = p;
      previous = Date.now();
      if (!timeout) {
        timeout = setTimeout(_later, wait);
        if (immediate) result = func.apply(context, args);
      }
      return result;
    };
    debounced.cancel = function () {
      clearTimeout(timeout);
      timeout = args = context = null;
    };
    return debounced;
  }
  function timespan_str_to_seconds$1(str) {
    var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hh:mm:ss";
    return timespan_str_to_ms$1(str, format) / 1000;
  }
  // will also handle decimal points (milliseconds)
  function timespan_str_to_ms$1(str) {
    var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hh:mm:ss";
    var multiply = 1;
    if (str.startsWith("-")) {
      multiply = -1;
      str = str.slice(1);
    }
    var parts = String(str).split(/:/);
    var format_parts = format.split(/:/);
    if (format_parts.length > parts.length) format_parts = format_parts.slice(-parts.length); // so if str = "10:00" and format = "hh:mm:ss", the assumed format will be "mm:ss"
    else parts = parts.slice(-format_parts.length);
    var ms = 0;
    for (var i = 0; i < parts.length; i++) {
      var v = parseFloat(parts[i]);
      var f = format_parts[i][0];
      if (!Number.isFinite(v)) v = 0; // handles NaN & Infinity
      if (f == "d") ms += v * 24 * 60 * 60 * 1000;else if (f == "h") ms += v * 60 * 60 * 1000;else if (f == "m") ms += v * 60 * 1000;else if (f == "s") ms += v * 1000;
    }
    return ms * multiply;
  }
  // ms
  function ms_to_timespan_str$1(num) {
    var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hh:mm:ss";
    var negative = num < 0;
    num = Math.abs(+num) || 0;
    var format_parts = format.split(/([^a-z])/i).filter(function (m) {
      return m;
    });
    var parts = [];
    for (var i = 0; i < format_parts.length; i++) {
      var p = format_parts[i];
      var divider = null;
      if (p.startsWith("d")) divider = 24 * 60 * 60 * 1000;else if (p.startsWith("h")) divider = 60 * 60 * 1000;else if (p.startsWith("m")) divider = 60 * 1000;else if (p.startsWith("s")) divider = 1000;else if (p.startsWith("S")) divider = 1;else if (parts.length == 0) continue;
      if (p == "?") {
        if (parts[parts.length - 1] == 0) parts.pop();
        continue;
      }
      if (divider) {
        var v = Math.floor(num / divider);
        p = v.toString().padStart(p.length, "0");
        num -= v * divider;
      }
      parts.push(p);
    }
    return (negative ? "-" : "") + parts.join("");
  }
  function array_remove$1(arr, item) {
    var index = arr.indexOf(item);
    if (index === -1) return false;
    arr.splice(index, 1);
    return true;
  }
  function random_string$1(length) {
    var chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var result = new Array(length),
      num_chars = chars.length;
    for (var i = length; i > 0; --i) result[i] = chars[Math.floor(Math.random() * num_chars)];
    return result.join("");
  }
  function all_equal$1(array) {
    if (array.length <= 1) return true;
    for (var i = 1; i < array.length; i++) {
      if (array[0] !== array[i]) return false;
    }
    return true;
  }
  /** @template T1 @param {function():T1} cb @param {*} [default_value] @returns {T1} */
  function _try$1(cb) {
    var default_value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    try {
      return cb();
    } catch (_unused4) {
      return default_value;
    }
  }
  function clear$1(obj) {
    if (Array.isArray(obj)) {
      obj.splice(0, obj.length);
    } else if (_typeof$1(obj) === "object") {
      for (var _i8 = 0, _Object$keys4 = Object.keys(obj); _i8 < _Object$keys4.length; _i8++) {
        var k = _Object$keys4[_i8];
        delete obj[k];
      }
    }
  }
  function round_to_factor$1(num) {
    var f = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
    return Math.round(num / f) * f;
  }
  function clamp$2(a) {
    var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return Math.min(max, Math.max(min, a));
  }
  function lerp$1(x, y, a) {
    return x * (1 - a) + y * a;
  }
  function split_datetime$1(date) {
    var apply_timezone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return function (date) {
      var date = +new Date(date);
      if (apply_timezone) date += -(+new Date(date).getTimezoneOffset() * 60 * 1000);
      var parts = new Date(date).toISOString().slice(0, -1).split("T");
      if (parts[0][0] == "+") parts[0] = parts[0].slice(1);
      return parts;
    }(date);
  }
  function join_datetime$1(parts) {
    var apply_timezone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var date = +new Date("".concat(parts.join(" "), "Z"));
    if (apply_timezone) date += +new Date(date).getTimezoneOffset() * 60 * 1000;
    return new Date(date);
  }
  function get_property_descriptor$1(obj, property) {
    while (obj) {
      var d = Object.getOwnPropertyDescriptor(obj, property);
      if (d) return d;
      obj = Object.getPrototypeOf(obj);
    }
    return null;
  }
  /** @template T @param {T} obj @param {Function(any):any} replacer @return {T} */
  function deep_copy$1(obj, replacer) {
    if (_typeof$1(obj) !== 'object' || obj === null) return obj;
    return JSON.parse(JSON.stringify(obj));
  }
  function get$2(fn_this, fn_path) {
    // if (typeof fn_path === "string") fn_path = fn_path.split(/\./);
    if (!Array.isArray(fn_path)) fn_path = [fn_path];
    var fn_ref = fn_this;
    try {
      var _iterator23 = _createForOfIteratorHelper$1(fn_path),
        _step23;
      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
          var fn_part = _step23.value;
          fn_this = fn_ref;
          var descriptor = get_property_descriptor$1(fn_ref, fn_part);
          if (descriptor && descriptor.get) fn_ref = descriptor.get.call(fn_this);else fn_ref = fn_ref[fn_part];
          // fn_ref = descriptor ? (descriptor.get ? descriptor.get.call(fn_this) : descriptor.value) : undefined;
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
    } catch (_unused5) {
      throw new RefException$1("".concat(fn_this, " -> ").concat(fn_path));
    }
    return fn_ref;
  }
  function nearest$1(num) {
    var minDiff = Number.MAX_VALUE;
    for (var _len15 = arguments.length, values = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
      values[_key15 - 1] = arguments[_key15];
    }
    for (var _i14 = 0, _values = values; _i14 < _values.length; _i14++) {
      var val = _values[_i14];
      var m = Math.abs(num - values[i]);
      if (m < minDiff) {
        minDiff = m;
        curr = val;
      }
    }
    return curr;
  }

  var _marked$1 = /*#__PURE__*/_regeneratorRuntime$1().mark(find);
  function _typeof$2(o) { "@babel/helpers - typeof"; return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof$2(o); }
  function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty$2(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function _superPropGet(t, e, o, r) { var p = _get(_getPrototypeOf$2(t.prototype ), e, o); return "function" == typeof p ? function (t) { return p.apply(o, t); } : p; }
  function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
  function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf$2(t));); return t; }
  function _slicedToArray$1(r, e) { return _arrayWithHoles$1(r) || _iterableToArrayLimit$1(r, e) || _unsupportedIterableToArray$2(r, e) || _nonIterableRest$1(); }
  function _nonIterableRest$1() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArrayLimit$1(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
  function _arrayWithHoles$1(r) { if (Array.isArray(r)) return r; }
  function _createForOfIteratorHelper$2(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$2(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
  function _toConsumableArray$2(r) { return _arrayWithoutHoles$2(r) || _iterableToArray$2(r) || _unsupportedIterableToArray$2(r) || _nonIterableSpread$2(); }
  function _nonIterableSpread$2() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _unsupportedIterableToArray$2(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$2(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0; } }
  function _iterableToArray$2(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
  function _arrayWithoutHoles$2(r) { if (Array.isArray(r)) return _arrayLikeToArray$2(r); }
  function _arrayLikeToArray$2(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  function _defineProperty$2(e, r, t) { return (r = _toPropertyKey$2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
  function _regeneratorRuntime$1() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$1 = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof$2(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof$2(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
  function asyncGeneratorStep$1(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
  function _asyncToGenerator$1(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep$1(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep$1(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
  function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration$1(e, a), a.add(e); }
  function _classPrivateFieldInitSpec$1(e, t, a) { _checkPrivateRedeclaration$1(e, t), t.set(e, a); }
  function _checkPrivateRedeclaration$1(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
  function _classPrivateFieldSet$1(s, a, r) { return s.set(_assertClassBrand$1(s, a), r), r; }
  function _classPrivateFieldGet$1(s, a) { return s.get(_assertClassBrand$1(s, a)); }
  function _assertClassBrand$1(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
  function _classCallCheck$2(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
  function _defineProperties$2(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey$2(o.key), o); } }
  function _createClass$2(e, r, t) { return r && _defineProperties$2(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
  function _toPropertyKey$2(t) { var i = _toPrimitive$2(t, "string"); return "symbol" == _typeof$2(i) ? i : i + ""; }
  function _toPrimitive$2(t, r) { if ("object" != _typeof$2(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof$2(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
  function _callSuper$2(t, o, e) { return o = _getPrototypeOf$2(o), _possibleConstructorReturn$2(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf$2(t).constructor) : o.apply(t, e)); }
  function _possibleConstructorReturn$2(t, e) { if (e && ("object" == _typeof$2(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized$2(t); }
  function _assertThisInitialized$2(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
  function _isNativeReflectConstruct$2() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() { return !!t; })(); }
  function _getPrototypeOf$2(t) { return _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf$2(t); }
  function _inherits$2(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$2(t, e); }
  function _setPrototypeOf$2(t, e) { return _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf$2(t, e); }
  var _temp_div = document.createElement('div');
  var _div2 = document.createElement('div');
  var $$2 = function $(html) {
    var elems = render_html(html);
    if (!elems) return null;
    return Array.isArray(elems) ? elems : [elems];
  };
  var textarea_input_events = ["input", "propertychange", "paste"];
  var entity_table = {
    34: 'quot',
    38: 'amp',
    39: 'apos',
    60: 'lt',
    62: 'gt',
    160: 'nbsp',
    161: 'iexcl',
    162: 'cent',
    163: 'pound',
    164: 'curren',
    165: 'yen',
    166: 'brvbar',
    167: 'sect',
    168: 'uml',
    169: 'copy',
    170: 'ordf',
    171: 'laquo',
    172: 'not',
    173: 'shy',
    174: 'reg',
    175: 'macr',
    176: 'deg',
    177: 'plusmn',
    178: 'sup2',
    179: 'sup3',
    180: 'acute',
    181: 'micro',
    182: 'para',
    183: 'middot',
    184: 'cedil',
    185: 'sup1',
    186: 'ordm',
    187: 'raquo',
    188: 'frac14',
    189: 'frac12',
    190: 'frac34',
    191: 'iquest',
    192: 'Agrave',
    193: 'Aacute',
    194: 'Acirc',
    195: 'Atilde',
    196: 'Auml',
    197: 'Aring',
    198: 'AElig',
    199: 'Ccedil',
    200: 'Egrave',
    201: 'Eacute',
    202: 'Ecirc',
    203: 'Euml',
    204: 'Igrave',
    205: 'Iacute',
    206: 'Icirc',
    207: 'Iuml',
    208: 'ETH',
    209: 'Ntilde',
    210: 'Ograve',
    211: 'Oacute',
    212: 'Ocirc',
    213: 'Otilde',
    214: 'Ouml',
    215: 'times',
    216: 'Oslash',
    217: 'Ugrave',
    218: 'Uacute',
    219: 'Ucirc',
    220: 'Uuml',
    221: 'Yacute',
    222: 'THORN',
    223: 'szlig',
    224: 'agrave',
    225: 'aacute',
    226: 'acirc',
    227: 'atilde',
    228: 'auml',
    229: 'aring',
    230: 'aelig',
    231: 'ccedil',
    232: 'egrave',
    233: 'eacute',
    234: 'ecirc',
    235: 'euml',
    236: 'igrave',
    237: 'iacute',
    238: 'icirc',
    239: 'iuml',
    240: 'eth',
    241: 'ntilde',
    242: 'ograve',
    243: 'oacute',
    244: 'ocirc',
    245: 'otilde',
    246: 'ouml',
    247: 'divide',
    248: 'oslash',
    249: 'ugrave',
    250: 'uacute',
    251: 'ucirc',
    252: 'uuml',
    253: 'yacute',
    254: 'thorn',
    255: 'yuml',
    402: 'fnof',
    913: 'Alpha',
    914: 'Beta',
    915: 'Gamma',
    916: 'Delta',
    917: 'Epsilon',
    918: 'Zeta',
    919: 'Eta',
    920: 'Theta',
    921: 'Iota',
    922: 'Kappa',
    923: 'Lambda',
    924: 'Mu',
    925: 'Nu',
    926: 'Xi',
    927: 'Omicron',
    928: 'Pi',
    929: 'Rho',
    931: 'Sigma',
    932: 'Tau',
    933: 'Upsilon',
    934: 'Phi',
    935: 'Chi',
    936: 'Psi',
    937: 'Omega',
    945: 'alpha',
    946: 'beta',
    947: 'gamma',
    948: 'delta',
    949: 'epsilon',
    950: 'zeta',
    951: 'eta',
    952: 'theta',
    953: 'iota',
    954: 'kappa',
    955: 'lambda',
    956: 'mu',
    957: 'nu',
    958: 'xi',
    959: 'omicron',
    960: 'pi',
    961: 'rho',
    962: 'sigmaf',
    963: 'sigma',
    964: 'tau',
    965: 'upsilon',
    966: 'phi',
    967: 'chi',
    968: 'psi',
    969: 'omega',
    977: 'thetasym',
    978: 'upsih',
    982: 'piv',
    8226: 'bull',
    8230: 'hellip',
    8242: 'prime',
    8243: 'Prime',
    8254: 'oline',
    8260: 'frasl',
    8472: 'weierp',
    8465: 'image',
    8476: 'real',
    8482: 'trade',
    8501: 'alefsym',
    8592: 'larr',
    8593: 'uarr',
    8594: 'rarr',
    8595: 'darr',
    8596: 'harr',
    8629: 'crarr',
    8656: 'lArr',
    8657: 'uArr',
    8658: 'rArr',
    8659: 'dArr',
    8660: 'hArr',
    8704: 'forall',
    8706: 'part',
    8707: 'exist',
    8709: 'empty',
    8711: 'nabla',
    8712: 'isin',
    8713: 'notin',
    8715: 'ni',
    8719: 'prod',
    8721: 'sum',
    8722: 'minus',
    8727: 'lowast',
    8730: 'radic',
    8733: 'prop',
    8734: 'infin',
    8736: 'ang',
    8743: 'and',
    8744: 'or',
    8745: 'cap',
    8746: 'cup',
    8747: 'int',
    8756: 'there4',
    8764: 'sim',
    8773: 'cong',
    8776: 'asymp',
    8800: 'ne',
    8801: 'equiv',
    8804: 'le',
    8805: 'ge',
    8834: 'sub',
    8835: 'sup',
    8836: 'nsub',
    8838: 'sube',
    8839: 'supe',
    8853: 'oplus',
    8855: 'otimes',
    8869: 'perp',
    8901: 'sdot',
    8968: 'lceil',
    8969: 'rceil',
    8970: 'lfloor',
    8971: 'rfloor',
    9001: 'lang',
    9002: 'rang',
    9674: 'loz',
    9824: 'spades',
    9827: 'clubs',
    9829: 'hearts',
    9830: 'diams',
    338: 'OElig',
    339: 'oelig',
    352: 'Scaron',
    353: 'scaron',
    376: 'Yuml',
    710: 'circ',
    732: 'tilde',
    8194: 'ensp',
    8195: 'emsp',
    8201: 'thinsp',
    8204: 'zwnj',
    8205: 'zwj',
    8206: 'lrm',
    8207: 'rlm',
    8211: 'ndash',
    8212: 'mdash',
    8216: 'lsquo',
    8217: 'rsquo',
    8218: 'sbquo',
    8220: 'ldquo',
    8221: 'rdquo',
    8222: 'bdquo',
    8224: 'dagger',
    8225: 'Dagger',
    8240: 'permil',
    8249: 'lsaquo',
    8250: 'rsaquo',
    8364: 'euro'
  };

  /* new MutationObserver(mutations => {
      Array.from(mutations).forEach(mutation => {
          Array.from(mutation.addedNodes).forEach(node => {
              if (node.matches("textarea[autosize]")) new AutoSizeController(node);
          });
          Array.from(mutation.removedNodes).forEach(node => {
              if (node.matches("textarea[autosize]")) node.__autosize__.destroy()
          });
      });
  }).observe(document.body, { childList: true }); */
  var TouchListener = /*#__PURE__*/function (_utils$EventEmitter) {
    function TouchListener(elem, user_settings) {
      var _this;
      _classCallCheck$2(this, TouchListener);
      _this = _callSuper$2(this, TouchListener);
      var settings = {
        mode: "normal",
        start: function start(e) {},
        move: function move(e) {},
        end: function end(e) {}
      };
      elem.style["touch-actions"] = "none";
      Object.assign(settings, user_settings);
      _this.elem = elem;
      var end_target = window.document;
      var start_events = ["pointerdown"];
      var move_events = ["pointermove"];
      var end_events = ["pointerup"];
      if (settings.mode == "hover") {
        start_events = ["pointerover"];
        end_events = ["pointerout"];
        end_target = _this.elem;
      }
      var _on_touch_start = function _on_touch_start(e) {
        // VERY NECESSARY!
        e.preventDefault();
      };
      var _on_start = function _on_start(e) {
        if (e.pointerId && settings.mode != "hover") {
          if (e.button != 0) return;
          _this.elem.setPointerCapture(e.pointerId);
          _this.elem.addEventListener("lostpointercapture", _on_end);
        }
        e.stopPropagation();
        e.preventDefault();
        settings.start(e);
        move_events.forEach(function (et) {
          return window.addEventListener(et, _on_move);
        });
        end_events.forEach(function (et) {
          return end_target.addEventListener(et, _on_end);
        });
      };
      var _on_move = function _on_move(e) {
        // console.log(e.type, e);
        settings.move(e);
      };
      var _on_end = function _on_end(e) {
        // console.log(e.type, e);
        settings.end(e);
        cleanup();
      };
      var cleanup = function cleanup() {
        _this.elem.removeEventListener("lostpointercapture", _on_end);
        move_events.forEach(function (et) {
          return window.removeEventListener(et, _on_move);
        });
        end_events.forEach(function (et) {
          return end_target.removeEventListener(et, _on_end);
        });
      };
      _this._destroy = function () {
        _this.elem.removeEventListener("touchstart", _on_touch_start);
        start_events.forEach(function (et) {
          return _this.elem.removeEventListener(et, _on_start);
        });
        cleanup();
      };
      start_events.forEach(function (et) {
        return _this.elem.addEventListener(et, _on_start);
      });
      _this.elem.addEventListener("touchstart", _on_touch_start);
      return _this;
    }
    _inherits$2(TouchListener, _utils$EventEmitter);
    return _createClass$2(TouchListener, [{
      key: "destroy",
      value: function destroy() {
        this._destroy();
      }
    }]);
  }(EventEmitter$2);
  var AutoSizeController = /*#__PURE__*/function (_utils$EventEmitter2) {
    function AutoSizeController(elem, min_rows) {
      var _this2;
      var auto_update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      _classCallCheck$2(this, AutoSizeController);
      _this2 = _callSuper$2(this, AutoSizeController);
      _this2.elem = elem;
      _this2.min_rows = min_rows || 1;
      _this2.on_change = function (e) {
        _this2.update();
      };
      _this2.debounced_update = debounce$4(function () {
        return _this2.update();
      }, 50);
      textarea_input_events.forEach(function (ev) {
        return _this2.elem.addEventListener(ev, _this2.on_change);
      });
      if (auto_update) {
        window.addEventListener("resize", _this2.debounced_update);
        var fs;
        _this2.check_interval = setInterval(function () {
          var new_fs = getComputedStyle(elem).getPropertyValue("font-size");
          if (new_fs !== fs) _this2.update();
          fs = new_fs;
        }, 200);
      }
      elem.__autosize__ = _this2;
      _this2.update();
      return _this2;
    }
    _inherits$2(AutoSizeController, _utils$EventEmitter2);
    return _createClass$2(AutoSizeController, [{
      key: "update",
      value: function update() {
        this.emit("pre-update");
        autosize(this.elem, this.min_rows);
        this.emit("post_update");
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;
        delete elem.__autosize__;
        clearInterval(this.check_interval);
        this.input_events.forEach(function (ev) {
          return _this3.elem.removeEventListener(ev, _this3.on_change);
        });
        window.removeEventListener("resize", this.debounced_update);
      }
    }]);
  }(EventEmitter$2); // var LocalStorageDeleted = Symbol("LocalStorageDeleted");
  var _name = /*#__PURE__*/new WeakMap();
  var _data = /*#__PURE__*/new WeakMap();
  var _defaults = /*#__PURE__*/new WeakMap();
  var _last_data_hash = /*#__PURE__*/new WeakMap();
  var _interval = /*#__PURE__*/new WeakMap();
  var _LocalStorageBucket_brand = /*#__PURE__*/new WeakSet();
  var LocalStorageBucket = /*#__PURE__*/function (_utils$EventEmitter3) {
    function LocalStorageBucket(name, defaults) {
      var _this4;
      _classCallCheck$2(this, LocalStorageBucket);
      _this4 = _callSuper$2(this, LocalStorageBucket);
      _classPrivateMethodInitSpec(_this4, _LocalStorageBucket_brand);
      _classPrivateFieldInitSpec$1(_this4, _name, void 0);
      _classPrivateFieldInitSpec$1(_this4, _data, {});
      _classPrivateFieldInitSpec$1(_this4, _defaults, void 0);
      _classPrivateFieldInitSpec$1(_this4, _last_data_hash, void 0);
      _classPrivateFieldInitSpec$1(_this4, _interval, void 0);
      _this4.save = debounce$4(_assertClassBrand$1(_LocalStorageBucket_brand, _this4, _save), 0);
      _classPrivateFieldSet$1(_name, _this4, name);
      _classPrivateFieldSet$1(_defaults, _this4, defaults ? deep_copy$1(defaults) : {});
      // in case it is altered in another window.
      _classPrivateFieldSet$1(_interval, _this4, setInterval(function () {
        return _this4.load();
      }, 2000));
      _this4.load();
      return _this4;
    }
    _inherits$2(LocalStorageBucket, _utils$EventEmitter3);
    return _createClass$2(LocalStorageBucket, [{
      key: "$",
      get: function get() {
        return this.data;
      }
    }, {
      key: "data",
      get: function get() {
        return Object.assign({}, this.defaults, _classPrivateFieldGet$1(_data, this));
      }
    }, {
      key: "keys",
      get: function get() {
        return Object.keys(this.data);
      }
    }, {
      key: "defaults",
      get: function get() {
        return _classPrivateFieldGet$1(_defaults, this);
      }
    }, {
      key: "get",
      value: function get(k) {
        return k in _classPrivateFieldGet$1(_data, this) ? _classPrivateFieldGet$1(_data, this)[k] : _classPrivateFieldGet$1(_defaults, this)[k];
      }
    }, {
      key: "set",
      value: function set(k, new_value) {
        var new_hash = JSON.stringify(new_value);
        var old_value = _classPrivateFieldGet$1(_data, this)[k];
        var old_hash = JSON.stringify(old_value);
        var default_hash = JSON.stringify(_classPrivateFieldGet$1(_defaults, this)[k]);
        if (new_hash === old_hash) return;
        if (new_hash === default_hash) delete _classPrivateFieldGet$1(_data, this)[k];else _classPrivateFieldGet$1(_data, this)[k] = new_value;
        this.emit("change", {
          name: k,
          old_value: old_value,
          new_value: new_value
        });
        this.save();
      }
    }, {
      key: "unset",
      value: function unset(k) {
        if (!(k in _classPrivateFieldGet$1(_data, this))) return;
        this.set(k, _classPrivateFieldGet$1(_defaults, this)[k]);
      }
    }, {
      key: "toggle",
      value: function toggle(k) {
        this.set(k, !this.get(k));
      }
    }, {
      key: "load",
      value: function load() {
        var reset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var new_values;
        try {
          new_values = JSON.parse(localStorage.getItem(_classPrivateFieldGet$1(_name, this)));
        } catch (_unused) {
          return;
        }
        if (reset) clear$1(_classPrivateFieldGet$1(_data, this));
        for (var k in new_values) {
          if (k in _classPrivateFieldGet$1(_defaults, this)) {
            this.set(k, new_values[k]);
          } else {
            console.warn("LocalStorageBucket '".concat(_classPrivateFieldGet$1(_name, this), "' key '").concat(k, "' not defined in defaults."));
          }
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        clearInterval(_classPrivateFieldGet$1(_interval, this));
      }
    }]);
  }(EventEmitter$2);
  function _save() {
    _classPrivateFieldSet$1(_last_data_hash, this, JSON.stringify(_classPrivateFieldGet$1(_data, this)));
    localStorage.setItem(_classPrivateFieldGet$1(_name, this), _classPrivateFieldGet$1(_last_data_hash, this));
  }
  var WebSocket2 = /*#__PURE__*/function (_utils$EventEmitter4) {
    function WebSocket2(url) {
      var _this5;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _classCallCheck$2(this, WebSocket2);
      _this5 = _callSuper$2(this, WebSocket2);
      _this5.url = url;
      _this5.options = Object.assign({
        auto_reconnect: true,
        auto_reconnect_interval: 1000
      }, options);
      _this5._init_websocket();
      return _this5;
    }
    _inherits$2(WebSocket2, _utils$EventEmitter4);
    return _createClass$2(WebSocket2, [{
      key: "requests",
      get: function get() {
        return this._requests;
      }
    }, {
      key: "ready_state",
      get: function get() {
        return this.ws.readyState;
      }
    }, {
      key: "ready_promise",
      get: function get() {
        var _this6 = this;
        return this.ws.readyState === WebSocket.OPEN ? Promise.resolve(true) : new Promise(function (resolve) {
          return _this6.once("open", resolve);
        });
      }
    }, {
      key: "request",
      value: function request(data, timeout) {
        var _this7 = this;
        return new Promise(function (resolve, reject) {
          var rid = ++_this7._requests;
          _this7._request_ids[rid] = function (response) {
            if (response.error) reject(response.error.message);else resolve(response.result);
          };
          _this7.send(Object.assign({
            __id__: rid
          }, data));
          setTimeout(function () {
            return reject("WebSocket2 request ".concat(rid, " timed out"));
          }, timeout);
        })["catch"](function (e) {
          return console.error(e);
        });
      }
    }, {
      key: "send",
      value: function () {
        var _send = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1().mark(function _callee(data) {
          return _regeneratorRuntime$1().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.ready_promise;
              case 2:
                if (data instanceof ArrayBuffer || data instanceof Blob) {
                  this.ws.send(data);
                } else {
                  this.ws.send(JSON.stringify(data));
                }
              case 3:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function send(_x) {
          return _send.apply(this, arguments);
        }
        return send;
      }()
    }, {
      key: "_init_websocket",
      value: function _init_websocket() {
        var _this8 = this;
        this._request_ids = {};
        this._requests = 0;
        var url = this.url;
        var protocols = this.protocols;
        if (typeof url === "function") url = url();
        if (typeof protocols === "function") protocols = protocols();
        this.ws = new WebSocket(url, protocols);
        this.emit("connecting");
        var try_reconnect = function try_reconnect() {
          if (!_this8.options.auto_reconnect) return;
          clearTimeout(_this8._reconnect_timeout);
          _this8._reconnect_timeout = setTimeout(function () {
            _this8._init_websocket();
          }, _this8.options.auto_reconnect_interval);
        };
        this.ws.addEventListener("open", function (e) {
          clearTimeout(_this8._reconnect_timeout);
          _this8.emit("open", e);
        });
        this.ws.addEventListener("message", function (e) {
          _this8.emit("message", e);
          if (e.data === "ping") {
            _this8.ws.send("pong");
            return;
          }
          var data;
          try {
            data = JSON.parse(e.data);
          } catch (ex) {
            console.error(ex);
            return;
          }
          if (data && data.__id__ !== undefined) {
            var cb = _this8._request_ids[data.__id__];
            delete _this8._request_ids[data.__id__];
            cb(data);
          }
          _this8.emit("data", data);
          // this event always runs before cb() promise as promises resolve later in another (pseudo) thread.
          // setTimeout(()=>this.emit("data", data), 0);
        });
        this.ws.addEventListener("close", function (e) {
          _this8.emit("close", e);
          if (e.code == 1014) {
            // bad gateway, don't bother.
            console.error("Connection refused: Bad gateway.");
          } else {
            try_reconnect();
          }
        });
        this.ws.addEventListener("error", function (e) {
          _this8.emit("error", e);
        });
      }
    }]);
  }(EventEmitter$2); // depends on tippy js
  var UI = /*#__PURE__*/function (_utils$EventEmitter5) {
    // get_children() { return UI.find(this.elem, UI, false); }
    // get_descendents() { return UI.find(this.elem, UI, true); }
    // get_parents() { return UI.parents(this.elem); }

    function UI(elem, settings) {
      var _this9;
      _classCallCheck$2(this, UI);
      _this9 = _callSuper$2(this, UI);
      /** @type {Set<UI>} */
      _defineProperty$2(_this9, "_children", new Set());
      /** @type {UI} */
      _defineProperty$2(_this9, "_parent", void 0);
      _this9.__UID__ = ++UI.id;
      if (typeof elem === "string") elem = $$2(elem)[0];
      if (elem instanceof Document) elem = elem.body;
      if (!(elem instanceof Element) && !settings) {
        settings = elem;
        elem = null;
      }
      if (!elem) elem = document.createElement('div');
      /** @type {HTMLElement} */
      _this9.elem = elem;
      _this9.elem[UI.expando] = _this9;
      _this9.elem.classList.add(UI.pre);
      _this9.settings = Object.assign({}, settings);
      if ("class" in _this9.settings) {
        var _this9$elem$classList;
        var classes = _this9.get_setting("class");
        if (typeof classes === "string") classes = classes.split(/\s+/);
        (_this9$elem$classList = _this9.elem.classList).add.apply(_this9$elem$classList, _toConsumableArray$2(classes));
      }

      // this.__update_display();

      // this.update();
      _this9.update_next_frame = debounce_next_frame(function () {
        _this9.update();
      });
      // this.update_next_frame();

      if (_this9.elem.isConnected) {
        _this9.root.register(_this9);
      }
      _this9.init();
      _this9.get_setting("init");
      return _this9;
    }
    _inherits$2(UI, _utils$EventEmitter5);
    return _createClass$2(UI, [{
      key: "disabled",
      get: function get() {
        // var parent = this.parent;
        var disabled = !!this.get_setting("disabled");
        return disabled;
      },
      set: function set(value) {
        if (this.settings.disabled == value) return;
        this.settings.disabled = value;
        this.update_next_frame();
      }
    }, {
      key: "disabled_or_parent_disabled",
      get: function get() {
        return this.disabled || this.disabled_parent;
      }
    }, {
      key: "disabled_parent",
      get: function get() {
        var parent = this.parent;
        return parent ? parent.disabled_or_parent_disabled : false;
      }
    }, {
      key: "hidden",
      get: function get() {
        return this.get_setting("hidden");
      },
      set: function set(value) {
        if (this.settings.hidden == value) return;
        this.settings.hidden = value;
        this.update_next_frame();
        // this.debounced_update();
      }
    }, {
      key: "root",
      get: function get() {
        return this.get_closest(UI.Root);
      }
    }, {
      key: "visible",
      get: function get() {
        return is_visible(this.elem);
      } // not the opposite of hidden
    }, {
      key: "children",
      get: function get() {
        return _toConsumableArray$2(this.get_children());
      }
    }, {
      key: "descendents",
      get: function get() {
        return _toConsumableArray$2(this.get_descendents());
      }
    }, {
      key: "parents",
      get: function get() {
        return _toConsumableArray$2(this.get_parents());
      }
    }, {
      key: "parent",
      get: function get() {
        return this._parent;
      }
    }, {
      key: "id",
      get: function get() {
        return this.__UID__;
      }
    }, {
      key: "style",
      get: function get() {
        return this.elem.style;
      }
    }, {
      key: "get_children",
      value: /*#__PURE__*/_regeneratorRuntime$1().mark(function get_children() {
        var _iterator, _step, c;
        return _regeneratorRuntime$1().wrap(function get_children$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _iterator = _createForOfIteratorHelper$2(this._children);
              _context2.prev = 1;
              _iterator.s();
            case 3:
              if ((_step = _iterator.n()).done) {
                _context2.next = 9;
                break;
              }
              c = _step.value;
              _context2.next = 7;
              return c;
            case 7:
              _context2.next = 3;
              break;
            case 9:
              _context2.next = 14;
              break;
            case 11:
              _context2.prev = 11;
              _context2.t0 = _context2["catch"](1);
              _iterator.e(_context2.t0);
            case 14:
              _context2.prev = 14;
              _iterator.f();
              return _context2.finish(14);
            case 17:
            case "end":
              return _context2.stop();
          }
        }, get_children, this, [[1, 11, 14, 17]]);
      }) /** @return {Generator<UI>} */
    }, {
      key: "get_descendents",
      value:
      /*#__PURE__*/
      _regeneratorRuntime$1().mark(function get_descendents() {
        var _iterator2, _step2, c, _iterator3, _step3, gc;
        return _regeneratorRuntime$1().wrap(function get_descendents$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelper$2(this._children);
              _context3.prev = 1;
              _iterator2.s();
            case 3:
              if ((_step2 = _iterator2.n()).done) {
                _context3.next = 26;
                break;
              }
              c = _step2.value;
              _context3.next = 7;
              return c;
            case 7:
              _iterator3 = _createForOfIteratorHelper$2(c.get_descendents());
              _context3.prev = 8;
              _iterator3.s();
            case 10:
              if ((_step3 = _iterator3.n()).done) {
                _context3.next = 16;
                break;
              }
              gc = _step3.value;
              _context3.next = 14;
              return gc;
            case 14:
              _context3.next = 10;
              break;
            case 16:
              _context3.next = 21;
              break;
            case 18:
              _context3.prev = 18;
              _context3.t0 = _context3["catch"](8);
              _iterator3.e(_context3.t0);
            case 21:
              _context3.prev = 21;
              _iterator3.f();
              return _context3.finish(21);
            case 24:
              _context3.next = 3;
              break;
            case 26:
              _context3.next = 31;
              break;
            case 28:
              _context3.prev = 28;
              _context3.t1 = _context3["catch"](1);
              _iterator2.e(_context3.t1);
            case 31:
              _context3.prev = 31;
              _iterator2.f();
              return _context3.finish(31);
            case 34:
            case "end":
              return _context3.stop();
          }
        }, get_descendents, this, [[1, 28, 31, 34], [8, 18, 21, 24]]);
      })
    }, {
      key: "get_parents",
      value: /*#__PURE__*/_regeneratorRuntime$1().mark(function get_parents() {
        var p;
        return _regeneratorRuntime$1().wrap(function get_parents$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              p = this._parent;
            case 1:
              if (!p) {
                _context4.next = 7;
                break;
              }
              _context4.next = 4;
              return p;
            case 4:
              p = p._parent;
              _context4.next = 1;
              break;
            case 7:
            case "end":
              return _context4.stop();
          }
        }, get_parents, this);
      }) /** @template [T=UI] @param {new() => T} type @returns {T} */
    }, {
      key: "get_closest",
      value: function get_closest() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : UI;
        return UI.closest(this.elem, type);
      }
    }, {
      key: "init",
      value: function init() {}
    }, {
      key: "update",
      value: function update() {
        this.emit("pre_update");
        this.__update_display();
        this.get_setting("update");
        this.emit("update");
        var _iterator4 = _createForOfIteratorHelper$2(this._children),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var c = _step4.value;
            c.update();
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        this.get_setting("post_update");
        this.emit("post_update");
      }
    }, {
      key: "update_settings",
      value: function update_settings(settings) {
        Object.assign(this.settings, settings);
        this.update_next_frame();
      }
    }, {
      key: "__update_display",
      value: function __update_display() {
        var _this10 = this;
        var hidden = this.hidden;
        if (hidden !== undefined) toggle_class(this.elem, "d-none", hidden);
        toggle_attribute(this.elem, "disabled", !!this.disabled_or_parent_disabled);

        /* var _class = this.class.join(" ");
        if ("class" in this.settings) {
            var c = this.get_setting("class");
            _class += " "+(typeof c === "string" ? c : c.join(" "));
        }
        if (_class !== this.__last_class) {
            this.__last_class = _class; // I hate this so much
            this.elem.className = _class;
        } */

        if ("gap" in this.settings) {
          var gap = this.get_setting("gap");
          if (typeof gap !== "string" || gap.match(/^[0-9.]+$/)) gap = "".concat(parseFloat(gap), "px");
          this.elem.style.setProperty("gap", gap);
        }
        if ("title" in this.settings) this.elem.title = this.get_setting("title");
        if ("display" in this.settings) this.elem.style.display = this.get_setting("display");
        if ("align" in this.settings) this.elem.style.alignItems = this.get_setting("align");
        if ("justify" in this.settings) this.elem.style.justifyContent = this.get_setting("justify");
        if ("flex" in this.settings) this.elem.style.flex = this.get_setting("flex");
        if ("id" in this.settings) this.elem.id = this.get_setting("id");
        if ("children" in this.settings) set_children(this.elem, this.get_setting("children"));
        if ("content" in this.settings) set_inner_html(this.elem, this.get_setting("content"));
        if ("click" in this.settings) this.elem.onclick = function (e) {
          var r = _this10.get_setting("click", e);
          _this10.emit("click");
          return r;
        };
        if ("mousedown" in this.settings) this.elem.onmousedown = function (e) {
          var r = _this10.get_setting("mousedown", e);
          _this10.emit("mousedown");
          return r;
        };
        if ("mouseup" in this.settings) this.elem.onmouseup = function (e) {
          var r = _this10.get_setting("mouseup", e);
          _this10.emit("mouseup");
          return r;
        };
        if ("dblclick" in this.settings) this.elem.ondblclick = function (e) {
          var r = _this10.get_setting("dblclick", e);
          _this10.emit("dblclick");
          return r;
        };
      }
    }, {
      key: "get_setting",
      value: function get_setting(key) {
        var setting = this.settings[key];
        if (typeof setting === "function") {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          setting = setting.apply(this, args);
        }
        return setting;
      }
    }, {
      key: "get_settings_group",
      value: function get_settings_group(key) {
        return Object.fromEntries(Object.entries(this.settings).filter(function (_ref) {
          var _ref2 = _slicedToArray$1(_ref, 2),
            k = _ref2[0];
            _ref2[1];
          return k.startsWith(key + ".");
        }).map(function (_ref3) {
          var _ref4 = _slicedToArray$1(_ref3, 2),
            k = _ref4[0],
            v = _ref4[1];
          return [k.slice(key.length + 1), v];
        }));
      }
    }, {
      key: "empty",
      value: function empty() {
        _empty(this.elem);
        return this;
      }
      /** @template T @param {T} el @returns {T} */
    }, {
      key: "append",
      value: function append(el) {
        var _this$elem;
        (_this$elem = this.elem).append.apply(_this$elem, arguments);
        return el;
      }
      /** @template T @param {T} el @returns {T} */
    }, {
      key: "prepend",
      value: function prepend(el) {
        var _this$elem2;
        (_this$elem2 = this.elem).prepend.apply(_this$elem2, arguments);
        return el;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this.elem) this.elem.remove();
        this.emit("destroy");
      }
    }, {
      key: "update_layout",
      value: function update_layout(layout) {
        var _this11 = this;
        var hash = JSON.stringify(layout, function (k, p) {
          return p instanceof UI ? p.id : p;
        });
        if (hash !== this._layout_hash) {
          this._layout_hash = hash;
          this.elem.innerHTML = "";
          var _process = function process(parent, layout) {
            var _iterator5 = _createForOfIteratorHelper$2(layout),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var o = _step5.value;
                if (Array.isArray(o)) {
                  var r = _this11.append(new UI.FlexRow({
                    "hidden": function hidden() {
                      return this.children.every(function (c) {
                        return c.hidden;
                      });
                    }
                  }));
                  _process(r, o);
                } else if (typeof o === "string" && o.startsWith("-")) {
                  _this11.append(new UI.Separator());
                } else if (o) {
                  parent.append(o);
                }
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          };
          _process(this, layout);
        }
        this.update_next_frame();
      }

      /* clone() {
          return new this.constructor(elem, settings);
      } */
    }]);
  }(EventEmitter$2);
  UI.id = 0;
  UI.pre = "uis";
  UI.expando = "".concat(UI.pre, "-").concat(Date.now());
  var old_append = Element.prototype.append;
  var old_prepend = Element.prototype.prepend;

  // UI.creating = 0;
  /* UI.create = function(...args) {
      var oc = ++UI.creating;
      var ui = new this();
      if (UI.creating != oc) {
          throw new Error("Cannot initialize new UI in constructor function");
      }
      --UI.creating;
      ui.init(...args);
      return ui;
  } */

  /** @template [T=UI] @param {Element} elem @param {new() => T} type @param {function(UI):boolean|boolean} cb @param {boolean} include_self @returns {Generator<T>} */
  UI.find = function (elem) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UI;
    var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var include_self = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    return /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee2() {
      var _iterator6, _step6, c, found, check, _iterator7, _step7, sc;
      return _regeneratorRuntime$1().wrap(function _callee2$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            if (!type) type = UI;
            if (!(include_self && elem[UI.expando] && elem[UI.expando] instanceof type)) {
              _context5.next = 4;
              break;
            }
            _context5.next = 4;
            return elem[UI.expando];
          case 4:
            if (elem.children) {
              _context5.next = 6;
              break;
            }
            return _context5.abrupt("return");
          case 6:
            _iterator6 = _createForOfIteratorHelper$2(elem.children);
            _context5.prev = 7;
            _iterator6.s();
          case 9:
            if ((_step6 = _iterator6.n()).done) {
              _context5.next = 36;
              break;
            }
            c = _step6.value;
            found = c[UI.expando] && c[UI.expando] instanceof type;
            if (!found) {
              _context5.next = 15;
              break;
            }
            _context5.next = 15;
            return c[UI.expando];
          case 15:
            check = typeof cb === "function" ? cb(c[UI.expando]) : !!cb;
            if (!(!found || check)) {
              _context5.next = 34;
              break;
            }
            _iterator7 = _createForOfIteratorHelper$2(UI.find(c, type, cb));
            _context5.prev = 18;
            _iterator7.s();
          case 20:
            if ((_step7 = _iterator7.n()).done) {
              _context5.next = 26;
              break;
            }
            sc = _step7.value;
            _context5.next = 24;
            return sc;
          case 24:
            _context5.next = 20;
            break;
          case 26:
            _context5.next = 31;
            break;
          case 28:
            _context5.prev = 28;
            _context5.t0 = _context5["catch"](18);
            _iterator7.e(_context5.t0);
          case 31:
            _context5.prev = 31;
            _iterator7.f();
            return _context5.finish(31);
          case 34:
            _context5.next = 9;
            break;
          case 36:
            _context5.next = 41;
            break;
          case 38:
            _context5.prev = 38;
            _context5.t1 = _context5["catch"](7);
            _iterator6.e(_context5.t1);
          case 41:
            _context5.prev = 41;
            _iterator6.f();
            return _context5.finish(41);
          case 44:
          case "end":
            return _context5.stop();
        }
      }, _callee2, null, [[7, 38, 41, 44], [18, 28, 31, 34]]);
    })();
  };

  // /** @template [T=UI] @param {Element} elem @param {function(UI):boolean} cb @param {boolean} recursive @param {boolean} include_self @returns {Generator<T>} */
  // UI.walk = function(elem, type=UI, cb=null, include_self=false) {
  //     var r;
  //     if (include_self && elem[UI.expando]) {
  //         r = cb(elem[UI.expando]);
  //         if (r==true) yield elem[UI.expando];
  //         if (r==false) return;
  //     }
  //     if (!elem.children) return;
  //     for (var c of elem.children) {
  //         if (c[UI.expando]) {
  //             r = cb(c[UI.expando]);
  //             if (r==true) yield c[UI.expando];
  //             if (r==false) continue;
  //         }
  //         for (var ui of UI.walk(c, cb)) yield ui;
  //     }
  // }
  /** @returns {Generator<UI>} */
  UI.parents = function (elem) {
    var include_self = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee3() {
      return _regeneratorRuntime$1().wrap(function _callee3$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            if (!include_self) elem = elem.parentElement;
          case 1:
            if (!elem) {
              _context6.next = 8;
              break;
            }
            if (!elem[UI.expando]) {
              _context6.next = 5;
              break;
            }
            _context6.next = 5;
            return elem[UI.expando];
          case 5:
            elem = elem.parentElement;
            _context6.next = 1;
            break;
          case 8:
          case "end":
            return _context6.stop();
        }
      }, _callee3);
    })();
  };
  /** @returns {UI} */
  UI.parent = function (elem) {
    var _iterator8 = _createForOfIteratorHelper$2(UI.parents(elem)),
      _step8;
    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var ui = _step8.value;
        return ui;
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }
  };
  /** @template [T=UI] @param {Element} elem @param {new() => T} type @returns {T} */
  UI.closest = function (elem) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UI;
    var _iterator9 = _createForOfIteratorHelper$2(UI.parents(elem, true)),
      _step9;
    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var ui = _step9.value;
        if (ui instanceof type) return ui;
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
  };

  /* UI.merge_settings = function(...settings) {
      var o = {};
      for (var s of settings) {
          if (!s || typeof s !== "object") continue;
          for (var k in s) {
              let value = s[k];
              if (k === "class") {
                  if (typeof value === "string") {
                      value = value.split(/\s+/).filter(s=>s);
                  }
              } else if (k === "style") {
                  if (typeof value === "string") {
                      value = parse_style(value);
                  }
              }
              if (k in o) {
                  if (utils.is_plain_object(o[k])) {
                      Object.assign(o[k], value);
                      continue;
                  } else if (Array.isArray(o[k])) {
                      o[k].push(...value);
                      continue;
                  }
              }
              o[k] = value;
          }
      }
      return o;
  } */

  /** @return {Iterable<HTMLElement>} */
  var _handle_els = /*#__PURE__*/_regeneratorRuntime$1().mark(function handle_els(o) {
    var _iterator10, _step10, c, _iterator11, _step11, c2, _iterator12, _step12;
    return _regeneratorRuntime$1().wrap(function handle_els$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          if (!Array.isArray(o)) {
            _context7.next = 35;
            break;
          }
          _iterator10 = _createForOfIteratorHelper$2(o);
          _context7.prev = 2;
          _iterator10.s();
        case 4:
          if ((_step10 = _iterator10.n()).done) {
            _context7.next = 25;
            break;
          }
          c = _step10.value;
          _iterator11 = _createForOfIteratorHelper$2(_handle_els(c));
          _context7.prev = 7;
          _iterator11.s();
        case 9:
          if ((_step11 = _iterator11.n()).done) {
            _context7.next = 15;
            break;
          }
          c2 = _step11.value;
          _context7.next = 13;
          return c2;
        case 13:
          _context7.next = 9;
          break;
        case 15:
          _context7.next = 20;
          break;
        case 17:
          _context7.prev = 17;
          _context7.t0 = _context7["catch"](7);
          _iterator11.e(_context7.t0);
        case 20:
          _context7.prev = 20;
          _iterator11.f();
          return _context7.finish(20);
        case 23:
          _context7.next = 4;
          break;
        case 25:
          _context7.next = 30;
          break;
        case 27:
          _context7.prev = 27;
          _context7.t1 = _context7["catch"](2);
          _iterator10.e(_context7.t1);
        case 30:
          _context7.prev = 30;
          _iterator10.f();
          return _context7.finish(30);
        case 33:
          _context7.next = 63;
          break;
        case 35:
          if (!(o instanceof UI)) {
            _context7.next = 40;
            break;
          }
          _context7.next = 38;
          return o.elem;
        case 38:
          _context7.next = 63;
          break;
        case 40:
          if (!(typeof o === "string")) {
            _context7.next = 60;
            break;
          }
          _iterator12 = _createForOfIteratorHelper$2($$2(o));
          _context7.prev = 42;
          _iterator12.s();
        case 44:
          if ((_step12 = _iterator12.n()).done) {
            _context7.next = 50;
            break;
          }
          c = _step12.value;
          _context7.next = 48;
          return c;
        case 48:
          _context7.next = 44;
          break;
        case 50:
          _context7.next = 55;
          break;
        case 52:
          _context7.prev = 52;
          _context7.t2 = _context7["catch"](42);
          _iterator12.e(_context7.t2);
        case 55:
          _context7.prev = 55;
          _iterator12.f();
          return _context7.finish(55);
        case 58:
          _context7.next = 63;
          break;
        case 60:
          if (!o) {
            _context7.next = 63;
            break;
          }
          _context7.next = 63;
          return o;
        case 63:
        case "end":
          return _context7.stop();
      }
    }, handle_els, null, [[2, 27, 30, 33], [7, 17, 20, 23], [42, 52, 55, 58]]);
  });
  Element.prototype.append = function () {
    for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      children[_key2] = arguments[_key2];
    }
    old_append.apply(this, _toConsumableArray$2(_handle_els(children)));
  };
  Element.prototype.prepend = function () {
    for (var _len3 = arguments.length, children = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      children[_key3] = arguments[_key3];
    }
    old_prepend.apply(this, _toConsumableArray$2(_handle_els(children)));
  };
  UI.Column = /*#__PURE__*/function (_UI2) {
    function Column() {
      _classCallCheck$2(this, Column);
      return _callSuper$2(this, Column, arguments);
    }
    _inherits$2(Column, _UI2);
    return _createClass$2(Column, [{
      key: "init",
      value: function init() {
        _superPropGet(Column, "init", this)([]);
        this.elem.classList.add("column");
      }
    }]);
  }(UI);
  UI.FlexColumn = /*#__PURE__*/function (_UI3) {
    function FlexColumn() {
      _classCallCheck$2(this, FlexColumn);
      return _callSuper$2(this, FlexColumn, arguments);
    }
    _inherits$2(FlexColumn, _UI3);
    return _createClass$2(FlexColumn, [{
      key: "init",
      value: function init() {
        _superPropGet(FlexColumn, "init", this)([]);
        this.elem.classList.add("flex", "column");
      }
    }]);
  }(UI);
  UI.Row = /*#__PURE__*/function (_UI4) {
    function Row() {
      _classCallCheck$2(this, Row);
      return _callSuper$2(this, Row, arguments);
    }
    _inherits$2(Row, _UI4);
    return _createClass$2(Row, [{
      key: "init",
      value: function init() {
        _superPropGet(Row, "init", this)([]);
        this.elem.classList.add("row");
      }
    }]);
  }(UI);
  UI.FlexRow = /*#__PURE__*/function (_UI5) {
    function FlexRow() {
      _classCallCheck$2(this, FlexRow);
      return _callSuper$2(this, FlexRow, arguments);
    }
    _inherits$2(FlexRow, _UI5);
    return _createClass$2(FlexRow, [{
      key: "init",
      value: function init() {
        _superPropGet(FlexRow, "init", this)([]);
        this.elem.classList.add("flex", "row");
      }
    }]);
  }(UI);
  UI.Separator = /*#__PURE__*/function (_UI6) {
    function Separator(settings) {
      _classCallCheck$2(this, Separator);
      return _callSuper$2(this, Separator, ["<hr>", settings]);
    }
    _inherits$2(Separator, _UI6);
    return _createClass$2(Separator);
  }(UI);
  UI.Label = /*#__PURE__*/function (_UI7) {
    function Label(content, settings) {
      _classCallCheck$2(this, Label);
      return _callSuper$2(this, Label, ["<label></label>", _objectSpread({
        content: content
      }, settings)]);
    }
    _inherits$2(Label, _UI7);
    return _createClass$2(Label);
  }(UI);
  UI.Link = /*#__PURE__*/function (_UI8) {
    function Link(content, settings) {
      var _this12;
      _classCallCheck$2(this, Link);
      var el = $$2("<a>")[0];
      el.innerHTML = content;
      _this12 = _callSuper$2(this, Link, [el, _objectSpread({}, settings)]);
      _this12.on("update", function () {
        if ("href" in _this12.settings) _this12.elem.href = _this12.get_setting("href");
        if ("target" in _this12.settings) _this12.elem.target = _this12.get_setting("target");
      });
      return _this12;
    }
    _inherits$2(Link, _UI8);
    return _createClass$2(Link);
  }(UI);
  UI.Button = /*#__PURE__*/function (_UI9) {
    function Button(label, settings) {
      _classCallCheck$2(this, Button);
      var el = $$2("<button>")[0];
      el.innerHTML = label;
      return _callSuper$2(this, Button, [el, _objectSpread({}, settings)]);
    }
    _inherits$2(Button, _UI9);
    return _createClass$2(Button, [{
      key: "init",
      value: function init() {
        _superPropGet(Button, "init", this)([]);
        this.elem.classList.add("button");
      }
    }]);
  }(UI);
  UI.Root = /*#__PURE__*/function (_UI10) {
    /** @type {Set<UI>} */
    // connected_uis = new Set();
    function Root(root) {
      var _this13;
      _classCallCheck$2(this, Root);
      if (!root) root = document.body;
      _this13 = _callSuper$2(this, Root, [root]);
      _this13.ui_interval = setInterval(function () {
        _this13.update();
      }, 1000);
      _this13.ui_observer = new MutationObserver(function (mutations) {
        var _iterator13 = _createForOfIteratorHelper$2(mutations),
          _step13;
        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var mutation = _step13.value;
            var _iterator14 = _createForOfIteratorHelper$2(mutation.addedNodes),
              _step14;
            try {
              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                var node = _step14.value;
                var _iterator16 = _createForOfIteratorHelper$2(UI.find(node, UI, true, true)),
                  _step16;
                try {
                  for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                    var ui = _step16.value;
                    _this13.register(ui);
                  }
                } catch (err) {
                  _iterator16.e(err);
                } finally {
                  _iterator16.f();
                }
              }
            } catch (err) {
              _iterator14.e(err);
            } finally {
              _iterator14.f();
            }
            var _iterator15 = _createForOfIteratorHelper$2(mutation.removedNodes),
              _step15;
            try {
              for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                var node = _step15.value;
                var _iterator17 = _createForOfIteratorHelper$2(UI.find(node, UI, true, true)),
                  _step17;
                try {
                  for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                    var ui = _step17.value;
                    _this13.unregister(ui);
                  }
                } catch (err) {
                  _iterator17.e(err);
                } finally {
                  _iterator17.f();
                }
              }
            } catch (err) {
              _iterator15.e(err);
            } finally {
              _iterator15.f();
            }
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      });
      ["keydown", "keyup", "mousedown", "mouseup", "click"].forEach(function (ev) {
        root.addEventListener(ev, function (e) {
          _this13.update_next_frame();
          /* for (var ui of UI.parents(e.target, true)) {
              ui.update_next_frame();
          } */
        });
      });
      _this13.ui_observer.observe(root, {
        childList: true,
        subtree: true
      }); //, attributes:true
      return _this13;
    }
    /** @param {UI} ui */
    _inherits$2(Root, _UI10);
    return _createClass$2(Root, [{
      key: "register",
      value: function register(ui) {
        this.unregister(ui);
        ui._parent = UI.parent(ui.elem);
        if (ui instanceof UI.Property) {
          ui._container = UI.closest(ui.elem, UI.PropertyContainer);
          if (ui._container) ui._container._properties.add(ui);
        }
        if (ui._parent) ui._parent._children.add(ui);
        ui.update_next_frame();
        /* if (!this.connected_uis.has(ui)) {
            this.connected_uis.add(ui);
            ui.update_next_frame();
        } */
      }
      /** @param {UI} ui */
    }, {
      key: "unregister",
      value: function unregister(ui) {
        if (ui._parent) {
          ui._parent._children["delete"](ui);
          ui._parent = null;
        }
        if (ui._container) {
          ui._container._properties["delete"](ui);
          ui._container = null;
        }
        // this.connected_uis.delete(ui);
      }
      /* update() {
          for (var ui of this.connected_uis) {
              ui.update();
          }
      } */
    }, {
      key: "destroy",
      value: function destroy() {
        _superPropGet(Root, "destroy", this)([]);
        clearInterval(this.ui_interval);
        this.ui_observer.disconnect();
      }
    }]);
  }(UI);
  UI.PropertyContainer = /*#__PURE__*/function (_UI11) {
    function PropertyContainer(settings) {
      var _this14;
      _classCallCheck$2(this, PropertyContainer);
      _this14 = _callSuper$2(this, PropertyContainer, [null, Object.assign({
        data: function data(a) {
          return a;
        },
        nullify_defaults: false,
        disabled: false
        // autoregister: true,
      }, settings)]);
      /** @type {Set<UI.Property>} */
      _defineProperty$2(_this14, "_properties", new Set());
      _this14.elem.classList.add("property-container");

      // /** @type {Set<UI.Property>} */
      // this.properties = new Set();

      /* if (this.settings.autoregister) {
          this.autoregister_observer = new MutationObserver(mutations=>{
              for (var mutation of mutations) {
                  for (var node of mutation.addedNodes) {
                      this.register_properties(...UI.find(node, UI.Property, false, true));
                  }
              }
          });
          this.autoregister_observer.observe(this.elem, { childList:true, subtree:true });
      } */

      _this14.datas = [null]; // necessary so update(null, {...}) can work

      _this14.elem.addEventListener("keydown", function (e) {
        if (e.key === "Enter" && e.target.matches("input,select")) {
          var inputs = _this14.get_interactive_elements();
          var next_input = inputs[inputs.indexOf(e.target) + 1];
          if (next_input) next_input.focus();else e.target.blur();
          e.preventDefault();
          e.stopPropagation();
        }
      });
      return _this14;
    }

    // /** @param {UI.Properties} properties */
    // register_properties(...properties) {
    //     for (var p of properties) {
    //         this.properties.add(p);
    //         p.container = this;
    //     }
    // }

    // /** @param {UI.Properties} properties */
    // unregister_properties(...properties) {
    //     for (var p of properties) {
    //         this.properties.delete(p);
    //         p.container = undefined;
    //     }
    // }
    _inherits$2(PropertyContainer, _UI11);
    return _createClass$2(PropertyContainer, [{
      key: "data",
      get: function get() {
        return this.get_setting("data", this._datas[0]);
      },
      set: function set(value) {
        this._datas = [value];
      }
    }, {
      key: "datas",
      get: function get() {
        var _this15 = this;
        return this._datas.map(function (data) {
          return _this15.get_setting("data", data);
        });
      }
      /** @type {object[]} */,
      set: function set(values) {
        if (!Array.isArray(values)) values = [values];
        this._datas = _toConsumableArray$2(values);
        if (this._datas.length == 0) this._datas = [null];
      }
    }, {
      key: "valid",
      get: function get() {
        return this.properties.every(function (p) {
          return p.valid;
        });
      }
    }, {
      key: "valid_visible",
      get: function get() {
        var _iterator18 = _createForOfIteratorHelper$2(this.get_properties()),
          _step18;
        try {
          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
            var p = _step18.value;
            if (p.visible && !p.valid) return false;
          }
        } catch (err) {
          _iterator18.e(err);
        } finally {
          _iterator18.f();
        }
        return true;
      }
      /** @type {object} */
    }, {
      key: "property_lookup",
      get: function get() {
        return Object.fromEntries(this.properties.map(function (p) {
          return [p.id, p._value];
        }));
      }
      /** @type {object} */
    }, {
      key: "named_property_lookup",
      get: function get() {
        return Object.fromEntries(this.properties.filter(function (p) {
          return !p.is_indeterminate && p.name;
        }).map(function (p) {
          return [p.name, p._value];
        }));
      }
      /** @type {object} */
    }, {
      key: "named_property_lookup_not_null",
      get: function get() {
        return Object.fromEntries(Object.entries(this.named_property_lookup).filter(function (_ref5) {
          var _ref6 = _slicedToArray$1(_ref5, 2);
            _ref6[0];
            var v = _ref6[1];
          return v !== null;
        }));
      }
    }, {
      key: "properties",
      get: function get() {
        return _toConsumableArray$2(this.get_properties());
      }
    }, {
      key: "get_properties",
      value: /*#__PURE__*/_regeneratorRuntime$1().mark(function get_properties() {
        var _iterator19, _step19, p;
        return _regeneratorRuntime$1().wrap(function get_properties$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              if (this._properties) {
                _context8.next = 2;
                break;
              }
              return _context8.abrupt("return");
            case 2:
              _iterator19 = _createForOfIteratorHelper$2(this._properties);
              _context8.prev = 3;
              _iterator19.s();
            case 5:
              if ((_step19 = _iterator19.n()).done) {
                _context8.next = 11;
                break;
              }
              p = _step19.value;
              _context8.next = 9;
              return p;
            case 9:
              _context8.next = 5;
              break;
            case 11:
              _context8.next = 16;
              break;
            case 13:
              _context8.prev = 13;
              _context8.t0 = _context8["catch"](3);
              _iterator19.e(_context8.t0);
            case 16:
              _context8.prev = 16;
              _iterator19.f();
              return _context8.finish(16);
            case 19:
            case "end":
              return _context8.stop();
          }
        }, get_properties, this, [[3, 13, 16, 19]]);
      })
    }, {
      key: "get_properties_by_name",
      value: function get_properties_by_name(name) {
        return this.properties.filter(function (p) {
          return p.name === name;
        });
      }
    }, {
      key: "get_property_by_name",
      value: function get_property_by_name(name) {
        return this.get_properties_by_name(name)[0];
      }
    }, {
      key: "get_interactive_elements",
      value: function get_interactive_elements() {
        return _toConsumableArray$2(this.elem.querySelectorAll("input,select,textarea")).filter(function (e) {
          return is_visible(e);
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        var _iterator20 = _createForOfIteratorHelper$2(this.get_properties()),
          _step20;
        try {
          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
            var p = _step20.value;
            p.reset(true);
          }
        } catch (err) {
          _iterator20.e(err);
        } finally {
          _iterator20.f();
        }
      }
    }, {
      key: "update",
      value: function update() {
        var _iterator21 = _createForOfIteratorHelper$2(this.get_properties()),
          _step21;
        try {
          for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
            var p = _step21.value;
            if (p.settings["data"] !== undefined) {
              var values = this.datas.map(function (d) {
                return p.get_setting("data", d);
              });
              p.set_values(values);
            } else if (p.name) {
              var path = p.name.split("/").filter(function (p) {
                return p;
              });
              var values = this.datas.map(function (d) {
                if (!d) return null;
                return _try$1(function () {
                  return get$2(d, path);
                });
              });
              var hash = JSON.stringify(values);
              if (p._last_values_on_property_update !== hash) {
                p._last_values_on_property_update = hash;
                p.set_values(values);
              }
            }
          }
        } catch (err) {
          _iterator21.e(err);
        } finally {
          _iterator21.f();
        }
        _superPropGet(PropertyContainer, "update", this)([]);
      }
    }]);
  }(UI);

  /* UI.Indeterminate = Object.freeze(new class {
      toString() { return "[Indeterminate]"; }
  }()); */

  /** @typedef {HTMLInputElement|HTMLSelectElement|HTMLTextAreaElement} Input */

  UI.Property = /*#__PURE__*/function (_UI12) {
    /** @param {string} name @param {string} label @param {string|Element[]} contents @param {object} settings */
    function Property(name, label, contents, settings) {
      var _this16;
      _classCallCheck$2(this, Property);
      settings = _objectSpread({
        "setup": function setup() {
          var inputs_selector = "input,select,textarea";
          var inputs = _this16.contents.map(function (e) {
            if (e.matches(inputs_selector)) return [e];
            return Array.from(e.querySelectorAll(inputs_selector));
          }).flat();
          inputs.forEach(function (i) {
            return _this16.setup_generic_input(i);
          });
          return inputs;
        },
        "label": label,
        // "event":(e)=>e.type === "change",
        "placeholder": "",
        "invalid_class": "invalid",
        "default": null,
        "readonly": undefined,
        "spinner": undefined,
        "min": undefined,
        "max": undefined,
        "step": undefined,
        "round": undefined,
        "precision": undefined,
        "disabled": false,
        "reset": true,
        "hidden": false,
        "info": undefined,
        "options": undefined,
        "copy": false,
        "reset_on_dblclick": false,
        "nullify_defaults": function nullify_defaults() {
          var container = _this16.container;
          return container ? container.get_setting("nullify_defaults") : false;
        }
      }, settings);
      _this16 = _callSuper$2(this, Property, [null, settings]);
      _this16.elem.classList.add("property");
      _this16._values = [null];
      /** @type {Element[]} */
      _this16.contents = [];
      /** @type {Input[]} */
      _this16.inputs = [];
      /** @type {Function(any,Input):string[]} */
      _this16.input_modifiers = [];
      /** @type {Function(any,Input):any[]} */
      _this16.output_modifiers = []; //(v,input)=>input.value=v
      /** @type {Function(any,Input):any[]} */
      _this16.validators = [];
      _this16.options_consistant = true;
      // this.values_valid = true;
      _this16.inputs_valid = true;
      _this16.name = name;
      _this16.name_id = "".concat(_this16.name, "-").concat(_this16.id);
      _this16.inner = new UI();
      _this16.inner.elem.classList.add("property-inner");
      _this16.append(_this16.inner);
      contents = typeof contents === "string" ? $$2(contents) : contents;
      if (!Array.isArray(contents)) contents = [contents];
      contents.forEach(function (e) {
        return _this16.inner.append(e);
      });
      _this16.contents = contents;
      var inputs = _this16.get_setting("setup") || [];
      if (!Array.isArray(inputs)) inputs = [inputs];
      _this16.inputs = inputs;
      if (_this16.input) {
        if (_this16.settings["placeholder"] === undefined) _this16.settings["placeholder"] = _this16.input.placeholder;
        if (_this16.settings["readonly"] === undefined) _this16.settings["readonly"] = _this16.input.readOnly;
        if (_this16.settings["default"] === undefined) _this16.settings["default"] = _this16.input.value;
        if (_this16.settings["min"] === undefined && _this16.input.min) _this16.settings["min"] = function () {
          return _this16.apply_input_modifiers(+_this16.input.min);
        };
        if (_this16.settings["max"] === undefined && _this16.input.max) _this16.settings["max"] = function () {
          return _this16.apply_input_modifiers(+_this16.input.max);
        };
        if (_this16.settings["step"] === undefined && _this16.input.step) _this16.settings["step"] = function () {
          return _this16.apply_input_modifiers(+_this16.input.step);
        };
      }
      if (_this16.input && _this16.input.type === "number" || _this16.settings["step"] !== undefined || _this16.settings["precision"] !== undefined || _this16.settings["round"] !== undefined || _this16.settings["min"] !== undefined || _this16.settings["max"] !== undefined || _this16.settings["spinner"] !== undefined) {
        _this16.is_numeric = true;
        _this16.settings["step"] = _this16.settings["step"] || 1;
        if (_this16.settings["spinner"] !== false && _this16.input.type !== "range") {
          _this16.spinner_elem = new UI().elem;
          _this16.spinner_elem.classList.add("spinner");
          _this16.up_button = new UI.Button("<i class=\"fas fa-caret-up\"></i>", {
            "click": function click(e) {
              return _this16.set_values(_this16.value + _this16.get_setting("step"), {
                trigger_if_changed: true
              });
            },
            "disabled": function disabled() {
              return _this16.value >= _this16.get_setting("max");
            }
          });
          _this16.down_button = new UI.Button("<i class=\"fas fa-caret-down\"></i>", {
            "click": function click(e) {
              return _this16.set_values(_this16.value - _this16.get_setting("step"), {
                trigger_if_changed: true
              });
            },
            "disabled": function disabled() {
              return _this16.value <= _this16.get_setting("min");
            }
          });
          _this16.spinner_elem.append(_this16.up_button, _this16.down_button);
          _this16.inner.append(_this16.spinner_elem);
        }
      }
      var label_elem = _this16.elem.querySelector("label");
      if (!label_elem) {
        label_elem = $$2("<label><span></span></label>")[0];
        _this16.label = new UI(label_elem, {
          hidden: function hidden() {
            return !_this16.get_setting("label", _this16.data);
          },
          update: function update() {
            set_inner_html(_this16.label.elem.firstChild, _this16.get_setting("label", _this16.data));
            var info = _this16.get_setting("info", _this16.data);
            if (info) {
              if (!_this16.info_elem) {
                _this16.info_elem = $$2("<span><i class=\"fas fa-question-circle info\"></i></span>")[0];
                _this16.label.append(_this16.info_elem);
                _this16.tooltip = new UI.Tooltip(_this16.info_elem);
              }
              _this16.tooltip.set_content(info);
            }
            if (_this16.info_elem) toggle_class(_this16.info_elem, "d-none", !info);
          }
        });
        _this16.prepend(_this16.label);
      }
      label_elem.setAttribute("for", _this16.name_id);
      if (_this16.get_setting("copy")) {
        var copy_hide_timeout;
        var copy_tippy;
        _this16.copy_button = new UI.Button("<i class=\"fas fa-copy\"></i>", {
          "click": function click(e) {
            e.preventDefault();
            _this16.input.select();
            window.navigator.clipboard.writeText(_this16.input.value);
            if (!copy_tippy) {
              copy_tippy = tippy(_this16.input, {
                content: "Copied!",
                distance: 0,
                trigger: "manual",
                zIndex: 999999,
                onShow: function onShow(instance) {
                  clearTimeout(copy_hide_timeout);
                  copy_hide_timeout = setTimeout(function () {
                    return instance.hide();
                  }, 1500);
                }
              });
            }
            copy_tippy.show();
          },
          "title": "Copy"
        });
        _this16.inner.append(_this16.copy_button);
        var _iterator22 = _createForOfIteratorHelper$2(_this16.inputs),
          _step22;
        try {
          var _loop = function _loop() {
            var input = _step22.value;
            input.addEventListener("mousedown", function (e) {
              input.select();
              if (e.button == 0) e.preventDefault();
            });
          };
          for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator22.e(err);
        } finally {
          _iterator22.f();
        }
      }
      _this16.reset_button = new UI.Button("<i class=\"fas fa-undo\"></i>", {
        "click": function click() {
          return _this16.reset(true);
        },
        "title": "Reset",
        "hidden": function hidden() {
          return !_this16.get_setting("reset");
        }
      });
      _this16.inner.append(_this16.reset_button);

      /* requestAnimationFrame(()=>{
          this.update_inputs(true);
      }); */
      return _this16;
    }
    _inherits$2(Property, _UI12);
    return _createClass$2(Property, [{
      key: "content",
      get: function get() {
        return this.contents[0];
      }
    }, {
      key: "input",
      get: function get() {
        return this.inputs[0];
      }
    }, {
      key: "_value",
      get: function get() {
        return this._values[0];
      }
    }, {
      key: "value",
      get: function get() {
        return this.iterate_values().next().value;
      } // this.indeterminate ? UI.Indeterminate : 
    }, {
      key: "values",
      get: function get() {
        return Array.from(this.iterate_values());
      }
      /** @type {boolean} */
    }, {
      key: "is_indeterminate",
      get: function get() {
        return !all_equal$1(this.values);
      }
      /** @type {boolean} */
    }, {
      key: "is_default",
      get: function get() {
        var _this17 = this;
        if (this.nullify_defaults) return this._values.every(function (v) {
          return v == null;
        });
        return this.datas.every(function (item, i) {
          return JSON.stringify(_this17.get_setting("default", item)) === JSON.stringify(_this17.values[i]);
        }); // was this._values[i]
      }
      /** @type {boolean} */
    }, {
      key: "nullify_defaults",
      get: function get() {
        return this.get_setting("nullify_defaults");
      }
    }, {
      key: "data",
      get: function get() {
        return this.datas[0];
      }
    }, {
      key: "datas",
      get: function get() {
        var container = this.container;
        if ("data" in this.settings) return [this.get_setting("data")];
        return container ? container._datas : [null];
      }
      /** @type {UI.PropertyContainer} */
    }, {
      key: "container",
      get: function get() {
        return this._container;
        // return this.get_closest(UI.PropertyContainer);
      }
    }, {
      key: "hidden",
      get: function get() {
        var _this18 = this;
        return this.datas.some(function (item) {
          return _this18.get_setting("hidden", item);
        }); // (this.parent||{}).hidden || 
      }
    }, {
      key: "disabled",
      get: function get() {
        var _this19 = this;
        return this.datas.some(function (item) {
          return _this19.get_setting("disabled", item);
        }) || this.disabled_parent || !this.options_consistant;
      }
    }, {
      key: "valid",
      get: function get() {
        //return this.values_valid === true &&
        return this.inputs_valid === true;
      }
    }, {
      key: "setup_generic_input",
      value: function setup_generic_input(input) {
        var _this20 = this;
        input.setAttribute("id", this.name_id);
        // input.setAttribute("name", this.name);
        var input_events = ["change", "input"];
        input_events.forEach(function (ev_type) {
          input.addEventListener(ev_type, function (e, i) {
            if (ev_type == "input") _this20.emit("input", e);
            var value = get_value(input);
            value = _this20.apply_input_modifiers(value, input);
            _this20.set_value(value, {
              trigger_if_changed: e.type == "change"
            });
          });
        });
        input.addEventListener("blur", function (e) {
          _this20.update_next_frame();
        });
        input.addEventListener("focus", function (e) {
          _this20.update_next_frame();
        });
        if (input.nodeName === "INPUT") {
          input.addEventListener("keydown", function (e) {
            if (e.key === "Enter") {
              e.preventDefault();
              e.target.blur();
            }
            if (input.type !== "number" && _this20.is_numeric) {
              var new_value;
              if (e.key == "ArrowUp") new_value = _this20.value + _this20.get_setting("step");else if (e.key == "ArrowDown") new_value = _this20.value - _this20.get_setting("step");
              if (new_value !== undefined) {
                e.stopPropagation();
                e.preventDefault();
                // input._force_update_value = true;
                _this20.set_values(new_value, {
                  trigger_if_changed: true
                });
              }
            }
          });
        }
        input.addEventListener("dblclick", function (e) {
          if (_this20.get_setting("reset_on_dblclick")) {
            _this20.set_values(null, {
              trigger_if_changed: true
            });
          }
        });

        /* Object.defineProperty(input, 'value', {
            get () { return this.get_value(); },
            set (value) { this.set_value(value, false); }
        }); */
      }
    }, {
      key: "reset",
      value: function reset() {
        var trigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        this.set_values(null, {
          trigger_if_changed: trigger
        });
      }
    }, {
      key: "fix_value",
      value: function fix_value(value) {
        if (typeof value == "number") {
          var min = this.get_setting("min");
          var max = this.get_setting("max");
          var round = this.get_setting("round");
          var precision = this.get_setting("precision");
          if (max !== undefined) value = Math.min(value, +max);
          if (min !== undefined) value = Math.max(value, +min);
          if (round !== undefined) value = round_to_factor$1(value, round);
          if (precision !== undefined) value = +value.toFixed(precision);
          /* if (isNaN(value)) {
              debugger;
              value = 0
          } */
        }
        return value;
      }

      /** @typedef {{trigger:boolean, trigger_if_changed:boolean}} SetValueOptions */
      /** @param {SetValueOptions} options */
    }, {
      key: "set_value",
      value: function set_value(value, options) {
        return this.set_values(this.datas.map(function (_) {
          return value;
        }), options);
      }

      /** @param {SetValueOptions} options */
    }, {
      key: "set_values",
      value: function set_values(values, options) {
        var _this21 = this;
        options = Object.assign({
          trigger: false,
          trigger_if_changed: false
        }, options);
        // console.trace(this.name, values, trigger);
        // if (!Array.isArray(values)) throw new Error("Values must be array...");
        if (!Array.isArray(values)) values = this.datas.map(function (item) {
          return values;
        });
        if (values.length != this.datas.length) {
          throw new Error("Values length (".concat(values.length, ") mismatch datas length (").concat(this.datas.length, ")..."));
        }
        values = values.map(function (v) {
          return _this21.fix_value(v);
        });
        this._values = this.datas.map(function (data, i) {
          var default_value = _this21.fix_value(_this21.get_setting("default", data));
          if (_this21.nullify_defaults) return JSON.stringify(values[i]) === JSON.stringify(default_value) ? null : values[i];
          return values[i] == null ? default_value : values[i];
        });

        // --------------- DO NOT TOUCH ---------------
        // -------- THIS IS A DELICATE MACHINE --------

        var values_hash = JSON.stringify([this.values, this._values, options.trigger_if_changed, options.trigger]);
        var changed = values_hash !== this._last_changed_values_hash;
        if (changed) this._last_changed_values_hash = values_hash;
        var trigger = options.trigger || options.trigger_if_changed && changed;
        if (trigger) {
          this.inputs.forEach(function (input) {
            return input._force_update_value = true;
          });
        }

        // --------------------------------------------

        this.update_next_frame();
        var e = {
          "datas": _toConsumableArray$2(this.datas),
          "name": this.name,
          "_value": this._value,
          "_values": this._values,
          "value": this.value,
          "values": this.values,
          "trigger": trigger
        };
        var container = this.container;
        if (changed || trigger) {
          this.emit("change", e);
          if (container) container.emit("property-change", e);
        }
        return changed;
      }
    }, {
      key: "update",
      value: function update() {
        var _this22 = this;
        var is_default = this.is_default;
        var is_indeterminate = this.is_indeterminate;
        var default_value = this.get_setting("default", this.data);
        var readonly = this.get_setting("readonly");
        var disabled = this.disabled;
        var style_not_default = !!this.get_setting("reset");
        this.options_consistant = true;
        if (this.settings["options"] !== undefined) {
          var options = [];
          var items_options = this.datas.map(function (item) {
            return _this22.get_setting("options", item) || [];
          });
          this.options_consistant = function () {
            if (_this22.datas.length <= 1) return true;
            var last;
            var _iterator23 = _createForOfIteratorHelper$2(items_options),
              _step23;
            try {
              for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                var o = _step23.value;
                var curr = JSON.stringify(o);
                if (last && curr != last) return false;
                last = curr;
              }
            } catch (err) {
              _iterator23.e(err);
            } finally {
              _iterator23.f();
            }
            return true;
          }();
          if (!this.options_consistant) is_indeterminate = true;
          if (!this.options_consistant || is_indeterminate) options = [{
            value: "",
            text: "Multiple values",
            style: {
              "display": "none"
            }
          }];
          if (this.options_consistant) {
            var _options;
            (_options = options).push.apply(_options, _toConsumableArray$2(deep_copy$1(items_options[0])));
          }
          options = fix_options(options);
          if (style_not_default) {
            options.forEach(function (o) {
              if (String(o.value) === String(default_value)) o.text += " *";
            });
          }
          this.inputs.filter(function (e) {
            return e.nodeName === "SELECT";
          }).forEach(function (e) {
            return set_select_options(e, options);
          });
        }
        var valids = [];
        this.inputs.forEach(function (/**@type {HTMLInputElement|HTMLTextAreaElement|HTMLSelectElement}*/input, i) {
          // input.disabled = disabled;
          input.toggleAttribute("disabled", disabled === true);
          if (readonly !== undefined) {
            input.readOnly = readonly;
            // set_attribute(input, "readonly", readonly);
          }
          var is_focused = has_focus(input);
          var is_checkbox = input.nodeName === "INPUT" && input.type === "checkbox";
          input.classList.toggle("not-default", !is_default && style_not_default); // !is_focused && 

          if (is_checkbox) {
            input.indeterminate = is_indeterminate;
          }
          var value = _this22.value;
          if (is_indeterminate) {
            if (input.type == "color") value = "#000000";else value = "";
          } else {
            value = _this22.apply_output_modifiers(value, input);
            if (typeof value === "number" && _this22.settings["precision"] !== undefined) {
              value = value.toFixed(_this22.get_setting("precision"));
              if (value.includes(".")) value = value.replace(/\.?0+$/, "");
            }
          }
          // if ((input.nodeName === "INPUT" || input.nodeName === "TEXTAREA") && is_focused && !input.hasAttribute("readonly") && !input._force_update_value) {
          /* if ((input.nodeName === "INPUT" && (input.type == "date" || input.type == "time")) && is_focused) {
          } else {
          } */
          if (!is_focused || input._force_update_value) {
            set_value(input, value, false);
          }
          input._force_update_value = false;

          // set_value(input, value, false);

          /* if (blur) {
              input.blur();
          } */

          // set_attribute(input, "placeholder", placeholder);
          input.placeholder = is_indeterminate ? "Multiple values" : _this22.get_setting("placeholder");
          var title = is_indeterminate ? "Multiple values" : _this22.get_setting("title") || "";
          if (title) input.setAttribute("title", title);else input.removeAttribute("title");
          var valid = disabled || is_indeterminate || function () {
            var _iterator24 = _createForOfIteratorHelper$2(_this22.validators),
              _step24;
            try {
              for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                var validator = _step24.value;
                valid = validator.apply(_this22, [_this22.value, input]);
                if (valid !== true) return valid;
              }
            } catch (err) {
              _iterator24.e(err);
            } finally {
              _iterator24.f();
            }
            return true;
          }();
          valids.push(valid);
          var invalid_class = _this22.get_setting("invalid_class");
          if (invalid_class) input.classList.toggle(invalid_class, valid !== true);
          if (valid === false) valid = "Invalid input";
          if (input._last_valid !== valid) {
            if (typeof valid === "string") {
              if (!input._tooltip) new UI.Tooltip(input);
              input._tooltip.set_content(valid);
            } else {
              if (input._tooltip) input._tooltip.destroy();
            }
            input._last_valid = valid;
          }
        });
        this.inputs_valid = valids.every(function (v) {
          return v === true;
        });
        _superPropGet(Property, "update", this)([]);
      }
    }, {
      key: "add_validator",
      value: function add_validator() {
        var _this$validators;
        (_this$validators = this.validators).push.apply(_this$validators, arguments);
      }
    }, {
      key: "apply_input_modifiers",
      value: function apply_input_modifiers(v, input) {
        var _iterator25 = _createForOfIteratorHelper$2(this.input_modifiers),
          _step25;
        try {
          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
            var m = _step25.value;
            v = m.apply(this, [v, input]);
          }
        } catch (err) {
          _iterator25.e(err);
        } finally {
          _iterator25.f();
        }
        return v;
      }
    }, {
      key: "apply_output_modifiers",
      value: function apply_output_modifiers(v, input) {
        var v;
        var _iterator26 = _createForOfIteratorHelper$2(this.output_modifiers),
          _step26;
        try {
          for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
            var m = _step26.value;
            v = m.apply(this, [v, input]);
            if (v === undefined) return;
          }
        } catch (err) {
          _iterator26.e(err);
        } finally {
          _iterator26.f();
        }
        return v;
      }
    }, {
      key: "iterate_values",
      value: /*#__PURE__*/_regeneratorRuntime$1().mark(function iterate_values() {
        var datas, i;
        return _regeneratorRuntime$1().wrap(function iterate_values$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              datas = this.datas;
              i = 0;
            case 2:
              if (!(i < this._values.length)) {
                _context9.next = 8;
                break;
              }
              _context9.next = 5;
              return this._values[i] == null ? this.get_setting("default", datas[i]) : this._values[i];
            case 5:
              i++;
              _context9.next = 2;
              break;
            case 8:
            case "end":
              return _context9.stop();
          }
        }, iterate_values, this);
      })
      /* destroy() {
          if (this.container) this.container.unregister_properties(this);
          super.destroy();
      } */
    }]);
  }(UI);
  UI.MultiProperty = /*#__PURE__*/function (_UI$Property) {
    function MultiProperty(name, label, contents, settings) {
      var _this23;
      _classCallCheck$2(this, MultiProperty);
      _this23 = _callSuper$2(this, MultiProperty, [name, label, contents, settings]);
      _this23.input_modifiers.push(function (value, input) {
        if (Array.isArray(_this23.value)) {
          var i = _this23.inputs.indexOf(input);
          var v = _toConsumableArray$2(_this23.value);
          v[i] = value;
        }
        return v;
      });
      _this23.output_modifiers.push(function (value, input) {
        if (Array.isArray(_this23.value)) {
          var i = _this23.inputs.indexOf(input);
          value = value[i];
        }
        return value;
      });
      return _this23;
    }
    _inherits$2(MultiProperty, _UI$Property);
    return _createClass$2(MultiProperty);
  }(UI.Property);
  UI.DateTimeProperty = /*#__PURE__*/function (_UI$Property2) {
    function DateTimeProperty(name, label) {
      var _this24;
      var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      _classCallCheck$2(this, DateTimeProperty);
      var inputs = $$2("<input type=\"date\"><input type=\"time\">");
      var get_value = function get_value() {
        var values = inputs.map(function (i) {
          return i.value;
        });
        if (values.every(function (v) {
          return v === "";
        })) return NaN;
        if (!values[0]) values[0] = _this24.today_str;
        if (!values[1]) values[1] = "00:00";
        return join_datetime$1(values, _this24.get_setting("datetime.apply_timezone"));
      };
      _this24 = _callSuper$2(this, DateTimeProperty, [name, label, inputs, Object.assign({
        "datetime.apply_timezone": true,
        "default": null,
        "setup": function setup() {
          inputs.forEach(function (input) {
            input.addEventListener("blur", function (e) {
              var value = get_value();
              if (!isNaN(value)) {
                _this24.set_value(value, {
                  trigger_if_changed: true
                });
              }
            });
            input.addEventListener("keydown", function (e) {
              if (e.key === "Enter") {
                e.preventDefault();
                e.target.blur();
                if (e.target === inputs[0]) inputs[1].focus();
              }
            });
          });
          return inputs;
        }
      }, settings)]);
      _this24.add_validator(function (_, input) {
        if (_this24.get_setting("datetime.after_now")) {
          // inputs[0].min = utils.split_datetime(new Date())[0];
          if (!input.value) return true;
          var before_now = get_value() < Math.floor(new Date() / 1000) * 1000;
          var before_today = new Date(inputs[0].value) < new Date(_this24.today_str);
          if (before_today && input === inputs[0]) return "Scheduled date is in the past.";else if (!before_today && before_now && input === inputs[1]) return "Scheduled time is in the past.";
          return true;
        }
      });
      _this24.output_modifiers.push(function (value, input) {
        // if (isNaN(get_value()) && !v) return;
        var parts = ["", ""];
        if (value) {
          parts = split_datetime$1(value, _this24.get_setting("datetime.apply_timezone"));
        }
        if (input === inputs[0]) {
          return parts[0];
        } else {
          return parts[1].slice(0, 5);
        }
      });
      return _this24;
    }
    _inherits$2(DateTimeProperty, _UI$Property2);
    return _createClass$2(DateTimeProperty, [{
      key: "today_str",
      get: function get() {
        return new Date().toISOString().split("T")[0];
      }
    }]);
  }(UI.Property);
  UI.TimeSpanProperty = /*#__PURE__*/function (_UI$Property3) {
    function TimeSpanProperty(name, label) {
      var _this25;
      var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      _classCallCheck$2(this, TimeSpanProperty);
      var input = $$2("<input type=\"text\">")[0];
      _this25 = _callSuper$2(this, TimeSpanProperty, [name, label, input, Object.assign({
        "timespan.format": "hh:mm:ss",
        "timespan.zero_infinity": false,
        "step": 1.0,
        "min-step": 0.001,
        "default": 0
      }, settings)]);
      _this25.input_modifiers.push(function (v) {
        var zero_infinity = _this25.get_setting("timespan.zero_infinity");
        if (zero_infinity && v.toLowerCase() === "infinity") return 0;
        v = timespan_str_to_seconds$1(v, _this25.get_setting("timespan.format"));
        return v;
      });
      _this25.output_modifiers.push(function (v) {
        var zero_infinity = _this25.get_setting("timespan.zero_infinity");
        if (zero_infinity && v == 0) return "Infinity";
        return ms_to_timespan_str$1(v * 1000, _this25.get_setting("timespan.format"));
      });
      return _this25;
    }
    _inherits$2(TimeSpanProperty, _UI$Property3);
    return _createClass$2(TimeSpanProperty);
  }(UI.Property);
  UI.TextArea = /*#__PURE__*/function (_UI$Property4) {
    function TextArea(name, label) {
      var _this26;
      var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      _classCallCheck$2(this, TextArea);
      var input = $$2("<textarea style=\"resize:none\"></textarea>")[0];
      _this26 = _callSuper$2(this, TextArea, [name, label, input, Object.assign({
        "default": "",
        "textarea.rows": 4,
        "textarea.min_rows": null,
        "textarea.return_blur": false
      }, settings)]);
      /** @type {AutoSizeController} */
      var asc;
      var rows = _this26.get_setting("textarea.rows");
      var min_rows = _this26.get_setting("textarea.min_rows");
      if (min_rows) {
        asc = new AutoSizeController(input, min_rows, false);
      } else if (rows) {
        _this26.input.rows = rows;
      }
      var max_length = _this26.get_setting("textarea.max_length");
      if (max_length) input.maxLength = max_length;
      if (_this26.get_setting("textarea.show_count")) {
        textarea_input_events.forEach(function (ev) {
          return input.addEventListener(ev, function () {
            return _this26.update_char_count();
          });
        });
        _this26.char_count = $$2("<div style=\"text-align:right\"></div>")[0];
        _this26.append(_this26.char_count);
        _this26.update_char_count();
      }
      input.addEventListener("keydown", function (e) {
        if (e.key == "Enter") {
          if (_this26.get_setting("textarea.return_blur")) {
            e.preventDefault();
            input.blur();
          }
        }
      });
      _this26.on("update", function () {
        if (asc) asc.update();
      });
      return _this26;
    }
    _inherits$2(TextArea, _UI$Property4);
    return _createClass$2(TextArea, [{
      key: "update_char_count",
      value: function update_char_count() {
        this.char_count.innerHTML = "(".concat(this.input.value.length, "/").concat(this.get_setting("textarea.max_length") || "-", ")");
      }
    }]);
  }(UI.Property);
  UI.Tooltip = /*#__PURE__*/function () {
    function _class(elem, content) {
      _classCallCheck$2(this, _class);
      this._tippy = tippy(elem, {
        allowHTML: true,
        zIndex: 99999
        // appendTo: root,
      });
      this.elem = elem;
      if (content) this.set_content(content);
      elem._tooltip = this;
    }
    return _createClass$2(_class, [{
      key: "set_content",
      value: function set_content(content) {
        if (this._content === content) return;
        this._content = content;
        this._tippy.setContent(content);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (!this._tippy) return;
        this._tippy.destroy();
        this._tippy = null;
        this.elem._tooltip = null;
      }
    }]);
  }();
  UI.VALIDATORS = {
    not_empty: function not_empty(v) {
      return !!v || "Field cannot be empty";
    },
    rtmp: function rtmp(v) {
      return is_valid_rtmp_url$1(v) || "Invalid RTMP URL";
    },
    url: function url(v) {
      return is_valid_url$1(v) || "Invalid URL";
    },
    json: function json(v) {
      try {
        JSON.parse(v);
        return true;
      } catch (_unused2) {
        return false;
      }
    }
  };
  function is_visible(elem) {
    if (!elem.isConnected) return false;
    if (elem.offsetHeight === 0 && elem.offsetWidth === 0) return false;
    return true;
    /* if (!elem.ownerDocument) return false;
    while(elem) {
        if (getComputedStyle(elem).display === "none") return false;
        elem = elem.parentElement;
    }
    return true; */
  }
  function select_text(elem) {
    elem.focus();
    var range = elem.ownerDocument.createRange();
    range.selectNodeContents(elem);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }
  function fetch(url) {
    return new Promise(function (resolve) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
          resolve(xhr.responseText);
        }
      };
      xhr.open("GET", url, true);
      xhr.send();
    });
  }
  function parse_style(s) {
    _div2.setAttribute("style", s);
    var d = {};
    for (var i = 0; i < _div2.style.length; i++) {
      var k = _div2.style[i];
      d[k] = _div2.style.getPropertyValue(k);
    }
    return d;
  }
  function clone_document_head(from, to, opts) {
    opts = Object.assign({
      style: true,
      script: false,
      other: true,
      remove_media_rules: true
    }, opts);
    var promises = [];
    if (from instanceof Document) from = from.head;
    var _iterator27 = _createForOfIteratorHelper$2(from.children),
      _step27;
    try {
      for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
        var c = _step27.value;
        var is_stylesheet = c.nodeName === "LINK" && c.rel === "stylesheet";
        if (c.nodeName === "SCRIPT") {
          if (!opts.script) continue;
        } else if (is_stylesheet || c.nodeName === "STYLE") {
          if (!opts.style) continue;
        } else {
          if (!opts.other) continue;
        }
        var clone = c.cloneNode(true);
        to.append(clone);
        if (is_stylesheet && opts.remove_media_rules) {
          var promise = on_stylesheet_load(clone);
          promise.then(function (ss) {
            // order.push([new Date()-t, clone, ss]);
            var rules = [];
            try {
              rules = ss.cssRules;
            } catch (_unused3) {}
            if (!rules) return;
            for (var j = rules.length - 1; j >= 0; j--) {
              if (rules[j].cssText.indexOf('@media') === 0) {
                ss.deleteRule(j);
              }
            }
          });
          promises.push(promise);
        }
      }
    } catch (err) {
      _iterator27.e(err);
    } finally {
      _iterator27.f();
    }
    return Promise.all(promises);
  }
  /* copy_stylesheets: async function(from, to, remove_media_queries = false) {
      if (from.ownerDocument === to.ownerDocument) {
          console.log(`copy_stylesheets: both ownerDocuments identical.`);
          return;
      }
      var style_nodes = new Set();
      function add_style(elem) {
          if (typeof elem === "string") elem = $(elem)[0];
          style_nodes.add(elem);
          to.append(elem);
      }
      var remote_stylesheets = 0;
      // var promises = [];
      for (let e of from.querySelectorAll("*")) {
          if (e instanceof HTMLStyleElement || (e instanceof HTMLLinkElement && e.rel === "stylesheet")) {
              // var cloneable = true;
              // try { var test_access = (e.sheet && e.sheet.cssRules) } catch { cloneable = false; }
              // if (cloneable) {
              //     add_style(e.cloneNode(true));
              // } else {
              //     var p = fetch(e.href).then((css)=>{
              //         add_style(`<style type=${e.type} media=${e.media}>${css}</style>`);
              //     });
              //     promises.push(p);
              // }
              if (e.href) {
                  var href = e.href;
                  if (href.startsWith("//")) href = "https:"+href
                  else if (href.startsWith("/")) href = location.origin+href;
                  try {
                      var url = new URL(href);
                      if (url.host !== location.host) remote_stylesheets++;
                  } catch {}
              }
              add_style(e.cloneNode(true));
          }
      }
      var num_stylesheets = style_nodes.size - remote_stylesheets;
      // await Promise.all(promises);
      
      return new Promise((resolve)=>{
          var check_interval = setInterval(()=>{
              for (var ss of to.ownerDocument.styleSheets) {
                  if (!style_nodes.has(ss.ownerNode)) continue;
                  style_nodes.delete(ss.ownerNode);
                  try {
                      if (!ss.cssRules) continue;
                  } catch {
                      continue;
                  }
                  if (remove_media_queries) {
                      for (var j = ss.cssRules.length-1; j >= 0; j--) {
                          if (ss.cssRules[j].cssText.indexOf('@media') === 0) {
                              ss.deleteRule(j);
                          }
                      }
                  }
              }
              if (style_nodes.size === 0 || to.ownerDocument.styleSheets.length >= num_stylesheets) {
                  clearInterval(check_interval);
                  resolve();
              }
          }, 1000/20);
      });
  }, */
  // get_all_css(from, ignore_media_queries = false) {
  //     var document = from instanceof Document ? from : from.ownerDocument;
  //     var rules = [];
  //     for (ss of document.styleSheets) {
  //         rules.push(`/* ------------- ${ss.href||"Local StyleSheet"} ------------- */`)
  //         try {
  //             var test = ss.cssRules;
  //         } catch {
  //             continue;
  //         }
  //         for (var i = 0; i < ss.cssRules.length; i++) {
  //             var css = ss.cssRules[i].cssText;
  //             if (ignore_media_queries && css.indexOf('@media') === 0) continue;
  //             css.replace(/url\(\"(.+?)\"\)/g, (...m)=>{
  //                 if (m[1].match(/^(?:data\:|#|https?\:\/\/|\/)/)) return m[0];
  //                 var url = utils.join_paths(utils.dirname(ss.href), m[1]);
  //                 return `url("${url}")`
  //             })
  //             rules.push(css);
  //         }
  //         rules.push(`/* ------------- END ------------- */`)
  //     }
  //     return rules.join("\n");
  // },
  function insert_at(container, element, index) {
    if (container.children[index] === element) return;
    index = Math.max(index, 0);
    if (index === 0) {
      container.prepend(element);
    } else {
      var after = container.children[index];
      if (after) container.insertBefore(element, after);else container.append(element);
    }
  }
  function insert_after(target, elem) {
    var parent = target.parentNode;
    if (parent.lastChild === target) {
      parent.appendChild(elem);
    } else {
      parent.insertBefore(elem, target.nextSibling);
    }
  }
  function move(elem) {
    var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (i == 0) return;
    var children = _toConsumableArray$2(elem.parentElement.children);
    var index = children.indexOf(elem);
    if (i > 0) index += 1;
    insert_at(elem.parentElement, elem, index + i);
  }
  function upload(contentType) {
    var multiple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return new Promise(function (resolve) {
      var input = document.createElement('input');
      input.type = 'file';
      input.multiple = multiple;
      input.accept = contentType;
      input.onchange = function () {
        var files = _toConsumableArray$2(input.files);
        if (multiple) resolve(files);else resolve(files[0]);
      };
      input.click();
    });
  }
  function download(filename, text) {
    var element = document.createElement('a');
    element.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(text);
    element.download = filename;
    element.click();
  }
  /** @typedef {{multiple:boolean, accept:string, directories:boolean}} FileDialogOptions */
  /** @return {File[]} @param {FileDialogOptions} opts */
  function open_file_dialog(opts) {
    opts = Object.assign({}, opts);
    return new Promise(function (resolve) {
      var element = document.createElement("input");
      element.style.display = 'none';
      element.type = "file";
      if (opts.accept) element.accept = opts.accept;
      if (opts.multiple) element.multiple = true;
      if (opts.directories) element.webkitdirectory = true;
      document.body.appendChild(element);
      element.addEventListener("change", function () {
        resolve(_toConsumableArray$2(this.files));
      });
      element.dispatchEvent(new MouseEvent("click"));
      document.body.removeChild(element);
    });
  }
  function _empty(elem) {
    while (elem.firstChild) elem.removeChild(elem.firstChild);
  }
  function set_select_options(select, options) {
    // if (!Array.isArray(settings)) Object.entries(settings);
    options = fix_options(options);
    var hash = JSON.stringify(options);
    if (hash === select._options_hash) return;
    select._options_hash = hash;
    select.innerHTML = "";
    return options.map(function (o) {
      var e = $$2("<option></option>")[0];
      e.innerHTML = o.text;
      if (o.disabled) e.disabled = true;
      if (o.selected) e.selected = true;
      if (o.hidden) e.hidden = true;
      if (o["class"]) e["class"].forEach(function (c) {
        return e.classList.add(c);
      });
      if (o.style) Object.assign(e.style, o.style);
      if (o.value !== undefined) {
        e.value = o.value;
        e.dataset.value = JSON.stringify(o.value);
      }
      select.append(e);
      return e;
    });
  }
  function fix_options(options) {
    return options.map(function (o) {
      if (Array.isArray(o)) {
        var i = 0,
          new_o = {};
        for (var i = 0; i < o.length; i++) {
          if (_typeof$2(o[i]) === "object" && o[i] !== null) Object.assign(new_o, o[i]);else if (new_o.value === undefined) {
            var _ref7 = [o[i], o[i]];
            new_o.value = _ref7[0];
            new_o.text = _ref7[1];
          } else new_o.text = String(o[i]);
        }
        return new_o;
      } else if (_typeof$2(o) === "object" && o !== null) {
        if (o.name && !o.text) {
          o.text = o.name;
          delete o.name;
        }
        return o;
      } else return {
        value: o,
        text: String(o)
      };
    });
  }
  function read_file(file, options) {
    options = Object.assign({
      encoding: "utf-8"
    }, options);
    return new Promise(function (resolve) {
      var reader = new FileReader();
      reader.addEventListener('load', function (e) {
        resolve(e.target.result);
      });
      reader.readAsText(file, options.encoding);
    });
  }
  function render_html(htmlString) {
    if (typeof htmlString !== "string") return null;
    _temp_div.innerHTML = htmlString.trim();
    if (_temp_div.childNodes.length == 1) return _temp_div.childNodes[0];
    return Array.from(_temp_div.childNodes);
  }
  function get_value(elem) {
    if (elem.type === "checkbox") {
      return elem.checked;
    } else if (elem.nodeName === "SELECT") {
      var option = _toConsumableArray$2(elem.children).find(function (e) {
        return e.value == elem.value;
      });
      if (option && option.dataset.value !== undefined) return JSON.parse(option.dataset.value);else return elem.value;
    } else if (["number", "range"].includes(elem.type)) {
      return parseFloat(elem.value) || 0;
    } else {
      return elem.value;
    }
  }
  // sets value and triggers change (only if value is different to previous value)
  function set_value(elem, new_value) {
    var trigger_change = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    // var curr_val = get_value(elem);
    // if (curr_val === val) return;
    if (elem.type === "checkbox") {
      new_value = !!new_value;
      if (elem.checked === new_value) return false;
      elem.checked = !!new_value;
    } else {
      if (elem.nodeName === "SELECT") {
        var json = JSON.stringify(new_value);
        var option = _toConsumableArray$2(elem.children).find(function (e) {
          return e.dataset.value == json;
        });
        if (option) new_value = option.value;else new_value = "";
      }
      if (new_value === null || new_value === undefined) {
        new_value = "";
      } else {
        new_value = String(new_value);
      }
      var old_value = elem.value;
      if (old_value === new_value) return false;
      var position = elem.selectionStart;
      elem.value = new_value;
      if (position !== undefined && elem.selectionEnd != null) elem.selectionEnd = position;
    }
    if (trigger_change) elem.dispatchEvent(new Event("change"));
    return true;
  }
  function get_index(element) {
    if (!element.parentNode) return -1;
    return Array.from(element.parentNode.children).indexOf(element);
  }
  /** @template T @param {{selector:string, auto_insert:boolean, remove:function(Element):void, add:function(T,Element,Number):Element }} opts @param {T[]} items */
  function rebuild(container, items, opts) {
    if (!opts) opts = {};
    opts = Object.assign({
      selector: ":scope>*",
      auto_insert: true,
      remove: function remove(elem) {
        return elem.remove();
      },
      add: function add(elem) {},
      id_callback: null
    }, opts);
    var orig_elems = Array.from(container.querySelectorAll(opts.selector));
    var leftovers = new Set(orig_elems);
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var id = opts.id_callback ? opts.id_callback.apply(item, [item]) : item.id;
      var elem = orig_elems.find(function (e) {
        return e.dataset.id == id;
      });
      elem = opts.add(item, elem, i) || elem;
      elem.dataset.id = id;
      if (opts.auto_insert) {
        insert_at(container, elem, i);
      }
      leftovers["delete"](elem);
    }
    var _iterator28 = _createForOfIteratorHelper$2(leftovers),
      _step28;
    try {
      for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
        var elem = _step28.value;
        if (opts.remove) opts.remove(elem);else elem.remove();
      }
    } catch (err) {
      _iterator28.e(err);
    } finally {
      _iterator28.f();
    }
  }
  function is_html(str) {
    _temp_div.innerHTML = str;
    for (var c = _temp_div.childNodes, i = c.length; i--;) {
      if (c[i].nodeType == 1) return true;
    }
    return false;
  }
  function restart_animation(elem) {
    var parent = elem.parentElement;
    var i = get_index(elem);
    if (parent) {
      elem.remove();
      insert_at(parent, elem, i);
    }
  }
  function build_table(datas, opts) {
    opts = Object.assign({
      header: true,
      empty: "No Data"
    }, opts);
    var thead = "";
    var header = opts.header;
    if (typeof header == "boolean") {
      if (datas.length) header = Object.fromEntries(Object.keys(datas[0]).map(function (k) {
        return [k, k];
      }));else header = {};
    }
    header = Object.fromEntries(Object.entries(header).map(function (_ref8) {
      var _ref9 = _slicedToArray$1(_ref8, 2),
        k = _ref9[0],
        h = _ref9[1];
      return [k, typeof h === "string" ? {
        name: h
      } : h];
    }));
    thead = "<thead><tr>".concat(Object.values(header).map(function (h) {
      return "<th style=\"".concat(h.style || "", "\">").concat(h.name, "</th>");
    }).join(""), "</tr></thead>");
    var tbody = "<tbody>".concat(datas.length ? datas.map(function (d) {
      return "<tr>".concat(Object.keys(header).map(function (k) {
        return "<td style=\"".concat(header[k].style || "", "\">").concat(d[k], "</td>");
      }).join(""), "</tr>");
    }).join("") : "<td colspan=\"".concat(Object.keys(header).length, "\" style=\"text-align:center\">").concat(opts.empty, "</td>"), "</tbody>");
    var html = "<table>".concat(thead).concat(tbody, "</table>");
    return $$2(html)[0];
  }
  function scroll_percent(e, v) {
    if (v === undefined) {
      var x = e.scrollLeft / (e.scrollWidth - e.clientWidth);
      var y = e.scrollTop / (e.scrollHeight - e.clientHeight);
      return [isNaN(x) ? 1 : x, isNaN(y) ? 1 : y];
    } else {
      e.scrollLeft = (e.scrollWidth - e.clientWidth) * v[0];
      e.scrollTop = (e.scrollHeight - e.clientHeight) * v[1];
    }
  }
  function scroll_pos_from_bottom(e, v) {
    if (v === undefined) {
      return e.scrollHeight - e.clientHeight - e.scrollTop;
    } else {
      e.scrollTop = e.scrollHeight - e.clientHeight - v;
    }
  }
  /* scroll_into_view(e) {
      var p = e.parentElement;
      if ((e.offsetTop + e.offsetHeight) < p.scrollTop) p.scrollTop = e.offsetTop;
      else if (e.offsetTop > (p.scrollTop + p.offsetHeight)) p.scrollTop = e.offsetTop + e.offsetHeight - p.offsetHeight;
  }, */
  /** @param {Element} el @param {{block_offset:number, inline_offset:number, block:ScrollLogicalPosition, inline:ScrollLogicalPosition, behavior:ScrollBehavior }} options */
  function scroll_to(container, el, options) {
    var block_offset = options.block_offset,
      inline_offset = options.inline_offset,
      block = options.block,
      inline = options.inline,
      behavior = options.behavior;
    var rect = el.getBoundingClientRect();
    if (!block && !inline) block = "start";
    if (block && rect.height == 0) return;
    if (inline && rect.width == 0) return;
    var scroll_opts = {
      block: block,
      inline: inline,
      behavior: behavior
    };
    if (block) {
      var offset = rect.top - (block_offset || 0);
      if (block == "nearest" && nearest$1(0, rect.top, rect.bottom) == rect.bottom) block = "end";
      if (block == 'center') {
        var space = window.innerHeight - offset;
        if (rect.height < space) offset -= (space - rect.height) / 2;
      } else if (block == "end") {
        offset -= rect.height;
      }
      scroll_opts.top = offset;
    }
    if (inline) {
      var _offset = rect.left - (inline_offset || 0);
      if (block == "nearest" && nearest$1(0, rect.left, rect.right) == rect.right) block = "end";
      if (block == 'center') {
        var _space = window.innerWidth - _offset;
        if (rect.width < _space) _offset -= (_space - rect.width) / 2;
      } else if (block == "end") {
        _offset -= rect.width;
      }
      scroll_opts.left = _offset;
    }
    container.scrollBy(scroll_opts);
  }
  function set_text(elem, text) {
    text = String(text);
    if (elem.textContent != text) elem.textContent = text;
  }
  var inner_html_prop = "__inner_html_" + random_string$1(8);
  function set_inner_html(elem, html) {
    if (Array.isArray(html)) {
      set_children(elem, html);
    } else if (html instanceof Element) {
      if (elem.children[0] !== html) elem.prepend(html);
      for (var i = 1; i < elem.children.length; i++) elem.children[i].remove();
    } else {
      if (elem[inner_html_prop] !== html) {
        elem[inner_html_prop] = elem.innerHTML = html;
      }
      // _temp_div.innerHTML = html; // ugh. Needed for entities like & and whatnot
      // if (elem.innerHTML !== _temp_div.innerHTML) {
      //     elem.innerHTML = html;
      // }
    }
  }
  function set_children(elem, new_children) {
    var children = _toConsumableArray$2(elem.children);
    if (children.length && children.every(function (e, i) {
      return e === new_children[i];
    })) return;
    elem.replaceChildren.apply(elem, _toConsumableArray$2(new_children));
  }
  function encode_html_entities(str) {
    return String(str).replace(/[\u00A0-\u9999<>\&]/gim, function (i) {
      return "&#".concat(i.charCodeAt(0), ";");
    });
  }
  function decode_html_entities(str) {
    return String(str).replace(/&#\d+;/gm, function (s) {
      return String.fromCharCode(s.match(/\d+/)[0]);
    });
  }
  function toggle_class(elem, clazz, value) {
    if (elem.classList.contains(clazz) != value) {
      elem.classList.toggle(clazz, value);
    }
  }
  function set_attribute(elem, attr, value) {
    if (elem.getAttribute(attr) != value) {
      elem.setAttribute(attr, value);
    }
  }
  function toggle_attribute(elem, attr, value) {
    if (elem.hasAttribute(attr) != value) {
      elem.toggleAttribute(attr, value);
    }
  }
  function set_style_property(elem, prop, value) {
    if (elem.style.getPropertyValue(prop) != value) {
      elem.style.setProperty(prop, value);
    }
  }
  function escape_html_entities(text) {
    return text.replace(/[\u00A0-\u2666<>\&]/g, function (c) {
      return '&' + (entity_table[c.charCodeAt(0)] || '#' + c.charCodeAt(0)) + ';';
    });
  }
  function on_click_and_hold(elem, callback) {
    var delay = 0;
    var next_time = 0;
    var is_down = false;
    elem.addEventListener("mousedown", function (e) {
      next_time = 0;
      delay = 250;
      handleMouseDown(e);
    });
    document.addEventListener("mouseup", function (e) {
      handleMouseUp(e);
    });
    function handleMouseDown(e) {
      e.preventDefault();
      e.stopPropagation();
      is_down = true;
      requestAnimationFrame(watcher);
    }
    function handleMouseUp(e) {
      e.preventDefault();
      e.stopPropagation();
      is_down = false;
    }
    function watcher(time) {
      if (!is_down) return;
      if (time > next_time) {
        next_time = time + delay;
        delay = Math.max(50, delay - 50);
        callback.apply(elem);
      }
      requestAnimationFrame(watcher);
    }
  }
  function cycle_select(elem) {
    var trigger_change = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var value = elem.value;
    var options = Array.from(elem.options);
    var i = 0;
    for (; i < options.length; i++) {
      if (options[i].value == value) {
        i++;
        break;
      }
    }
    elem.value = options[i % options.length].value;
    if (trigger_change) elem.dispatchEvent(new Event("change"));
  }
  /** @return {Window} */
  function get_owner_window(node) {
    var doc = node.ownerDocument;
    return doc.defaultView ? doc.defaultView : doc.parentWindow;
  }

  // for textareas only
  function autosize(elem) {
    var min_rows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    // var nearest_scrollable = closest(elem, (e)=>is_scrollbar_visible(e));
    // var scroll = [];
    // if (nearest_scrollable) {
    //     scroll = [nearest_scrollable.scrollLeft, nearest_scrollable.scrollTop];
    // }
    elem.setAttribute("rows", min_rows);
    elem.style.resize = "none";
    var style = getComputedStyle(elem, null);
    var heightOffset;
    if (style.boxSizing === 'content-box') {
      heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
    } else {
      heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    }
    // Fix when a textarea is not on document body and heightOffset is Not a Number
    if (isNaN(heightOffset)) {
      heightOffset = 0;
    }
    elem.style.overflow = "hidden";
    elem.style.height = "auto";
    var h = Math.max(18 * min_rows, elem.scrollHeight) + heightOffset;
    if (h) elem.style.height = "".concat(h, "px");

    // if (nearest_scrollable) {
    //     nearest_scrollable.scrollTo(...scroll);
    // }
  }
  function has_focus(el) {
    var ancestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var active = el.getRootNode().activeElement;
    if (!ancestors) return active === el;
    return closest(el, function (e) {
      return e === active;
    });
  }
  function has_touch_screen() {
    if ("maxTouchPoints" in window.navigator) {
      return window.navigator.maxTouchPoints > 0;
    } else if ("msMaxTouchPoints" in window.navigator) {
      return window.navigator.msMaxTouchPoints > 0;
    } else {
      var mQ = window.matchMedia && window.matchMedia("(pointer:coarse)");
      if (mQ && mQ.media === "(pointer:coarse)") {
        return !!mQ.matches;
      } else if ('orientation' in window) {
        return true; // deprecated, but good fallback
      } else {
        // Only as a last resort, fall back to user agent sniffing
        var UA = window.navigator.userAgent;
        return /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) || /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA);
      }
    }
  }
  function get_top_position(el) {
    var _el$getBoundingClient = el.getBoundingClientRect(),
      top = _el$getBoundingClient.top;
    var _window$getComputedSt = window.getComputedStyle(el),
      marginTop = _window$getComputedSt.marginTop;
    return top - parseInt(marginTop, 10);
  }
  function detect_wrapped_elements(parent, opts) {
    opts = Object.assign({
      isChildrenWrappedClassName: "is-wrapped",
      isSiblingWrappedClassName: "sibling-is-wrapped",
      isSelfWrappedClassName: "self-is-wrapped",
      nextIsWrappedClassName: "next-is-wrapped"
    }, opts);
    var any_wrapping = false;
    for (var i = 0; i < parent.children.length; i++) {
      var child = parent.children[i];
      var prev = parent.children[i - 1];
      var top = get_top_position(child);
      var prevTop = prev ? get_top_position(prev) : top;
      var is_wrapped = top > prevTop;
      child.classList.toggle(opts.isSelfWrappedClassName, is_wrapped);
      if (prev) prev.classList.toggle(opts.nextIsWrappedClassName, is_wrapped);
      if (is_wrapped) any_wrapping = true;
    }
    parent.classList.toggle(opts.isChildrenWrappedClassName, any_wrapping);
    _toConsumableArray$2(parent.children).forEach(function (e) {
      e.classList.toggle(opts.isSiblingWrappedClassName, !e.classList.contains(opts.isSelfWrappedClassName) && any_wrapping);
    });
  }
  function on_stylesheet_load(_x2) {
    return _on_stylesheet_load.apply(this, arguments);
  }
  function _on_stylesheet_load() {
    _on_stylesheet_load = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1().mark(function _callee5(elem) {
      var href, check_interval, resolve, i, check;
      return _regeneratorRuntime$1().wrap(function _callee5$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            check = function _check2() {
              if (elem.sheet || ++i >= 100) return resolve(elem.sheet);
              var _iterator33 = _createForOfIteratorHelper$2(elem.ownerDocument.styleSheets),
                _step33;
              try {
                for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
                  var ss = _step33.value;
                  if (ss.href === href) return resolve(ss);
                }
              } catch (err) {
                _iterator33.e(err);
              } finally {
                _iterator33.f();
              }
            };
            href = elem.href;
            if (href.startsWith("//")) href = location.protocol + href;else if (href.startsWith("/")) href = location.origin + href;
            if (!(elem.nodeName === "LINK" && elem.sheet)) {
              _context12.next = 5;
              break;
            }
            return _context12.abrupt("return", true);
          case 5:
            i = 0;
            return _context12.abrupt("return", new Promise(function (_resolve) {
              resolve = function resolve() {
                return _resolve(elem.sheet);
              };
              elem.addEventListener("load", resolve);
              check_interval = setInterval(check, 100);
              // setTimeout(check, 1);
            }).then(function (ss) {
              clearInterval(check_interval);
              elem.removeEventListener("load", resolve);
              return ss;
            }));
          case 7:
          case "end":
            return _context12.stop();
        }
      }, _callee5);
    }));
    return _on_stylesheet_load.apply(this, arguments);
  }
  function closest(elem, delegate) {
    var p = elem;
    while (p) {
      var r = delegate.apply(p, [p]);
      if (r) return p;
      p = p.parentElement;
    }
  }
  function is_scrollbar_visible(elem) {
    var doc = elem.ownerDocument;
    var win = doc.defaultView || doc.parentWindow;
    var scroll_lookup = {
      auto: true,
      scroll: true,
      visible: false,
      hidden: false
    };
    var styles = win.getComputedStyle(elem, null);
    var overflow_x = scroll_lookup[styles.overflowX.toLowerCase()] || false;
    var overflow_y = scroll_lookup[styles.overflowY.toLowerCase()] || false;
    return overflow_x || overflow_y;
  }
  function debounce_next_frame(func) {
    var timeout, args, context;
    var later = function later() {
      timeout = null;
      func.apply(context, args);
    };
    var debounced = function debounced() {
      context = this;
      for (var _len4 = arguments.length, p = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        p[_key4] = arguments[_key4];
      }
      args = p;
      if (!timeout) {
        timeout = requestAnimationFrame(later);
      }
    };
    debounced.cancel = function () {
      cancelAnimationFrame(timeout);
      timeout = args = context = null;
    };
    return debounced;
  }
  function uuid4() {
    return "".concat(1e7, "-", 1e3, "-", 4e3, "-", 8e3, "-", 1e11).replace(/[018]/g, function (c) {
      return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16);
    });
  }
  function uuidb64() {
    return btoa(uuid4());
  }
  // ignores text elements and whitespace
  /** @param {Element} dst @param {Element} src */
  function sync_attributes(dst, src) {
    var _iterator29 = _createForOfIteratorHelper$2(src.attributes),
      _step29;
    try {
      for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
        var attr = _step29.value;
        if (src.getAttribute(attr.name) !== dst.getAttribute(attr.name)) dst.setAttribute(attr.name, attr.value);
      }
    } catch (err) {
      _iterator29.e(err);
    } finally {
      _iterator29.f();
    }
    var _iterator30 = _createForOfIteratorHelper$2(dst.attributes),
      _step30;
    try {
      for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
        var attr = _step30.value;
        if (!src.hasAttribute(attr.name)) dst.removeAttribute(attr.name);
      }
    } catch (err) {
      _iterator30.e(err);
    } finally {
      _iterator30.f();
    }
  }
  // ignores text elements and whitespace
  /** @param {Element} dst @param {Element} src */
  function sync_dom(dst, src, opts) {
    opts = Object.assign({
      attrs: true
    }, opts);
    if (!(src && dst && src.nodeName === dst.nodeName)) throw new Error("src and dst must match nodeName to sync");
    if (opts.attrs) {
      sync_attributes(dst, src);
    }
    if (src.children.length == 0 && dst.children.length == 0) {
      set_inner_html(dst, src.innerHTML);
      return;
    }
    var get_id = function get_id(el) {
      return opts.get_id ? opts.get_id(el) : el.getAttribute("data-id") || el.id;
    };
    var dst_children = _toConsumableArray$2(dst.children);
    var i;
    for (i = 0; i < src.children.length; i++) {
      var src_c = src.children[i];
      var src_id = get_id(src_c);
      if (src_id) {
        var dst_c_index = dst_children.findIndex(function (c) {
          return get_id(c) === src_id;
        });
        if (dst_c_index != -1 && dst_c_index != i) {
          dst_children.splice(i, 0, dst_children.splice(dst_c_index, 1));
        }
      }
      var dst_c = dst_children[i];
      var same = src_c && dst_c && src_c.nodeName === dst_c.nodeName;
      if (!same) {
        if (dst_c) {
          dst_c.remove();
          dst_c = null;
        }
        if (src_c) dst_c = src_c.cloneNode(true);
      }
      if (dst_c) {
        if (!dst.children[i]) dst.append(dst_c);else if (dst.children[i] !== dst_c) dst.children[i].before(dst_c);
      }
      if (same) {
        sync_dom(dst_c, src_c);
      }
    }
    var leftovers = _toConsumableArray$2(dst.children).slice(i);
    var _iterator31 = _createForOfIteratorHelper$2(leftovers),
      _step31;
    try {
      for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
        var dst_c = _step31.value;
        dst_c.remove();
      }
    } catch (err) {
      _iterator31.e(err);
    } finally {
      _iterator31.f();
    }
  }
  /* sync_contents(dst, src_children_or_inner_html) {
      if (typeof src_children_or_inner_html === "string") {
          set_inner_html(dst, src_children_or_inner_html);
          return;
      }
      var src_children = src_children_or_inner_html;
      if (!Array.isArray(src_children)) src_children = [src_children];
      for (var i=0; i<src_children.length; i++) {
          var dst_c = dst.children[i];
          var src_c = src_children[i];
          if (dst_c && src_c && dst_c.nodeName === src_c.nodeName) {
              sync_dom(dst_c, src_c);
          } else {
              if (dst_c) {
                  dst_c.before(src_c);
                  dst_c.remove();
              } else {
                  dst.append(src_c);
              }
          }
      }
      var leftovers = [...dst.children].slice(i);
      for (var e of leftovers) {
          e.remove();
      }
  } */

  /** @param {Element} el */
  function get_anchor_same_origin_hash(el) {
    var url = get_anchor_url(el);
    if (url && url.origin + url.pathname === window.location.origin + window.location.pathname && url.hash) return url.hash;
  }

  /** @param {Element} el */
  function get_anchor_url(el) {
    if (!el.matches("a")) return;
    /** @type {HTMLAnchorElement} */
    var anchor = el;
    return _try$1(function () {
      return new URL(anchor.href);
    });
  }

  /** @param {Element} el */
  function reset_style(el) {
    var props = [];
    for (var i = 0; i < el.style.length; i++) props[i] = el.style[i];
    for (var _i = 0, _props = props; _i < _props.length; _i++) {
      var k = _props[_i];
      el.style[k] = "";
    }
  }
  var _on_message = /*#__PURE__*/new WeakMap();
  var WindowCommunicator = /*#__PURE__*/function () {
    /** @param {Window} _window */
    function WindowCommunicator(_window) {
      var _this27 = this;
      _classCallCheck$2(this, WindowCommunicator);
      _defineProperty$2(this, "id", 0);
      _defineProperty$2(this, "requests", {});
      _defineProperty$2(this, "handlers", {});
      _classPrivateFieldInitSpec$1(this, _on_message, void 0);
      this.window = _window = _window || window;
      _window.addEventListener("message", _classPrivateFieldSet$1(_on_message, this, /*#__PURE__*/function () {
        var _ref10 = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1().mark(function _callee4(e) {
          var _e$data, request, data, id, response, payload, _e$data2;
          return _regeneratorRuntime$1().wrap(function _callee4$(_context10) {
            while (1) switch (_context10.prev = _context10.next) {
              case 0:
                if (!(e.data.event === "request")) {
                  _context10.next = 8;
                  break;
                }
                _e$data = e.data, request = _e$data.request, data = _e$data.data, id = _e$data.id;
                if (!_this27.handlers[request]) {
                  _context10.next = 6;
                  break;
                }
                _context10.next = 5;
                return Promise.resolve(_this27.handlers[request](data, e.source)).then(function (r) {
                  return response = r;
                });
              case 5:
                if (response !== undefined) {
                  payload = {
                    event: "response",
                    response: response,
                    id: id
                  };
                  e.source.postMessage(payload, "*");
                }
              case 6:
                _context10.next = 9;
                break;
              case 8:
                if (e.data.event === "response") {
                  // console.log(e.data)
                  _e$data2 = e.data, id = _e$data2.id, response = _e$data2.response;
                  if (id in _this27.requests) {
                    _this27.requests[id](response);
                    delete _this27.requests[id];
                  }
                }
              case 9:
              case "end":
                return _context10.stop();
            }
          }, _callee4);
        }));
        return function (_x3) {
          return _ref10.apply(this, arguments);
        };
      }()));
    }
    /** @param {string} request @param {function(any,Window):any} handler */
    return _createClass$2(WindowCommunicator, [{
      key: "on",
      value: function on(request, handler) {
        this.handlers[request] = handler;
      }
      /** @param {Window} window */
    }, {
      key: "request",
      value: function request(window, _request, data) {
        var _this28 = this;
        var timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10000;
        var id = ++this.id;
        var payload = {
          event: "request",
          request: _request,
          data: data,
          id: id
        };
        return new Promise(function (resolve, reject) {
          _this28.requests[id] = function (response) {
            resolve(response);
          };
          window.postMessage(payload, "*");
          setTimeout(function () {
            return reject("WindowCommunicator request ".concat(id, " timed out"));
          }, timeout);
        })["catch"](function (e) {
          return console.error(e);
        });
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.window.removeEventListener("message", _classPrivateFieldGet$1(_on_message, this));
      }
    }]);
  }();
  var ScrollOverlay = /*#__PURE__*/_createClass$2(function ScrollOverlay(el, opts) {
    _classCallCheck$2(this, ScrollOverlay);
    /** @type {import("overlayscrollbars").Options} */
    var os_opts = {};
    if (opts.hide) {
      os_opts.scrollbars = {};
      os_opts.scrollbars.autoHide = "move";
    }
    if (opts.x || opts.y) {
      os_opts.overflow = {};
      os_opts.overflow.x = opts.x ? "scroll" : "hidden";
      os_opts.overflow.y = opts.y ? "scroll" : "hidden";
    }
    this.overlayScrollbars = OverlayScrollbars(el, os_opts);
    this.viewport = this.overlayScrollbars.elements().viewport;
    if (opts.flex) this.viewport.style.display = "flex";
  });

  /** @param {HTMLIFrameElement} el */
  function iframe_ready(el) {
    return new Promise(function (resolve) {
      var _check = function check() {
        var doc = el.contentDocument || el.contentWindow.document;
        if (doc.readyState == 'complete') resolve();else setTimeout(_check, 100);
      };
      _check();
    });
  }

  /** @template T @param {Node} el @param {string} selector @param {new()=>T} type @returns {Iterable<T>} */
  function find(el, selector, type) {
    var _iterator32, _step32, c;
    return _regeneratorRuntime$1().wrap(function find$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          if (el instanceof HTMLElement) {
            _context11.next = 2;
            break;
          }
          return _context11.abrupt("return");
        case 2:
          if (!el.matches(selector)) {
            _context11.next = 7;
            break;
          }
          _context11.next = 5;
          return el;
        case 5:
          _context11.next = 24;
          break;
        case 7:
          _iterator32 = _createForOfIteratorHelper$2(el.querySelectorAll(selector));
          _context11.prev = 8;
          _iterator32.s();
        case 10:
          if ((_step32 = _iterator32.n()).done) {
            _context11.next = 16;
            break;
          }
          c = _step32.value;
          _context11.next = 14;
          return c;
        case 14:
          _context11.next = 10;
          break;
        case 16:
          _context11.next = 21;
          break;
        case 18:
          _context11.prev = 18;
          _context11.t0 = _context11["catch"](8);
          _iterator32.e(_context11.t0);
        case 21:
          _context11.prev = 21;
          _iterator32.f();
          return _context11.finish(21);
        case 24:
        case "end":
          return _context11.stop();
      }
    }, _marked$1, null, [[8, 18, 21, 24]]);
  }

  var dom = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AutoSizeController: AutoSizeController,
    ClickScrollPlugin: Dt,
    Cookie: api,
    LocalStorageBucket: LocalStorageBucket,
    OverlayScrollbars: OverlayScrollbars,
    ScrollOverlay: ScrollOverlay,
    ScrollbarsHidingPlugin: It,
    SizeObserverPlugin: Et,
    TouchListener: TouchListener,
    UI: UI,
    WebSocket: WebSocket2,
    WindowCommunicator: WindowCommunicator,
    autosize: autosize,
    build_table: build_table,
    clone_document_head: clone_document_head,
    closest: closest,
    cycle_select: cycle_select,
    debounce_next_frame: debounce_next_frame,
    decode_html_entities: decode_html_entities,
    detect_wrapped_elements: detect_wrapped_elements,
    download: download,
    empty: _empty,
    encode_html_entities: encode_html_entities,
    escape_html_entities: escape_html_entities,
    fetch: fetch,
    find: find,
    fix_options: fix_options,
    get_anchor_same_origin_hash: get_anchor_same_origin_hash,
    get_anchor_url: get_anchor_url,
    get_index: get_index,
    get_owner_window: get_owner_window,
    get_top_position: get_top_position,
    get_value: get_value,
    has_focus: has_focus,
    has_touch_screen: has_touch_screen,
    iframe_ready: iframe_ready,
    insert_after: insert_after,
    insert_at: insert_at,
    is_html: is_html,
    is_scrollbar_visible: is_scrollbar_visible,
    is_visible: is_visible,
    move: move,
    on_click_and_hold: on_click_and_hold,
    on_stylesheet_load: on_stylesheet_load,
    open_file_dialog: open_file_dialog,
    parse_style: parse_style,
    read_file: read_file,
    rebuild: rebuild,
    render_html: render_html,
    reset_style: reset_style,
    restart_animation: restart_animation,
    scroll_percent: scroll_percent,
    scroll_pos_from_bottom: scroll_pos_from_bottom,
    scroll_to: scroll_to,
    select_text: select_text,
    set_attribute: set_attribute,
    set_children: set_children,
    set_inner_html: set_inner_html,
    set_select_options: set_select_options,
    set_style_property: set_style_property,
    set_text: set_text,
    set_value: set_value,
    sync_attributes: sync_attributes,
    sync_dom: sync_dom,
    tippy: tippy,
    toggle_attribute: toggle_attribute,
    toggle_class: toggle_class,
    upload: upload,
    uuid4: uuid4,
    uuidb64: uuidb64
  });

  var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var lib$1 = {exports: {}};

  (function (module, exports) {
  	!function(r,n){module.exports=n();}("undefined"!=typeof self?self:commonjsGlobal$1,(function(){return function(r){var n={};function e(t){if(n[t])return n[t].exports;var o=n[t]={i:t,l:!1,exports:{}};return r[t].call(o.exports,o,o.exports,e),o.l=!0,o.exports}return e.m=r,e.c=n,e.d=function(r,n,t){e.o(r,n)||Object.defineProperty(r,n,{enumerable:!0,get:t});},e.r=function(r){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0});},e.t=function(r,n){if(1&n&&(r=e(r)),8&n)return r;if(4&n&&"object"==typeof r&&r&&r.__esModule)return r;var t=Object.create(null);if(e.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:r}),2&n&&"string"!=typeof r)for(var o in r)e.d(t,o,function(n){return r[n]}.bind(null,o));return t},e.n=function(r){var n=r&&r.__esModule?function(){return r.default}:function(){return r};return e.d(n,"a",n),n},e.o=function(r,n){return Object.prototype.hasOwnProperty.call(r,n)},e.p="",e(e.s=0)}([function(r,n,e){e.r(n),e.d(n,"md5",(function(){return p}));var t="0123456789abcdef".split("");var o=function(r){for(var n="",e=0;e<4;e++)n+=t[r>>8*e+4&15]+t[r>>8*e&15];return n};var u=function(r){for(var n=r.length,e=0;e<n;e++)r[e]=o(r[e]);return r.join("")};var f=function(r,n){return r+n&4294967295};var i=function(r,n,e,t,o,u,i){return function(r,n,e){return f(r<<n|r>>>32-n,e)}(n=function(r,n,e,t){return n=f(f(n,r),f(e,t))}(r,n,t,u),o,e)};var a=function(r,n,e,t,o,u,f,a){return i(e&t|~e&o,n,e,u,f,a)};var c=function(r,n,e,t,o,u,f,a){return i(e&o|t&~o,n,e,u,f,a)};var l=function(r,n,e,t,o,u,f,a){return i(e^t^o,n,e,u,f,a)};var d=function(r,n,e,t,o,u,f,a){return i(t^(e|~o),n,e,u,f,a)};var v=function(r,n,e){void 0===e&&(e=f);var t=r[0],o=r[1],u=r[2],i=r[3],v=a.bind(null,e);t=v(t,o,u,i,n[0],7,-680876936),i=v(i,t,o,u,n[1],12,-389564586),u=v(u,i,t,o,n[2],17,606105819),o=v(o,u,i,t,n[3],22,-1044525330),t=v(t,o,u,i,n[4],7,-176418897),i=v(i,t,o,u,n[5],12,1200080426),u=v(u,i,t,o,n[6],17,-1473231341),o=v(o,u,i,t,n[7],22,-45705983),t=v(t,o,u,i,n[8],7,1770035416),i=v(i,t,o,u,n[9],12,-1958414417),u=v(u,i,t,o,n[10],17,-42063),o=v(o,u,i,t,n[11],22,-1990404162),t=v(t,o,u,i,n[12],7,1804603682),i=v(i,t,o,u,n[13],12,-40341101),u=v(u,i,t,o,n[14],17,-1502002290),o=v(o,u,i,t,n[15],22,1236535329);var s=c.bind(null,e);t=s(t,o,u,i,n[1],5,-165796510),i=s(i,t,o,u,n[6],9,-1069501632),u=s(u,i,t,o,n[11],14,643717713),o=s(o,u,i,t,n[0],20,-373897302),t=s(t,o,u,i,n[5],5,-701558691),i=s(i,t,o,u,n[10],9,38016083),u=s(u,i,t,o,n[15],14,-660478335),o=s(o,u,i,t,n[4],20,-405537848),t=s(t,o,u,i,n[9],5,568446438),i=s(i,t,o,u,n[14],9,-1019803690),u=s(u,i,t,o,n[3],14,-187363961),o=s(o,u,i,t,n[8],20,1163531501),t=s(t,o,u,i,n[13],5,-1444681467),i=s(i,t,o,u,n[2],9,-51403784),u=s(u,i,t,o,n[7],14,1735328473),o=s(o,u,i,t,n[12],20,-1926607734);var b=l.bind(null,e);t=b(t,o,u,i,n[5],4,-378558),i=b(i,t,o,u,n[8],11,-2022574463),u=b(u,i,t,o,n[11],16,1839030562),o=b(o,u,i,t,n[14],23,-35309556),t=b(t,o,u,i,n[1],4,-1530992060),i=b(i,t,o,u,n[4],11,1272893353),u=b(u,i,t,o,n[7],16,-155497632),o=b(o,u,i,t,n[10],23,-1094730640),t=b(t,o,u,i,n[13],4,681279174),i=b(i,t,o,u,n[0],11,-358537222),u=b(u,i,t,o,n[3],16,-722521979),o=b(o,u,i,t,n[6],23,76029189),t=b(t,o,u,i,n[9],4,-640364487),i=b(i,t,o,u,n[12],11,-421815835),u=b(u,i,t,o,n[15],16,530742520),o=b(o,u,i,t,n[2],23,-995338651);var p=d.bind(null,e);t=p(t,o,u,i,n[0],6,-198630844),i=p(i,t,o,u,n[7],10,1126891415),u=p(u,i,t,o,n[14],15,-1416354905),o=p(o,u,i,t,n[5],21,-57434055),t=p(t,o,u,i,n[12],6,1700485571),i=p(i,t,o,u,n[3],10,-1894986606),u=p(u,i,t,o,n[10],15,-1051523),o=p(o,u,i,t,n[1],21,-2054922799),t=p(t,o,u,i,n[8],6,1873313359),i=p(i,t,o,u,n[15],10,-30611744),u=p(u,i,t,o,n[6],15,-1560198380),o=p(o,u,i,t,n[13],21,1309151649),t=p(t,o,u,i,n[4],6,-145523070),i=p(i,t,o,u,n[11],10,-1120210379),u=p(u,i,t,o,n[2],15,718787259),o=p(o,u,i,t,n[9],21,-343485551),r[0]=e(t,r[0]),r[1]=e(o,r[1]),r[2]=e(u,r[2]),r[3]=e(i,r[3]);};var s=function(r){for(var n=[],e=0;e<64;e+=4)n[e>>2]=r.charCodeAt(e)+(r.charCodeAt(e+1)<<8)+(r.charCodeAt(e+2)<<16)+(r.charCodeAt(e+3)<<24);return n};var b=function(r,n){var e,t=r.length,o=[1732584193,-271733879,-1732584194,271733878];for(e=64;e<=t;e+=64)v(o,s(r.substring(e-64,e)),n);var u=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],f=(r=r.substring(e-64)).length;for(e=0;e<f;e++)u[e>>2]|=r.charCodeAt(e)<<(e%4<<3);if(u[e>>2]|=128<<(e%4<<3),e>55)for(v(o,u,n),e=16;e--;)u[e]=0;return u[14]=8*t,v(o,u,n),o};function p(r){var n;return "5d41402abc4b2a76b9719d911017c592"!==u(b("hello"))&&(n=function(r,n){var e=(65535&r)+(65535&n);return (r>>16)+(n>>16)+(e>>16)<<16|65535&e}),u(b(r,n))}}])}));
  	
  } (lib$1));

  var libExports$1 = lib$1.exports;

  var _marked = /*#__PURE__*/_regeneratorRuntime().mark(iterate_unique);
  function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
  function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
  function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
  function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
  function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
  function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
  function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
  function _regeneratorRuntime() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
  function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$1(r)) || e) { t && (r = t); var _n2 = 0, F = function F() {}; return { s: F, n: function n() { return _n2 >= r.length ? { done: !0 } : { done: !1, value: r[_n2++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
  function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray$1(r) || _nonIterableSpread(); }
  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
  function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray$1(r); }
  function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  function _defineProperty$1(e, r, t) { return (r = _toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
  function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$1(r, e) || _nonIterableRest(); }
  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _unsupportedIterableToArray$1(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$1(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0; } }
  function _arrayLikeToArray$1(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
  function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
  function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey$1(o.key), o); } }
  function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
  function _toPropertyKey$1(t) { var i = _toPrimitive$1(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  function _toPrimitive$1(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
  function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
  function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
  function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
  function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
  function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
  function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
  function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
  function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
  function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
  var FLT_EPSILON = 1.19209290e-7;
  var path_separator_regex = /[\\\/]+/g;
  var emoji_regex = /(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26FF]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])/g;
  var DIVIDERS = {
    d: 24 * 60 * 60 * 1000,
    h: 60 * 60 * 1000,
    m: 60 * 1000,
    s: 1000
  };
  var RefException = /*#__PURE__*/function (_Error) {
    function RefException(str) {
      _classCallCheck(this, RefException);
      return _callSuper(this, RefException, ["Invalid reference : ".concat(str)]);
    }
    _inherits(RefException, _Error);
    return _createClass(RefException);
  }(/*#__PURE__*/_wrapNativeSuper(Error));
  var PromisePool = /*#__PURE__*/function () {
    function PromisePool() {
      var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;
      _classCallCheck(this, PromisePool);
      this.executing = new Set();
      this.queue = [];
      this.limit = limit;
    }
    return _createClass(PromisePool, [{
      key: "full",
      get: function get() {
        return this.executing.size >= this.limit;
      }
    }, {
      key: "_next",
      value: function _next() {
        var _this2 = this;
        if (this.queue.length == 0 || this.executing.size >= this.limit) return;
        var _this$queue$shift = this.queue.shift(),
          _this$queue$shift2 = _slicedToArray(_this$queue$shift, 2),
          cb = _this$queue$shift2[0],
          resolve = _this$queue$shift2[1];
        var p = Promise.resolve(cb());
        this.executing.add(p);
        p.then(resolve);
        p["finally"](function () {
          _this2.executing["delete"](p);
          _this2._next();
        });
      }
    }, {
      key: "enqueue",
      value: function enqueue(cb) {
        var _this3 = this;
        return new Promise(function (resolve) {
          _this3.queue.push([cb, resolve]);
          _this3._next();
        });
      }
    }]);
  }();
  var EventEmitter$1 = /*#__PURE__*/function () {
    function EventEmitter() {
      _classCallCheck(this, EventEmitter);
      _defineProperty$1(this, "_events", {});
      this.addEventListener = this.on;
      this.addListener = this.on;
      this.removeEventListener = this.off;
      this.removeListener = this.off;
    }
    return _createClass(EventEmitter, [{
      key: "on",
      value: function on(event, listener) {
        if (_typeof(this._events[event]) !== 'object') this._events[event] = [];
        this._events[event].push(listener);
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        clear(this._events);
      }
    }, {
      key: "off",
      value: function off(event, listener) {
        if (!event) {
          this.removeAllListeners();
          return;
        }
        if (_typeof(this._events[event]) !== 'object') return;
        if (listener) array_remove(this._events[event], listener);else clear(this._events[event]);
      }
    }, {
      key: "emit",
      value: function emit(event) {
        if (_typeof(this._events[event]) !== 'object') return;
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        for (var _i = 0, _arr = _toConsumableArray(this._events[event]); _i < _arr.length; _i++) {
          var l = _arr[_i];
          l.apply(this, args);
        }
      }
    }, {
      key: "once",
      value: function once(event, listener) {
        var _this4 = this;
        var _listener_wrapped = function listener_wrapped() {
          _this4.removeListener(event, _listener_wrapped);
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          listener.apply(_this4, args);
        };
        this.on(event, _listener_wrapped);
      }
    }]);
  }();
  var Timer = /*#__PURE__*/function (_EventEmitter2) {
    function Timer() {
      var _this5;
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var autostart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      _classCallCheck(this, Timer);
      _this5 = _callSuper(this, Timer);
      _this5._total_time = time;
      _this5._interval_id;
      _this5._last_seconds_left;
      _this5._stopwatch = new StopWatch();
      _this5._stopwatch.on("pause", function () {
        clearInterval(_this5._interval_id);
        _this5.emit("pause");
      });
      _this5._stopwatch.on("start", function () {
        _this5._interval_id = setInterval(function () {
          return _this5.tick();
        }, Timer.TICK_INTERVAL);
        _this5.emit("start");
      });
      _this5._stopwatch.on("reset", function () {
        _this5._last_seconds_left = _this5.seconds_left;
        _this5.emit("reset");
        _this5.emit("second", _this5._last_seconds_left);
      });
      if (autostart) _this5.restart();
      return _this5;
    }
    _inherits(Timer, _EventEmitter2);
    return _createClass(Timer, [{
      key: "time_left",
      get: function get() {
        return Math.max(0, this._total_time - this._stopwatch.time);
      }
    }, {
      key: "seconds_left",
      get: function get() {
        return Math.ceil(this.time_left / 1000);
      }
    }, {
      key: "finished",
      get: function get() {
        return this.time_left <= 0;
      }
    }, {
      key: "paused",
      get: function get() {
        return this._stopwatch.paused;
      }
    }, {
      key: "restart",
      value: function restart(time) {
        if (time !== undefined) this._total_time = time;
        this._stopwatch.reset();
        this.resume();
      }
    }, {
      key: "tick",
      value: function tick() {
        var seconds_left = this.seconds_left;
        for (var i = this._last_seconds_left - 1; i >= seconds_left; i--) {
          this.emit("second", i);
        }
        this._last_seconds_left = seconds_left;
        this.emit("tick");
        if (this.finished) {
          this.pause();
          this.emit("finish");
        }
      }
    }, {
      key: "pause",
      value: function pause() {
        this._stopwatch.pause();
      }
    }, {
      key: "resume",
      value: function resume() {
        this._stopwatch.resume();
      }
    }, {
      key: "reset",
      value: function reset() {
        this._stopwatch.reset();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this._stopwatch.destroy();
        this.removeAllListeners();
      }
    }]);
  }(EventEmitter$1);
  Timer.TICK_INTERVAL = 1000 / 60;
  var StopWatch = /*#__PURE__*/function (_EventEmitter3) {
    function StopWatch() {
      var _this6;
      _classCallCheck(this, StopWatch);
      _this6 = _callSuper(this, StopWatch);
      _this6._start_time = 0;
      _this6._pause_time = 0;
      _this6._paused = true;
      return _this6;
    }
    _inherits(StopWatch, _EventEmitter3);
    return _createClass(StopWatch, [{
      key: "time",
      get: function get() {
        return (this._paused ? this._pause_time : Date.now()) - this._start_time;
      }
    }, {
      key: "paused",
      get: function get() {
        return this._paused;
      }
    }, {
      key: "start",
      value: function start() {
        var now = Date.now();
        if (!this._start_time) this._start_time = now;
        if (this._paused) {
          this._paused = false;
          this._start_time += now - this._pause_time;
          this._pause_time = 0;
          this.emit("start");
        }
      }
    }, {
      key: "resume",
      value: function resume() {
        this.start();
      }
    }, {
      key: "pause",
      value: function pause() {
        if (this._paused) return;
        this._paused = true;
        this._pause_time = Date.now();
        this.emit("pause");
      }
    }, {
      key: "reset",
      value: function reset() {
        this._start_time = Date.now();
        if (this._paused) this._pause_time = this._start_time;
        this.emit("reset");
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.removeAllListeners();
      }
    }]);
  }(EventEmitter$1);
  var Diff = /*#__PURE__*/_createClass(function Diff(old_value, new_value) {
    _classCallCheck(this, Diff);
    if (old_value === new_value) this.type = 0;
    if (old_value === undefined) this.type = Diff.CREATED;else if (new_value === undefined) this.type = Diff.DELETED;else this.type = Diff.CHANGED;
    this.old_value = old_value;
    this.new_value = new_value;
    Object.freeze(this);
  });
  Diff.CREATED = 1;
  Diff.DELETED = 2;
  Diff.CHANGED = 3;

  /* class History {
  	get current() { return this.get(this.i); }
  	get prev() { return this.get(this.i-1); }
  	get next() { return this.get(this.i+1); }
  	get can_go_back() { return this.has(this.i-1); }
  	get can_go_forward() { return this.has(this.i+1); }
  	constructor(length=512, json_encode=false, compress=false) {
  		this.length = length;
  		this.reset();
  		if (compress && !!window.LZUTF8) this.compress = true;
  		this.json_encode = json_encode;
  	}
  	push(state) {
  		this.i++;
  		var s = typeof state === "string";
  		if (this.json_encode) state = JSON.stringify(state);
  		if (this.compress) state = LZUTF8.compress(state);
  		this.states[this.i%this.length] = {states:state,i:this.i};
  		for (var i = this.i; i < this.i + this.length; i++) {
  			var o = this.states[i%this.length];
  			if (!o || o.i <= this.i) break;
  			this.states[i%this.length] = null;
  		}
  	}
  	has(i) {
  		var s = this.states[i%this.length];
  		return (s && s.i == i);
  	}
  	get(i) {
  		if (!this.has(i)) return;
  		var state = s.state;
  		if (this.compress) state = LZUTF8.decompress(state);
  		if (this.json_encode) state = JSON.parse(state);
  		else return state;
  	}
  	goto(i) {
  		if (!this.has(i)) return;
  		this.i = i;
  		return this.current;
  	}
  	go_back() { return this.goto(this.i-1); }
  	go_forward() { return this.goto(this.i+1); }
  	reset() {
  		this.i = -1;
  		this.states = new Array(this.length);
  	}
  } */
  var URLParams = /*#__PURE__*/function () {
    function URLParams(params_str) {
      _classCallCheck(this, URLParams);
      this._params = [];
      if (!params_str) return;
      if (params_str.substr(0, 1) == "?") params_str = params_str.slice(1);
      var _iterator = _createForOfIteratorHelper(params_str.split("&")),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          this.append.apply(this, _toConsumableArray(p.split("=")));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return _createClass(URLParams, [{
      key: "append",
      value: function append(param) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        var p = {
          name: param
        };
        if (value !== undefined) p.value = String(value);
        Object.freeze(p);
        this._params.push(p);
      }
    }, {
      key: "remove",
      value: function remove(param) {
        if (_typeof(param) === "object") {
          this._params.filter(function (p) {
            return p !== param;
          });
        } else {
          this._params = this._params.filter(function (p) {
            return p.name != param;
          });
        }
      }
    }, {
      key: Symbol.iterator,
      value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
        var _iterator2, _step2, p;
        return _regeneratorRuntime().wrap(function value$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelper(this._params);
              _context.prev = 1;
              _iterator2.s();
            case 3:
              if ((_step2 = _iterator2.n()).done) {
                _context.next = 9;
                break;
              }
              p = _step2.value;
              _context.next = 7;
              return p;
            case 7:
              _context.next = 3;
              break;
            case 9:
              _context.next = 14;
              break;
            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](1);
              _iterator2.e(_context.t0);
            case 14:
              _context.prev = 14;
              _iterator2.f();
              return _context.finish(14);
            case 17:
            case "end":
              return _context.stop();
          }
        }, value, this, [[1, 11, 14, 17]]);
      })
    }, {
      key: "toString",
      value: function toString() {
        return this._params.map(function (p) {
          if (p.value === undefined) return p.name;
          return "".concat(p.name, "=").concat(p.value);
        }).join("&");
      }
    }]);
  }();
  var Point = /*#__PURE__*/_createClass(function Point(x, y) {
    _classCallCheck(this, Point);
    this.x = x;
    this.y = y;
  });
  Point.distance = function (x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2), Math.pow(y2 - y1, 2));
  };
  var Rectangle = /*#__PURE__*/function () {
    function Rectangle() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      _classCallCheck(this, Rectangle);
      args = function () {
        if (args.length == 4) return args;
        if (args.length == 2) return [0, 0].concat(_toConsumableArray(args));
        if (args.length == 1) {
          if (Array.isArray(args[0])) return args[0];
          if (_typeof(args[0]) === "object") {
            var _args$ = args[0],
              x = _args$.x,
              y = _args$.y,
              width = _args$.width,
              height = _args$.height,
              left = _args$.left,
              right = _args$.right,
              bottom = _args$.bottom,
              top = _args$.top;
            if (x == undefined) x = left;
            if (y == undefined) y = top;
            if (width == undefined) width = right - left;
            if (height == undefined) height = bottom - top;
            return [x, y, width, height];
          }
        }
        if (args.length == 0) return [0, 0, 0, 0];
      }();
      this.x = +args[0] || 0;
      this.y = +args[1] || 0;
      this.width = +args[2] || 0;
      this.height = +args[3] || 0;
    }
    return _createClass(Rectangle, [{
      key: "left",
      get: function get() {
        return this.x;
      },
      set: function set(value) {
        var d = value - this.x;
        this.x += d;
        this.width -= d;
      }
    }, {
      key: "top",
      get: function get() {
        return this.y;
      },
      set: function set(value) {
        var d = value - this.y;
        this.y += d;
        this.height -= d;
      }
    }, {
      key: "right",
      get: function get() {
        return this.x + this.width;
      },
      set: function set(value) {
        this.width += value - this.right;
      }
    }, {
      key: "bottom",
      get: function get() {
        return this.y + this.height;
      },
      set: function set(value) {
        this.height += value - this.bottom;
      }
    }, {
      key: "center",
      get: function get() {
        return {
          x: this.x + this.width / 2,
          y: this.y + this.height / 2
        };
      }
    }, {
      key: "contains",
      value: function contains(obj) {
        if (!obj.width && !obj.height) return obj.x > this.left && obj.x < this.right && obj.y > this.top && obj.y < this.bottom;
        return obj.x > this.left && obj.x + obj.width < this.right && obj.y > this.top && obj.y + obj.height < this.bottom;
      }
    }, {
      key: "intersects",
      value: function intersects(obj) {
        return obj.x + obj.width > this.left && obj.x < this.right && obj.y + obj.height > this.top && obj.y < this.bottom;
      }
    }, {
      key: "union",
      value: function union(obj) {
        var x = Math.min(obj.x, this.x);
        var y = Math.min(obj.y, this.y);
        var right = Math.max(obj.x + (obj.width || 0), this.right);
        var bottom = Math.max(obj.y + (obj.height || 0), this.bottom);
        return new Rectangle(x, y, right - x, bottom - y);
      }
    }, {
      key: "intersection",
      value: function intersection(obj) {
        var x = Math.max(obj.x, this.x);
        var y = Math.max(obj.y, this.y);
        var right = Math.min(obj.x + obj.width, this.right);
        var bottom = Math.min(obj.y + obj.height, this.bottom);
        return new Rectangle(x, y, right - x, bottom - y);
      }
    }, {
      key: "scale",
      value: function scale(x, y) {
        if (y === undefined) y = x;
        this.x *= x;
        this.y *= y;
        this.width *= x;
        this.height *= y;
        return this;
      }
    }, {
      key: "expand",
      value: function expand(x, y) {
        if (y === undefined) y = x;
        this.x -= x / 2;
        this.y -= y / 2;
        this.width += x;
        this.height += y;
        return this;
      }
    }, {
      key: "fix",
      value: function fix() {
        if (this.width < 0) {
          this.x += this.width;
          this.width *= -1;
        }
        if (this.height < 0) {
          this.y += this.height;
          this.height *= -1;
        }
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
      }
    }, {
      key: "equals",
      value: function equals(obj) {
        try {
          return this.x === obj.x && this.y === obj.y && this.width === obj.width && this.height === obj.height;
        } catch (_unused) {
          return false;
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        return "[Rectangle x:".concat(this.x, " y:").concat(this.y, " width:").concat(this.width, " height:").concat(this.height, "]");
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height
        };
      }
    }]);
  }();
  Rectangle.union = function () {
    for (var _len4 = arguments.length, rects = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      rects[_key4] = arguments[_key4];
    }
    var x = Math.min.apply(Math, _toConsumableArray(rects.map(function (r) {
      return r.x;
    })));
    var y = Math.min.apply(Math, _toConsumableArray(rects.map(function (r) {
      return r.y;
    })));
    var right = Math.max.apply(Math, _toConsumableArray(rects.map(function (r) {
      return r.x + r.width;
    })));
    var bottom = Math.max.apply(Math, _toConsumableArray(rects.map(function (r) {
      return r.y + r.height;
    })));
    return new Rectangle(x, y, right - x, bottom - y);
  };
  Rectangle.intersection = function () {
    for (var _len5 = arguments.length, rects = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      rects[_key5] = arguments[_key5];
    }
    var x = Math.max.apply(Math, _toConsumableArray(rects.map(function (r) {
      return r.x;
    })));
    var y = Math.max.apply(Math, _toConsumableArray(rects.map(function (r) {
      return r.y;
    })));
    var right = Math.min.apply(Math, _toConsumableArray(rects.map(function (r) {
      return r.x + r.width;
    })));
    var bottom = Math.min.apply(Math, _toConsumableArray(rects.map(function (r) {
      return r.y + r.height;
    })));
    return new Rectangle(x, y, right - x, bottom - y);
  };
  var TimeoutError = /*#__PURE__*/function (_Error2) {
    function TimeoutError(message) {
      var _this7;
      _classCallCheck(this, TimeoutError);
      _this7 = _callSuper(this, TimeoutError, [message]);
      _this7.name = "TimeoutError";
      return _this7;
    }
    _inherits(TimeoutError, _Error2);
    return _createClass(TimeoutError);
  }(/*#__PURE__*/_wrapNativeSuper(Error));
  var Color = /*#__PURE__*/function () {
    function Color() {
      for (var _len6 = arguments.length, components = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        components[_key6] = arguments[_key6];
      }
      _classCallCheck(this, Color);
      this._r = 0;
      this._g = 0;
      this._b = 0;
      this._h = 0;
      this._s = 0;
      this._l = 0;
      this._a = 1.0;
      if (components.length == 1) {
        var c = components[0];
        if (Array.isArray(c)) {
          s;
          components = _toConsumableArray(c);
        } else if (_typeof(c) === "object") {
          components = [c.r || c.red || 0, c.g || c.green || 0, c.b || c.blue || 0, c.a || c.alpha || 1];
        } else if (typeof c === "string") {
          if (c.charAt(0) === "#") c = c.slice(1);else if (c.substring(0, 2) === "0x") c = c.slice(2);
          if (c.length < 6) components = c.split("").map(function (a) {
            return a + a;
          });else components = c.match(/.{1,2}/g);
        }
      }
      components = components.map(function (c) {
        if (typeof c === "string" && c.match(/^[0-9a-f]{2}$/)) return parseInt(c, 16);
        return +c;
      });
      this.from_rgba.apply(this, _toConsumableArray(components));
    }
    return _createClass(Color, [{
      key: "r",
      get: function get() {
        return this._r;
      }
    }, {
      key: "g",
      get: function get() {
        return this._g;
      }
    }, {
      key: "b",
      get: function get() {
        return this._b;
      }
    }, {
      key: "h",
      get: function get() {
        return this._h;
      }
    }, {
      key: "s",
      get: function get() {
        return this._s;
      }
    }, {
      key: "l",
      get: function get() {
        return this._l;
      }
    }, {
      key: "a",
      get: function get() {
        return this._a;
      }
    }, {
      key: "from_hsl",
      value: function from_hsl() {
        var h = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var l = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return this.from_hsla(h, s, l, 1);
      }
    }, {
      key: "from_hsla",
      value: function from_hsla() {
        var h = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var l = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        this._h = h = clamp$1(h, 0, 1);
        this._s = s = clamp$1(s, 0, 1);
        this._l = l = clamp$1(l, 0, 1);
        this._a = a = clamp$1(a, 0, 1);
        var r, g, b;
        if (s == 0) {
          r = g = b = l;
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = Color.hue2rgb(p, q, h + 1 / 3);
          g = Color.hue2rgb(p, q, h);
          b = Color.hue2rgb(p, q, h - 1 / 3);
        }
        this._r = Math.round(r * 255);
        this._g = Math.round(g * 255);
        this._b = Math.round(b * 255);
        return this;
      }
    }, {
      key: "from_rgb",
      value: function from_rgb() {
        var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return this.from_rgba(r, g, b, 1);
      }
    }, {
      key: "from_rgba",
      value: function from_rgba() {
        var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        this._r = r = Math.round(clamp$1(r, 0, 255));
        this._g = g = Math.round(clamp$1(g, 0, 255));
        this._b = b = Math.round(clamp$1(b, 0, 255));
        this._a = a = Math.round(clamp$1(a, 0, 1));
        r /= 255;
        g /= 255;
        b /= 255;
        var cMax = Math.max(r, g, b);
        var cMin = Math.min(r, g, b);
        var delta = cMax - cMin;
        var l = (cMax + cMin) / 2;
        var h = 0;
        var s = 0;
        if (delta == 0) h = 0;else if (cMax == r) h = 60 * ((g - b) / delta % 6);else if (cMax == g) h = 60 * ((b - r) / delta + 2);else h = 60 * ((r - g) / delta + 4);
        s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
        this._h = h;
        this._s = s;
        this._l = l;
        return this;
      }
    }, {
      key: "rgb_mix",
      value: function rgb_mix(c) {
        var m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
        return this.rgba_mix(c, m);
      }
    }, {
      key: "rgba_mix",
      value: function rgba_mix(c) {
        var m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
        c = Color.from(c);
        return new Color(lerp(this._r, c.r, m), lerp(this._g, c.g, m), lerp(this._b, c.b, m), lerp(this._a, c.a, m));
      }
    }, {
      key: "hsl_mix",
      value: function hsl_mix(c) {
        var m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
        return this.hsla_mix(c, m);
      }
    }, {
      key: "hsla_mix",
      value: function hsla_mix(c) {
        var m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
        c = Color.from(c);
        return new Color(lerp(this._h, c.h, m), lerp(this._s, c.s, m), lerp(this._l, c.l, m), lerp(this._a, c.a, m));
      }
    }, {
      key: "to_hsl_array",
      value: function to_hsl_array() {
        return [this._h, this._s, this._l];
      }
    }, {
      key: "to_rgb_array",
      value: function to_rgb_array() {
        return [this._r, this._g, this._b];
      }
    }, {
      key: "to_hsla_array",
      value: function to_hsla_array() {
        return [this._h, this._s, this._l, this._a];
      }
    }, {
      key: "to_rgba_array",
      value: function to_rgba_array() {
        return [this._r, this._g, this._b, this._a];
      }
    }, {
      key: "to_hsl_string",
      value: function to_hsl_string() {
        return "hsl(".concat(this._h, ", ").concat(this._s, ", ").concat(this._l, ")");
      }
    }, {
      key: "to_rgb_string",
      value: function to_rgb_string() {
        return "rgb(".concat(this._r, ", ").concat(this._g, ", ").concat(this._b, ")");
      }
    }, {
      key: "to_hsla_string",
      value: function to_hsla_string() {
        return "hsla(".concat(this._h, ", ").concat(this._s, ", ").concat(this._l, ", ").concat(this._a, ")");
      }
    }, {
      key: "to_rgba_string",
      value: function to_rgba_string() {
        return "rgba(".concat(this._r, ", ").concat(this._g, ", ").concat(this._b, ", ").concat(this._a, ")");
      }
    }, {
      key: "to_rgb_hex",
      value: function to_rgb_hex() {
        return "#".concat(this._r.toString(16)).concat(this._g.toString(16)).concat(this._b.toString(16));
      }
    }, {
      key: "to_rgba_hex",
      value: function to_rgba_hex() {
        return "#".concat(this._r.toString(16)).concat(this._g.toString(16)).concat(this._b.toString(16)).concat(this._a.toString(16));
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.to_rgba_string();
      }
    }, {
      key: "copy",
      value: function copy() {
        var c = new Color();
        c._r = this._r;
        c._g = this._g;
        c._b = this._b;
        c._h = this._h;
        c._s = this._s;
        c._l = this._l;
        c._a = this._a;
        return c;
      }
    }]);
  }();
  Color.from = function () {
    for (var _len7 = arguments.length, components = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      components[_key7] = arguments[_key7];
    }
    if (components.length === 1 && components[0] instanceof Color) {
      return components[0];
    }
    return _construct(Color, components);
  };
  Color.mix = function (c1, c2) {
    var m = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
    return Color.from(c1).mix(c2, m);
  };
  Color.hue_to_rgb = function (p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  };

  /** @typedef {{interval:number, immediate:bool, await:bool, context:any}} IntervalOptions  */
  var _options = /*#__PURE__*/new WeakMap();
  var _ticks = /*#__PURE__*/new WeakMap();
  var _destroyed = /*#__PURE__*/new WeakMap();
  var _last_tick = /*#__PURE__*/new WeakMap();
  var _timeout = /*#__PURE__*/new WeakMap();
  var Interval = /*#__PURE__*/function () {
    /** @param {function():void} callback @param {IntervalOptions} opts */
    function Interval(callback, opts) {
      _classCallCheck(this, Interval);
      /** @type {IntervalOptions} */
      _classPrivateFieldInitSpec(this, _options, void 0);
      _classPrivateFieldInitSpec(this, _ticks, 0);
      _classPrivateFieldInitSpec(this, _destroyed, false);
      _classPrivateFieldInitSpec(this, _last_tick, 0);
      _classPrivateFieldInitSpec(this, _timeout, void 0);
      if (_typeof(opts) !== "object") opts = {
        interval: opts
      };
      _classPrivateFieldSet(_options, this, Object.assign({
        interval: 10000,
        immediate: false,
        "await": true,
        context: null
      }, opts));
      /** @type {IntervalOptions} */
      this.options = options_proxy(_classPrivateFieldGet(_options, this));
      if (!this.options.immediate) _classPrivateFieldSet(_last_tick, this, Date.now());
      this.callback = callback;
      if (this.options.immediate) this.tick();else this.next();
    }
    return _createClass(Interval, [{
      key: "time_since_last_tick",
      get: function get() {
        return Math.max(0, Date.now() - _classPrivateFieldGet(_last_tick, this));
      }
    }, {
      key: "time_until_next_tick",
      get: function get() {
        return Math.max(0, this.options.interval - this.time_since_last_tick);
      }
    }, {
      key: "update",
      value: function update(opts) {
        Object.assign(_classPrivateFieldGet(_options, this), opts);
      }
    }, {
      key: "tick",
      value: function () {
        var _tick = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var _this$ticks;
          var callback_args,
            ticks,
            _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                callback_args = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : null;
                ticks = _classPrivateFieldSet(_ticks, this, (_this$ticks = _classPrivateFieldGet(_ticks, this), ++_this$ticks));
                if (!_classPrivateFieldGet(_options, this)["await"]) {
                  _context2.next = 5;
                  break;
                }
                _context2.next = 5;
                return this._current_promise;
              case 5:
                if (!_classPrivateFieldGet(_destroyed, this) && ticks == _classPrivateFieldGet(_ticks, this)) {
                  _classPrivateFieldSet(_last_tick, this, Date.now());
                  this._current_promise = Promise.resolve(this.callback.apply(this.options.context, callback_args));
                  this.next();
                }
                return _context2.abrupt("return", this._current_promise);
              case 7:
              case "end":
                return _context2.stop();
            }
          }, _callee, this);
        }));
        function tick() {
          return _tick.apply(this, arguments);
        }
        return tick;
      }()
    }, {
      key: "next",
      value: function () {
        var _next2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var _this8 = this;
          return _regeneratorRuntime().wrap(function _callee2$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                clearTimeout(_classPrivateFieldGet(_timeout, this));
                _classPrivateFieldSet(_timeout, this, setTimeout(function () {
                  return _this8.tick();
                }, this.options.interval));
              case 2:
              case "end":
                return _context3.stop();
            }
          }, _callee2, this);
        }));
        function next() {
          return _next2.apply(this, arguments);
        }
        return next;
      }()
    }, {
      key: "destroy",
      value: function destroy() {
        _classPrivateFieldSet(_destroyed, this, true);
        clearTimeout(_classPrivateFieldGet(_timeout, this));
      }
    }]);
  }();
  function options_proxy(opts) {
    return new Proxy(opts, {
      get: function get(target, prop, receiver) {
        if (prop in target) {
          if (typeof target[prop] === "function") return target[prop]();
          return target[prop];
        }
      }
    });
  }
  var OrderedSet = /*#__PURE__*/function () {
    function OrderedSet(items) {
      _classCallCheck(this, OrderedSet);
      this.set = new Set();
      this.array = [];
      if (Symbol.iterator in Object(items)) {
        var _iterator3 = _createForOfIteratorHelper(items),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var i = _step3.value;
            this.add(i);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    }
    return _createClass(OrderedSet, [{
      key: "add",
      value: function add(item) {
        if (this.set.has(item)) return false;
        this.set.add(item);
        this.array.push(item);
        return true;
      }
    }, {
      key: "delete",
      value: function _delete(item) {
        if (!this.set.has(item)) return false;
        this.set["delete"](item);
        this.array.splice(this.array.indexOf(item), 1);
        return true;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.set.clear();
        this.array = [];
      }
    }, {
      key: "has",
      value: function has(item) {
        return this.set.has(item);
      }
    }, {
      key: "indexOf",
      value: function indexOf(item) {
        return this.array.indexOf(item);
      }
    }, {
      key: "size",
      get: function get() {
        return this.set.size;
      }
    }, {
      key: Symbol.iterator,
      value: function value() {
        return this.array[Symbol.iterator]();
      }
    }]);
  }();

  /** @typedef {{path:string, type:string, old_value:any new_value:any, nested:boolean}} ObserverChange */
  /** @callback ObserverListenerCallback @param {ObserverChange} change */

  var Observer = function () {
    var Observer_core = Symbol("Observer_core");
    var Observer_target = Symbol("Observer_target");
    var CHANGE = Object.freeze({
      set: "set",
      update: "update",
      "delete": "delete"
    });

    // var force_emit = false;
    /** @return {Proxy} */
    function Observer(target) {
      var _this = this;
      /** @type {ObserverListenerCallback[]} */
      var listeners = [];
      var parents = new Map();
      function listen(cb) {
        listeners.push(cb);
      }
      function unlisten(cb) {
        array_remove(listeners, cb);
      }
      function destroy() {
        listeners.splice(0, listeners.length);
        for (var _i2 = 0, _Array$from = Array.from(parents); _i2 < _Array$from.length; _i2++) {
          var _Array$from$_i = _slicedToArray(_Array$from[_i2], 2),
            key = _Array$from$_i[0],
            parent = _Array$from$_i[1];
          delete parent.proxy[key];
        }
      }
      function emit(path, type, old_value, new_value) {
        var nested = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        // technically accurate - to track changes objects must be deep copied here... but unnecessary for my purposes.
        // if (Observer.is_proxy(old_value)) old_value = deep_copy(old_value);
        // if (Observer.is_proxy(new_value)) new_value = deep_copy(new_value);
        if (listeners.length) {
          var _iterator4 = _createForOfIteratorHelper(listeners),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var listener = _step4.value;
              listener.apply(_this, [{
                path: path,
                type: type,
                old_value: old_value,
                new_value: new_value,
                nested: nested
              }]);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
        var _iterator5 = _createForOfIteratorHelper(parents),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 2),
              key = _step5$value[0],
              parent = _step5$value[1];
            parent.emit([key].concat(_toConsumableArray(path)), type, old_value, new_value, nested);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
      Object.assign(this, {
        parents: parents,
        listen: listen,
        unlisten: unlisten,
        destroy: destroy,
        emit: emit
      });

      // -----------------

      function walk(o, delegate) {
        var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        if (_typeof(o) !== "object" || o === null) return;
        for (var k in o) {
          var sub_path = [].concat(_toConsumableArray(path), [k]);
          delegate.apply(o, [sub_path, o[k]]);
          walk(o[k], delegate, sub_path);
        }
      }
      function klaw(o, delegate) {
        var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        if (_typeof(o) !== "object" || o === null) return;
        for (var k in o) {
          var sub_path = [].concat(_toConsumableArray(path), [k]);
          klaw(o[k], delegate, sub_path);
          delegate.apply(o, [sub_path, o[k]]);
        }
      }
      function try_unregister_child(child, prop) {
        var child_observer = Observer.get_observer(child);
        if (child_observer && child_observer instanceof Observer) {
          klaw(child, function (path, val) {
            emit([prop].concat(_toConsumableArray(path)), CHANGE["delete"], val, undefined, true);
          });
          child_observer.parents["delete"](prop);
        }
      }
      function try_register_child(child, prop) {
        var child_observer = Observer.get_observer(child);
        if (child_observer && child_observer instanceof Observer) {
          walk(child, function (path, val) {
            emit([prop].concat(_toConsumableArray(path)), CHANGE.set, undefined, val, true);
          });
          child_observer.parents.set(prop, _this);
        }
      }

      // -----------------

      // !! Arrays (shift(), splice(), etc.) produce TONS of events... consider replacing arrays with special object that doesnt emit so many changes.

      var validator = {
        get: function get(target, prop) {
          if (prop === Observer_core) return _this;
          if (prop === Observer_target) return target;
          return target[prop];
        },
        set: function set(target, prop, new_value) {
          var old_value = target[prop];
          new_value = Observer.resolve(new_value);
          var changed = old_value !== new_value;
          if (changed) {
            var type = target[prop] === undefined ? CHANGE.set : CHANGE.update;
            try_unregister_child(old_value, prop);
            target[prop] = new_value;
            emit([prop], type, old_value, new_value);
            try_register_child(new_value, prop);
          }
          return true;
        },
        deleteProperty: function deleteProperty(target, prop) {
          if (prop in target) {
            var old_value = target[prop];
            try_unregister_child(old_value, prop);
            delete target[prop];
            emit([prop], CHANGE["delete"], old_value, undefined);
          }
          return true;
        } // defineProperty(target, prop, descriptor) {
        // },
        // enumerate(target, prop) {
        // },
        // ownKeys(target, prop) {
        // },
        // has(target, prop) {
        // },
        // getOwnPropertyDescriptor(target, prop) {
        // },
        // construct(target, prop) {
        // },
        // apply(target, thisArg, argumentsList) {
        // }
      };
      var proxy = new Proxy(Array.isArray(target) ? [] : {}, validator);
      Object.assign(proxy, target);
      _this.proxy = proxy;
      return proxy;
    }
    var RESET_KEY = "__RESET_0f726b__";
    Observer.RESET_KEY = RESET_KEY;
    Observer.get_observer = function (proxy) {
      if (proxy == null) return null;
      return proxy[Observer_core];
    };
    Observer.get_target = function (proxy) {
      if (proxy == null) return null;
      return proxy[Observer_target];
    };
    Observer.is_proxy = function (proxy) {
      return !!Observer.get_observer(proxy);
    };
    /** @param {ObserverListenerCallback} cb */
    Observer.listen = function (proxy, cb) {
      var observer = Observer.get_observer(proxy);
      if (observer) observer.listen(cb);
      return cb;
    };
    /** @param {ObserverListenerCallback} cb */
    Observer.unlisten = function (proxy, cb) {
      var observer = Observer.get_observer(proxy);
      if (observer) observer.unlisten(cb);
    };
    Observer.resolve = function (object) {
      if (Observer.is_proxy(object) || object === null || _typeof(object) !== "object") return object;
      return new Observer(object);
    };
    Observer.destroy = function (proxy) {
      var observer = Observer.get_observer(proxy);
      if (observer) observer.destroy();
    };
    Observer.flatten_changes = function (changes) {
      var result = {};
      var _iterator6 = _createForOfIteratorHelper(changes),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var c = _step6.value;
          var key = c.path[c.path.length - 1];
          var r = result;
          for (var _i3 = 0; _i3 < c.path.length - 1; _i3++) {
            var p = c.path[_i3];
            if (r[p] === undefined) r[p] = {};
            r = r[p];
          }
          var new_value = c.new_value;
          if (Observer.is_proxy(new_value)) {
            var target = Observer.get_target(new_value);
            new_value = {};
            if (c.old_value !== null) {
              new_value[RESET_KEY] = Array.isArray(target) ? 1 : 0; // 1 = Array, 0 = Object
            }
          }
          r[key] = new_value;
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return result;
    };

    // root must be object, not array.
    Observer.apply_changes = function (target, changes) {
      var _apply = function apply(target, changes) {
        for (var k in changes) {
          if (k === RESET_KEY) continue;
          if (_typeof(changes[k]) === 'object' && changes[k] !== null) {
            if (RESET_KEY in changes[k]) {
              if (!target[k] || Array.isArray(target[k]) != changes[k][RESET_KEY]) {
                target[k] = changes[k][RESET_KEY] ? [] : {};
              } else {
                clear(target[k]); // VERY IMPORTANT - this keeps any prototype stuff.
              }
            }
            if (_typeof(target[k]) !== "object" || target[k] === null) {
              target[k] = Array.isArray(changes[k]) ? [] : {};
            }
            _apply(target[k], changes[k]);
            if (Array.isArray(changes[k])) target[k].length = changes[k].length;
          } else if (changes[k] === null) {
            delete target[k];
          } else {
            target[k] = changes[k];
          }
        }
      };
      _apply(target, changes);
    };
    return Observer;
  }();

  /** @typedef {{[0]:number, [1]:number, next:RangeTreeNode}} RangeTreeNode */
  var RangeTree = /*#__PURE__*/function () {
    function RangeTree(values) {
      _classCallCheck(this, RangeTree);
      /** @type {RangeTreeNode} */
      this._first = null;
      if (values) {
        var _iterator7 = _createForOfIteratorHelper(values),
          _step7;
        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var v = _step7.value;
            this.add(v[0], v[1]);
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      }
    }
    return _createClass(RangeTree, [{
      key: "values",
      get: function get() {
        return _toConsumableArray(this);
      }
    }, {
      key: "total",
      get: function get() {
        var a = 0;
        var _iterator8 = _createForOfIteratorHelper(this),
          _step8;
        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var p = _step8.value;
            a += p[1] - p[0];
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
        return a;
      }
    }, {
      key: "add",
      value: function add(start, end) {
        if (start < 0) throw new Error("start must be >= 0: ".concat(start));
        if (start > end) throw new Error("start must be smaller than end: ".concat(start, " > ").concat(end));
        if (start == end) return;
        /** @type {RangeTreeNode} */
        var new_node = [start, end];
        if (!this._first || new_node[0] < this._first[0]) {
          new_node.next = this._first;
          this._first = new_node;
        }
        var curr = this._first;
        while (curr) {
          if (!curr.next || curr.next[0] > new_node[0]) {
            var n = curr.next;
            curr.next = new_node;
            new_node.next = n;
            if (new_node[0] <= curr[1] && new_node[0] >= curr[0]) {
              curr[1] = Math.max(new_node[1], curr[1]);
              curr.next = new_node.next;
            }
            if (new_node[1] <= curr[0] && new_node[1] >= curr[1]) {
              curr[0] = Math.min(new_node[0], curr[0]);
              curr.next = new_node.next;
            }
            while (curr.next && curr[1] >= curr.next[0]) {
              curr[1] = Math.max(curr[1], curr.next[1]);
              curr.next = curr.next.next;
            }
            break;
          }
          curr = curr.next;
        }
      }
    }, {
      key: "includes",
      value: function includes(low, high) {
        if (!high) high = low;
        var _iterator9 = _createForOfIteratorHelper(this),
          _step9;
        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var r = _step9.value;
            if (low >= r[0] && high <= r[1]) return true;
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
        return false;
      }
    }, {
      key: Symbol.iterator,
      value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
        var next;
        return _regeneratorRuntime().wrap(function value$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              next = this._first;
            case 1:
              if (!next) {
                _context4.next = 8;
                break;
              }
              if (!next) {
                _context4.next = 5;
                break;
              }
              _context4.next = 5;
              return _toConsumableArray(next);
            case 5:
              next = next.next;
              _context4.next = 1;
              break;
            case 8:
            case "end":
              return _context4.stop();
          }
        }, value, this);
      })
    }]);
  }();
  var regex = {
    urls: /(https?:\/\/[^\s]+)/gi
  };
  function is_valid_url(str) {
    return /(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})/i.test(str);
  }
  function is_valid_rtmp_url(str) {
    return /^rtmps?\:\/\//i.test(str);
  }
  function is_valid_ip(str) {
    return /((^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$)|(^((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?$))/.test(str);
  }
  function is_uri(s) {
    return /^[a-z]{2,}\:\/\//.test(String(s));
  }
  function is_absolute_path(s) {
    return /^(?:[a-zA-Z]\:[\\/]|\/)/.test(String(s));
  }
  // includes subdomains
  function domain_match(uri, domain) {
    try {
      uri = new URL(uri).hostname || uri;
    } catch (_unused3) {}
    return !!uri.match("^(?:[^:]+:\\/\\/)?(?:.+?.)?(".concat(escape_regex(domain), ")(?:/|$)"));
  }
  function capitalize(str) {
    return String(str).replace(/(?:^|\s)\S/g, function (a) {
      return a.toUpperCase();
    });
  }
  function kebabcase(str) {
    return String(str).replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, '-').toLowerCase();
  }
  function escape_regex(str) {
    return String(str).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }
  function split_after_first_line(str) {
    var m = str.match(/(.+?)[\n\r]+/);
    return m ? [m[1], str.slice(m[0].length)] : [str, undefined];
  }
  /* str_to_js(str) {
  	try { return JSON.parse(str); } catch (e) { }
  	return str;
  }, */
  function is_numeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
  function zip() {
    for (var _len8 = arguments.length, its = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      its[_key8] = arguments[_key8];
    }
    its = its.map(function (it) {
      return Array.isArray(it) ? it : _toConsumableArray(it);
    });
    return its[0].map(function (_, i) {
      return its.map(function (a) {
        return a[i];
      });
    });
  }
  /* export function zip(keys, values) {
  	return keys.reduce(
  		(obj, key, i)=>{
  			obj[key] = values[i];
  			return obj;
  		}, {}
  	);
  } */
  /** @template T @param {Iterable<T>} a @param {Iterable<T>} b @return {Set<T>} */
  function set_union(a, b) {
    return new Set([].concat(_toConsumableArray(a), _toConsumableArray(b)));
  }
  /** @template T @param {Iterable<T>} a @param {Iterable<T>} b @return {Set<T>} */
  function set_difference(a, b) {
    if (!(b instanceof Set)) b = new Set(b);
    return new Set(_toConsumableArray(a).filter(function (x) {
      return !b.has(x);
    }));
  }
  /** @template T @param {Iterable<T>} a @param {Iterable<T>} b @return {Set<T>} */
  function set_intersection(a, b) {
    if (!(b instanceof Set)) b = new Set(b);
    return new Set(_toConsumableArray(a).filter(function (x) {
      return b.has(x);
    }));
  }
  function sets_equal() {
    for (var _len9 = arguments.length, sets = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      sets[_key9] = arguments[_key9];
    }
    var seta = sets[0];
    if (!(seta instanceof Set)) seta = new Set(seta);
    var _iterator10 = _createForOfIteratorHelper(sets.slice(1)),
      _step10;
    try {
      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
        var setb = _step10.value;
        if (!(setb instanceof Set)) setb = new Set(setb);
        if (seta.size !== setb.size) return false;
        var _iterator11 = _createForOfIteratorHelper(seta),
          _step11;
        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var a = _step11.value;
            if (!setb.has(a)) return false;
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
      }
    } catch (err) {
      _iterator10.e(err);
    } finally {
      _iterator10.f();
    }
    return true;
  }
  function debounce$1(func) {
    var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var timeout, previous, args, result, context;
    var _later = function later() {
      var passed = Date.now() - previous;
      if (wait > passed) {
        timeout = setTimeout(_later, wait - passed);
      } else {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
        if (!timeout) args = context = null;
      }
    };
    var debounced = function debounced() {
      context = this;
      for (var _len10 = arguments.length, p = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        p[_key10] = arguments[_key10];
      }
      args = p;
      previous = Date.now();
      if (!timeout) {
        timeout = setTimeout(_later, wait);
        if (immediate) result = func.apply(context, args);
      }
      return result;
    };
    debounced.cancel = function () {
      clearTimeout(timeout);
      timeout = args = context = null;
    };
    return debounced;
  }
  function throttle$1(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};
    var later = function later() {
      previous = options.leading === false ? 0 : now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    var throttled = function throttled() {
      var _now = now();
      if (!previous && options.leading === false) previous = _now;
      var remaining = wait - (_now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = _now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
    throttled.cancel = function () {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };
    return throttled;
  }
  function almost_equal(a, b) {
    var epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : FLT_EPSILON;
    var d = Math.abs(a - b);
    return d <= epsilon;
  }
  /* sync_objects(src, dst) {
  	var dst_keys = new Set(Object.keys(dst));
  	for (var k in src) {
  		dst_keys.delete(k);
  		if (dst[k] !== src[k]) dst[k] = src[k];
  	}
  	for (var k of dst_keys) {
  		delete dst[k];
  	}
  }, */
  function sanitize_filename(name) {
    return String(name).toLowerCase().replace(/^\W+/, "").replace(/\W+$/, "").replace(/\W+/g, "-").trim().slice(0, 128);
  }
  function remove_nulls(obj) {
    if (Array.isArray(obj)) {
      var i = obj.length;
      while (i--) {
        if (obj[i] == null) obj.splice(i, 1);
      }
    } else {
      for (var _i4 = 0, _Object$keys = Object.keys(obj); _i4 < _Object$keys.length; _i4++) {
        var k = _Object$keys[_i4];
        if (obj[k] == null) delete obj[k];
      }
    }
  }
  /** @template T @param {Iterable<T>} values @param {function(T):string} cb @return {Record<string,T[]>} */
  function group_by(values, cb) {
    var groups = {};
    var _iterator12 = _createForOfIteratorHelper(values),
      _step12;
    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var value = _step12.value;
        var key = cb(value);
        if (!groups[key]) groups[key] = [];
        groups[key].push(value);
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }
    return groups;
  }
  /** @template T, K @param {Iterable<T>} values @param {function(T):K} cb @return {Map<K,T[]>} */
  function map_group_by(values, cb) {
    /** @type {Map<T,K[]>} */
    var groups = new Map();
    var _iterator13 = _createForOfIteratorHelper(values),
      _step13;
    try {
      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
        var value = _step13.value;
        var key = cb(value);
        if (!groups.has(key)) groups.set(key, []);
        groups.get(key).push(value);
      }
    } catch (err) {
      _iterator13.e(err);
    } finally {
      _iterator13.f();
    }
    return groups;
  }
  function is_path_remote(path_str) {
    return path_str.includes("://");
  }
  function transpose(array) {
    return array[0].map(function (_, c) {
      return array.map(function (row) {
        return row[c];
      });
    });
  }
  function format_bytes(bytes) {
    var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    decimals = Math.max(decimals, 0);
    var k = 1024;
    var sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'];
    var i = clamp$1(Math.floor(Math.log(bytes) / Math.log(k)), min, sizes.length - 1);
    if (!isFinite(i)) i = 0;
    return "".concat((bytes / Math.pow(k, i)).toFixed(decimals), " ").concat(sizes[i]);
  }
  /** @param {string} s */
  function string_to_bytes(s) {
    var m = s.match(/[a-z]+/i);
    var num = parseFloat(s);
    var e = 1;
    var unit = m[0] || "";
    if (m = unit.match(/^ki(bi)?/i)) e = 1024;else if (m = unit.match(/^k(ilo)?/i)) e = 1000;else if (m = unit.match(/^mi(bi)?/i)) e = Math.pow(1024, 2);else if (m = unit.match(/^m(ega)?/i)) e = Math.pow(1000, 2);else if (m = unit.match(/^gi(bi)?/i)) e = Math.pow(1024, 3);else if (m = unit.match(/^g(iga)?/i)) e = Math.pow(1000, 3);else if (m = unit.match(/^ti(bi)?/i)) e = Math.pow(1024, 4);else if (m = unit.match(/^t(era)?/i)) e = Math.pow(1000, 4);else if (m = unit.match(/^pi(bi)?/i)) e = Math.pow(1024, 5);else if (m = unit.match(/^p(eta)?/i)) e = Math.pow(1000, 5);
    unit = unit.slice(m ? m[0].length : 0);
    if (unit.match(/^b(?!yte)/)) num /= 8;
    return num * e;
  }
  function is_ip_local(ip) {
    return ip === "127.0.0.1" || ip === "::1" || ip == "::ffff:127.0.0.1";
  }
  function date_to_string(date, options) {
    if (date === undefined) date = Date.now();
    options = Object.assign({
      date: true,
      time: true,
      delimiter: "-"
    }, options);
    date = new Date(date);
    var parts = date.toISOString().slice(0, -1).split("T");
    if (!options.time) parts.splice(1, 1);
    if (!options.date) parts.splice(0, 1);
    var str = parts.join("-").replace(/[^\d]+/g, options.delimiter);
    return str;
  }
  function uniquify(arr, resolver) {
    if (!resolver) resolver = function resolver(s, i, n) {
      return n > 1 ? "".concat(s, " [").concat(i + 1, "]") : "".concat(s);
    };
    var map = new Map();
    var _iterator14 = _createForOfIteratorHelper(arr),
      _step14;
    try {
      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
        var e = _step14.value;
        if (map.has(e)) map.set(map.get(e) + 1);else map.set(e, 1);
      }
    } catch (err) {
      _iterator14.e(err);
    } finally {
      _iterator14.f();
    }
    return arr.map(function (e, i) {
      var n = map.get(e);
      return resolver.apply(null, [e, i, n]);
    });
  }
  function time_delta_readable(delta) {
    var time_formats = [[1, '1 second ago', '1 second from now'], [60, 'seconds', 1], [60 * 2, '1 minute ago', '1 minute from now'], [60 * 60, 'minutes', 60], [60 * 60 * 2, '1 hour ago', '1 hour from now'], [60 * 60 * 24, 'hours', 60 * 60], [60 * 60 * 24 * 2, 'Yesterday', 'Tomorrow'], [60 * 60 * 24 * 7, 'days', 60 * 60 * 24], [60 * 60 * 24 * 7 * 2, 'Last week', 'Next week'], [60 * 60 * 24 * 7 * 4, 'weeks', 60 * 60 * 24 * 7], [60 * 60 * 24 * 7 * 4 * 2, 'Last month', 'Next month'], [60 * 60 * 24 * 7 * 4 * 12, 'months', 60 * 60 * 24 * 30], [60 * 60 * 24 * 7 * 4 * 12 * 2, 'Last year', 'Next year'], [60 * 60 * 24 * 7 * 4 * 12 * 100, 'years', 60 * 60 * 24 * 365], [60 * 60 * 24 * 7 * 4 * 12 * 100 * 2, 'Last century', 'Next century'], [60 * 60 * 24 * 7 * 4 * 12 * 100 * 20, 'centuries', 60 * 60 * 24 * 365 * 100]];
    var seconds = Math.floor(delta / 1000);
    if (seconds == 0) return 'Just now';
    var _ref = seconds < 0 ? ["ago", 1] : ['from now', 2],
      _ref2 = _slicedToArray(_ref, 2),
      token = _ref2[0],
      i = _ref2[1];
    seconds = Math.abs(seconds);
    for (var _i5 = 0, _time_formats = time_formats; _i5 < _time_formats.length; _i5++) {
      var format = _time_formats[_i5];
      if (seconds >= format[0]) continue;
      return typeof format[2] === 'string' ? format[i] : "".concat(Math.floor(seconds / format[2]), " ").concat(format[1], " ").concat(token);
    }
    return time;
  }
  function time_diff_readable(from, to) {
    if (from && !to) {
      var _ref3 = [new Date(), from];
      from = _ref3[0];
      to = _ref3[1];
    }
    if (!from) from = new Date();
    if (!to) to = new Date();
    return time_delta_readable(to - from);
  }
  function split_path(path) {
    return path.split(path_separator_regex).filter(function (p) {
      return p;
    });
  }
  /* register_change(obj, name) {
  	return (key,value) => {
  		// if key is int, value an array element.
  		if (typeof key === "number") {
  			if (!obj[name]) obj[name] = [];
  			obj[name].push(value);
  		} else {
  			if (!obj[name]) obj[name] = {};
  			obj[name][key] = value;
  		}
  	}
  }, */
  function is_plain_object(obj) {
    return _typeof(obj) === 'object' && obj !== null && obj.constructor === Object && Object.prototype.toString.call(obj) === '[object Object]';
  }
  function websocket_ready(ws) {
    var is_open = ws ? ws.readyState === 1 : false;
    if (is_open) return Promise.resolve();
    return new Promise(function (resolve) {
      ws.on("open", function () {
        return resolve();
      });
    });
  }
  /* once(event_emitter, event){
  	return new Promise(resolve=>{
  		event_emitter.once(event, (...args)=>{
  			resolve(...args);
  		})
  	})
  }, */
  /** @template T @param {Object.<string,T|PromiseLike<T>>} obj @returns {Object.<string,Promise<Awaited<T>[]>>}; */
  function promise_all_object(_x) {
    return _promise_all_object.apply(this, arguments);
  }
  function _promise_all_object() {
    _promise_all_object = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(obj) {
      var new_obj;
      return _regeneratorRuntime().wrap(function _callee3$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            new_obj = {};
            _context6.next = 3;
            return Promise.all(Object.entries(obj).map(function (_ref8) {
              var _ref9 = _slicedToArray(_ref8, 2),
                k = _ref9[0],
                p = _ref9[1];
              return Promise.resolve(p).then(function (data) {
                return new_obj[k] = data;
              });
            }));
          case 3:
            return _context6.abrupt("return", new_obj);
          case 4:
          case "end":
            return _context6.stop();
        }
      }, _callee3);
    }));
    return _promise_all_object.apply(this, arguments);
  }
  function replace_all(str, search, replace) {
    return str.split(search).join(replace);
  }
  function shuffle(arra1) {
    var ctr = arra1.length,
      temp,
      index;
    while (ctr > 0) {
      index = Math.floor(Math.random() * ctr);
      ctr--;
      temp = arra1[ctr];
      arra1[ctr] = arra1[index];
      arra1[index] = temp;
    }
    return arra1;
  }
  function matchAll(s, re) {
    var matches = [],
      m = null;
    while (m = re.exec(s)) {
      matches.push(m);
    }
    return matches;
  }
  function promise_timeout(promise) {
    var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;
    if (typeof promise === "function") promise = new Promise(promise);
    if (!ms || ms <= 0) return promise;
    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        reject(new TimeoutError("Timed out in ".concat(ms, "ms.")));
      }, ms);
      promise.then(resolve)["catch"](reject);
    });
  }
  function promise_wait_atleast(promise) {
    var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;
    return Promise.all([promise, timeout(ms)]).then(function (d) {
      return d[0];
    });
  }
  function promise_pool(array, iteratorFn) {
    var poolLimit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
    var i = 0;
    var ret = [];
    var executing = new Set();
    array = _toConsumableArray(array);
    var _enqueue = function enqueue() {
      if (i === array.length) {
        return Promise.resolve();
      }
      var item = array[i];
      var p = Promise.resolve().then(function () {
        return iteratorFn(item, i, array);
      });
      ret.push(p);
      var e = p.then(function () {
        return executing["delete"](e);
      });
      executing.add(e);
      var r = executing.size >= poolLimit ? Promise.race(executing) : Promise.resolve();
      i++;
      return r.then(function () {
        return _enqueue();
      });
    };
    return _enqueue().then(function () {
      return Promise.all(ret);
    });
  }
  function timeout(ms) {
    if (!Number.isFinite(ms) || ms <= 0) return Promise.resolve();
    return new Promise(function (resolve) {
      return setTimeout(resolve, ms);
    });
  }
  function split_string(str, partLength) {
    var list = [];
    if (str !== "" && partLength > 0) {
      for (var i = 0; i < str.length; i += partLength) {
        list.push(str.substr(i, Math.min(partLength, str.length)));
      }
    }
    return list;
  }
  function remove_emojis(str) {
    return str.replace(emoji_regex, '');
  }
  function array_move_before(arr, from, to) {
    if (to > from) to--;
    if (from === to) return arr;
    return array_move(arr, from, to);
  }
  function array_move(arr, from, to) {
    from = clamp$1(from, 0, arr.length - 1);
    to = clamp$1(to, 0, arr.length - 1);
    arr.splice.apply(arr, [to, 0].concat(_toConsumableArray(arr.splice(from, 1))));
    return arr;
  }
  function remove_duplicates(arr) {
    var s = new Set();
    var new_arr = [];
    var _iterator15 = _createForOfIteratorHelper(arr),
      _step15;
    try {
      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
        var i = _step15.value;
        if (s.has(i)) continue;
        s.add(i);
        new_arr.push(i);
      }
    } catch (err) {
      _iterator15.e(err);
    } finally {
      _iterator15.f();
    }
    return new_arr;
  }
  function timespan_str_to_seconds(str) {
    var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hh:mm:ss";
    return timespan_str_to_ms(str, format) / 1000;
  }
  // will also handle decimal points (milliseconds)
  function timespan_str_to_ms(str) {
    var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hh:mm:ss";
    var multiply = 1;
    if (str.startsWith("-")) {
      multiply = -1;
      str = str.slice(1);
    }
    var parts = String(str).split(/:/);
    var format_parts = format.split(/:/);
    if (format_parts.length > parts.length) format_parts = format_parts.slice(-parts.length); // so if str = "10:00" and format = "hh:mm:ss", the assumed format will be "mm:ss"
    else parts = parts.slice(-format_parts.length);
    var ms = 0;
    for (var i = 0; i < parts.length; i++) {
      var v = parseFloat(parts[i]);
      var f = format_parts[i][0];
      if (!Number.isFinite(v)) v = 0; // handles NaN & Infinity
      if (f == "d") ms += v * 24 * 60 * 60 * 1000;else if (f == "h") ms += v * 60 * 60 * 1000;else if (f == "m") ms += v * 60 * 1000;else if (f == "s") ms += v * 1000;
    }
    return ms * multiply;
  }
  // ms
  function ms_to_timespan_str(num) {
    var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hh:mm:ss";
    var negative = num < 0;
    num = Math.abs(+num) || 0;
    var format_parts = format.split(/([^a-z])/i).filter(function (m) {
      return m;
    });
    var parts = [];
    for (var i = 0; i < format_parts.length; i++) {
      var p = format_parts[i];
      var divider = null;
      if (p.startsWith("d")) divider = 24 * 60 * 60 * 1000;else if (p.startsWith("h")) divider = 60 * 60 * 1000;else if (p.startsWith("m")) divider = 60 * 1000;else if (p.startsWith("s")) divider = 1000;else if (p.startsWith("S")) divider = 1;else if (parts.length == 0) continue;
      if (p == "?") {
        if (parts[parts.length - 1] == 0) parts.pop();
        continue;
      }
      if (divider) {
        var v = Math.floor(num / divider);
        p = v.toString().padStart(p.length, "0");
        num -= v * divider;
      }
      parts.push(p);
    }
    return (negative ? "-" : "") + parts.join("");
  }
  function seconds_to_timespan_str(num) {
    var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hh:mm:ss";
    return ms_to_timespan_str(num * 1000, format);
  }
  // ms
  function ms_to_shorthand_str(num) {
    var show_ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var negative = num < 0;
    num = Math.abs(+num) || 0;
    var parts = [];
    for (var k in DIVIDERS) {
      var divider = DIVIDERS[k];
      var d = Math.floor(num / divider);
      num -= d * divider;
      if (k == "s" && show_ms) {
        d = (d + num / 1000).toFixed(+show_ms);
      }
      if (d) parts.push("".concat(d).concat(k));
    }
    return (negative ? "-" : "") + parts.join(" ");
  }
  function seconds_to_human_readable_str(t) {
    return ms_to_human_readable_str(t * 1000);
  }
  function ms_to_human_readable_str(t) {
    var days = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var hours = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var minutes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var seconds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var o = {};
    if (days) o["Day"] = 1000 * 60 * 60 * 24;
    if (hours) o["Hour"] = 1000 * 60 * 60;
    if (minutes) o["Minute"] = 1000 * 60;
    if (seconds) o["Second"] = 1000;
    var parts = [];
    for (var k in o) {
      var v = Math.floor(t / o[k]);
      if (v) parts.push("".concat(v.toLocaleString(), " ").concat(k).concat(v > 1 ? "s" : ""));
      t -= v * o[k];
    }
    return parts.join(" ") || "0 Seconds";
  }
  function array_remove(arr, item) {
    var index = arr.indexOf(item);
    if (index === -1) return false;
    arr.splice(index, 1);
    return true;
  }
  function array_unique(arr) {
    return Array.from(iterate_unique(arr));
  }
  function iterate_unique(arr) {
    var seen, _iterator16, _step16, a;
    return _regeneratorRuntime().wrap(function iterate_unique$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          seen = new Set();
          _iterator16 = _createForOfIteratorHelper(arr);
          _context5.prev = 2;
          _iterator16.s();
        case 4:
          if ((_step16 = _iterator16.n()).done) {
            _context5.next = 13;
            break;
          }
          a = _step16.value;
          if (!seen.has(a)) {
            _context5.next = 8;
            break;
          }
          return _context5.abrupt("continue", 11);
        case 8:
          seen.add(a);
          _context5.next = 11;
          return a;
        case 11:
          _context5.next = 4;
          break;
        case 13:
          _context5.next = 18;
          break;
        case 15:
          _context5.prev = 15;
          _context5.t0 = _context5["catch"](2);
          _iterator16.e(_context5.t0);
        case 18:
          _context5.prev = 18;
          _iterator16.f();
          return _context5.finish(18);
        case 21:
        case "end":
          return _context5.stop();
      }
    }, _marked, null, [[2, 15, 18, 21]]);
  }
  function random(min, max) {
    // min and max included
    return Math.random() * (max - min) + min;
  }
  function random_int(min, max) {
    // min and max included
    min = ~~min;
    max = ~~max;
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
  function array_repeat(d, n) {
    // min and max included
    var arr = [];
    while (n-- > 0) arr.push(d);
    return arr;
  }
  function random_string(length) {
    var chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var result = new Array(length),
      num_chars = chars.length;
    for (var i = length; i > 0; --i) result[i] = chars[Math.floor(Math.random() * num_chars)];
    return result.join("");
  }
  function random_hex_string(length) {
    return random_string(length, "0123456789abcdef");
  }
  /* random_string(length) {
  	[...Array(length)].map(i=>(~~(Math.random()*36)).toString(36)).join('')
  }, */
  function is_empty(obj) {
    if (!obj) return true;
    if (_typeof(obj) !== "object") return false;
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) return false;
    }
    return true;
  }
  function filter_object(obj, filter_callback) {
    var in_place = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (in_place) {
      for (var _i6 = 0, _Object$keys2 = Object.keys(obj); _i6 < _Object$keys2.length; _i6++) {
        var k = _Object$keys2[_i6];
        if (!filter_callback(k, obj[k])) delete obj[k];
      }
      return obj;
    } else {
      var new_obj = {};
      for (var _i7 = 0, _Object$keys3 = Object.keys(obj); _i7 < _Object$keys3.length; _i7++) {
        var k = _Object$keys3[_i7];
        if (filter_callback(k, obj[k])) new_obj[k] = obj[k];
      }
      return new_obj;
    }
  }
  function array_equals(arr1, arr2) {
    var length = arr1.length;
    if (length !== arr2.length) return false;
    for (var i = 0; i < length; i++) {
      if (arr1[i] !== arr2[i]) return false;
    }
    return true;
  }
  function all_equal(array) {
    if (array.length <= 1) return true;
    for (var i = 1; i < array.length; i++) {
      if (array[0] !== array[i]) return false;
    }
    return true;
  }
  /** @template T1 @param {function():T1} cb @param {*} [default_value] @returns {T1} */
  function _try(cb) {
    var default_value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    try {
      return cb();
    } catch (_unused4) {
      return default_value;
    }
  }
  function clear(obj) {
    if (Array.isArray(obj)) {
      obj.splice(0, obj.length);
    } else if (_typeof(obj) === "object") {
      for (var _i8 = 0, _Object$keys4 = Object.keys(obj); _i8 < _Object$keys4.length; _i8++) {
        var k = _Object$keys4[_i8];
        delete obj[k];
      }
    }
  }
  function round_to_factor(num) {
    var f = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
    return Math.round(num / f) * f;
  }
  function ceil_to_factor(num) {
    var f = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
    return Math.ceil(num / f) * f;
  }
  function floor_to_factor(num) {
    var f = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
    return Math.floor(num / f) * f;
  }
  function round_precise(num) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var m = Math.pow(10, precision);
    return Math.round(num * m) / m;
  }
  function clamp$1(a) {
    var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return Math.min(max, Math.max(min, a));
  }
  function lerp(x, y, a) {
    return x * (1 - a) + y * a;
  }
  function invlerp(x, y, a) {
    return clamp$1((a - x) / (y - x));
  }
  function range(x1, y1, x2, y2, a) {
    return lerp(x2, y2, invlerp(x1, y1, a));
  }
  function loop(num, min, max) {
    var len = max - min;
    num = min + (len != 0 ? (num - min) % len : 0);
    if (num < min) num += len;
    return num;
  }
  function log$1(n, base) {
    return Math.log(n) / (base ? Math.log(base) : 1);
  }
  /** @param {Iterable<number>} iterable */
  function sum(iterable) {
    var total = 0.0;
    var _iterator17 = _createForOfIteratorHelper(iterable),
      _step17;
    try {
      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
        var num = _step17.value;
        total += num;
      }
    } catch (err) {
      _iterator17.e(err);
    } finally {
      _iterator17.f();
    }
    return total;
  }
  /** @param {Iterable<number>} iterable */
  function average(iterable) {
    var total = 0,
      n = 0;
    var _iterator18 = _createForOfIteratorHelper(iterable),
      _step18;
    try {
      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
        var num = _step18.value;
        total += num;
        n++;
      }
    } catch (err) {
      _iterator18.e(err);
    } finally {
      _iterator18.f();
    }
    return total / n;
  }
  /** @param {Iterable<number>} iterable */
  function get_best(iterable, cb) {
    var best_item = undefined,
      best_value = undefined,
      i = 0;
    var _iterator19 = _createForOfIteratorHelper(iterable),
      _step19;
    try {
      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
        var item = _step19.value;
        var curr_value = cb(item);
        if (i == 0 || curr_value > best_item) {
          best_item = item;
          best_value = curr_value;
        }
        i++;
      }
    } catch (err) {
      _iterator19.e(err);
    } finally {
      _iterator19.f();
    }
    return best_item;
  }
  function key_count(ob) {
    var i = 0;
    for (var k in ob) i++;
    return i;
  }
  /** @template T @param {Record<string,T>} ob @param {number} max_size  @returns {T[]} */
  function trim_object(ob, max_size) {
    var result = [];
    var num_keys = key_count(ob);
    for (var k in ob) {
      if (num_keys <= max_size) break;
      result.push(ob[k]);
      delete ob[k];
      num_keys--;
    }
    return result;
  }
  /**
   * @template T
   * @param {T[]} arr
   * @param {...(function(T):number)} cbs
  */
  function sort(arr) {
    for (var _len11 = arguments.length, cbs = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
      cbs[_key11 - 1] = arguments[_key11];
    }
    if (!cbs.length) cbs = [function (v) {
      return v;
    }];
    return arr.sort(function (a, b) {
      for (var _i9 = 0, _cbs = cbs; _i9 < _cbs.length; _i9++) {
        var cb = _cbs[_i9];
        var av = cb(a),
          bv = cb(b);
        if (!Array.isArray(av)) av = [av, "ASCENDING"];
        if (!Array.isArray(bv)) bv = [bv, "ASCENDING"];
        var m = 1;
        if (av[1] === "ASCENDING") m = 1;else if (av[1] === "DESCENDING") m = -1;else throw new Error();
        if (av[0] < bv[0]) return -1 * m;
        if (av[0] > bv[0]) return 1 * m;
      }
      return 0;
    });
  }
  function set_add(set, vals) {
    var _iterator20 = _createForOfIteratorHelper(vals),
      _step20;
    try {
      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
        var v = _step20.value;
        set.add(v);
      }
    } catch (err) {
      _iterator20.e(err);
    } finally {
      _iterator20.f();
    }
  }
  /* best(values, getter, comparator) {
  	var max, best;
  	for (var v of values) {
  		var a = getter(v);
  		if (comparator(a, max)) {
  			best = v;
  			max = a
  		}
  	}
  	return best;
  },
  min(values, cb) {
  	var min=Number.MAX_VALUE, best;
  	for (var v of values) {
  		var a = cb(v);
  		if (a < min) {
  			best = v;
  			min = a
  		}
  	}
  	return best;
  },
  max(values, cb) {
  	var max=Number.MIN_VALUE, best;
  	for (var v of values) {
  		var a = cb(v);
  		if (a > max) {
  			best = v;
  			max = a
  		}
  	}
  	return best;
  }, */
  function num_to_str(num) {
    var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    return num.toLocaleString(undefined, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals
    });
  }
  var Ease = {
    // no easing, no acceleration
    linear: function linear(t) {
      return t;
    },
    // accelerating from zero velocity
    inQuad: function inQuad(t) {
      return t * t;
    },
    // decelerating to zero velocity
    outQuad: function outQuad(t) {
      return t * (2 - t);
    },
    // acceleration until halfway, then deceleration
    inOutQuad: function inOutQuad(t) {
      return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    // accelerating from zero velocity 
    inCubic: function inCubic(t) {
      return t * t * t;
    },
    // decelerating to zero velocity 
    outCubic: function outCubic(t) {
      return --t * t * t + 1;
    },
    // acceleration until halfway, then deceleration 
    inOutCubic: function inOutCubic(t) {
      return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    },
    // accelerating from zero velocity 
    inQuart: function inQuart(t) {
      return t * t * t * t;
    },
    // decelerating to zero velocity 
    outQuart: function outQuart(t) {
      return 1 - --t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    inOutQuart: function inOutQuart(t) {
      return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    },
    // accelerating from zero velocity
    inQuint: function inQuint(t) {
      return t * t * t * t * t;
    },
    // decelerating to zero velocity
    outQuint: function outQuint(t) {
      return 1 + --t * t * t * t * t;
    },
    // acceleration until halfway, then deceleration 
    inOutQuint: function inOutQuint(t) {
      return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    }
  };
  function remove_trailing_slash(filename) {
    return String(filename).replace(/[\/\\]+$/, "");
  }
  function dirname(filename) {
    filename = String(filename);
    filename = remove_trailing_slash(filename);
    return filename.substring(0, filename.length - basename(filename).length - 1);
  }
  function basename(filename) {
    filename = String(filename);
    return remove_trailing_slash(filename).split(path_separator_regex).pop();
  }
  function split_ext(filename) {
    filename = String(filename);
    var i = filename.lastIndexOf(".");
    if (i == -1) return [filename, ""];
    return [filename.substr(0, i), filename.slice(i)];
  }
  function join_paths() {
    for (var _len12 = arguments.length, paths = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      paths[_key12] = arguments[_key12];
    }
    var last = paths.pop();
    return [].concat(_toConsumableArray(paths.map(function (f) {
      return remove_trailing_slash(f);
    })), [last]).join("/");
  }
  function relative_path(source, target) {
    var target_parts = String(target).split(path_separator_regex);
    var source_parts = String(source).split(path_separator_regex);
    if (array_equals(target_parts, source_parts)) {
      return ".";
    }
    var filename = target_parts.pop();
    var target_path = target_parts.join("/");
    var relative_parts = [];
    while (target_path.indexOf(source_parts.join("/")) === -1) {
      relative_parts.push("..");
      source_parts.pop();
    }
    relative_parts.push.apply(relative_parts, _toConsumableArray(target_parts.slice(source_parts.length)).concat([filename]));
    return relative_parts.join("/");
  }
  function split_datetime(date) {
    var apply_timezone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return function (date) {
      var date = +new Date(date);
      if (apply_timezone) date += -(+new Date(date).getTimezoneOffset() * 60 * 1000);
      var parts = new Date(date).toISOString().slice(0, -1).split("T");
      if (parts[0][0] == "+") parts[0] = parts[0].slice(1);
      return parts;
    }(date);
  }
  function join_datetime(parts) {
    var apply_timezone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var date = +new Date("".concat(parts.join(" "), "Z"));
    if (apply_timezone) date += +new Date(date).getTimezoneOffset() * 60 * 1000;
    return new Date(date);
  }
  function get_property_descriptor(obj, property) {
    while (obj) {
      var d = Object.getOwnPropertyDescriptor(obj, property);
      if (d) return d;
      obj = Object.getPrototypeOf(obj);
    }
    return null;
  }
  /** @return {string[]} */
  function get_property_keys(obj) {
    var proto = Object.getPrototypeOf(obj);
    var inherited = proto ? get_property_keys(proto) : [];
    var seen = new Set(inherited);
    return [].concat(_toConsumableArray(inherited), _toConsumableArray(Object.getOwnPropertyNames(obj).filter(function (k) {
      return !seen.has(k);
    })));
  }
  /* *walk(o, children_delegate) {
  	for (var c of children_delegate.apply(o, [o])) {
  		yield c;
  		var children = walk(c,children_delegate)
  		if (children && Symbol.iterator in children) {
  			for (var sc of children) {
  				yield sc;
  			}
  		}
  	}
  }, */
  /** @template T @param {T} o @param {function(T):Iterable<T>} children_cb */
  function flatten_tree(o, children_cb) {
    /** @type {T[]} */
    var result = [];
    var _next3 = function next(o) {
      result.push(o);
      var children = children_cb.apply(o, [o]);
      if (!children || !(Symbol.iterator in children)) return;
      var _iterator21 = _createForOfIteratorHelper(children),
        _step21;
      try {
        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
          var c = _step21.value;
          _next3(c);
        }
      } catch (err) {
        _iterator21.e(err);
      } finally {
        _iterator21.f();
      }
    };
    _next3(o);
    return result;
  }
  /** @template T @param {T} obj @param {Function(any):any} replacer @return {T} */
  function deep_copy(obj, replacer) {
    if (_typeof(obj) !== 'object' || obj === null) return obj;
    return JSON.parse(replacer ? JSON.stringify(obj, replacer) : JSON.stringify(obj));
  }
  function deep_filter(obj, cb) {
    var new_obj = Array.isArray(obj) ? [] : {};
    for (var _i10 = 0, _Object$keys5 = Object.keys(obj); _i10 < _Object$keys5.length; _i10++) {
      var k = _Object$keys5[_i10];
      if (_typeof(obj[k]) === "object" && obj[k] !== null) new_obj[k] = deep_filter(obj[k], cb);else if (cb.apply(obj, [k, obj[k]])) new_obj[k] = obj[k];
    }
    return new_obj;
  }
  function deep_merge(dst, src) {
    var delete_nulls = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var info = {
      changes: 0
    };
    var _deep_merge = function deep_merge(dst, src) {
      var is_array = Array.isArray(src);
      for (var k in src) {
        if (_typeof(src[k]) === 'object' && src[k] !== null) {
          if (_typeof(dst[k]) !== "object" || dst[k] === null) {
            dst[k] = Array.isArray(src[k]) ? [] : {};
            info.changes++;
          }
          _deep_merge(dst[k], src[k]);
        } else {
          if (dst[k] !== src[k]) info.changes++;
          if (!is_array && delete_nulls && src[k] === null) delete dst[k];else dst[k] = src[k];
        }
      }
      if (is_array) dst.length = src.length;
    };
    _deep_merge(dst, src);
    return info;
  }
  function deep_assign(o1) {
    if (_typeof(o1) !== "object") throw new Error("deep_assign requires Object as first argument");
    for (var _len13 = arguments.length, objects = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
      objects[_key13 - 1] = arguments[_key13];
    }
    for (var _i11 = 0, _objects = objects; _i11 < _objects.length; _i11++) {
      var o2 = _objects[_i11];
      deep_merge(o1, o2);
    }
    return o1;
  }
  // syncs 2 objects to become identical, everything besides key order.
  function deep_sync(dst, src) {
    var dst_keys = Object.keys(dst);
    for (var k in src) {
      if (src[k] === dst[k]) continue;
      if (src[k] !== null && dst[k] !== null && _typeof(src[k]) === 'object' && _typeof(dst[k]) === 'object' && Array.isArray(src[k]) == Array.isArray(dst[k])) {
        deep_sync(dst[k], src[k]);
      } else {
        dst[k] = deep_copy(src[k]);
      }
    }
    if (Array.isArray(src)) dst.length = src.length;
    for (var _i12 = 0, _dst_keys = dst_keys; _i12 < _dst_keys.length; _i12++) {
      var k = _dst_keys[_i12];
      if (!(k in src)) delete dst[k];
    }
  }
  /* deep_diff(o1, o2) {
  	var changes = [];
  	function _deep_diff(o1,o2,path) {
  		if (typeof o1 !== "object" || typeof o2 !== "object") {
  			var type;
  			if (o1 === o2) return;
  			else if (o1 === undefined) type = "created";
  			else if (o2 === undefined) type = "deleted";
  			else type = "changed";
  			changes.push({
  				path,
  				type,
  				old_value: o1,
  				new_value: o2,
  			});
  		} else {
  			for (var key in o1) {
  				_deep_diff(o1[key], o2[key], [...path, key]);
  			}
  			for (var key in o2) {
  				if (o1[key] === undefined) _deep_diff(undefined, o2[key], [...path, key]);
  			}
  		}
  	}
  	_deep_diff(o1,o2,[]);
  	return changes;
  }, */
  function deep_equals(o1, o2) {
    var t1 = _typeof(o1);
    var t2 = _typeof(o2);
    if (t1 === "object" && t2 === "object" && o1 !== null && o2 !== null) {
      for (var k in o1) {
        if (!deep_equals(o1[k], o2[k])) return false;
      }
      for (var k in o2) {
        if (!(k in o1)) return false;
      }
      return true;
    } else {
      if (t1 == "number" && t2 == "number" && isNaN(o1) && isNaN(o2)) return true;
      if (o1 === o2) return true;
      return false;
    }
  }
  /* deep_equals(a, b) {
  	if (a === b) return true;
  	var [a_type,b_type] = [typeof a, typeof b];
  	if (a_type !== b_type) return false;
  	if (a_type === 'number' && isNaN(a) && isNaN(b)) return true;
  	if (a_type !== "object") return a === b;
  	var [a_keys,b_keys] = [Object.keys(a),Object.keys(b)];
  	if (a_keys.length !== b_keys.length) return false;
  	if (!a_keys.every((key)=>b.hasOwnProperty(key))) return false;
  	return a_keys.every((key)=>deep_equals(a[key], b[key]));
  }, */
  function deep_diff(o1, o2) {
    function _deep_diff(o1, o2) {
      if (_typeof(o1) === "object" && _typeof(o2) === "object" && o1 !== null && o2 !== null) {
        var diff = {},
          diffs = 0;
        for (var k in o1) {
          var d = _deep_diff(o1[k], o2[k]);
          if (d) {
            diff[k] = d;
            diffs++;
          }
        }
        for (var k in o2) {
          if (k in o1) continue;
          var d = _deep_diff(undefined, o2[k]);
          if (d) {
            diff[k] = d;
            diffs++;
          }
        }
        if (diffs) {
          return diff;
        }
      } else {
        if (deep_equals(o1, o2)) return;
        return new Diff(o1, o2);
      }
    }
    return _deep_diff(o1, o2) || {};
  }

  // flattens tree like object structure to list of paths and values
  function deep_entries(o) {
    var only_values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    if (o == null) throw new Error("Cannot convert undefined or null to object");
    var entries = [];
    var _walk = function walk(o, path) {
      if (_typeof(o) === "object" && o !== null) {
        if (!only_values && path.length) entries.push([path, o]);
        for (var k in o) {
          var new_path = [].concat(_toConsumableArray(path), [k]);
          if (filter && !filter.apply(o, [k, o[k], new_path])) {
            entries.push([new_path, o[k]]);
            continue;
          }
          _walk(o[k], new_path);
        }
      } else {
        entries.push([path, o]);
      }
    };
    _walk(o, []);
    return entries;
  }
  function deep_keys(o) {
    var only_values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return deep_entries(o, only_values, filter).map(function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
        k = _ref5[0];
        _ref5[1];
      return k;
    });
  }
  function deep_values(o) {
    var only_values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return deep_entries(o, only_values, filter).map(function (_ref6) {
      var _ref7 = _slicedToArray(_ref6, 2);
        _ref7[0];
        var v = _ref7[1];
      return v;
    });
  }
  function pathed_key_to_lookup(key, value) {
    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = typeof key === "string" ? key.split("/") : _toConsumableArray(key);
    var curr = target;
    for (var i = 0; i < path.length - 1; i++) {
      var p = path[i];
      if (_typeof(curr[p]) !== "object" || curr[p] === null) curr[p] = {};
      curr = curr[p];
    }
    curr[path[path.length - 1]] = value;
    return target;
  }
  function tree_from_entries(entries) {
    var root = {};
    if (!Array.isArray(entries)) entries = [entries];
    var _iterator22 = _createForOfIteratorHelper(entries),
      _step22;
    try {
      for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
        var c = _step22.value;
        if (Array.isArray(c)) {
          deep_merge(root, pathed_key_to_lookup(c[0], c[1]));
        } else {
          for (var k in c) {
            deep_merge(root, pathed_key_to_lookup(k, c[k]));
          }
        }
      }
    } catch (err) {
      _iterator22.e(err);
    } finally {
      _iterator22.f();
    }
    return root;
  }
  /** @typedef {[id:any,pid:any]} TreeCallbackResult */
  /** @template T @typedef {{value:T,children:TreeNode<T>[]}} TreeNode<T> */
  /** @template T @param {T[]} list @param {function(T):TreeCallbackResult} cb */
  function tree(list, cb) {
    var nodes = {},
      /** @type {TreeCallbackResult[]} */infos = [],
      /** @type {TreeNode<T>[]} */root_nodes = [];
    var i;
    for (i = 0; i < list.length; i++) {
      var info = infos[i] = cb(list[i]);
      nodes[info[0]] = {
        value: list[i],
        children: []
      };
    }
    for (i = 0; i < list.length; i++) {
      var info = infos[i];
      var node = nodes[info[0]];
      var parent_node = nodes[info[1]];
      if (parent_node) {
        parent_node.children.push(node);
      } else {
        root_nodes.push(node);
      }
    }
    return root_nodes;
  }
  function deep_map(o, cb) {
    if (_typeof(o) !== "object" || o === null) return;
    var new_o = {};
    for (var k in o) {
      if (_typeof(o[k]) === "object" && o[k] !== null) {
        new_o[k] = deep_map(o[k], cb);
      } else {
        new_o[k] = cb.apply(o, [k, o[k]]);
      }
    }
    return new_o;
  }
  function deep_walk(o, delegate_filter) {
    var _deep_walk = function deep_walk(o, delegate_filter, path) {
      if (_typeof(o) !== "object" || o === null) return;
      for (var k in o) {
        if (delegate_filter && delegate_filter.apply(o, [k, o[k], [].concat(_toConsumableArray(path), [k])]) === false) continue;
        _deep_walk(o[k], delegate_filter, [].concat(_toConsumableArray(path), [k]));
      }
    };
    _deep_walk(o, delegate_filter, []);
  }
  function replace_async(_x2, _x3, _x4) {
    return _replace_async.apply(this, arguments);
  }
  function _replace_async() {
    _replace_async = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(str, re, callback) {
      var parts, i, m, args, strings;
      return _regeneratorRuntime().wrap(function _callee4$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            str = String(str);
            parts = [], i = 0;
            if (!(re instanceof RegExp)) {
              _context7.next = 15;
              break;
            }
            if (re.global) re.lastIndex = i;
          case 4:
            if (!(m = re.exec(str))) {
              _context7.next = 13;
              break;
            }
            args = m.concat([m.index, m.input]);
            parts.push(str.slice(i, m.index), callback.apply(null, args));
            i = re.lastIndex;
            if (re.global) {
              _context7.next = 10;
              break;
            }
            return _context7.abrupt("break", 13);
          case 10:
            // for non-global regexes only take the first match
            if (m[0].length == 0) re.lastIndex++;
            _context7.next = 4;
            break;
          case 13:
            _context7.next = 19;
            break;
          case 15:
            re = String(re);
            i = str.indexOf(re);
            parts.push(str.slice(0, i), callback.apply(null, [re, i, str]));
            i += re.length;
          case 19:
            parts.push(str.slice(i));
            _context7.next = 22;
            return Promise.all(parts);
          case 22:
            strings = _context7.sent;
            return _context7.abrupt("return", strings.join(""));
          case 24:
          case "end":
            return _context7.stop();
        }
      }, _callee4);
    }));
    return _replace_async.apply(this, arguments);
  }
  function get$1(fn_this, fn_path) {
    // if (typeof fn_path === "string") fn_path = fn_path.split(/\./);
    if (!Array.isArray(fn_path)) fn_path = [fn_path];
    var fn_ref = fn_this;
    try {
      var _iterator23 = _createForOfIteratorHelper(fn_path),
        _step23;
      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
          var fn_part = _step23.value;
          fn_this = fn_ref;
          var descriptor = get_property_descriptor(fn_ref, fn_part);
          if (descriptor && descriptor.get) fn_ref = descriptor.get.call(fn_this);else fn_ref = fn_ref[fn_part];
          // fn_ref = descriptor ? (descriptor.get ? descriptor.get.call(fn_this) : descriptor.value) : undefined;
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
    } catch (_unused5) {
      throw new RefException("".concat(fn_this, " -> ").concat(fn_path));
    }
    return fn_ref;
  }
  function set$1(fn_this, fn_path, fn_value) {
    // if (typeof fn_path === "string") fn_path = fn_path.split(/\./);
    if (!Array.isArray(fn_path)) fn_path = [fn_path];
    var fn_ref = get$1(fn_this, fn_path.slice(0, -1));
    var prop = fn_path.slice(-1)[0];
    var descriptor = get_property_descriptor(fn_ref, prop);
    if (descriptor && descriptor.set) descriptor.set.call(fn_this, [fn_value]);else fn_ref[prop] = fn_value;
    return true;
  }
  function _delete(fn_this, fn_path) {
    // if (typeof fn_path === "string") fn_path = fn_path.split(/\./);
    if (!Array.isArray(fn_path)) fn_path = [fn_path];
    try {
      var fn_ref = get$1(fn_this, fn_path.slice(0, -1));
      var prop = fn_path.slice(-1)[0];
      delete fn_ref[prop];
    } catch (_unused6) {}
  }
  function call(fn_this, fn_path, fn_args) {
    var args = Array.prototype.slice.call(arguments);
    // if (typeof fn_path === "string") fn_path = fn_path.split(/\./);
    if (!Array.isArray(fn_path)) fn_path = [fn_path];
    if (!Array.isArray(fn_args)) fn_args = [fn_args];
    var fn_this = get$1(fn_this, fn_path.slice(0, -1));
    var fn_ref = get$1(fn_this, fn_path.slice(-1));
    if (fn_ref) {
      return fn_ref.apply(fn_this, fn_args);
    } else {
      throw new RefException("Bad call ref: ".concat(args.join(", ")));
    }
  }
  function build_url() {
    var config, url;
    for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
      args[_key14] = arguments[_key14];
    }
    if (args.length == 1) {
      config = args[0];
    } else {
      url = args[0];
      config = args[1];
    }
    url = String(url || (typeof window !== "undefined" && window.location ? window.location.origin : null) || "https://localhost");
    var protocol = url.match(/^([^:]+:)?\/\//)[0];
    url = "https://" + url.slice(protocol.length);
    if (config.protocol) protocol = config.protocol;
    var url_ob = new URL(url);
    for (var k in config) url_ob[k] = config[k];
    url = url_ob.toString();
    if (url_ob.protocol != protocol) url = url.replace("https:", protocol);
    return url;
  }
  function path_to_file_uri(path) {
    if (!path.startsWith("/")) path = "/" + path;
    return new URL("file://" + path).toString();
  }
  function file_uri_to_path(uri) {
    if (typeof uri !== 'string' || uri.substring(0, 7) !== 'file://') {
      throw new TypeError('Must pass in a file:// URI to convert to a file path');
    }
    var rest = decodeURI(uri.substring(7));
    var firstSlash = rest.indexOf('/');
    var host = rest.substring(0, firstSlash);
    var path = rest.substring(firstSlash + 1);
    if (host === 'localhost') host = '';
    if (host) host = "//" + host;
    path = path.replace(/^(.+)\|/, '$1:');
    // path = path.replace(/\//g, '\\');
    // if not windows path...
    if (!/^.+:/.test(path)) {
      path = "/" + path;
    }
    return host + path;
  }
  function try_file_uri_to_path(uri) {
    try {
      return file_uri_to_path(uri);
    } catch (e) {
      return uri;
    }
  }
  /* get_random_values(array) {
  	for (let i = 0, l = array.length; i < l; i++) {
  			array[i] = Math.floor(Math.random() * 256);
  	}
  	return array;
  }, */
  function convert_links_to_html(str) {
    return str.replace(/(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim, '<a href="$1" target="_blank">$1</a>');
  }
  function convert_bytes(num) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    num = Math.abs(num);
    var divider = 1;
    for (var _i13 = 0, _arr2 = ["bytes", "KB", "MB", "GB", "TB", "PB"]; _i13 < _arr2.length; _i13++) {
      x = _arr2[_i13];
      if (num / divider < 1024.0) break;
      divider *= 1024.0;
    }
    return "".concat((num / divider).toFixed(precision), " ").concat(x);
  }
  function get_default_stream(streams, type) {
    var index_map = new Map();
    streams.forEach(function (s, i) {
      return index_map.set(s, i);
    });
    if (type === "subtitle") streams = streams.filter(function (s) {
      return s["default"] || s.forced;
    });
    return sort(_toConsumableArray(streams), function (s) {
      return +s.forced;
    }, function (s) {
      return +s["default"];
    }, function (s) {
      return -index_map.get(s);
    }).pop();
  }

  /* fmod(a,b) {
  	return Number((a - (Math.floor(a / b) * b)));
  } */

  // the following junk prevents node 16.13.0 + vs code crashing when I start the debugger (weird but true)
  // a:1,
  // b:1,
  // c:1,
  var _cache = /*#__PURE__*/new WeakMap();
  var _limit = /*#__PURE__*/new WeakMap();
  var _n = /*#__PURE__*/new WeakMap();
  var Cache = /*#__PURE__*/function () {
    function Cache() {
      var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      _classCallCheck(this, Cache);
      _classPrivateFieldInitSpec(this, _cache, {});
      _classPrivateFieldInitSpec(this, _limit, 0);
      _classPrivateFieldInitSpec(this, _n, 0);
      _classPrivateFieldSet(_limit, this, limit);
    }
    return _createClass(Cache, [{
      key: "has",
      value: function has(key) {
        return key in _classPrivateFieldGet(_cache, this);
      }
    }, {
      key: "get",
      value: function get(key) {
        return _classPrivateFieldGet(_cache, this)[key];
      }
    }, {
      key: "set",
      value: function set(key, value) {
        var _this$n3;
        if (key in _classPrivateFieldGet(_cache, this)) {
          var _this$n;
          delete _classPrivateFieldGet(_cache, this)[key];
          _classPrivateFieldSet(_n, this, (_this$n = _classPrivateFieldGet(_n, this), _this$n--, _this$n));
        }
        _classPrivateFieldGet(_cache, this)[key] = value;
        _classPrivateFieldSet(_n, this, (_this$n3 = _classPrivateFieldGet(_n, this), _this$n3++, _this$n3));
        if (_classPrivateFieldGet(_limit, this) > 0) {
          for (var k in _classPrivateFieldGet(_cache, this)) {
            var _this$n5;
            if (_classPrivateFieldGet(_n, this) <= _classPrivateFieldGet(_limit, this)) break;
            delete _classPrivateFieldGet(_cache, this)[k];
            _classPrivateFieldSet(_n, this, (_this$n5 = _classPrivateFieldGet(_n, this), _this$n5--, _this$n5));
          }
        }
      }
    }]);
  }();
  function nearest(num) {
    var minDiff = Number.MAX_VALUE;
    for (var _len15 = arguments.length, values = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
      values[_key15 - 1] = arguments[_key15];
    }
    for (var _i14 = 0, _values = values; _i14 < _values.length; _i14++) {
      var val = _values[_i14];
      var m = Math.abs(num - values[i]);
      if (m < minDiff) {
        minDiff = m;
        curr = val;
      }
    }
    return curr;
  }
  function truncate(str, len) {
    var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
    str = String(str);
    if (str.length > len) str = str.slice(0, len) + suffix;
    return str;
  }

  /** @returns {Promise & {resolve:function(any):void, reject:function(any):void}} */
  function deferred() {
    var resolve, reject;
    var prom = new Promise(function (_resolve, _reject) {
      resolve = _resolve;
      reject = _reject;
    });
    prom.resolve = resolve;
    prom.reject = reject;
    return prom;
  }
  function fix_url(_url) {
    _url = String(_url).trim();
    var url;
    try {
      url = new URL(url);
      if (!url.hostname) url = new URL("https://" + _url);
    } catch (_unused7) {
      try {
        url = new URL("https://" + _url);
      } catch (_unused8) {
        return;
      }
    }
    return url.toString();
  }

  var md5 = libExports$1.md5;

  var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Cache: Cache,
    Color: Color,
    Diff: Diff,
    Ease: Ease,
    EventEmitter: EventEmitter$1,
    Interval: Interval,
    Observer: Observer,
    OrderedSet: OrderedSet,
    Point: Point,
    PromisePool: PromisePool,
    RangeTree: RangeTree,
    Rectangle: Rectangle,
    RefException: RefException,
    StopWatch: StopWatch,
    TimeoutError: TimeoutError,
    Timer: Timer,
    URLParams: URLParams,
    all_equal: all_equal,
    almost_equal: almost_equal,
    array_equals: array_equals,
    array_move: array_move,
    array_move_before: array_move_before,
    array_remove: array_remove,
    array_repeat: array_repeat,
    array_unique: array_unique,
    average: average,
    basename: basename,
    build_url: build_url,
    call: call,
    capitalize: capitalize,
    ceil_to_factor: ceil_to_factor,
    clamp: clamp$1,
    clear: clear,
    convert_bytes: convert_bytes,
    convert_links_to_html: convert_links_to_html,
    date_to_string: date_to_string,
    debounce: debounce$1,
    deep_assign: deep_assign,
    deep_copy: deep_copy,
    deep_diff: deep_diff,
    deep_entries: deep_entries,
    deep_equals: deep_equals,
    deep_filter: deep_filter,
    deep_keys: deep_keys,
    deep_map: deep_map,
    deep_merge: deep_merge,
    deep_sync: deep_sync,
    deep_values: deep_values,
    deep_walk: deep_walk,
    deferred: deferred,
    delete: _delete,
    dirname: dirname,
    domain_match: domain_match,
    emoji_regex: emoji_regex,
    escape_regex: escape_regex,
    file_uri_to_path: file_uri_to_path,
    filter_object: filter_object,
    fix_url: fix_url,
    flatten_tree: flatten_tree,
    floor_to_factor: floor_to_factor,
    format_bytes: format_bytes,
    get: get$1,
    get_best: get_best,
    get_default_stream: get_default_stream,
    get_property_descriptor: get_property_descriptor,
    get_property_keys: get_property_keys,
    group_by: group_by,
    invlerp: invlerp,
    is_absolute_path: is_absolute_path,
    is_empty: is_empty,
    is_ip_local: is_ip_local,
    is_numeric: is_numeric,
    is_path_remote: is_path_remote,
    is_plain_object: is_plain_object,
    is_uri: is_uri,
    is_valid_ip: is_valid_ip,
    is_valid_rtmp_url: is_valid_rtmp_url,
    is_valid_url: is_valid_url,
    iterate_unique: iterate_unique,
    join_datetime: join_datetime,
    join_paths: join_paths,
    kebabcase: kebabcase,
    key_count: key_count,
    lerp: lerp,
    log: log$1,
    loop: loop,
    map_group_by: map_group_by,
    matchAll: matchAll,
    md5: md5,
    ms_to_human_readable_str: ms_to_human_readable_str,
    ms_to_shorthand_str: ms_to_shorthand_str,
    ms_to_timespan_str: ms_to_timespan_str,
    nearest: nearest,
    num_to_str: num_to_str,
    options_proxy: options_proxy,
    path_separator_regex: path_separator_regex,
    path_to_file_uri: path_to_file_uri,
    pathed_key_to_lookup: pathed_key_to_lookup,
    promise_all_object: promise_all_object,
    promise_pool: promise_pool,
    promise_timeout: promise_timeout,
    promise_wait_atleast: promise_wait_atleast,
    random: random,
    random_hex_string: random_hex_string,
    random_int: random_int,
    random_string: random_string,
    range: range,
    regex: regex,
    relative_path: relative_path,
    remove_duplicates: remove_duplicates,
    remove_emojis: remove_emojis,
    remove_nulls: remove_nulls,
    remove_trailing_slash: remove_trailing_slash,
    replace_all: replace_all,
    replace_async: replace_async,
    round_precise: round_precise,
    round_to_factor: round_to_factor,
    sanitize_filename: sanitize_filename,
    seconds_to_human_readable_str: seconds_to_human_readable_str,
    seconds_to_timespan_str: seconds_to_timespan_str,
    set: set$1,
    set_add: set_add,
    set_difference: set_difference,
    set_intersection: set_intersection,
    set_union: set_union,
    sets_equal: sets_equal,
    shuffle: shuffle,
    sort: sort,
    split_after_first_line: split_after_first_line,
    split_datetime: split_datetime,
    split_ext: split_ext,
    split_path: split_path,
    split_string: split_string,
    string_to_bytes: string_to_bytes,
    sum: sum,
    throttle: throttle$1,
    time_delta_readable: time_delta_readable,
    time_diff_readable: time_diff_readable,
    timeout: timeout,
    timespan_str_to_ms: timespan_str_to_ms,
    timespan_str_to_seconds: timespan_str_to_seconds,
    transpose: transpose,
    tree: tree,
    tree_from_entries: tree_from_entries,
    trim_object: trim_object,
    truncate: truncate,
    try: _try,
    try_file_uri_to_path: try_file_uri_to_path,
    uniquify: uniquify,
    websocket_ready: websocket_ready,
    zip: zip
  });

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs$1 (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var jquery$1 = {exports: {}};

  /*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   */

  (function (module) {
  	( function( global, factory ) {

  		{

  			// For CommonJS and CommonJS-like environments where a proper `window`
  			// is present, execute the factory and get jQuery.
  			// For environments that do not have a `window` with a `document`
  			// (such as Node.js), expose a factory as module.exports.
  			// This accentuates the need for the creation of a real `window`.
  			// e.g. var jQuery = require("jquery")(window);
  			// See ticket trac-14549 for more info.
  			module.exports = global.document ?
  				factory( global, true ) :
  				function( w ) {
  					if ( !w.document ) {
  						throw new Error( "jQuery requires a window with a document" );
  					}
  					return factory( w );
  				};
  		}

  	// Pass this if window is not defined yet
  	} )( typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

  	var arr = [];

  	var getProto = Object.getPrototypeOf;

  	var slice = arr.slice;

  	var flat = arr.flat ? function( array ) {
  		return arr.flat.call( array );
  	} : function( array ) {
  		return arr.concat.apply( [], array );
  	};


  	var push = arr.push;

  	var indexOf = arr.indexOf;

  	var class2type = {};

  	var toString = class2type.toString;

  	var hasOwn = class2type.hasOwnProperty;

  	var fnToString = hasOwn.toString;

  	var ObjectFunctionString = fnToString.call( Object );

  	var support = {};

  	var isFunction = function isFunction( obj ) {

  			// Support: Chrome <=57, Firefox <=52
  			// In some browsers, typeof returns "function" for HTML <object> elements
  			// (i.e., `typeof document.createElement( "object" ) === "function"`).
  			// We don't want to classify *any* DOM node as a function.
  			// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
  			// Plus for old WebKit, typeof returns "function" for HTML collections
  			// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
  			return typeof obj === "function" && typeof obj.nodeType !== "number" &&
  				typeof obj.item !== "function";
  		};


  	var isWindow = function isWindow( obj ) {
  			return obj != null && obj === obj.window;
  		};


  	var document = window.document;



  		var preservedScriptAttributes = {
  			type: true,
  			src: true,
  			nonce: true,
  			noModule: true
  		};

  		function DOMEval( code, node, doc ) {
  			doc = doc || document;

  			var i, val,
  				script = doc.createElement( "script" );

  			script.text = code;
  			if ( node ) {
  				for ( i in preservedScriptAttributes ) {

  					// Support: Firefox 64+, Edge 18+
  					// Some browsers don't support the "nonce" property on scripts.
  					// On the other hand, just using `getAttribute` is not enough as
  					// the `nonce` attribute is reset to an empty string whenever it
  					// becomes browsing-context connected.
  					// See https://github.com/whatwg/html/issues/2369
  					// See https://html.spec.whatwg.org/#nonce-attributes
  					// The `node.getAttribute` check was added for the sake of
  					// `jQuery.globalEval` so that it can fake a nonce-containing node
  					// via an object.
  					val = node[ i ] || node.getAttribute && node.getAttribute( i );
  					if ( val ) {
  						script.setAttribute( i, val );
  					}
  				}
  			}
  			doc.head.appendChild( script ).parentNode.removeChild( script );
  		}


  	function toType( obj ) {
  		if ( obj == null ) {
  			return obj + "";
  		}

  		// Support: Android <=2.3 only (functionish RegExp)
  		return typeof obj === "object" || typeof obj === "function" ?
  			class2type[ toString.call( obj ) ] || "object" :
  			typeof obj;
  	}
  	/* global Symbol */
  	// Defining this global in .eslintrc.json would create a danger of using the global
  	// unguarded in another place, it seems safer to define global only for this module



  	var version = "3.7.1",

  		rhtmlSuffix = /HTML$/i,

  		// Define a local copy of jQuery
  		jQuery = function( selector, context ) {

  			// The jQuery object is actually just the init constructor 'enhanced'
  			// Need init if jQuery is called (just allow error to be thrown if not included)
  			return new jQuery.fn.init( selector, context );
  		};

  	jQuery.fn = jQuery.prototype = {

  		// The current version of jQuery being used
  		jquery: version,

  		constructor: jQuery,

  		// The default length of a jQuery object is 0
  		length: 0,

  		toArray: function() {
  			return slice.call( this );
  		},

  		// Get the Nth element in the matched element set OR
  		// Get the whole matched element set as a clean array
  		get: function( num ) {

  			// Return all the elements in a clean array
  			if ( num == null ) {
  				return slice.call( this );
  			}

  			// Return just the one element from the set
  			return num < 0 ? this[ num + this.length ] : this[ num ];
  		},

  		// Take an array of elements and push it onto the stack
  		// (returning the new matched element set)
  		pushStack: function( elems ) {

  			// Build a new jQuery matched element set
  			var ret = jQuery.merge( this.constructor(), elems );

  			// Add the old object onto the stack (as a reference)
  			ret.prevObject = this;

  			// Return the newly-formed element set
  			return ret;
  		},

  		// Execute a callback for every element in the matched set.
  		each: function( callback ) {
  			return jQuery.each( this, callback );
  		},

  		map: function( callback ) {
  			return this.pushStack( jQuery.map( this, function( elem, i ) {
  				return callback.call( elem, i, elem );
  			} ) );
  		},

  		slice: function() {
  			return this.pushStack( slice.apply( this, arguments ) );
  		},

  		first: function() {
  			return this.eq( 0 );
  		},

  		last: function() {
  			return this.eq( -1 );
  		},

  		even: function() {
  			return this.pushStack( jQuery.grep( this, function( _elem, i ) {
  				return ( i + 1 ) % 2;
  			} ) );
  		},

  		odd: function() {
  			return this.pushStack( jQuery.grep( this, function( _elem, i ) {
  				return i % 2;
  			} ) );
  		},

  		eq: function( i ) {
  			var len = this.length,
  				j = +i + ( i < 0 ? len : 0 );
  			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
  		},

  		end: function() {
  			return this.prevObject || this.constructor();
  		},

  		// For internal use only.
  		// Behaves like an Array's method, not like a jQuery method.
  		push: push,
  		sort: arr.sort,
  		splice: arr.splice
  	};

  	jQuery.extend = jQuery.fn.extend = function() {
  		var options, name, src, copy, copyIsArray, clone,
  			target = arguments[ 0 ] || {},
  			i = 1,
  			length = arguments.length,
  			deep = false;

  		// Handle a deep copy situation
  		if ( typeof target === "boolean" ) {
  			deep = target;

  			// Skip the boolean and the target
  			target = arguments[ i ] || {};
  			i++;
  		}

  		// Handle case when target is a string or something (possible in deep copy)
  		if ( typeof target !== "object" && !isFunction( target ) ) {
  			target = {};
  		}

  		// Extend jQuery itself if only one argument is passed
  		if ( i === length ) {
  			target = this;
  			i--;
  		}

  		for ( ; i < length; i++ ) {

  			// Only deal with non-null/undefined values
  			if ( ( options = arguments[ i ] ) != null ) {

  				// Extend the base object
  				for ( name in options ) {
  					copy = options[ name ];

  					// Prevent Object.prototype pollution
  					// Prevent never-ending loop
  					if ( name === "__proto__" || target === copy ) {
  						continue;
  					}

  					// Recurse if we're merging plain objects or arrays
  					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
  						( copyIsArray = Array.isArray( copy ) ) ) ) {
  						src = target[ name ];

  						// Ensure proper type for the source value
  						if ( copyIsArray && !Array.isArray( src ) ) {
  							clone = [];
  						} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
  							clone = {};
  						} else {
  							clone = src;
  						}
  						copyIsArray = false;

  						// Never move original objects, clone them
  						target[ name ] = jQuery.extend( deep, clone, copy );

  					// Don't bring in undefined values
  					} else if ( copy !== undefined ) {
  						target[ name ] = copy;
  					}
  				}
  			}
  		}

  		// Return the modified object
  		return target;
  	};

  	jQuery.extend( {

  		// Unique for each copy of jQuery on the page
  		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

  		// Assume jQuery is ready without the ready module
  		isReady: true,

  		error: function( msg ) {
  			throw new Error( msg );
  		},

  		noop: function() {},

  		isPlainObject: function( obj ) {
  			var proto, Ctor;

  			// Detect obvious negatives
  			// Use toString instead of jQuery.type to catch host objects
  			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
  				return false;
  			}

  			proto = getProto( obj );

  			// Objects with no prototype (e.g., `Object.create( null )`) are plain
  			if ( !proto ) {
  				return true;
  			}

  			// Objects with prototype are plain iff they were constructed by a global Object function
  			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
  			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
  		},

  		isEmptyObject: function( obj ) {
  			var name;

  			for ( name in obj ) {
  				return false;
  			}
  			return true;
  		},

  		// Evaluates a script in a provided context; falls back to the global one
  		// if not specified.
  		globalEval: function( code, options, doc ) {
  			DOMEval( code, { nonce: options && options.nonce }, doc );
  		},

  		each: function( obj, callback ) {
  			var length, i = 0;

  			if ( isArrayLike( obj ) ) {
  				length = obj.length;
  				for ( ; i < length; i++ ) {
  					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  						break;
  					}
  				}
  			} else {
  				for ( i in obj ) {
  					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  						break;
  					}
  				}
  			}

  			return obj;
  		},


  		// Retrieve the text value of an array of DOM nodes
  		text: function( elem ) {
  			var node,
  				ret = "",
  				i = 0,
  				nodeType = elem.nodeType;

  			if ( !nodeType ) {

  				// If no nodeType, this is expected to be an array
  				while ( ( node = elem[ i++ ] ) ) {

  					// Do not traverse comment nodes
  					ret += jQuery.text( node );
  				}
  			}
  			if ( nodeType === 1 || nodeType === 11 ) {
  				return elem.textContent;
  			}
  			if ( nodeType === 9 ) {
  				return elem.documentElement.textContent;
  			}
  			if ( nodeType === 3 || nodeType === 4 ) {
  				return elem.nodeValue;
  			}

  			// Do not include comment or processing instruction nodes

  			return ret;
  		},

  		// results is for internal usage only
  		makeArray: function( arr, results ) {
  			var ret = results || [];

  			if ( arr != null ) {
  				if ( isArrayLike( Object( arr ) ) ) {
  					jQuery.merge( ret,
  						typeof arr === "string" ?
  							[ arr ] : arr
  					);
  				} else {
  					push.call( ret, arr );
  				}
  			}

  			return ret;
  		},

  		inArray: function( elem, arr, i ) {
  			return arr == null ? -1 : indexOf.call( arr, elem, i );
  		},

  		isXMLDoc: function( elem ) {
  			var namespace = elem && elem.namespaceURI,
  				docElem = elem && ( elem.ownerDocument || elem ).documentElement;

  			// Assume HTML when documentElement doesn't yet exist, such as inside
  			// document fragments.
  			return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
  		},

  		// Support: Android <=4.0 only, PhantomJS 1 only
  		// push.apply(_, arraylike) throws on ancient WebKit
  		merge: function( first, second ) {
  			var len = +second.length,
  				j = 0,
  				i = first.length;

  			for ( ; j < len; j++ ) {
  				first[ i++ ] = second[ j ];
  			}

  			first.length = i;

  			return first;
  		},

  		grep: function( elems, callback, invert ) {
  			var callbackInverse,
  				matches = [],
  				i = 0,
  				length = elems.length,
  				callbackExpect = !invert;

  			// Go through the array, only saving the items
  			// that pass the validator function
  			for ( ; i < length; i++ ) {
  				callbackInverse = !callback( elems[ i ], i );
  				if ( callbackInverse !== callbackExpect ) {
  					matches.push( elems[ i ] );
  				}
  			}

  			return matches;
  		},

  		// arg is for internal usage only
  		map: function( elems, callback, arg ) {
  			var length, value,
  				i = 0,
  				ret = [];

  			// Go through the array, translating each of the items to their new values
  			if ( isArrayLike( elems ) ) {
  				length = elems.length;
  				for ( ; i < length; i++ ) {
  					value = callback( elems[ i ], i, arg );

  					if ( value != null ) {
  						ret.push( value );
  					}
  				}

  			// Go through every key on the object,
  			} else {
  				for ( i in elems ) {
  					value = callback( elems[ i ], i, arg );

  					if ( value != null ) {
  						ret.push( value );
  					}
  				}
  			}

  			// Flatten any nested arrays
  			return flat( ret );
  		},

  		// A global GUID counter for objects
  		guid: 1,

  		// jQuery.support is not used in Core but other projects attach their
  		// properties to it so it needs to exist.
  		support: support
  	} );

  	if ( typeof Symbol === "function" ) {
  		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
  	}

  	// Populate the class2type map
  	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
  		function( _i, name ) {
  			class2type[ "[object " + name + "]" ] = name.toLowerCase();
  		} );

  	function isArrayLike( obj ) {

  		// Support: real iOS 8.2 only (not reproducible in simulator)
  		// `in` check used to prevent JIT error (gh-2145)
  		// hasOwn isn't used here due to false negatives
  		// regarding Nodelist length in IE
  		var length = !!obj && "length" in obj && obj.length,
  			type = toType( obj );

  		if ( isFunction( obj ) || isWindow( obj ) ) {
  			return false;
  		}

  		return type === "array" || length === 0 ||
  			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
  	}


  	function nodeName( elem, name ) {

  		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

  	}
  	var pop = arr.pop;


  	var sort = arr.sort;


  	var splice = arr.splice;


  	var whitespace = "[\\x20\\t\\r\\n\\f]";


  	var rtrimCSS = new RegExp(
  		"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
  		"g"
  	);




  	// Note: an element does not contain itself
  	jQuery.contains = function( a, b ) {
  		var bup = b && b.parentNode;

  		return a === bup || !!( bup && bup.nodeType === 1 && (

  			// Support: IE 9 - 11+
  			// IE doesn't have `contains` on SVG.
  			a.contains ?
  				a.contains( bup ) :
  				a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
  		) );
  	};




  	// CSS string/identifier serialization
  	// https://drafts.csswg.org/cssom/#common-serializing-idioms
  	var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

  	function fcssescape( ch, asCodePoint ) {
  		if ( asCodePoint ) {

  			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
  			if ( ch === "\0" ) {
  				return "\uFFFD";
  			}

  			// Control characters and (dependent upon position) numbers get escaped as code points
  			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
  		}

  		// Other potentially-special ASCII characters get backslash-escaped
  		return "\\" + ch;
  	}

  	jQuery.escapeSelector = function( sel ) {
  		return ( sel + "" ).replace( rcssescape, fcssescape );
  	};




  	var preferredDoc = document,
  		pushNative = push;

  	( function() {

  	var i,
  		Expr,
  		outermostContext,
  		sortInput,
  		hasDuplicate,
  		push = pushNative,

  		// Local document vars
  		document,
  		documentElement,
  		documentIsHTML,
  		rbuggyQSA,
  		matches,

  		// Instance-specific data
  		expando = jQuery.expando,
  		dirruns = 0,
  		done = 0,
  		classCache = createCache(),
  		tokenCache = createCache(),
  		compilerCache = createCache(),
  		nonnativeSelectorCache = createCache(),
  		sortOrder = function( a, b ) {
  			if ( a === b ) {
  				hasDuplicate = true;
  			}
  			return 0;
  		},

  		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
  			"loop|multiple|open|readonly|required|scoped",

  		// Regular expressions

  		// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
  		identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
  			"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

  		// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
  		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

  			// Operator (capture 2)
  			"*([*^$|!~]?=)" + whitespace +

  			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
  			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
  			whitespace + "*\\]",

  		pseudos = ":(" + identifier + ")(?:\\((" +

  			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
  			// 1. quoted (capture 3; capture 4 or capture 5)
  			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

  			// 2. simple (capture 6)
  			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

  			// 3. anything else (capture 2)
  			".*" +
  			")\\)|)",

  		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  		rwhitespace = new RegExp( whitespace + "+", "g" ),

  		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  		rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
  			whitespace + "*" ),
  		rdescend = new RegExp( whitespace + "|>" ),

  		rpseudo = new RegExp( pseudos ),
  		ridentifier = new RegExp( "^" + identifier + "$" ),

  		matchExpr = {
  			ID: new RegExp( "^#(" + identifier + ")" ),
  			CLASS: new RegExp( "^\\.(" + identifier + ")" ),
  			TAG: new RegExp( "^(" + identifier + "|[*])" ),
  			ATTR: new RegExp( "^" + attributes ),
  			PSEUDO: new RegExp( "^" + pseudos ),
  			CHILD: new RegExp(
  				"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
  					whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
  					whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
  			bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

  			// For use in libraries implementing .is()
  			// We use this for POS matching in `select`
  			needsContext: new RegExp( "^" + whitespace +
  				"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
  				"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
  		},

  		rinputs = /^(?:input|select|textarea|button)$/i,
  		rheader = /^h\d$/i,

  		// Easily-parseable/retrievable ID or TAG or CLASS selectors
  		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  		rsibling = /[+~]/,

  		// CSS escapes
  		// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  		runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
  			"?|\\\\([^\\r\\n\\f])", "g" ),
  		funescape = function( escape, nonHex ) {
  			var high = "0x" + escape.slice( 1 ) - 0x10000;

  			if ( nonHex ) {

  				// Strip the backslash prefix from a non-hex escape sequence
  				return nonHex;
  			}

  			// Replace a hexadecimal escape sequence with the encoded Unicode code point
  			// Support: IE <=11+
  			// For values outside the Basic Multilingual Plane (BMP), manually construct a
  			// surrogate pair
  			return high < 0 ?
  				String.fromCharCode( high + 0x10000 ) :
  				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
  		},

  		// Used for iframes; see `setDocument`.
  		// Support: IE 9 - 11+, Edge 12 - 18+
  		// Removing the function wrapper causes a "Permission Denied"
  		// error in IE/Edge.
  		unloadHandler = function() {
  			setDocument();
  		},

  		inDisabledFieldset = addCombinator(
  			function( elem ) {
  				return elem.disabled === true && nodeName( elem, "fieldset" );
  			},
  			{ dir: "parentNode", next: "legend" }
  		);

  	// Support: IE <=9 only
  	// Accessing document.activeElement can throw unexpectedly
  	// https://bugs.jquery.com/ticket/13393
  	function safeActiveElement() {
  		try {
  			return document.activeElement;
  		} catch ( err ) { }
  	}

  	// Optimize for push.apply( _, NodeList )
  	try {
  		push.apply(
  			( arr = slice.call( preferredDoc.childNodes ) ),
  			preferredDoc.childNodes
  		);

  		// Support: Android <=4.0
  		// Detect silently failing push.apply
  		// eslint-disable-next-line no-unused-expressions
  		arr[ preferredDoc.childNodes.length ].nodeType;
  	} catch ( e ) {
  		push = {
  			apply: function( target, els ) {
  				pushNative.apply( target, slice.call( els ) );
  			},
  			call: function( target ) {
  				pushNative.apply( target, slice.call( arguments, 1 ) );
  			}
  		};
  	}

  	function find( selector, context, results, seed ) {
  		var m, i, elem, nid, match, groups, newSelector,
  			newContext = context && context.ownerDocument,

  			// nodeType defaults to 9, since context defaults to document
  			nodeType = context ? context.nodeType : 9;

  		results = results || [];

  		// Return early from calls with invalid selector or context
  		if ( typeof selector !== "string" || !selector ||
  			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

  			return results;
  		}

  		// Try to shortcut find operations (as opposed to filters) in HTML documents
  		if ( !seed ) {
  			setDocument( context );
  			context = context || document;

  			if ( documentIsHTML ) {

  				// If the selector is sufficiently simple, try using a "get*By*" DOM method
  				// (excepting DocumentFragment context, where the methods don't exist)
  				if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

  					// ID selector
  					if ( ( m = match[ 1 ] ) ) {

  						// Document context
  						if ( nodeType === 9 ) {
  							if ( ( elem = context.getElementById( m ) ) ) {

  								// Support: IE 9 only
  								// getElementById can match elements by name instead of ID
  								if ( elem.id === m ) {
  									push.call( results, elem );
  									return results;
  								}
  							} else {
  								return results;
  							}

  						// Element context
  						} else {

  							// Support: IE 9 only
  							// getElementById can match elements by name instead of ID
  							if ( newContext && ( elem = newContext.getElementById( m ) ) &&
  								find.contains( context, elem ) &&
  								elem.id === m ) {

  								push.call( results, elem );
  								return results;
  							}
  						}

  					// Type selector
  					} else if ( match[ 2 ] ) {
  						push.apply( results, context.getElementsByTagName( selector ) );
  						return results;

  					// Class selector
  					} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
  						push.apply( results, context.getElementsByClassName( m ) );
  						return results;
  					}
  				}

  				// Take advantage of querySelectorAll
  				if ( !nonnativeSelectorCache[ selector + " " ] &&
  					( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

  					newSelector = selector;
  					newContext = context;

  					// qSA considers elements outside a scoping root when evaluating child or
  					// descendant combinators, which is not what we want.
  					// In such cases, we work around the behavior by prefixing every selector in the
  					// list with an ID selector referencing the scope context.
  					// The technique has to be used as well when a leading combinator is used
  					// as such selectors are not recognized by querySelectorAll.
  					// Thanks to Andrew Dupont for this technique.
  					if ( nodeType === 1 &&
  						( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

  						// Expand context for sibling selectors
  						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
  							context;

  						// We can use :scope instead of the ID hack if the browser
  						// supports it & if we're not changing the context.
  						// Support: IE 11+, Edge 17 - 18+
  						// IE/Edge sometimes throw a "Permission denied" error when
  						// strict-comparing two documents; shallow comparisons work.
  						// eslint-disable-next-line eqeqeq
  						if ( newContext != context || !support.scope ) {

  							// Capture the context ID, setting it first if necessary
  							if ( ( nid = context.getAttribute( "id" ) ) ) {
  								nid = jQuery.escapeSelector( nid );
  							} else {
  								context.setAttribute( "id", ( nid = expando ) );
  							}
  						}

  						// Prefix every selector in the list
  						groups = tokenize( selector );
  						i = groups.length;
  						while ( i-- ) {
  							groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
  								toSelector( groups[ i ] );
  						}
  						newSelector = groups.join( "," );
  					}

  					try {
  						push.apply( results,
  							newContext.querySelectorAll( newSelector )
  						);
  						return results;
  					} catch ( qsaError ) {
  						nonnativeSelectorCache( selector, true );
  					} finally {
  						if ( nid === expando ) {
  							context.removeAttribute( "id" );
  						}
  					}
  				}
  			}
  		}

  		// All others
  		return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
  	}

  	/**
  	 * Create key-value caches of limited size
  	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
  	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
  	 *	deleting the oldest entry
  	 */
  	function createCache() {
  		var keys = [];

  		function cache( key, value ) {

  			// Use (key + " ") to avoid collision with native prototype properties
  			// (see https://github.com/jquery/sizzle/issues/157)
  			if ( keys.push( key + " " ) > Expr.cacheLength ) {

  				// Only keep the most recent entries
  				delete cache[ keys.shift() ];
  			}
  			return ( cache[ key + " " ] = value );
  		}
  		return cache;
  	}

  	/**
  	 * Mark a function for special use by jQuery selector module
  	 * @param {Function} fn The function to mark
  	 */
  	function markFunction( fn ) {
  		fn[ expando ] = true;
  		return fn;
  	}

  	/**
  	 * Support testing using an element
  	 * @param {Function} fn Passed the created element and returns a boolean result
  	 */
  	function assert( fn ) {
  		var el = document.createElement( "fieldset" );

  		try {
  			return !!fn( el );
  		} catch ( e ) {
  			return false;
  		} finally {

  			// Remove from its parent by default
  			if ( el.parentNode ) {
  				el.parentNode.removeChild( el );
  			}

  			// release memory in IE
  			el = null;
  		}
  	}

  	/**
  	 * Returns a function to use in pseudos for input types
  	 * @param {String} type
  	 */
  	function createInputPseudo( type ) {
  		return function( elem ) {
  			return nodeName( elem, "input" ) && elem.type === type;
  		};
  	}

  	/**
  	 * Returns a function to use in pseudos for buttons
  	 * @param {String} type
  	 */
  	function createButtonPseudo( type ) {
  		return function( elem ) {
  			return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
  				elem.type === type;
  		};
  	}

  	/**
  	 * Returns a function to use in pseudos for :enabled/:disabled
  	 * @param {Boolean} disabled true for :disabled; false for :enabled
  	 */
  	function createDisabledPseudo( disabled ) {

  		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
  		return function( elem ) {

  			// Only certain elements can match :enabled or :disabled
  			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
  			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
  			if ( "form" in elem ) {

  				// Check for inherited disabledness on relevant non-disabled elements:
  				// * listed form-associated elements in a disabled fieldset
  				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
  				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
  				// * option elements in a disabled optgroup
  				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
  				// All such elements have a "form" property.
  				if ( elem.parentNode && elem.disabled === false ) {

  					// Option elements defer to a parent optgroup if present
  					if ( "label" in elem ) {
  						if ( "label" in elem.parentNode ) {
  							return elem.parentNode.disabled === disabled;
  						} else {
  							return elem.disabled === disabled;
  						}
  					}

  					// Support: IE 6 - 11+
  					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
  					return elem.isDisabled === disabled ||

  						// Where there is no isDisabled, check manually
  						elem.isDisabled !== !disabled &&
  							inDisabledFieldset( elem ) === disabled;
  				}

  				return elem.disabled === disabled;

  			// Try to winnow out elements that can't be disabled before trusting the disabled property.
  			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
  			// even exist on them, let alone have a boolean value.
  			} else if ( "label" in elem ) {
  				return elem.disabled === disabled;
  			}

  			// Remaining elements are neither :enabled nor :disabled
  			return false;
  		};
  	}

  	/**
  	 * Returns a function to use in pseudos for positionals
  	 * @param {Function} fn
  	 */
  	function createPositionalPseudo( fn ) {
  		return markFunction( function( argument ) {
  			argument = +argument;
  			return markFunction( function( seed, matches ) {
  				var j,
  					matchIndexes = fn( [], seed.length, argument ),
  					i = matchIndexes.length;

  				// Match elements found at the specified indexes
  				while ( i-- ) {
  					if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
  						seed[ j ] = !( matches[ j ] = seed[ j ] );
  					}
  				}
  			} );
  		} );
  	}

  	/**
  	 * Checks a node for validity as a jQuery selector context
  	 * @param {Element|Object=} context
  	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
  	 */
  	function testContext( context ) {
  		return context && typeof context.getElementsByTagName !== "undefined" && context;
  	}

  	/**
  	 * Sets document-related variables once based on the current document
  	 * @param {Element|Object} [node] An element or document object to use to set the document
  	 * @returns {Object} Returns the current document
  	 */
  	function setDocument( node ) {
  		var subWindow,
  			doc = node ? node.ownerDocument || node : preferredDoc;

  		// Return early if doc is invalid or already selected
  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
  			return document;
  		}

  		// Update global variables
  		document = doc;
  		documentElement = document.documentElement;
  		documentIsHTML = !jQuery.isXMLDoc( document );

  		// Support: iOS 7 only, IE 9 - 11+
  		// Older browsers didn't support unprefixed `matches`.
  		matches = documentElement.matches ||
  			documentElement.webkitMatchesSelector ||
  			documentElement.msMatchesSelector;

  		// Support: IE 9 - 11+, Edge 12 - 18+
  		// Accessing iframe documents after unload throws "permission denied" errors
  		// (see trac-13936).
  		// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
  		// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
  		if ( documentElement.msMatchesSelector &&

  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			// eslint-disable-next-line eqeqeq
  			preferredDoc != document &&
  			( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

  			// Support: IE 9 - 11+, Edge 12 - 18+
  			subWindow.addEventListener( "unload", unloadHandler );
  		}

  		// Support: IE <10
  		// Check if getElementById returns elements by name
  		// The broken getElementById methods don't pick up programmatically-set names,
  		// so use a roundabout getElementsByName test
  		support.getById = assert( function( el ) {
  			documentElement.appendChild( el ).id = jQuery.expando;
  			return !document.getElementsByName ||
  				!document.getElementsByName( jQuery.expando ).length;
  		} );

  		// Support: IE 9 only
  		// Check to see if it's possible to do matchesSelector
  		// on a disconnected node.
  		support.disconnectedMatch = assert( function( el ) {
  			return matches.call( el, "*" );
  		} );

  		// Support: IE 9 - 11+, Edge 12 - 18+
  		// IE/Edge don't support the :scope pseudo-class.
  		support.scope = assert( function() {
  			return document.querySelectorAll( ":scope" );
  		} );

  		// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
  		// Make sure the `:has()` argument is parsed unforgivingly.
  		// We include `*` in the test to detect buggy implementations that are
  		// _selectively_ forgiving (specifically when the list includes at least
  		// one valid selector).
  		// Note that we treat complete lack of support for `:has()` as if it were
  		// spec-compliant support, which is fine because use of `:has()` in such
  		// environments will fail in the qSA path and fall back to jQuery traversal
  		// anyway.
  		support.cssHas = assert( function() {
  			try {
  				document.querySelector( ":has(*,:jqfake)" );
  				return false;
  			} catch ( e ) {
  				return true;
  			}
  		} );

  		// ID filter and find
  		if ( support.getById ) {
  			Expr.filter.ID = function( id ) {
  				var attrId = id.replace( runescape, funescape );
  				return function( elem ) {
  					return elem.getAttribute( "id" ) === attrId;
  				};
  			};
  			Expr.find.ID = function( id, context ) {
  				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  					var elem = context.getElementById( id );
  					return elem ? [ elem ] : [];
  				}
  			};
  		} else {
  			Expr.filter.ID =  function( id ) {
  				var attrId = id.replace( runescape, funescape );
  				return function( elem ) {
  					var node = typeof elem.getAttributeNode !== "undefined" &&
  						elem.getAttributeNode( "id" );
  					return node && node.value === attrId;
  				};
  			};

  			// Support: IE 6 - 7 only
  			// getElementById is not reliable as a find shortcut
  			Expr.find.ID = function( id, context ) {
  				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  					var node, i, elems,
  						elem = context.getElementById( id );

  					if ( elem ) {

  						// Verify the id attribute
  						node = elem.getAttributeNode( "id" );
  						if ( node && node.value === id ) {
  							return [ elem ];
  						}

  						// Fall back on getElementsByName
  						elems = context.getElementsByName( id );
  						i = 0;
  						while ( ( elem = elems[ i++ ] ) ) {
  							node = elem.getAttributeNode( "id" );
  							if ( node && node.value === id ) {
  								return [ elem ];
  							}
  						}
  					}

  					return [];
  				}
  			};
  		}

  		// Tag
  		Expr.find.TAG = function( tag, context ) {
  			if ( typeof context.getElementsByTagName !== "undefined" ) {
  				return context.getElementsByTagName( tag );

  			// DocumentFragment nodes don't have gEBTN
  			} else {
  				return context.querySelectorAll( tag );
  			}
  		};

  		// Class
  		Expr.find.CLASS = function( className, context ) {
  			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
  				return context.getElementsByClassName( className );
  			}
  		};

  		/* QSA/matchesSelector
  		---------------------------------------------------------------------- */

  		// QSA and matchesSelector support

  		rbuggyQSA = [];

  		// Build QSA regex
  		// Regex strategy adopted from Diego Perini
  		assert( function( el ) {

  			var input;

  			documentElement.appendChild( el ).innerHTML =
  				"<a id='" + expando + "' href='' disabled='disabled'></a>" +
  				"<select id='" + expando + "-\r\\' disabled='disabled'>" +
  				"<option selected=''></option></select>";

  			// Support: iOS <=7 - 8 only
  			// Boolean attributes and "value" are not treated correctly in some XML documents
  			if ( !el.querySelectorAll( "[selected]" ).length ) {
  				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
  			}

  			// Support: iOS <=7 - 8 only
  			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
  				rbuggyQSA.push( "~=" );
  			}

  			// Support: iOS 8 only
  			// https://bugs.webkit.org/show_bug.cgi?id=136851
  			// In-page `selector#id sibling-combinator selector` fails
  			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
  				rbuggyQSA.push( ".#.+[+~]" );
  			}

  			// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
  			// In some of the document kinds, these selectors wouldn't work natively.
  			// This is probably OK but for backwards compatibility we want to maintain
  			// handling them through jQuery traversal in jQuery 3.x.
  			if ( !el.querySelectorAll( ":checked" ).length ) {
  				rbuggyQSA.push( ":checked" );
  			}

  			// Support: Windows 8 Native Apps
  			// The type and name attributes are restricted during .innerHTML assignment
  			input = document.createElement( "input" );
  			input.setAttribute( "type", "hidden" );
  			el.appendChild( input ).setAttribute( "name", "D" );

  			// Support: IE 9 - 11+
  			// IE's :disabled selector does not pick up the children of disabled fieldsets
  			// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
  			// In some of the document kinds, these selectors wouldn't work natively.
  			// This is probably OK but for backwards compatibility we want to maintain
  			// handling them through jQuery traversal in jQuery 3.x.
  			documentElement.appendChild( el ).disabled = true;
  			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
  				rbuggyQSA.push( ":enabled", ":disabled" );
  			}

  			// Support: IE 11+, Edge 15 - 18+
  			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
  			// Adding a temporary attribute to the document before the selection works
  			// around the issue.
  			// Interestingly, IE 10 & older don't seem to have the issue.
  			input = document.createElement( "input" );
  			input.setAttribute( "name", "" );
  			el.appendChild( input );
  			if ( !el.querySelectorAll( "[name='']" ).length ) {
  				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
  					whitespace + "*(?:''|\"\")" );
  			}
  		} );

  		if ( !support.cssHas ) {

  			// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
  			// Our regular `try-catch` mechanism fails to detect natively-unsupported
  			// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
  			// in browsers that parse the `:has()` argument as a forgiving selector list.
  			// https://drafts.csswg.org/selectors/#relational now requires the argument
  			// to be parsed unforgivingly, but browsers have not yet fully adjusted.
  			rbuggyQSA.push( ":has" );
  		}

  		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

  		/* Sorting
  		---------------------------------------------------------------------- */

  		// Document order sorting
  		sortOrder = function( a, b ) {

  			// Flag for duplicate removal
  			if ( a === b ) {
  				hasDuplicate = true;
  				return 0;
  			}

  			// Sort on method existence if only one input has compareDocumentPosition
  			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
  			if ( compare ) {
  				return compare;
  			}

  			// Calculate position if both inputs belong to the same document
  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			// eslint-disable-next-line eqeqeq
  			compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
  				a.compareDocumentPosition( b ) :

  				// Otherwise we know they are disconnected
  				1;

  			// Disconnected nodes
  			if ( compare & 1 ||
  				( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

  				// Choose the first element that is related to our preferred document
  				// Support: IE 11+, Edge 17 - 18+
  				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  				// two documents; shallow comparisons work.
  				// eslint-disable-next-line eqeqeq
  				if ( a === document || a.ownerDocument == preferredDoc &&
  					find.contains( preferredDoc, a ) ) {
  					return -1;
  				}

  				// Support: IE 11+, Edge 17 - 18+
  				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  				// two documents; shallow comparisons work.
  				// eslint-disable-next-line eqeqeq
  				if ( b === document || b.ownerDocument == preferredDoc &&
  					find.contains( preferredDoc, b ) ) {
  					return 1;
  				}

  				// Maintain original order
  				return sortInput ?
  					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
  					0;
  			}

  			return compare & 4 ? -1 : 1;
  		};

  		return document;
  	}

  	find.matches = function( expr, elements ) {
  		return find( expr, null, null, elements );
  	};

  	find.matchesSelector = function( elem, expr ) {
  		setDocument( elem );

  		if ( documentIsHTML &&
  			!nonnativeSelectorCache[ expr + " " ] &&
  			( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

  			try {
  				var ret = matches.call( elem, expr );

  				// IE 9's matchesSelector returns false on disconnected nodes
  				if ( ret || support.disconnectedMatch ||

  						// As well, disconnected nodes are said to be in a document
  						// fragment in IE 9
  						elem.document && elem.document.nodeType !== 11 ) {
  					return ret;
  				}
  			} catch ( e ) {
  				nonnativeSelectorCache( expr, true );
  			}
  		}

  		return find( expr, document, null, [ elem ] ).length > 0;
  	};

  	find.contains = function( context, elem ) {

  		// Set document vars if needed
  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		if ( ( context.ownerDocument || context ) != document ) {
  			setDocument( context );
  		}
  		return jQuery.contains( context, elem );
  	};


  	find.attr = function( elem, name ) {

  		// Set document vars if needed
  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		if ( ( elem.ownerDocument || elem ) != document ) {
  			setDocument( elem );
  		}

  		var fn = Expr.attrHandle[ name.toLowerCase() ],

  			// Don't get fooled by Object.prototype properties (see trac-13807)
  			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
  				fn( elem, name, !documentIsHTML ) :
  				undefined;

  		if ( val !== undefined ) {
  			return val;
  		}

  		return elem.getAttribute( name );
  	};

  	find.error = function( msg ) {
  		throw new Error( "Syntax error, unrecognized expression: " + msg );
  	};

  	/**
  	 * Document sorting and removing duplicates
  	 * @param {ArrayLike} results
  	 */
  	jQuery.uniqueSort = function( results ) {
  		var elem,
  			duplicates = [],
  			j = 0,
  			i = 0;

  		// Unless we *know* we can detect duplicates, assume their presence
  		//
  		// Support: Android <=4.0+
  		// Testing for detecting duplicates is unpredictable so instead assume we can't
  		// depend on duplicate detection in all browsers without a stable sort.
  		hasDuplicate = !support.sortStable;
  		sortInput = !support.sortStable && slice.call( results, 0 );
  		sort.call( results, sortOrder );

  		if ( hasDuplicate ) {
  			while ( ( elem = results[ i++ ] ) ) {
  				if ( elem === results[ i ] ) {
  					j = duplicates.push( i );
  				}
  			}
  			while ( j-- ) {
  				splice.call( results, duplicates[ j ], 1 );
  			}
  		}

  		// Clear input after sorting to release objects
  		// See https://github.com/jquery/sizzle/pull/225
  		sortInput = null;

  		return results;
  	};

  	jQuery.fn.uniqueSort = function() {
  		return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
  	};

  	Expr = jQuery.expr = {

  		// Can be adjusted by the user
  		cacheLength: 50,

  		createPseudo: markFunction,

  		match: matchExpr,

  		attrHandle: {},

  		find: {},

  		relative: {
  			">": { dir: "parentNode", first: true },
  			" ": { dir: "parentNode" },
  			"+": { dir: "previousSibling", first: true },
  			"~": { dir: "previousSibling" }
  		},

  		preFilter: {
  			ATTR: function( match ) {
  				match[ 1 ] = match[ 1 ].replace( runescape, funescape );

  				// Move the given value to match[3] whether quoted or unquoted
  				match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
  					.replace( runescape, funescape );

  				if ( match[ 2 ] === "~=" ) {
  					match[ 3 ] = " " + match[ 3 ] + " ";
  				}

  				return match.slice( 0, 4 );
  			},

  			CHILD: function( match ) {

  				/* matches from matchExpr["CHILD"]
  					1 type (only|nth|...)
  					2 what (child|of-type)
  					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
  					4 xn-component of xn+y argument ([+-]?\d*n|)
  					5 sign of xn-component
  					6 x of xn-component
  					7 sign of y-component
  					8 y of y-component
  				*/
  				match[ 1 ] = match[ 1 ].toLowerCase();

  				if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

  					// nth-* requires argument
  					if ( !match[ 3 ] ) {
  						find.error( match[ 0 ] );
  					}

  					// numeric x and y parameters for Expr.filter.CHILD
  					// remember that false/true cast respectively to 0/1
  					match[ 4 ] = +( match[ 4 ] ?
  						match[ 5 ] + ( match[ 6 ] || 1 ) :
  						2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
  					);
  					match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

  				// other types prohibit arguments
  				} else if ( match[ 3 ] ) {
  					find.error( match[ 0 ] );
  				}

  				return match;
  			},

  			PSEUDO: function( match ) {
  				var excess,
  					unquoted = !match[ 6 ] && match[ 2 ];

  				if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
  					return null;
  				}

  				// Accept quoted arguments as-is
  				if ( match[ 3 ] ) {
  					match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

  				// Strip excess characters from unquoted arguments
  				} else if ( unquoted && rpseudo.test( unquoted ) &&

  					// Get excess from tokenize (recursively)
  					( excess = tokenize( unquoted, true ) ) &&

  					// advance to the next closing parenthesis
  					( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

  					// excess is a negative index
  					match[ 0 ] = match[ 0 ].slice( 0, excess );
  					match[ 2 ] = unquoted.slice( 0, excess );
  				}

  				// Return only captures needed by the pseudo filter method (type and argument)
  				return match.slice( 0, 3 );
  			}
  		},

  		filter: {

  			TAG: function( nodeNameSelector ) {
  				var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
  				return nodeNameSelector === "*" ?
  					function() {
  						return true;
  					} :
  					function( elem ) {
  						return nodeName( elem, expectedNodeName );
  					};
  			},

  			CLASS: function( className ) {
  				var pattern = classCache[ className + " " ];

  				return pattern ||
  					( pattern = new RegExp( "(^|" + whitespace + ")" + className +
  						"(" + whitespace + "|$)" ) ) &&
  					classCache( className, function( elem ) {
  						return pattern.test(
  							typeof elem.className === "string" && elem.className ||
  								typeof elem.getAttribute !== "undefined" &&
  									elem.getAttribute( "class" ) ||
  								""
  						);
  					} );
  			},

  			ATTR: function( name, operator, check ) {
  				return function( elem ) {
  					var result = find.attr( elem, name );

  					if ( result == null ) {
  						return operator === "!=";
  					}
  					if ( !operator ) {
  						return true;
  					}

  					result += "";

  					if ( operator === "=" ) {
  						return result === check;
  					}
  					if ( operator === "!=" ) {
  						return result !== check;
  					}
  					if ( operator === "^=" ) {
  						return check && result.indexOf( check ) === 0;
  					}
  					if ( operator === "*=" ) {
  						return check && result.indexOf( check ) > -1;
  					}
  					if ( operator === "$=" ) {
  						return check && result.slice( -check.length ) === check;
  					}
  					if ( operator === "~=" ) {
  						return ( " " + result.replace( rwhitespace, " " ) + " " )
  							.indexOf( check ) > -1;
  					}
  					if ( operator === "|=" ) {
  						return result === check || result.slice( 0, check.length + 1 ) === check + "-";
  					}

  					return false;
  				};
  			},

  			CHILD: function( type, what, _argument, first, last ) {
  				var simple = type.slice( 0, 3 ) !== "nth",
  					forward = type.slice( -4 ) !== "last",
  					ofType = what === "of-type";

  				return first === 1 && last === 0 ?

  					// Shortcut for :nth-*(n)
  					function( elem ) {
  						return !!elem.parentNode;
  					} :

  					function( elem, _context, xml ) {
  						var cache, outerCache, node, nodeIndex, start,
  							dir = simple !== forward ? "nextSibling" : "previousSibling",
  							parent = elem.parentNode,
  							name = ofType && elem.nodeName.toLowerCase(),
  							useCache = !xml && !ofType,
  							diff = false;

  						if ( parent ) {

  							// :(first|last|only)-(child|of-type)
  							if ( simple ) {
  								while ( dir ) {
  									node = elem;
  									while ( ( node = node[ dir ] ) ) {
  										if ( ofType ?
  											nodeName( node, name ) :
  											node.nodeType === 1 ) {

  											return false;
  										}
  									}

  									// Reverse direction for :only-* (if we haven't yet done so)
  									start = dir = type === "only" && !start && "nextSibling";
  								}
  								return true;
  							}

  							start = [ forward ? parent.firstChild : parent.lastChild ];

  							// non-xml :nth-child(...) stores cache data on `parent`
  							if ( forward && useCache ) {

  								// Seek `elem` from a previously-cached index
  								outerCache = parent[ expando ] || ( parent[ expando ] = {} );
  								cache = outerCache[ type ] || [];
  								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  								diff = nodeIndex && cache[ 2 ];
  								node = nodeIndex && parent.childNodes[ nodeIndex ];

  								while ( ( node = ++nodeIndex && node && node[ dir ] ||

  									// Fallback to seeking `elem` from the start
  									( diff = nodeIndex = 0 ) || start.pop() ) ) {

  									// When found, cache indexes on `parent` and break
  									if ( node.nodeType === 1 && ++diff && node === elem ) {
  										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
  										break;
  									}
  								}

  							} else {

  								// Use previously-cached element index if available
  								if ( useCache ) {
  									outerCache = elem[ expando ] || ( elem[ expando ] = {} );
  									cache = outerCache[ type ] || [];
  									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  									diff = nodeIndex;
  								}

  								// xml :nth-child(...)
  								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
  								if ( diff === false ) {

  									// Use the same loop as above to seek `elem` from the start
  									while ( ( node = ++nodeIndex && node && node[ dir ] ||
  										( diff = nodeIndex = 0 ) || start.pop() ) ) {

  										if ( ( ofType ?
  											nodeName( node, name ) :
  											node.nodeType === 1 ) &&
  											++diff ) {

  											// Cache the index of each encountered element
  											if ( useCache ) {
  												outerCache = node[ expando ] ||
  													( node[ expando ] = {} );
  												outerCache[ type ] = [ dirruns, diff ];
  											}

  											if ( node === elem ) {
  												break;
  											}
  										}
  									}
  								}
  							}

  							// Incorporate the offset, then check against cycle size
  							diff -= last;
  							return diff === first || ( diff % first === 0 && diff / first >= 0 );
  						}
  					};
  			},

  			PSEUDO: function( pseudo, argument ) {

  				// pseudo-class names are case-insensitive
  				// https://www.w3.org/TR/selectors/#pseudo-classes
  				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
  				// Remember that setFilters inherits from pseudos
  				var args,
  					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
  						find.error( "unsupported pseudo: " + pseudo );

  				// The user may use createPseudo to indicate that
  				// arguments are needed to create the filter function
  				// just as jQuery does
  				if ( fn[ expando ] ) {
  					return fn( argument );
  				}

  				// But maintain support for old signatures
  				if ( fn.length > 1 ) {
  					args = [ pseudo, pseudo, "", argument ];
  					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
  						markFunction( function( seed, matches ) {
  							var idx,
  								matched = fn( seed, argument ),
  								i = matched.length;
  							while ( i-- ) {
  								idx = indexOf.call( seed, matched[ i ] );
  								seed[ idx ] = !( matches[ idx ] = matched[ i ] );
  							}
  						} ) :
  						function( elem ) {
  							return fn( elem, 0, args );
  						};
  				}

  				return fn;
  			}
  		},

  		pseudos: {

  			// Potentially complex pseudos
  			not: markFunction( function( selector ) {

  				// Trim the selector passed to compile
  				// to avoid treating leading and trailing
  				// spaces as combinators
  				var input = [],
  					results = [],
  					matcher = compile( selector.replace( rtrimCSS, "$1" ) );

  				return matcher[ expando ] ?
  					markFunction( function( seed, matches, _context, xml ) {
  						var elem,
  							unmatched = matcher( seed, null, xml, [] ),
  							i = seed.length;

  						// Match elements unmatched by `matcher`
  						while ( i-- ) {
  							if ( ( elem = unmatched[ i ] ) ) {
  								seed[ i ] = !( matches[ i ] = elem );
  							}
  						}
  					} ) :
  					function( elem, _context, xml ) {
  						input[ 0 ] = elem;
  						matcher( input, null, xml, results );

  						// Don't keep the element
  						// (see https://github.com/jquery/sizzle/issues/299)
  						input[ 0 ] = null;
  						return !results.pop();
  					};
  			} ),

  			has: markFunction( function( selector ) {
  				return function( elem ) {
  					return find( selector, elem ).length > 0;
  				};
  			} ),

  			contains: markFunction( function( text ) {
  				text = text.replace( runescape, funescape );
  				return function( elem ) {
  					return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
  				};
  			} ),

  			// "Whether an element is represented by a :lang() selector
  			// is based solely on the element's language value
  			// being equal to the identifier C,
  			// or beginning with the identifier C immediately followed by "-".
  			// The matching of C against the element's language value is performed case-insensitively.
  			// The identifier C does not have to be a valid language name."
  			// https://www.w3.org/TR/selectors/#lang-pseudo
  			lang: markFunction( function( lang ) {

  				// lang value must be a valid identifier
  				if ( !ridentifier.test( lang || "" ) ) {
  					find.error( "unsupported lang: " + lang );
  				}
  				lang = lang.replace( runescape, funescape ).toLowerCase();
  				return function( elem ) {
  					var elemLang;
  					do {
  						if ( ( elemLang = documentIsHTML ?
  							elem.lang :
  							elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

  							elemLang = elemLang.toLowerCase();
  							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
  						}
  					} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
  					return false;
  				};
  			} ),

  			// Miscellaneous
  			target: function( elem ) {
  				var hash = window.location && window.location.hash;
  				return hash && hash.slice( 1 ) === elem.id;
  			},

  			root: function( elem ) {
  				return elem === documentElement;
  			},

  			focus: function( elem ) {
  				return elem === safeActiveElement() &&
  					document.hasFocus() &&
  					!!( elem.type || elem.href || ~elem.tabIndex );
  			},

  			// Boolean properties
  			enabled: createDisabledPseudo( false ),
  			disabled: createDisabledPseudo( true ),

  			checked: function( elem ) {

  				// In CSS3, :checked should return both checked and selected elements
  				// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  				return ( nodeName( elem, "input" ) && !!elem.checked ) ||
  					( nodeName( elem, "option" ) && !!elem.selected );
  			},

  			selected: function( elem ) {

  				// Support: IE <=11+
  				// Accessing the selectedIndex property
  				// forces the browser to treat the default option as
  				// selected when in an optgroup.
  				if ( elem.parentNode ) {
  					// eslint-disable-next-line no-unused-expressions
  					elem.parentNode.selectedIndex;
  				}

  				return elem.selected === true;
  			},

  			// Contents
  			empty: function( elem ) {

  				// https://www.w3.org/TR/selectors/#empty-pseudo
  				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
  				//   but not by others (comment: 8; processing instruction: 7; etc.)
  				// nodeType < 6 works because attributes (2) do not appear as children
  				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  					if ( elem.nodeType < 6 ) {
  						return false;
  					}
  				}
  				return true;
  			},

  			parent: function( elem ) {
  				return !Expr.pseudos.empty( elem );
  			},

  			// Element/input types
  			header: function( elem ) {
  				return rheader.test( elem.nodeName );
  			},

  			input: function( elem ) {
  				return rinputs.test( elem.nodeName );
  			},

  			button: function( elem ) {
  				return nodeName( elem, "input" ) && elem.type === "button" ||
  					nodeName( elem, "button" );
  			},

  			text: function( elem ) {
  				var attr;
  				return nodeName( elem, "input" ) && elem.type === "text" &&

  					// Support: IE <10 only
  					// New HTML5 attribute values (e.g., "search") appear
  					// with elem.type === "text"
  					( ( attr = elem.getAttribute( "type" ) ) == null ||
  						attr.toLowerCase() === "text" );
  			},

  			// Position-in-collection
  			first: createPositionalPseudo( function() {
  				return [ 0 ];
  			} ),

  			last: createPositionalPseudo( function( _matchIndexes, length ) {
  				return [ length - 1 ];
  			} ),

  			eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
  				return [ argument < 0 ? argument + length : argument ];
  			} ),

  			even: createPositionalPseudo( function( matchIndexes, length ) {
  				var i = 0;
  				for ( ; i < length; i += 2 ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} ),

  			odd: createPositionalPseudo( function( matchIndexes, length ) {
  				var i = 1;
  				for ( ; i < length; i += 2 ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} ),

  			lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
  				var i;

  				if ( argument < 0 ) {
  					i = argument + length;
  				} else if ( argument > length ) {
  					i = length;
  				} else {
  					i = argument;
  				}

  				for ( ; --i >= 0; ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} ),

  			gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
  				var i = argument < 0 ? argument + length : argument;
  				for ( ; ++i < length; ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} )
  		}
  	};

  	Expr.pseudos.nth = Expr.pseudos.eq;

  	// Add button/input type pseudos
  	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
  		Expr.pseudos[ i ] = createInputPseudo( i );
  	}
  	for ( i in { submit: true, reset: true } ) {
  		Expr.pseudos[ i ] = createButtonPseudo( i );
  	}

  	// Easy API for creating new setFilters
  	function setFilters() {}
  	setFilters.prototype = Expr.filters = Expr.pseudos;
  	Expr.setFilters = new setFilters();

  	function tokenize( selector, parseOnly ) {
  		var matched, match, tokens, type,
  			soFar, groups, preFilters,
  			cached = tokenCache[ selector + " " ];

  		if ( cached ) {
  			return parseOnly ? 0 : cached.slice( 0 );
  		}

  		soFar = selector;
  		groups = [];
  		preFilters = Expr.preFilter;

  		while ( soFar ) {

  			// Comma and first run
  			if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
  				if ( match ) {

  					// Don't consume trailing commas as valid
  					soFar = soFar.slice( match[ 0 ].length ) || soFar;
  				}
  				groups.push( ( tokens = [] ) );
  			}

  			matched = false;

  			// Combinators
  			if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
  				matched = match.shift();
  				tokens.push( {
  					value: matched,

  					// Cast descendant combinators to space
  					type: match[ 0 ].replace( rtrimCSS, " " )
  				} );
  				soFar = soFar.slice( matched.length );
  			}

  			// Filters
  			for ( type in Expr.filter ) {
  				if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
  					( match = preFilters[ type ]( match ) ) ) ) {
  					matched = match.shift();
  					tokens.push( {
  						value: matched,
  						type: type,
  						matches: match
  					} );
  					soFar = soFar.slice( matched.length );
  				}
  			}

  			if ( !matched ) {
  				break;
  			}
  		}

  		// Return the length of the invalid excess
  		// if we're just parsing
  		// Otherwise, throw an error or return tokens
  		if ( parseOnly ) {
  			return soFar.length;
  		}

  		return soFar ?
  			find.error( selector ) :

  			// Cache the tokens
  			tokenCache( selector, groups ).slice( 0 );
  	}

  	function toSelector( tokens ) {
  		var i = 0,
  			len = tokens.length,
  			selector = "";
  		for ( ; i < len; i++ ) {
  			selector += tokens[ i ].value;
  		}
  		return selector;
  	}

  	function addCombinator( matcher, combinator, base ) {
  		var dir = combinator.dir,
  			skip = combinator.next,
  			key = skip || dir,
  			checkNonElements = base && key === "parentNode",
  			doneName = done++;

  		return combinator.first ?

  			// Check against closest ancestor/preceding element
  			function( elem, context, xml ) {
  				while ( ( elem = elem[ dir ] ) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						return matcher( elem, context, xml );
  					}
  				}
  				return false;
  			} :

  			// Check against all ancestor/preceding elements
  			function( elem, context, xml ) {
  				var oldCache, outerCache,
  					newCache = [ dirruns, doneName ];

  				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
  				if ( xml ) {
  					while ( ( elem = elem[ dir ] ) ) {
  						if ( elem.nodeType === 1 || checkNonElements ) {
  							if ( matcher( elem, context, xml ) ) {
  								return true;
  							}
  						}
  					}
  				} else {
  					while ( ( elem = elem[ dir ] ) ) {
  						if ( elem.nodeType === 1 || checkNonElements ) {
  							outerCache = elem[ expando ] || ( elem[ expando ] = {} );

  							if ( skip && nodeName( elem, skip ) ) {
  								elem = elem[ dir ] || elem;
  							} else if ( ( oldCache = outerCache[ key ] ) &&
  								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

  								// Assign to newCache so results back-propagate to previous elements
  								return ( newCache[ 2 ] = oldCache[ 2 ] );
  							} else {

  								// Reuse newcache so results back-propagate to previous elements
  								outerCache[ key ] = newCache;

  								// A match means we're done; a fail means we have to keep checking
  								if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
  									return true;
  								}
  							}
  						}
  					}
  				}
  				return false;
  			};
  	}

  	function elementMatcher( matchers ) {
  		return matchers.length > 1 ?
  			function( elem, context, xml ) {
  				var i = matchers.length;
  				while ( i-- ) {
  					if ( !matchers[ i ]( elem, context, xml ) ) {
  						return false;
  					}
  				}
  				return true;
  			} :
  			matchers[ 0 ];
  	}

  	function multipleContexts( selector, contexts, results ) {
  		var i = 0,
  			len = contexts.length;
  		for ( ; i < len; i++ ) {
  			find( selector, contexts[ i ], results );
  		}
  		return results;
  	}

  	function condense( unmatched, map, filter, context, xml ) {
  		var elem,
  			newUnmatched = [],
  			i = 0,
  			len = unmatched.length,
  			mapped = map != null;

  		for ( ; i < len; i++ ) {
  			if ( ( elem = unmatched[ i ] ) ) {
  				if ( !filter || filter( elem, context, xml ) ) {
  					newUnmatched.push( elem );
  					if ( mapped ) {
  						map.push( i );
  					}
  				}
  			}
  		}

  		return newUnmatched;
  	}

  	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  		if ( postFilter && !postFilter[ expando ] ) {
  			postFilter = setMatcher( postFilter );
  		}
  		if ( postFinder && !postFinder[ expando ] ) {
  			postFinder = setMatcher( postFinder, postSelector );
  		}
  		return markFunction( function( seed, results, context, xml ) {
  			var temp, i, elem, matcherOut,
  				preMap = [],
  				postMap = [],
  				preexisting = results.length,

  				// Get initial elements from seed or context
  				elems = seed ||
  					multipleContexts( selector || "*",
  						context.nodeType ? [ context ] : context, [] ),

  				// Prefilter to get matcher input, preserving a map for seed-results synchronization
  				matcherIn = preFilter && ( seed || !selector ) ?
  					condense( elems, preMap, preFilter, context, xml ) :
  					elems;

  			if ( matcher ) {

  				// If we have a postFinder, or filtered seed, or non-seed postFilter
  				// or preexisting results,
  				matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

  					// ...intermediate processing is necessary
  					[] :

  					// ...otherwise use results directly
  					results;

  				// Find primary matches
  				matcher( matcherIn, matcherOut, context, xml );
  			} else {
  				matcherOut = matcherIn;
  			}

  			// Apply postFilter
  			if ( postFilter ) {
  				temp = condense( matcherOut, postMap );
  				postFilter( temp, [], context, xml );

  				// Un-match failing elements by moving them back to matcherIn
  				i = temp.length;
  				while ( i-- ) {
  					if ( ( elem = temp[ i ] ) ) {
  						matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
  					}
  				}
  			}

  			if ( seed ) {
  				if ( postFinder || preFilter ) {
  					if ( postFinder ) {

  						// Get the final matcherOut by condensing this intermediate into postFinder contexts
  						temp = [];
  						i = matcherOut.length;
  						while ( i-- ) {
  							if ( ( elem = matcherOut[ i ] ) ) {

  								// Restore matcherIn since elem is not yet a final match
  								temp.push( ( matcherIn[ i ] = elem ) );
  							}
  						}
  						postFinder( null, ( matcherOut = [] ), temp, xml );
  					}

  					// Move matched elements from seed to results to keep them synchronized
  					i = matcherOut.length;
  					while ( i-- ) {
  						if ( ( elem = matcherOut[ i ] ) &&
  							( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

  							seed[ temp ] = !( results[ temp ] = elem );
  						}
  					}
  				}

  			// Add elements to results, through postFinder if defined
  			} else {
  				matcherOut = condense(
  					matcherOut === results ?
  						matcherOut.splice( preexisting, matcherOut.length ) :
  						matcherOut
  				);
  				if ( postFinder ) {
  					postFinder( null, results, matcherOut, xml );
  				} else {
  					push.apply( results, matcherOut );
  				}
  			}
  		} );
  	}

  	function matcherFromTokens( tokens ) {
  		var checkContext, matcher, j,
  			len = tokens.length,
  			leadingRelative = Expr.relative[ tokens[ 0 ].type ],
  			implicitRelative = leadingRelative || Expr.relative[ " " ],
  			i = leadingRelative ? 1 : 0,

  			// The foundational matcher ensures that elements are reachable from top-level context(s)
  			matchContext = addCombinator( function( elem ) {
  				return elem === checkContext;
  			}, implicitRelative, true ),
  			matchAnyContext = addCombinator( function( elem ) {
  				return indexOf.call( checkContext, elem ) > -1;
  			}, implicitRelative, true ),
  			matchers = [ function( elem, context, xml ) {

  				// Support: IE 11+, Edge 17 - 18+
  				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  				// two documents; shallow comparisons work.
  				// eslint-disable-next-line eqeqeq
  				var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
  					( checkContext = context ).nodeType ?
  						matchContext( elem, context, xml ) :
  						matchAnyContext( elem, context, xml ) );

  				// Avoid hanging onto element
  				// (see https://github.com/jquery/sizzle/issues/299)
  				checkContext = null;
  				return ret;
  			} ];

  		for ( ; i < len; i++ ) {
  			if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
  				matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
  			} else {
  				matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

  				// Return special upon seeing a positional matcher
  				if ( matcher[ expando ] ) {

  					// Find the next relative operator (if any) for proper handling
  					j = ++i;
  					for ( ; j < len; j++ ) {
  						if ( Expr.relative[ tokens[ j ].type ] ) {
  							break;
  						}
  					}
  					return setMatcher(
  						i > 1 && elementMatcher( matchers ),
  						i > 1 && toSelector(

  							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
  							tokens.slice( 0, i - 1 )
  								.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
  						).replace( rtrimCSS, "$1" ),
  						matcher,
  						i < j && matcherFromTokens( tokens.slice( i, j ) ),
  						j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
  						j < len && toSelector( tokens )
  					);
  				}
  				matchers.push( matcher );
  			}
  		}

  		return elementMatcher( matchers );
  	}

  	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  		var bySet = setMatchers.length > 0,
  			byElement = elementMatchers.length > 0,
  			superMatcher = function( seed, context, xml, results, outermost ) {
  				var elem, j, matcher,
  					matchedCount = 0,
  					i = "0",
  					unmatched = seed && [],
  					setMatched = [],
  					contextBackup = outermostContext,

  					// We must always have either seed elements or outermost context
  					elems = seed || byElement && Expr.find.TAG( "*", outermost ),

  					// Use integer dirruns iff this is the outermost matcher
  					dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
  					len = elems.length;

  				if ( outermost ) {

  					// Support: IE 11+, Edge 17 - 18+
  					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  					// two documents; shallow comparisons work.
  					// eslint-disable-next-line eqeqeq
  					outermostContext = context == document || context || outermost;
  				}

  				// Add elements passing elementMatchers directly to results
  				// Support: iOS <=7 - 9 only
  				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
  				// elements by id. (see trac-14142)
  				for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
  					if ( byElement && elem ) {
  						j = 0;

  						// Support: IE 11+, Edge 17 - 18+
  						// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  						// two documents; shallow comparisons work.
  						// eslint-disable-next-line eqeqeq
  						if ( !context && elem.ownerDocument != document ) {
  							setDocument( elem );
  							xml = !documentIsHTML;
  						}
  						while ( ( matcher = elementMatchers[ j++ ] ) ) {
  							if ( matcher( elem, context || document, xml ) ) {
  								push.call( results, elem );
  								break;
  							}
  						}
  						if ( outermost ) {
  							dirruns = dirrunsUnique;
  						}
  					}

  					// Track unmatched elements for set filters
  					if ( bySet ) {

  						// They will have gone through all possible matchers
  						if ( ( elem = !matcher && elem ) ) {
  							matchedCount--;
  						}

  						// Lengthen the array for every element, matched or not
  						if ( seed ) {
  							unmatched.push( elem );
  						}
  					}
  				}

  				// `i` is now the count of elements visited above, and adding it to `matchedCount`
  				// makes the latter nonnegative.
  				matchedCount += i;

  				// Apply set filters to unmatched elements
  				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
  				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
  				// no element matchers and no seed.
  				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
  				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
  				// numerically zero.
  				if ( bySet && i !== matchedCount ) {
  					j = 0;
  					while ( ( matcher = setMatchers[ j++ ] ) ) {
  						matcher( unmatched, setMatched, context, xml );
  					}

  					if ( seed ) {

  						// Reintegrate element matches to eliminate the need for sorting
  						if ( matchedCount > 0 ) {
  							while ( i-- ) {
  								if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
  									setMatched[ i ] = pop.call( results );
  								}
  							}
  						}

  						// Discard index placeholder values to get only actual matches
  						setMatched = condense( setMatched );
  					}

  					// Add matches to results
  					push.apply( results, setMatched );

  					// Seedless set matches succeeding multiple successful matchers stipulate sorting
  					if ( outermost && !seed && setMatched.length > 0 &&
  						( matchedCount + setMatchers.length ) > 1 ) {

  						jQuery.uniqueSort( results );
  					}
  				}

  				// Override manipulation of globals by nested matchers
  				if ( outermost ) {
  					dirruns = dirrunsUnique;
  					outermostContext = contextBackup;
  				}

  				return unmatched;
  			};

  		return bySet ?
  			markFunction( superMatcher ) :
  			superMatcher;
  	}

  	function compile( selector, match /* Internal Use Only */ ) {
  		var i,
  			setMatchers = [],
  			elementMatchers = [],
  			cached = compilerCache[ selector + " " ];

  		if ( !cached ) {

  			// Generate a function of recursive functions that can be used to check each element
  			if ( !match ) {
  				match = tokenize( selector );
  			}
  			i = match.length;
  			while ( i-- ) {
  				cached = matcherFromTokens( match[ i ] );
  				if ( cached[ expando ] ) {
  					setMatchers.push( cached );
  				} else {
  					elementMatchers.push( cached );
  				}
  			}

  			// Cache the compiled function
  			cached = compilerCache( selector,
  				matcherFromGroupMatchers( elementMatchers, setMatchers ) );

  			// Save selector and tokenization
  			cached.selector = selector;
  		}
  		return cached;
  	}

  	/**
  	 * A low-level selection function that works with jQuery's compiled
  	 *  selector functions
  	 * @param {String|Function} selector A selector or a pre-compiled
  	 *  selector function built with jQuery selector compile
  	 * @param {Element} context
  	 * @param {Array} [results]
  	 * @param {Array} [seed] A set of elements to match against
  	 */
  	function select( selector, context, results, seed ) {
  		var i, tokens, token, type, find,
  			compiled = typeof selector === "function" && selector,
  			match = !seed && tokenize( ( selector = compiled.selector || selector ) );

  		results = results || [];

  		// Try to minimize operations if there is only one selector in the list and no seed
  		// (the latter of which guarantees us context)
  		if ( match.length === 1 ) {

  			// Reduce context if the leading compound selector is an ID
  			tokens = match[ 0 ] = match[ 0 ].slice( 0 );
  			if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
  					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

  				context = ( Expr.find.ID(
  					token.matches[ 0 ].replace( runescape, funescape ),
  					context
  				) || [] )[ 0 ];
  				if ( !context ) {
  					return results;

  				// Precompiled matchers will still verify ancestry, so step up a level
  				} else if ( compiled ) {
  					context = context.parentNode;
  				}

  				selector = selector.slice( tokens.shift().value.length );
  			}

  			// Fetch a seed set for right-to-left matching
  			i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
  			while ( i-- ) {
  				token = tokens[ i ];

  				// Abort if we hit a combinator
  				if ( Expr.relative[ ( type = token.type ) ] ) {
  					break;
  				}
  				if ( ( find = Expr.find[ type ] ) ) {

  					// Search, expanding context for leading sibling combinators
  					if ( ( seed = find(
  						token.matches[ 0 ].replace( runescape, funescape ),
  						rsibling.test( tokens[ 0 ].type ) &&
  							testContext( context.parentNode ) || context
  					) ) ) {

  						// If seed is empty or no tokens remain, we can return early
  						tokens.splice( i, 1 );
  						selector = seed.length && toSelector( tokens );
  						if ( !selector ) {
  							push.apply( results, seed );
  							return results;
  						}

  						break;
  					}
  				}
  			}
  		}

  		// Compile and execute a filtering function if one is not provided
  		// Provide `match` to avoid retokenization if we modified the selector above
  		( compiled || compile( selector, match ) )(
  			seed,
  			context,
  			!documentIsHTML,
  			results,
  			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
  		);
  		return results;
  	}

  	// One-time assignments

  	// Support: Android <=4.0 - 4.1+
  	// Sort stability
  	support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

  	// Initialize against the default document
  	setDocument();

  	// Support: Android <=4.0 - 4.1+
  	// Detached nodes confoundingly follow *each other*
  	support.sortDetached = assert( function( el ) {

  		// Should return 1, but returns 4 (following)
  		return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
  	} );

  	jQuery.find = find;

  	// Deprecated
  	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
  	jQuery.unique = jQuery.uniqueSort;

  	// These have always been private, but they used to be documented as part of
  	// Sizzle so let's maintain them for now for backwards compatibility purposes.
  	find.compile = compile;
  	find.select = select;
  	find.setDocument = setDocument;
  	find.tokenize = tokenize;

  	find.escape = jQuery.escapeSelector;
  	find.getText = jQuery.text;
  	find.isXML = jQuery.isXMLDoc;
  	find.selectors = jQuery.expr;
  	find.support = jQuery.support;
  	find.uniqueSort = jQuery.uniqueSort;

  		/* eslint-enable */

  	} )();


  	var dir = function( elem, dir, until ) {
  		var matched = [],
  			truncate = until !== undefined;

  		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
  			if ( elem.nodeType === 1 ) {
  				if ( truncate && jQuery( elem ).is( until ) ) {
  					break;
  				}
  				matched.push( elem );
  			}
  		}
  		return matched;
  	};


  	var siblings = function( n, elem ) {
  		var matched = [];

  		for ( ; n; n = n.nextSibling ) {
  			if ( n.nodeType === 1 && n !== elem ) {
  				matched.push( n );
  			}
  		}

  		return matched;
  	};


  	var rneedsContext = jQuery.expr.match.needsContext;

  	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



  	// Implement the identical functionality for filter and not
  	function winnow( elements, qualifier, not ) {
  		if ( isFunction( qualifier ) ) {
  			return jQuery.grep( elements, function( elem, i ) {
  				return !!qualifier.call( elem, i, elem ) !== not;
  			} );
  		}

  		// Single element
  		if ( qualifier.nodeType ) {
  			return jQuery.grep( elements, function( elem ) {
  				return ( elem === qualifier ) !== not;
  			} );
  		}

  		// Arraylike of elements (jQuery, arguments, Array)
  		if ( typeof qualifier !== "string" ) {
  			return jQuery.grep( elements, function( elem ) {
  				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
  			} );
  		}

  		// Filtered directly for both simple and complex selectors
  		return jQuery.filter( qualifier, elements, not );
  	}

  	jQuery.filter = function( expr, elems, not ) {
  		var elem = elems[ 0 ];

  		if ( not ) {
  			expr = ":not(" + expr + ")";
  		}

  		if ( elems.length === 1 && elem.nodeType === 1 ) {
  			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
  		}

  		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
  			return elem.nodeType === 1;
  		} ) );
  	};

  	jQuery.fn.extend( {
  		find: function( selector ) {
  			var i, ret,
  				len = this.length,
  				self = this;

  			if ( typeof selector !== "string" ) {
  				return this.pushStack( jQuery( selector ).filter( function() {
  					for ( i = 0; i < len; i++ ) {
  						if ( jQuery.contains( self[ i ], this ) ) {
  							return true;
  						}
  					}
  				} ) );
  			}

  			ret = this.pushStack( [] );

  			for ( i = 0; i < len; i++ ) {
  				jQuery.find( selector, self[ i ], ret );
  			}

  			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
  		},
  		filter: function( selector ) {
  			return this.pushStack( winnow( this, selector || [], false ) );
  		},
  		not: function( selector ) {
  			return this.pushStack( winnow( this, selector || [], true ) );
  		},
  		is: function( selector ) {
  			return !!winnow(
  				this,

  				// If this is a positional/relative selector, check membership in the returned set
  				// so $("p:first").is("p:last") won't return true for a doc with two "p".
  				typeof selector === "string" && rneedsContext.test( selector ) ?
  					jQuery( selector ) :
  					selector || [],
  				false
  			).length;
  		}
  	} );


  	// Initialize a jQuery object


  	// A central reference to the root jQuery(document)
  	var rootjQuery,

  		// A simple way to check for HTML strings
  		// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
  		// Strict HTML recognition (trac-11290: must start with <)
  		// Shortcut simple #id case for speed
  		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

  		init = jQuery.fn.init = function( selector, context, root ) {
  			var match, elem;

  			// HANDLE: $(""), $(null), $(undefined), $(false)
  			if ( !selector ) {
  				return this;
  			}

  			// Method init() accepts an alternate rootjQuery
  			// so migrate can support jQuery.sub (gh-2101)
  			root = root || rootjQuery;

  			// Handle HTML strings
  			if ( typeof selector === "string" ) {
  				if ( selector[ 0 ] === "<" &&
  					selector[ selector.length - 1 ] === ">" &&
  					selector.length >= 3 ) {

  					// Assume that strings that start and end with <> are HTML and skip the regex check
  					match = [ null, selector, null ];

  				} else {
  					match = rquickExpr.exec( selector );
  				}

  				// Match html or make sure no context is specified for #id
  				if ( match && ( match[ 1 ] || !context ) ) {

  					// HANDLE: $(html) -> $(array)
  					if ( match[ 1 ] ) {
  						context = context instanceof jQuery ? context[ 0 ] : context;

  						// Option to run scripts is true for back-compat
  						// Intentionally let the error be thrown if parseHTML is not present
  						jQuery.merge( this, jQuery.parseHTML(
  							match[ 1 ],
  							context && context.nodeType ? context.ownerDocument || context : document,
  							true
  						) );

  						// HANDLE: $(html, props)
  						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
  							for ( match in context ) {

  								// Properties of context are called as methods if possible
  								if ( isFunction( this[ match ] ) ) {
  									this[ match ]( context[ match ] );

  								// ...and otherwise set as attributes
  								} else {
  									this.attr( match, context[ match ] );
  								}
  							}
  						}

  						return this;

  					// HANDLE: $(#id)
  					} else {
  						elem = document.getElementById( match[ 2 ] );

  						if ( elem ) {

  							// Inject the element directly into the jQuery object
  							this[ 0 ] = elem;
  							this.length = 1;
  						}
  						return this;
  					}

  				// HANDLE: $(expr, $(...))
  				} else if ( !context || context.jquery ) {
  					return ( context || root ).find( selector );

  				// HANDLE: $(expr, context)
  				// (which is just equivalent to: $(context).find(expr)
  				} else {
  					return this.constructor( context ).find( selector );
  				}

  			// HANDLE: $(DOMElement)
  			} else if ( selector.nodeType ) {
  				this[ 0 ] = selector;
  				this.length = 1;
  				return this;

  			// HANDLE: $(function)
  			// Shortcut for document ready
  			} else if ( isFunction( selector ) ) {
  				return root.ready !== undefined ?
  					root.ready( selector ) :

  					// Execute immediately if ready is not present
  					selector( jQuery );
  			}

  			return jQuery.makeArray( selector, this );
  		};

  	// Give the init function the jQuery prototype for later instantiation
  	init.prototype = jQuery.fn;

  	// Initialize central reference
  	rootjQuery = jQuery( document );


  	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

  		// Methods guaranteed to produce a unique set when starting from a unique set
  		guaranteedUnique = {
  			children: true,
  			contents: true,
  			next: true,
  			prev: true
  		};

  	jQuery.fn.extend( {
  		has: function( target ) {
  			var targets = jQuery( target, this ),
  				l = targets.length;

  			return this.filter( function() {
  				var i = 0;
  				for ( ; i < l; i++ ) {
  					if ( jQuery.contains( this, targets[ i ] ) ) {
  						return true;
  					}
  				}
  			} );
  		},

  		closest: function( selectors, context ) {
  			var cur,
  				i = 0,
  				l = this.length,
  				matched = [],
  				targets = typeof selectors !== "string" && jQuery( selectors );

  			// Positional selectors never match, since there's no _selection_ context
  			if ( !rneedsContext.test( selectors ) ) {
  				for ( ; i < l; i++ ) {
  					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

  						// Always skip document fragments
  						if ( cur.nodeType < 11 && ( targets ?
  							targets.index( cur ) > -1 :

  							// Don't pass non-elements to jQuery#find
  							cur.nodeType === 1 &&
  								jQuery.find.matchesSelector( cur, selectors ) ) ) {

  							matched.push( cur );
  							break;
  						}
  					}
  				}
  			}

  			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
  		},

  		// Determine the position of an element within the set
  		index: function( elem ) {

  			// No argument, return index in parent
  			if ( !elem ) {
  				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
  			}

  			// Index in selector
  			if ( typeof elem === "string" ) {
  				return indexOf.call( jQuery( elem ), this[ 0 ] );
  			}

  			// Locate the position of the desired element
  			return indexOf.call( this,

  				// If it receives a jQuery object, the first element is used
  				elem.jquery ? elem[ 0 ] : elem
  			);
  		},

  		add: function( selector, context ) {
  			return this.pushStack(
  				jQuery.uniqueSort(
  					jQuery.merge( this.get(), jQuery( selector, context ) )
  				)
  			);
  		},

  		addBack: function( selector ) {
  			return this.add( selector == null ?
  				this.prevObject : this.prevObject.filter( selector )
  			);
  		}
  	} );

  	function sibling( cur, dir ) {
  		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
  		return cur;
  	}

  	jQuery.each( {
  		parent: function( elem ) {
  			var parent = elem.parentNode;
  			return parent && parent.nodeType !== 11 ? parent : null;
  		},
  		parents: function( elem ) {
  			return dir( elem, "parentNode" );
  		},
  		parentsUntil: function( elem, _i, until ) {
  			return dir( elem, "parentNode", until );
  		},
  		next: function( elem ) {
  			return sibling( elem, "nextSibling" );
  		},
  		prev: function( elem ) {
  			return sibling( elem, "previousSibling" );
  		},
  		nextAll: function( elem ) {
  			return dir( elem, "nextSibling" );
  		},
  		prevAll: function( elem ) {
  			return dir( elem, "previousSibling" );
  		},
  		nextUntil: function( elem, _i, until ) {
  			return dir( elem, "nextSibling", until );
  		},
  		prevUntil: function( elem, _i, until ) {
  			return dir( elem, "previousSibling", until );
  		},
  		siblings: function( elem ) {
  			return siblings( ( elem.parentNode || {} ).firstChild, elem );
  		},
  		children: function( elem ) {
  			return siblings( elem.firstChild );
  		},
  		contents: function( elem ) {
  			if ( elem.contentDocument != null &&

  				// Support: IE 11+
  				// <object> elements with no `data` attribute has an object
  				// `contentDocument` with a `null` prototype.
  				getProto( elem.contentDocument ) ) {

  				return elem.contentDocument;
  			}

  			// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
  			// Treat the template element as a regular one in browsers that
  			// don't support it.
  			if ( nodeName( elem, "template" ) ) {
  				elem = elem.content || elem;
  			}

  			return jQuery.merge( [], elem.childNodes );
  		}
  	}, function( name, fn ) {
  		jQuery.fn[ name ] = function( until, selector ) {
  			var matched = jQuery.map( this, fn, until );

  			if ( name.slice( -5 ) !== "Until" ) {
  				selector = until;
  			}

  			if ( selector && typeof selector === "string" ) {
  				matched = jQuery.filter( selector, matched );
  			}

  			if ( this.length > 1 ) {

  				// Remove duplicates
  				if ( !guaranteedUnique[ name ] ) {
  					jQuery.uniqueSort( matched );
  				}

  				// Reverse order for parents* and prev-derivatives
  				if ( rparentsprev.test( name ) ) {
  					matched.reverse();
  				}
  			}

  			return this.pushStack( matched );
  		};
  	} );
  	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



  	// Convert String-formatted options into Object-formatted ones
  	function createOptions( options ) {
  		var object = {};
  		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
  			object[ flag ] = true;
  		} );
  		return object;
  	}

  	/*
  	 * Create a callback list using the following parameters:
  	 *
  	 *	options: an optional list of space-separated options that will change how
  	 *			the callback list behaves or a more traditional option object
  	 *
  	 * By default a callback list will act like an event callback list and can be
  	 * "fired" multiple times.
  	 *
  	 * Possible options:
  	 *
  	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
  	 *
  	 *	memory:			will keep track of previous values and will call any callback added
  	 *					after the list has been fired right away with the latest "memorized"
  	 *					values (like a Deferred)
  	 *
  	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  	 *
  	 *	stopOnFalse:	interrupt callings when a callback returns false
  	 *
  	 */
  	jQuery.Callbacks = function( options ) {

  		// Convert options from String-formatted to Object-formatted if needed
  		// (we check in cache first)
  		options = typeof options === "string" ?
  			createOptions( options ) :
  			jQuery.extend( {}, options );

  		var // Flag to know if list is currently firing
  			firing,

  			// Last fire value for non-forgettable lists
  			memory,

  			// Flag to know if list was already fired
  			fired,

  			// Flag to prevent firing
  			locked,

  			// Actual callback list
  			list = [],

  			// Queue of execution data for repeatable lists
  			queue = [],

  			// Index of currently firing callback (modified by add/remove as needed)
  			firingIndex = -1,

  			// Fire callbacks
  			fire = function() {

  				// Enforce single-firing
  				locked = locked || options.once;

  				// Execute callbacks for all pending executions,
  				// respecting firingIndex overrides and runtime changes
  				fired = firing = true;
  				for ( ; queue.length; firingIndex = -1 ) {
  					memory = queue.shift();
  					while ( ++firingIndex < list.length ) {

  						// Run callback and check for early termination
  						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
  							options.stopOnFalse ) {

  							// Jump to end and forget the data so .add doesn't re-fire
  							firingIndex = list.length;
  							memory = false;
  						}
  					}
  				}

  				// Forget the data if we're done with it
  				if ( !options.memory ) {
  					memory = false;
  				}

  				firing = false;

  				// Clean up if we're done firing for good
  				if ( locked ) {

  					// Keep an empty list if we have data for future add calls
  					if ( memory ) {
  						list = [];

  					// Otherwise, this object is spent
  					} else {
  						list = "";
  					}
  				}
  			},

  			// Actual Callbacks object
  			self = {

  				// Add a callback or a collection of callbacks to the list
  				add: function() {
  					if ( list ) {

  						// If we have memory from a past run, we should fire after adding
  						if ( memory && !firing ) {
  							firingIndex = list.length - 1;
  							queue.push( memory );
  						}

  						( function add( args ) {
  							jQuery.each( args, function( _, arg ) {
  								if ( isFunction( arg ) ) {
  									if ( !options.unique || !self.has( arg ) ) {
  										list.push( arg );
  									}
  								} else if ( arg && arg.length && toType( arg ) !== "string" ) {

  									// Inspect recursively
  									add( arg );
  								}
  							} );
  						} )( arguments );

  						if ( memory && !firing ) {
  							fire();
  						}
  					}
  					return this;
  				},

  				// Remove a callback from the list
  				remove: function() {
  					jQuery.each( arguments, function( _, arg ) {
  						var index;
  						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
  							list.splice( index, 1 );

  							// Handle firing indexes
  							if ( index <= firingIndex ) {
  								firingIndex--;
  							}
  						}
  					} );
  					return this;
  				},

  				// Check if a given callback is in the list.
  				// If no argument is given, return whether or not list has callbacks attached.
  				has: function( fn ) {
  					return fn ?
  						jQuery.inArray( fn, list ) > -1 :
  						list.length > 0;
  				},

  				// Remove all callbacks from the list
  				empty: function() {
  					if ( list ) {
  						list = [];
  					}
  					return this;
  				},

  				// Disable .fire and .add
  				// Abort any current/pending executions
  				// Clear all callbacks and values
  				disable: function() {
  					locked = queue = [];
  					list = memory = "";
  					return this;
  				},
  				disabled: function() {
  					return !list;
  				},

  				// Disable .fire
  				// Also disable .add unless we have memory (since it would have no effect)
  				// Abort any pending executions
  				lock: function() {
  					locked = queue = [];
  					if ( !memory && !firing ) {
  						list = memory = "";
  					}
  					return this;
  				},
  				locked: function() {
  					return !!locked;
  				},

  				// Call all callbacks with the given context and arguments
  				fireWith: function( context, args ) {
  					if ( !locked ) {
  						args = args || [];
  						args = [ context, args.slice ? args.slice() : args ];
  						queue.push( args );
  						if ( !firing ) {
  							fire();
  						}
  					}
  					return this;
  				},

  				// Call all the callbacks with the given arguments
  				fire: function() {
  					self.fireWith( this, arguments );
  					return this;
  				},

  				// To know if the callbacks have already been called at least once
  				fired: function() {
  					return !!fired;
  				}
  			};

  		return self;
  	};


  	function Identity( v ) {
  		return v;
  	}
  	function Thrower( ex ) {
  		throw ex;
  	}

  	function adoptValue( value, resolve, reject, noValue ) {
  		var method;

  		try {

  			// Check for promise aspect first to privilege synchronous behavior
  			if ( value && isFunction( ( method = value.promise ) ) ) {
  				method.call( value ).done( resolve ).fail( reject );

  			// Other thenables
  			} else if ( value && isFunction( ( method = value.then ) ) ) {
  				method.call( value, resolve, reject );

  			// Other non-thenables
  			} else {

  				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
  				// * false: [ value ].slice( 0 ) => resolve( value )
  				// * true: [ value ].slice( 1 ) => resolve()
  				resolve.apply( undefined, [ value ].slice( noValue ) );
  			}

  		// For Promises/A+, convert exceptions into rejections
  		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
  		// Deferred#then to conditionally suppress rejection.
  		} catch ( value ) {

  			// Support: Android 4.0 only
  			// Strict mode functions invoked without .call/.apply get global-object context
  			reject.apply( undefined, [ value ] );
  		}
  	}

  	jQuery.extend( {

  		Deferred: function( func ) {
  			var tuples = [

  					// action, add listener, callbacks,
  					// ... .then handlers, argument index, [final state]
  					[ "notify", "progress", jQuery.Callbacks( "memory" ),
  						jQuery.Callbacks( "memory" ), 2 ],
  					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
  						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
  					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
  						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
  				],
  				state = "pending",
  				promise = {
  					state: function() {
  						return state;
  					},
  					always: function() {
  						deferred.done( arguments ).fail( arguments );
  						return this;
  					},
  					"catch": function( fn ) {
  						return promise.then( null, fn );
  					},

  					// Keep pipe for back-compat
  					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
  						var fns = arguments;

  						return jQuery.Deferred( function( newDefer ) {
  							jQuery.each( tuples, function( _i, tuple ) {

  								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
  								var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

  								// deferred.progress(function() { bind to newDefer or newDefer.notify })
  								// deferred.done(function() { bind to newDefer or newDefer.resolve })
  								// deferred.fail(function() { bind to newDefer or newDefer.reject })
  								deferred[ tuple[ 1 ] ]( function() {
  									var returned = fn && fn.apply( this, arguments );
  									if ( returned && isFunction( returned.promise ) ) {
  										returned.promise()
  											.progress( newDefer.notify )
  											.done( newDefer.resolve )
  											.fail( newDefer.reject );
  									} else {
  										newDefer[ tuple[ 0 ] + "With" ](
  											this,
  											fn ? [ returned ] : arguments
  										);
  									}
  								} );
  							} );
  							fns = null;
  						} ).promise();
  					},
  					then: function( onFulfilled, onRejected, onProgress ) {
  						var maxDepth = 0;
  						function resolve( depth, deferred, handler, special ) {
  							return function() {
  								var that = this,
  									args = arguments,
  									mightThrow = function() {
  										var returned, then;

  										// Support: Promises/A+ section 2.3.3.3.3
  										// https://promisesaplus.com/#point-59
  										// Ignore double-resolution attempts
  										if ( depth < maxDepth ) {
  											return;
  										}

  										returned = handler.apply( that, args );

  										// Support: Promises/A+ section 2.3.1
  										// https://promisesaplus.com/#point-48
  										if ( returned === deferred.promise() ) {
  											throw new TypeError( "Thenable self-resolution" );
  										}

  										// Support: Promises/A+ sections 2.3.3.1, 3.5
  										// https://promisesaplus.com/#point-54
  										// https://promisesaplus.com/#point-75
  										// Retrieve `then` only once
  										then = returned &&

  											// Support: Promises/A+ section 2.3.4
  											// https://promisesaplus.com/#point-64
  											// Only check objects and functions for thenability
  											( typeof returned === "object" ||
  												typeof returned === "function" ) &&
  											returned.then;

  										// Handle a returned thenable
  										if ( isFunction( then ) ) {

  											// Special processors (notify) just wait for resolution
  											if ( special ) {
  												then.call(
  													returned,
  													resolve( maxDepth, deferred, Identity, special ),
  													resolve( maxDepth, deferred, Thrower, special )
  												);

  											// Normal processors (resolve) also hook into progress
  											} else {

  												// ...and disregard older resolution values
  												maxDepth++;

  												then.call(
  													returned,
  													resolve( maxDepth, deferred, Identity, special ),
  													resolve( maxDepth, deferred, Thrower, special ),
  													resolve( maxDepth, deferred, Identity,
  														deferred.notifyWith )
  												);
  											}

  										// Handle all other returned values
  										} else {

  											// Only substitute handlers pass on context
  											// and multiple values (non-spec behavior)
  											if ( handler !== Identity ) {
  												that = undefined;
  												args = [ returned ];
  											}

  											// Process the value(s)
  											// Default process is resolve
  											( special || deferred.resolveWith )( that, args );
  										}
  									},

  									// Only normal processors (resolve) catch and reject exceptions
  									process = special ?
  										mightThrow :
  										function() {
  											try {
  												mightThrow();
  											} catch ( e ) {

  												if ( jQuery.Deferred.exceptionHook ) {
  													jQuery.Deferred.exceptionHook( e,
  														process.error );
  												}

  												// Support: Promises/A+ section 2.3.3.3.4.1
  												// https://promisesaplus.com/#point-61
  												// Ignore post-resolution exceptions
  												if ( depth + 1 >= maxDepth ) {

  													// Only substitute handlers pass on context
  													// and multiple values (non-spec behavior)
  													if ( handler !== Thrower ) {
  														that = undefined;
  														args = [ e ];
  													}

  													deferred.rejectWith( that, args );
  												}
  											}
  										};

  								// Support: Promises/A+ section 2.3.3.3.1
  								// https://promisesaplus.com/#point-57
  								// Re-resolve promises immediately to dodge false rejection from
  								// subsequent errors
  								if ( depth ) {
  									process();
  								} else {

  									// Call an optional hook to record the error, in case of exception
  									// since it's otherwise lost when execution goes async
  									if ( jQuery.Deferred.getErrorHook ) {
  										process.error = jQuery.Deferred.getErrorHook();

  									// The deprecated alias of the above. While the name suggests
  									// returning the stack, not an error instance, jQuery just passes
  									// it directly to `console.warn` so both will work; an instance
  									// just better cooperates with source maps.
  									} else if ( jQuery.Deferred.getStackHook ) {
  										process.error = jQuery.Deferred.getStackHook();
  									}
  									window.setTimeout( process );
  								}
  							};
  						}

  						return jQuery.Deferred( function( newDefer ) {

  							// progress_handlers.add( ... )
  							tuples[ 0 ][ 3 ].add(
  								resolve(
  									0,
  									newDefer,
  									isFunction( onProgress ) ?
  										onProgress :
  										Identity,
  									newDefer.notifyWith
  								)
  							);

  							// fulfilled_handlers.add( ... )
  							tuples[ 1 ][ 3 ].add(
  								resolve(
  									0,
  									newDefer,
  									isFunction( onFulfilled ) ?
  										onFulfilled :
  										Identity
  								)
  							);

  							// rejected_handlers.add( ... )
  							tuples[ 2 ][ 3 ].add(
  								resolve(
  									0,
  									newDefer,
  									isFunction( onRejected ) ?
  										onRejected :
  										Thrower
  								)
  							);
  						} ).promise();
  					},

  					// Get a promise for this deferred
  					// If obj is provided, the promise aspect is added to the object
  					promise: function( obj ) {
  						return obj != null ? jQuery.extend( obj, promise ) : promise;
  					}
  				},
  				deferred = {};

  			// Add list-specific methods
  			jQuery.each( tuples, function( i, tuple ) {
  				var list = tuple[ 2 ],
  					stateString = tuple[ 5 ];

  				// promise.progress = list.add
  				// promise.done = list.add
  				// promise.fail = list.add
  				promise[ tuple[ 1 ] ] = list.add;

  				// Handle state
  				if ( stateString ) {
  					list.add(
  						function() {

  							// state = "resolved" (i.e., fulfilled)
  							// state = "rejected"
  							state = stateString;
  						},

  						// rejected_callbacks.disable
  						// fulfilled_callbacks.disable
  						tuples[ 3 - i ][ 2 ].disable,

  						// rejected_handlers.disable
  						// fulfilled_handlers.disable
  						tuples[ 3 - i ][ 3 ].disable,

  						// progress_callbacks.lock
  						tuples[ 0 ][ 2 ].lock,

  						// progress_handlers.lock
  						tuples[ 0 ][ 3 ].lock
  					);
  				}

  				// progress_handlers.fire
  				// fulfilled_handlers.fire
  				// rejected_handlers.fire
  				list.add( tuple[ 3 ].fire );

  				// deferred.notify = function() { deferred.notifyWith(...) }
  				// deferred.resolve = function() { deferred.resolveWith(...) }
  				// deferred.reject = function() { deferred.rejectWith(...) }
  				deferred[ tuple[ 0 ] ] = function() {
  					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
  					return this;
  				};

  				// deferred.notifyWith = list.fireWith
  				// deferred.resolveWith = list.fireWith
  				// deferred.rejectWith = list.fireWith
  				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
  			} );

  			// Make the deferred a promise
  			promise.promise( deferred );

  			// Call given func if any
  			if ( func ) {
  				func.call( deferred, deferred );
  			}

  			// All done!
  			return deferred;
  		},

  		// Deferred helper
  		when: function( singleValue ) {
  			var

  				// count of uncompleted subordinates
  				remaining = arguments.length,

  				// count of unprocessed arguments
  				i = remaining,

  				// subordinate fulfillment data
  				resolveContexts = Array( i ),
  				resolveValues = slice.call( arguments ),

  				// the primary Deferred
  				primary = jQuery.Deferred(),

  				// subordinate callback factory
  				updateFunc = function( i ) {
  					return function( value ) {
  						resolveContexts[ i ] = this;
  						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
  						if ( !( --remaining ) ) {
  							primary.resolveWith( resolveContexts, resolveValues );
  						}
  					};
  				};

  			// Single- and empty arguments are adopted like Promise.resolve
  			if ( remaining <= 1 ) {
  				adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
  					!remaining );

  				// Use .then() to unwrap secondary thenables (cf. gh-3000)
  				if ( primary.state() === "pending" ||
  					isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

  					return primary.then();
  				}
  			}

  			// Multiple arguments are aggregated like Promise.all array elements
  			while ( i-- ) {
  				adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
  			}

  			return primary.promise();
  		}
  	} );


  	// These usually indicate a programmer mistake during development,
  	// warn about them ASAP rather than swallowing them by default.
  	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  	// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
  	// captured before the async barrier to get the original error cause
  	// which may otherwise be hidden.
  	jQuery.Deferred.exceptionHook = function( error, asyncError ) {

  		// Support: IE 8 - 9 only
  		// Console exists when dev tools are open, which can happen at any time
  		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
  			window.console.warn( "jQuery.Deferred exception: " + error.message,
  				error.stack, asyncError );
  		}
  	};




  	jQuery.readyException = function( error ) {
  		window.setTimeout( function() {
  			throw error;
  		} );
  	};




  	// The deferred used on DOM ready
  	var readyList = jQuery.Deferred();

  	jQuery.fn.ready = function( fn ) {

  		readyList
  			.then( fn )

  			// Wrap jQuery.readyException in a function so that the lookup
  			// happens at the time of error handling instead of callback
  			// registration.
  			.catch( function( error ) {
  				jQuery.readyException( error );
  			} );

  		return this;
  	};

  	jQuery.extend( {

  		// Is the DOM ready to be used? Set to true once it occurs.
  		isReady: false,

  		// A counter to track how many items to wait for before
  		// the ready event fires. See trac-6781
  		readyWait: 1,

  		// Handle when the DOM is ready
  		ready: function( wait ) {

  			// Abort if there are pending holds or we're already ready
  			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
  				return;
  			}

  			// Remember that the DOM is ready
  			jQuery.isReady = true;

  			// If a normal DOM Ready event fired, decrement, and wait if need be
  			if ( wait !== true && --jQuery.readyWait > 0 ) {
  				return;
  			}

  			// If there are functions bound, to execute
  			readyList.resolveWith( document, [ jQuery ] );
  		}
  	} );

  	jQuery.ready.then = readyList.then;

  	// The ready event handler and self cleanup method
  	function completed() {
  		document.removeEventListener( "DOMContentLoaded", completed );
  		window.removeEventListener( "load", completed );
  		jQuery.ready();
  	}

  	// Catch cases where $(document).ready() is called
  	// after the browser event has already occurred.
  	// Support: IE <=9 - 10 only
  	// Older IE sometimes signals "interactive" too soon
  	if ( document.readyState === "complete" ||
  		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

  		// Handle it asynchronously to allow scripts the opportunity to delay ready
  		window.setTimeout( jQuery.ready );

  	} else {

  		// Use the handy event callback
  		document.addEventListener( "DOMContentLoaded", completed );

  		// A fallback to window.onload, that will always work
  		window.addEventListener( "load", completed );
  	}




  	// Multifunctional method to get and set values of a collection
  	// The value/s can optionally be executed if it's a function
  	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
  		var i = 0,
  			len = elems.length,
  			bulk = key == null;

  		// Sets many values
  		if ( toType( key ) === "object" ) {
  			chainable = true;
  			for ( i in key ) {
  				access( elems, fn, i, key[ i ], true, emptyGet, raw );
  			}

  		// Sets one value
  		} else if ( value !== undefined ) {
  			chainable = true;

  			if ( !isFunction( value ) ) {
  				raw = true;
  			}

  			if ( bulk ) {

  				// Bulk operations run against the entire set
  				if ( raw ) {
  					fn.call( elems, value );
  					fn = null;

  				// ...except when executing function values
  				} else {
  					bulk = fn;
  					fn = function( elem, _key, value ) {
  						return bulk.call( jQuery( elem ), value );
  					};
  				}
  			}

  			if ( fn ) {
  				for ( ; i < len; i++ ) {
  					fn(
  						elems[ i ], key, raw ?
  							value :
  							value.call( elems[ i ], i, fn( elems[ i ], key ) )
  					);
  				}
  			}
  		}

  		if ( chainable ) {
  			return elems;
  		}

  		// Gets
  		if ( bulk ) {
  			return fn.call( elems );
  		}

  		return len ? fn( elems[ 0 ], key ) : emptyGet;
  	};


  	// Matches dashed string for camelizing
  	var rmsPrefix = /^-ms-/,
  		rdashAlpha = /-([a-z])/g;

  	// Used by camelCase as callback to replace()
  	function fcamelCase( _all, letter ) {
  		return letter.toUpperCase();
  	}

  	// Convert dashed to camelCase; used by the css and data modules
  	// Support: IE <=9 - 11, Edge 12 - 15
  	// Microsoft forgot to hump their vendor prefix (trac-9572)
  	function camelCase( string ) {
  		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  	}
  	var acceptData = function( owner ) {

  		// Accepts only:
  		//  - Node
  		//    - Node.ELEMENT_NODE
  		//    - Node.DOCUMENT_NODE
  		//  - Object
  		//    - Any
  		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
  	};




  	function Data() {
  		this.expando = jQuery.expando + Data.uid++;
  	}

  	Data.uid = 1;

  	Data.prototype = {

  		cache: function( owner ) {

  			// Check if the owner object already has a cache
  			var value = owner[ this.expando ];

  			// If not, create one
  			if ( !value ) {
  				value = {};

  				// We can accept data for non-element nodes in modern browsers,
  				// but we should not, see trac-8335.
  				// Always return an empty object.
  				if ( acceptData( owner ) ) {

  					// If it is a node unlikely to be stringify-ed or looped over
  					// use plain assignment
  					if ( owner.nodeType ) {
  						owner[ this.expando ] = value;

  					// Otherwise secure it in a non-enumerable property
  					// configurable must be true to allow the property to be
  					// deleted when data is removed
  					} else {
  						Object.defineProperty( owner, this.expando, {
  							value: value,
  							configurable: true
  						} );
  					}
  				}
  			}

  			return value;
  		},
  		set: function( owner, data, value ) {
  			var prop,
  				cache = this.cache( owner );

  			// Handle: [ owner, key, value ] args
  			// Always use camelCase key (gh-2257)
  			if ( typeof data === "string" ) {
  				cache[ camelCase( data ) ] = value;

  			// Handle: [ owner, { properties } ] args
  			} else {

  				// Copy the properties one-by-one to the cache object
  				for ( prop in data ) {
  					cache[ camelCase( prop ) ] = data[ prop ];
  				}
  			}
  			return cache;
  		},
  		get: function( owner, key ) {
  			return key === undefined ?
  				this.cache( owner ) :

  				// Always use camelCase key (gh-2257)
  				owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
  		},
  		access: function( owner, key, value ) {

  			// In cases where either:
  			//
  			//   1. No key was specified
  			//   2. A string key was specified, but no value provided
  			//
  			// Take the "read" path and allow the get method to determine
  			// which value to return, respectively either:
  			//
  			//   1. The entire cache object
  			//   2. The data stored at the key
  			//
  			if ( key === undefined ||
  					( ( key && typeof key === "string" ) && value === undefined ) ) {

  				return this.get( owner, key );
  			}

  			// When the key is not a string, or both a key and value
  			// are specified, set or extend (existing objects) with either:
  			//
  			//   1. An object of properties
  			//   2. A key and value
  			//
  			this.set( owner, key, value );

  			// Since the "set" path can have two possible entry points
  			// return the expected data based on which path was taken[*]
  			return value !== undefined ? value : key;
  		},
  		remove: function( owner, key ) {
  			var i,
  				cache = owner[ this.expando ];

  			if ( cache === undefined ) {
  				return;
  			}

  			if ( key !== undefined ) {

  				// Support array or space separated string of keys
  				if ( Array.isArray( key ) ) {

  					// If key is an array of keys...
  					// We always set camelCase keys, so remove that.
  					key = key.map( camelCase );
  				} else {
  					key = camelCase( key );

  					// If a key with the spaces exists, use it.
  					// Otherwise, create an array by matching non-whitespace
  					key = key in cache ?
  						[ key ] :
  						( key.match( rnothtmlwhite ) || [] );
  				}

  				i = key.length;

  				while ( i-- ) {
  					delete cache[ key[ i ] ];
  				}
  			}

  			// Remove the expando if there's no more data
  			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

  				// Support: Chrome <=35 - 45
  				// Webkit & Blink performance suffers when deleting properties
  				// from DOM nodes, so set to undefined instead
  				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
  				if ( owner.nodeType ) {
  					owner[ this.expando ] = undefined;
  				} else {
  					delete owner[ this.expando ];
  				}
  			}
  		},
  		hasData: function( owner ) {
  			var cache = owner[ this.expando ];
  			return cache !== undefined && !jQuery.isEmptyObject( cache );
  		}
  	};
  	var dataPriv = new Data();

  	var dataUser = new Data();



  	//	Implementation Summary
  	//
  	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
  	//	2. Improve the module's maintainability by reducing the storage
  	//		paths to a single mechanism.
  	//	3. Use the same single mechanism to support "private" and "user" data.
  	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
  	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  		rmultiDash = /[A-Z]/g;

  	function getData( data ) {
  		if ( data === "true" ) {
  			return true;
  		}

  		if ( data === "false" ) {
  			return false;
  		}

  		if ( data === "null" ) {
  			return null;
  		}

  		// Only convert to a number if it doesn't change the string
  		if ( data === +data + "" ) {
  			return +data;
  		}

  		if ( rbrace.test( data ) ) {
  			return JSON.parse( data );
  		}

  		return data;
  	}

  	function dataAttr( elem, key, data ) {
  		var name;

  		// If nothing was found internally, try to fetch any
  		// data from the HTML5 data-* attribute
  		if ( data === undefined && elem.nodeType === 1 ) {
  			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
  			data = elem.getAttribute( name );

  			if ( typeof data === "string" ) {
  				try {
  					data = getData( data );
  				} catch ( e ) {}

  				// Make sure we set the data so it isn't changed later
  				dataUser.set( elem, key, data );
  			} else {
  				data = undefined;
  			}
  		}
  		return data;
  	}

  	jQuery.extend( {
  		hasData: function( elem ) {
  			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
  		},

  		data: function( elem, name, data ) {
  			return dataUser.access( elem, name, data );
  		},

  		removeData: function( elem, name ) {
  			dataUser.remove( elem, name );
  		},

  		// TODO: Now that all calls to _data and _removeData have been replaced
  		// with direct calls to dataPriv methods, these can be deprecated.
  		_data: function( elem, name, data ) {
  			return dataPriv.access( elem, name, data );
  		},

  		_removeData: function( elem, name ) {
  			dataPriv.remove( elem, name );
  		}
  	} );

  	jQuery.fn.extend( {
  		data: function( key, value ) {
  			var i, name, data,
  				elem = this[ 0 ],
  				attrs = elem && elem.attributes;

  			// Gets all values
  			if ( key === undefined ) {
  				if ( this.length ) {
  					data = dataUser.get( elem );

  					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
  						i = attrs.length;
  						while ( i-- ) {

  							// Support: IE 11 only
  							// The attrs elements can be null (trac-14894)
  							if ( attrs[ i ] ) {
  								name = attrs[ i ].name;
  								if ( name.indexOf( "data-" ) === 0 ) {
  									name = camelCase( name.slice( 5 ) );
  									dataAttr( elem, name, data[ name ] );
  								}
  							}
  						}
  						dataPriv.set( elem, "hasDataAttrs", true );
  					}
  				}

  				return data;
  			}

  			// Sets multiple values
  			if ( typeof key === "object" ) {
  				return this.each( function() {
  					dataUser.set( this, key );
  				} );
  			}

  			return access( this, function( value ) {
  				var data;

  				// The calling jQuery object (element matches) is not empty
  				// (and therefore has an element appears at this[ 0 ]) and the
  				// `value` parameter was not undefined. An empty jQuery object
  				// will result in `undefined` for elem = this[ 0 ] which will
  				// throw an exception if an attempt to read a data cache is made.
  				if ( elem && value === undefined ) {

  					// Attempt to get data from the cache
  					// The key will always be camelCased in Data
  					data = dataUser.get( elem, key );
  					if ( data !== undefined ) {
  						return data;
  					}

  					// Attempt to "discover" the data in
  					// HTML5 custom data-* attrs
  					data = dataAttr( elem, key );
  					if ( data !== undefined ) {
  						return data;
  					}

  					// We tried really hard, but the data doesn't exist.
  					return;
  				}

  				// Set the data...
  				this.each( function() {

  					// We always store the camelCased key
  					dataUser.set( this, key, value );
  				} );
  			}, null, value, arguments.length > 1, null, true );
  		},

  		removeData: function( key ) {
  			return this.each( function() {
  				dataUser.remove( this, key );
  			} );
  		}
  	} );


  	jQuery.extend( {
  		queue: function( elem, type, data ) {
  			var queue;

  			if ( elem ) {
  				type = ( type || "fx" ) + "queue";
  				queue = dataPriv.get( elem, type );

  				// Speed up dequeue by getting out quickly if this is just a lookup
  				if ( data ) {
  					if ( !queue || Array.isArray( data ) ) {
  						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
  					} else {
  						queue.push( data );
  					}
  				}
  				return queue || [];
  			}
  		},

  		dequeue: function( elem, type ) {
  			type = type || "fx";

  			var queue = jQuery.queue( elem, type ),
  				startLength = queue.length,
  				fn = queue.shift(),
  				hooks = jQuery._queueHooks( elem, type ),
  				next = function() {
  					jQuery.dequeue( elem, type );
  				};

  			// If the fx queue is dequeued, always remove the progress sentinel
  			if ( fn === "inprogress" ) {
  				fn = queue.shift();
  				startLength--;
  			}

  			if ( fn ) {

  				// Add a progress sentinel to prevent the fx queue from being
  				// automatically dequeued
  				if ( type === "fx" ) {
  					queue.unshift( "inprogress" );
  				}

  				// Clear up the last queue stop function
  				delete hooks.stop;
  				fn.call( elem, next, hooks );
  			}

  			if ( !startLength && hooks ) {
  				hooks.empty.fire();
  			}
  		},

  		// Not public - generate a queueHooks object, or return the current one
  		_queueHooks: function( elem, type ) {
  			var key = type + "queueHooks";
  			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
  				empty: jQuery.Callbacks( "once memory" ).add( function() {
  					dataPriv.remove( elem, [ type + "queue", key ] );
  				} )
  			} );
  		}
  	} );

  	jQuery.fn.extend( {
  		queue: function( type, data ) {
  			var setter = 2;

  			if ( typeof type !== "string" ) {
  				data = type;
  				type = "fx";
  				setter--;
  			}

  			if ( arguments.length < setter ) {
  				return jQuery.queue( this[ 0 ], type );
  			}

  			return data === undefined ?
  				this :
  				this.each( function() {
  					var queue = jQuery.queue( this, type, data );

  					// Ensure a hooks for this queue
  					jQuery._queueHooks( this, type );

  					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
  						jQuery.dequeue( this, type );
  					}
  				} );
  		},
  		dequeue: function( type ) {
  			return this.each( function() {
  				jQuery.dequeue( this, type );
  			} );
  		},
  		clearQueue: function( type ) {
  			return this.queue( type || "fx", [] );
  		},

  		// Get a promise resolved when queues of a certain type
  		// are emptied (fx is the type by default)
  		promise: function( type, obj ) {
  			var tmp,
  				count = 1,
  				defer = jQuery.Deferred(),
  				elements = this,
  				i = this.length,
  				resolve = function() {
  					if ( !( --count ) ) {
  						defer.resolveWith( elements, [ elements ] );
  					}
  				};

  			if ( typeof type !== "string" ) {
  				obj = type;
  				type = undefined;
  			}
  			type = type || "fx";

  			while ( i-- ) {
  				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
  				if ( tmp && tmp.empty ) {
  					count++;
  					tmp.empty.add( resolve );
  				}
  			}
  			resolve();
  			return defer.promise( obj );
  		}
  	} );
  	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

  	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


  	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

  	var documentElement = document.documentElement;



  		var isAttached = function( elem ) {
  				return jQuery.contains( elem.ownerDocument, elem );
  			},
  			composed = { composed: true };

  		// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  		// Check attachment across shadow DOM boundaries when possible (gh-3504)
  		// Support: iOS 10.0-10.2 only
  		// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  		// leading to errors. We need to check for `getRootNode`.
  		if ( documentElement.getRootNode ) {
  			isAttached = function( elem ) {
  				return jQuery.contains( elem.ownerDocument, elem ) ||
  					elem.getRootNode( composed ) === elem.ownerDocument;
  			};
  		}
  	var isHiddenWithinTree = function( elem, el ) {

  			// isHiddenWithinTree might be called from jQuery#filter function;
  			// in that case, element will be second argument
  			elem = el || elem;

  			// Inline style trumps all
  			return elem.style.display === "none" ||
  				elem.style.display === "" &&

  				// Otherwise, check computed style
  				// Support: Firefox <=43 - 45
  				// Disconnected elements can have computed display: none, so first confirm that elem is
  				// in the document.
  				isAttached( elem ) &&

  				jQuery.css( elem, "display" ) === "none";
  		};



  	function adjustCSS( elem, prop, valueParts, tween ) {
  		var adjusted, scale,
  			maxIterations = 20,
  			currentValue = tween ?
  				function() {
  					return tween.cur();
  				} :
  				function() {
  					return jQuery.css( elem, prop, "" );
  				},
  			initial = currentValue(),
  			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

  			// Starting value computation is required for potential unit mismatches
  			initialInUnit = elem.nodeType &&
  				( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
  				rcssNum.exec( jQuery.css( elem, prop ) );

  		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

  			// Support: Firefox <=54
  			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
  			initial = initial / 2;

  			// Trust units reported by jQuery.css
  			unit = unit || initialInUnit[ 3 ];

  			// Iteratively approximate from a nonzero starting point
  			initialInUnit = +initial || 1;

  			while ( maxIterations-- ) {

  				// Evaluate and update our best guess (doubling guesses that zero out).
  				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
  				jQuery.style( elem, prop, initialInUnit + unit );
  				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
  					maxIterations = 0;
  				}
  				initialInUnit = initialInUnit / scale;

  			}

  			initialInUnit = initialInUnit * 2;
  			jQuery.style( elem, prop, initialInUnit + unit );

  			// Make sure we update the tween properties later on
  			valueParts = valueParts || [];
  		}

  		if ( valueParts ) {
  			initialInUnit = +initialInUnit || +initial || 0;

  			// Apply relative offset (+=/-=) if specified
  			adjusted = valueParts[ 1 ] ?
  				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
  				+valueParts[ 2 ];
  			if ( tween ) {
  				tween.unit = unit;
  				tween.start = initialInUnit;
  				tween.end = adjusted;
  			}
  		}
  		return adjusted;
  	}


  	var defaultDisplayMap = {};

  	function getDefaultDisplay( elem ) {
  		var temp,
  			doc = elem.ownerDocument,
  			nodeName = elem.nodeName,
  			display = defaultDisplayMap[ nodeName ];

  		if ( display ) {
  			return display;
  		}

  		temp = doc.body.appendChild( doc.createElement( nodeName ) );
  		display = jQuery.css( temp, "display" );

  		temp.parentNode.removeChild( temp );

  		if ( display === "none" ) {
  			display = "block";
  		}
  		defaultDisplayMap[ nodeName ] = display;

  		return display;
  	}

  	function showHide( elements, show ) {
  		var display, elem,
  			values = [],
  			index = 0,
  			length = elements.length;

  		// Determine new display value for elements that need to change
  		for ( ; index < length; index++ ) {
  			elem = elements[ index ];
  			if ( !elem.style ) {
  				continue;
  			}

  			display = elem.style.display;
  			if ( show ) {

  				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
  				// check is required in this first loop unless we have a nonempty display value (either
  				// inline or about-to-be-restored)
  				if ( display === "none" ) {
  					values[ index ] = dataPriv.get( elem, "display" ) || null;
  					if ( !values[ index ] ) {
  						elem.style.display = "";
  					}
  				}
  				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
  					values[ index ] = getDefaultDisplay( elem );
  				}
  			} else {
  				if ( display !== "none" ) {
  					values[ index ] = "none";

  					// Remember what we're overwriting
  					dataPriv.set( elem, "display", display );
  				}
  			}
  		}

  		// Set the display of the elements in a second loop to avoid constant reflow
  		for ( index = 0; index < length; index++ ) {
  			if ( values[ index ] != null ) {
  				elements[ index ].style.display = values[ index ];
  			}
  		}

  		return elements;
  	}

  	jQuery.fn.extend( {
  		show: function() {
  			return showHide( this, true );
  		},
  		hide: function() {
  			return showHide( this );
  		},
  		toggle: function( state ) {
  			if ( typeof state === "boolean" ) {
  				return state ? this.show() : this.hide();
  			}

  			return this.each( function() {
  				if ( isHiddenWithinTree( this ) ) {
  					jQuery( this ).show();
  				} else {
  					jQuery( this ).hide();
  				}
  			} );
  		}
  	} );
  	var rcheckableType = ( /^(?:checkbox|radio)$/i );

  	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

  	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



  	( function() {
  		var fragment = document.createDocumentFragment(),
  			div = fragment.appendChild( document.createElement( "div" ) ),
  			input = document.createElement( "input" );

  		// Support: Android 4.0 - 4.3 only
  		// Check state lost if the name is set (trac-11217)
  		// Support: Windows Web Apps (WWA)
  		// `name` and `type` must use .setAttribute for WWA (trac-14901)
  		input.setAttribute( "type", "radio" );
  		input.setAttribute( "checked", "checked" );
  		input.setAttribute( "name", "t" );

  		div.appendChild( input );

  		// Support: Android <=4.1 only
  		// Older WebKit doesn't clone checked state correctly in fragments
  		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

  		// Support: IE <=11 only
  		// Make sure textarea (and checkbox) defaultValue is properly cloned
  		div.innerHTML = "<textarea>x</textarea>";
  		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

  		// Support: IE <=9 only
  		// IE <=9 replaces <option> tags with their contents when inserted outside of
  		// the select element.
  		div.innerHTML = "<option></option>";
  		support.option = !!div.lastChild;
  	} )();


  	// We have to close these tags to support XHTML (trac-13200)
  	var wrapMap = {

  		// XHTML parsers do not magically insert elements in the
  		// same way that tag soup parsers do. So we cannot shorten
  		// this by omitting <tbody> or other required elements.
  		thead: [ 1, "<table>", "</table>" ],
  		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
  		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
  		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

  		_default: [ 0, "", "" ]
  	};

  	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  	wrapMap.th = wrapMap.td;

  	// Support: IE <=9 only
  	if ( !support.option ) {
  		wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
  	}


  	function getAll( context, tag ) {

  		// Support: IE <=9 - 11 only
  		// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
  		var ret;

  		if ( typeof context.getElementsByTagName !== "undefined" ) {
  			ret = context.getElementsByTagName( tag || "*" );

  		} else if ( typeof context.querySelectorAll !== "undefined" ) {
  			ret = context.querySelectorAll( tag || "*" );

  		} else {
  			ret = [];
  		}

  		if ( tag === undefined || tag && nodeName( context, tag ) ) {
  			return jQuery.merge( [ context ], ret );
  		}

  		return ret;
  	}


  	// Mark scripts as having already been evaluated
  	function setGlobalEval( elems, refElements ) {
  		var i = 0,
  			l = elems.length;

  		for ( ; i < l; i++ ) {
  			dataPriv.set(
  				elems[ i ],
  				"globalEval",
  				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
  			);
  		}
  	}


  	var rhtml = /<|&#?\w+;/;

  	function buildFragment( elems, context, scripts, selection, ignored ) {
  		var elem, tmp, tag, wrap, attached, j,
  			fragment = context.createDocumentFragment(),
  			nodes = [],
  			i = 0,
  			l = elems.length;

  		for ( ; i < l; i++ ) {
  			elem = elems[ i ];

  			if ( elem || elem === 0 ) {

  				// Add nodes directly
  				if ( toType( elem ) === "object" ) {

  					// Support: Android <=4.0 only, PhantomJS 1 only
  					// push.apply(_, arraylike) throws on ancient WebKit
  					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

  				// Convert non-html into a text node
  				} else if ( !rhtml.test( elem ) ) {
  					nodes.push( context.createTextNode( elem ) );

  				// Convert html into DOM nodes
  				} else {
  					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

  					// Deserialize a standard representation
  					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
  					wrap = wrapMap[ tag ] || wrapMap._default;
  					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

  					// Descend through wrappers to the right content
  					j = wrap[ 0 ];
  					while ( j-- ) {
  						tmp = tmp.lastChild;
  					}

  					// Support: Android <=4.0 only, PhantomJS 1 only
  					// push.apply(_, arraylike) throws on ancient WebKit
  					jQuery.merge( nodes, tmp.childNodes );

  					// Remember the top-level container
  					tmp = fragment.firstChild;

  					// Ensure the created nodes are orphaned (trac-12392)
  					tmp.textContent = "";
  				}
  			}
  		}

  		// Remove wrapper from fragment
  		fragment.textContent = "";

  		i = 0;
  		while ( ( elem = nodes[ i++ ] ) ) {

  			// Skip elements already in the context collection (trac-4087)
  			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
  				if ( ignored ) {
  					ignored.push( elem );
  				}
  				continue;
  			}

  			attached = isAttached( elem );

  			// Append to fragment
  			tmp = getAll( fragment.appendChild( elem ), "script" );

  			// Preserve script evaluation history
  			if ( attached ) {
  				setGlobalEval( tmp );
  			}

  			// Capture executables
  			if ( scripts ) {
  				j = 0;
  				while ( ( elem = tmp[ j++ ] ) ) {
  					if ( rscriptType.test( elem.type || "" ) ) {
  						scripts.push( elem );
  					}
  				}
  			}
  		}

  		return fragment;
  	}


  	var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  	function returnTrue() {
  		return true;
  	}

  	function returnFalse() {
  		return false;
  	}

  	function on( elem, types, selector, data, fn, one ) {
  		var origFn, type;

  		// Types can be a map of types/handlers
  		if ( typeof types === "object" ) {

  			// ( types-Object, selector, data )
  			if ( typeof selector !== "string" ) {

  				// ( types-Object, data )
  				data = data || selector;
  				selector = undefined;
  			}
  			for ( type in types ) {
  				on( elem, type, selector, data, types[ type ], one );
  			}
  			return elem;
  		}

  		if ( data == null && fn == null ) {

  			// ( types, fn )
  			fn = selector;
  			data = selector = undefined;
  		} else if ( fn == null ) {
  			if ( typeof selector === "string" ) {

  				// ( types, selector, fn )
  				fn = data;
  				data = undefined;
  			} else {

  				// ( types, data, fn )
  				fn = data;
  				data = selector;
  				selector = undefined;
  			}
  		}
  		if ( fn === false ) {
  			fn = returnFalse;
  		} else if ( !fn ) {
  			return elem;
  		}

  		if ( one === 1 ) {
  			origFn = fn;
  			fn = function( event ) {

  				// Can use an empty set, since event contains the info
  				jQuery().off( event );
  				return origFn.apply( this, arguments );
  			};

  			// Use same guid so caller can remove using origFn
  			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
  		}
  		return elem.each( function() {
  			jQuery.event.add( this, types, fn, data, selector );
  		} );
  	}

  	/*
  	 * Helper functions for managing events -- not part of the public interface.
  	 * Props to Dean Edwards' addEvent library for many of the ideas.
  	 */
  	jQuery.event = {

  		global: {},

  		add: function( elem, types, handler, data, selector ) {

  			var handleObjIn, eventHandle, tmp,
  				events, t, handleObj,
  				special, handlers, type, namespaces, origType,
  				elemData = dataPriv.get( elem );

  			// Only attach events to objects that accept data
  			if ( !acceptData( elem ) ) {
  				return;
  			}

  			// Caller can pass in an object of custom data in lieu of the handler
  			if ( handler.handler ) {
  				handleObjIn = handler;
  				handler = handleObjIn.handler;
  				selector = handleObjIn.selector;
  			}

  			// Ensure that invalid selectors throw exceptions at attach time
  			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
  			if ( selector ) {
  				jQuery.find.matchesSelector( documentElement, selector );
  			}

  			// Make sure that the handler has a unique ID, used to find/remove it later
  			if ( !handler.guid ) {
  				handler.guid = jQuery.guid++;
  			}

  			// Init the element's event structure and main handler, if this is the first
  			if ( !( events = elemData.events ) ) {
  				events = elemData.events = Object.create( null );
  			}
  			if ( !( eventHandle = elemData.handle ) ) {
  				eventHandle = elemData.handle = function( e ) {

  					// Discard the second event of a jQuery.event.trigger() and
  					// when an event is called after a page has unloaded
  					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
  						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
  				};
  			}

  			// Handle multiple events separated by a space
  			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  			t = types.length;
  			while ( t-- ) {
  				tmp = rtypenamespace.exec( types[ t ] ) || [];
  				type = origType = tmp[ 1 ];
  				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  				// There *must* be a type, no attaching namespace-only handlers
  				if ( !type ) {
  					continue;
  				}

  				// If event changes its type, use the special event handlers for the changed type
  				special = jQuery.event.special[ type ] || {};

  				// If selector defined, determine special event api type, otherwise given type
  				type = ( selector ? special.delegateType : special.bindType ) || type;

  				// Update special based on newly reset type
  				special = jQuery.event.special[ type ] || {};

  				// handleObj is passed to all event handlers
  				handleObj = jQuery.extend( {
  					type: type,
  					origType: origType,
  					data: data,
  					handler: handler,
  					guid: handler.guid,
  					selector: selector,
  					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
  					namespace: namespaces.join( "." )
  				}, handleObjIn );

  				// Init the event handler queue if we're the first
  				if ( !( handlers = events[ type ] ) ) {
  					handlers = events[ type ] = [];
  					handlers.delegateCount = 0;

  					// Only use addEventListener if the special events handler returns false
  					if ( !special.setup ||
  						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

  						if ( elem.addEventListener ) {
  							elem.addEventListener( type, eventHandle );
  						}
  					}
  				}

  				if ( special.add ) {
  					special.add.call( elem, handleObj );

  					if ( !handleObj.handler.guid ) {
  						handleObj.handler.guid = handler.guid;
  					}
  				}

  				// Add to the element's handler list, delegates in front
  				if ( selector ) {
  					handlers.splice( handlers.delegateCount++, 0, handleObj );
  				} else {
  					handlers.push( handleObj );
  				}

  				// Keep track of which events have ever been used, for event optimization
  				jQuery.event.global[ type ] = true;
  			}

  		},

  		// Detach an event or set of events from an element
  		remove: function( elem, types, handler, selector, mappedTypes ) {

  			var j, origCount, tmp,
  				events, t, handleObj,
  				special, handlers, type, namespaces, origType,
  				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

  			if ( !elemData || !( events = elemData.events ) ) {
  				return;
  			}

  			// Once for each type.namespace in types; type may be omitted
  			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  			t = types.length;
  			while ( t-- ) {
  				tmp = rtypenamespace.exec( types[ t ] ) || [];
  				type = origType = tmp[ 1 ];
  				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  				// Unbind all events (on this namespace, if provided) for the element
  				if ( !type ) {
  					for ( type in events ) {
  						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
  					}
  					continue;
  				}

  				special = jQuery.event.special[ type ] || {};
  				type = ( selector ? special.delegateType : special.bindType ) || type;
  				handlers = events[ type ] || [];
  				tmp = tmp[ 2 ] &&
  					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

  				// Remove matching events
  				origCount = j = handlers.length;
  				while ( j-- ) {
  					handleObj = handlers[ j ];

  					if ( ( mappedTypes || origType === handleObj.origType ) &&
  						( !handler || handler.guid === handleObj.guid ) &&
  						( !tmp || tmp.test( handleObj.namespace ) ) &&
  						( !selector || selector === handleObj.selector ||
  							selector === "**" && handleObj.selector ) ) {
  						handlers.splice( j, 1 );

  						if ( handleObj.selector ) {
  							handlers.delegateCount--;
  						}
  						if ( special.remove ) {
  							special.remove.call( elem, handleObj );
  						}
  					}
  				}

  				// Remove generic event handler if we removed something and no more handlers exist
  				// (avoids potential for endless recursion during removal of special event handlers)
  				if ( origCount && !handlers.length ) {
  					if ( !special.teardown ||
  						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

  						jQuery.removeEvent( elem, type, elemData.handle );
  					}

  					delete events[ type ];
  				}
  			}

  			// Remove data and the expando if it's no longer used
  			if ( jQuery.isEmptyObject( events ) ) {
  				dataPriv.remove( elem, "handle events" );
  			}
  		},

  		dispatch: function( nativeEvent ) {

  			var i, j, ret, matched, handleObj, handlerQueue,
  				args = new Array( arguments.length ),

  				// Make a writable jQuery.Event from the native event object
  				event = jQuery.event.fix( nativeEvent ),

  				handlers = (
  					dataPriv.get( this, "events" ) || Object.create( null )
  				)[ event.type ] || [],
  				special = jQuery.event.special[ event.type ] || {};

  			// Use the fix-ed jQuery.Event rather than the (read-only) native event
  			args[ 0 ] = event;

  			for ( i = 1; i < arguments.length; i++ ) {
  				args[ i ] = arguments[ i ];
  			}

  			event.delegateTarget = this;

  			// Call the preDispatch hook for the mapped type, and let it bail if desired
  			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
  				return;
  			}

  			// Determine handlers
  			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

  			// Run delegates first; they may want to stop propagation beneath us
  			i = 0;
  			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
  				event.currentTarget = matched.elem;

  				j = 0;
  				while ( ( handleObj = matched.handlers[ j++ ] ) &&
  					!event.isImmediatePropagationStopped() ) {

  					// If the event is namespaced, then each handler is only invoked if it is
  					// specially universal or its namespaces are a superset of the event's.
  					if ( !event.rnamespace || handleObj.namespace === false ||
  						event.rnamespace.test( handleObj.namespace ) ) {

  						event.handleObj = handleObj;
  						event.data = handleObj.data;

  						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
  							handleObj.handler ).apply( matched.elem, args );

  						if ( ret !== undefined ) {
  							if ( ( event.result = ret ) === false ) {
  								event.preventDefault();
  								event.stopPropagation();
  							}
  						}
  					}
  				}
  			}

  			// Call the postDispatch hook for the mapped type
  			if ( special.postDispatch ) {
  				special.postDispatch.call( this, event );
  			}

  			return event.result;
  		},

  		handlers: function( event, handlers ) {
  			var i, handleObj, sel, matchedHandlers, matchedSelectors,
  				handlerQueue = [],
  				delegateCount = handlers.delegateCount,
  				cur = event.target;

  			// Find delegate handlers
  			if ( delegateCount &&

  				// Support: IE <=9
  				// Black-hole SVG <use> instance trees (trac-13180)
  				cur.nodeType &&

  				// Support: Firefox <=42
  				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
  				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
  				// Support: IE 11 only
  				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
  				!( event.type === "click" && event.button >= 1 ) ) {

  				for ( ; cur !== this; cur = cur.parentNode || this ) {

  					// Don't check non-elements (trac-13208)
  					// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
  					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
  						matchedHandlers = [];
  						matchedSelectors = {};
  						for ( i = 0; i < delegateCount; i++ ) {
  							handleObj = handlers[ i ];

  							// Don't conflict with Object.prototype properties (trac-13203)
  							sel = handleObj.selector + " ";

  							if ( matchedSelectors[ sel ] === undefined ) {
  								matchedSelectors[ sel ] = handleObj.needsContext ?
  									jQuery( sel, this ).index( cur ) > -1 :
  									jQuery.find( sel, this, null, [ cur ] ).length;
  							}
  							if ( matchedSelectors[ sel ] ) {
  								matchedHandlers.push( handleObj );
  							}
  						}
  						if ( matchedHandlers.length ) {
  							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
  						}
  					}
  				}
  			}

  			// Add the remaining (directly-bound) handlers
  			cur = this;
  			if ( delegateCount < handlers.length ) {
  				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
  			}

  			return handlerQueue;
  		},

  		addProp: function( name, hook ) {
  			Object.defineProperty( jQuery.Event.prototype, name, {
  				enumerable: true,
  				configurable: true,

  				get: isFunction( hook ) ?
  					function() {
  						if ( this.originalEvent ) {
  							return hook( this.originalEvent );
  						}
  					} :
  					function() {
  						if ( this.originalEvent ) {
  							return this.originalEvent[ name ];
  						}
  					},

  				set: function( value ) {
  					Object.defineProperty( this, name, {
  						enumerable: true,
  						configurable: true,
  						writable: true,
  						value: value
  					} );
  				}
  			} );
  		},

  		fix: function( originalEvent ) {
  			return originalEvent[ jQuery.expando ] ?
  				originalEvent :
  				new jQuery.Event( originalEvent );
  		},

  		special: {
  			load: {

  				// Prevent triggered image.load events from bubbling to window.load
  				noBubble: true
  			},
  			click: {

  				// Utilize native event to ensure correct state for checkable inputs
  				setup: function( data ) {

  					// For mutual compressibility with _default, replace `this` access with a local var.
  					// `|| data` is dead code meant only to preserve the variable through minification.
  					var el = this || data;

  					// Claim the first handler
  					if ( rcheckableType.test( el.type ) &&
  						el.click && nodeName( el, "input" ) ) {

  						// dataPriv.set( el, "click", ... )
  						leverageNative( el, "click", true );
  					}

  					// Return false to allow normal processing in the caller
  					return false;
  				},
  				trigger: function( data ) {

  					// For mutual compressibility with _default, replace `this` access with a local var.
  					// `|| data` is dead code meant only to preserve the variable through minification.
  					var el = this || data;

  					// Force setup before triggering a click
  					if ( rcheckableType.test( el.type ) &&
  						el.click && nodeName( el, "input" ) ) {

  						leverageNative( el, "click" );
  					}

  					// Return non-false to allow normal event-path propagation
  					return true;
  				},

  				// For cross-browser consistency, suppress native .click() on links
  				// Also prevent it if we're currently inside a leveraged native-event stack
  				_default: function( event ) {
  					var target = event.target;
  					return rcheckableType.test( target.type ) &&
  						target.click && nodeName( target, "input" ) &&
  						dataPriv.get( target, "click" ) ||
  						nodeName( target, "a" );
  				}
  			},

  			beforeunload: {
  				postDispatch: function( event ) {

  					// Support: Firefox 20+
  					// Firefox doesn't alert if the returnValue field is not set.
  					if ( event.result !== undefined && event.originalEvent ) {
  						event.originalEvent.returnValue = event.result;
  					}
  				}
  			}
  		}
  	};

  	// Ensure the presence of an event listener that handles manually-triggered
  	// synthetic events by interrupting progress until reinvoked in response to
  	// *native* events that it fires directly, ensuring that state changes have
  	// already occurred before other listeners are invoked.
  	function leverageNative( el, type, isSetup ) {

  		// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
  		if ( !isSetup ) {
  			if ( dataPriv.get( el, type ) === undefined ) {
  				jQuery.event.add( el, type, returnTrue );
  			}
  			return;
  		}

  		// Register the controller as a special universal handler for all event namespaces
  		dataPriv.set( el, type, false );
  		jQuery.event.add( el, type, {
  			namespace: false,
  			handler: function( event ) {
  				var result,
  					saved = dataPriv.get( this, type );

  				if ( ( event.isTrigger & 1 ) && this[ type ] ) {

  					// Interrupt processing of the outer synthetic .trigger()ed event
  					if ( !saved ) {

  						// Store arguments for use when handling the inner native event
  						// There will always be at least one argument (an event object), so this array
  						// will not be confused with a leftover capture object.
  						saved = slice.call( arguments );
  						dataPriv.set( this, type, saved );

  						// Trigger the native event and capture its result
  						this[ type ]();
  						result = dataPriv.get( this, type );
  						dataPriv.set( this, type, false );

  						if ( saved !== result ) {

  							// Cancel the outer synthetic event
  							event.stopImmediatePropagation();
  							event.preventDefault();

  							return result;
  						}

  					// If this is an inner synthetic event for an event with a bubbling surrogate
  					// (focus or blur), assume that the surrogate already propagated from triggering
  					// the native event and prevent that from happening again here.
  					// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
  					// bubbling surrogate propagates *after* the non-bubbling base), but that seems
  					// less bad than duplication.
  					} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
  						event.stopPropagation();
  					}

  				// If this is a native event triggered above, everything is now in order
  				// Fire an inner synthetic event with the original arguments
  				} else if ( saved ) {

  					// ...and capture the result
  					dataPriv.set( this, type, jQuery.event.trigger(
  						saved[ 0 ],
  						saved.slice( 1 ),
  						this
  					) );

  					// Abort handling of the native event by all jQuery handlers while allowing
  					// native handlers on the same element to run. On target, this is achieved
  					// by stopping immediate propagation just on the jQuery event. However,
  					// the native event is re-wrapped by a jQuery one on each level of the
  					// propagation so the only way to stop it for jQuery is to stop it for
  					// everyone via native `stopPropagation()`. This is not a problem for
  					// focus/blur which don't bubble, but it does also stop click on checkboxes
  					// and radios. We accept this limitation.
  					event.stopPropagation();
  					event.isImmediatePropagationStopped = returnTrue;
  				}
  			}
  		} );
  	}

  	jQuery.removeEvent = function( elem, type, handle ) {

  		// This "if" is needed for plain objects
  		if ( elem.removeEventListener ) {
  			elem.removeEventListener( type, handle );
  		}
  	};

  	jQuery.Event = function( src, props ) {

  		// Allow instantiation without the 'new' keyword
  		if ( !( this instanceof jQuery.Event ) ) {
  			return new jQuery.Event( src, props );
  		}

  		// Event object
  		if ( src && src.type ) {
  			this.originalEvent = src;
  			this.type = src.type;

  			// Events bubbling up the document may have been marked as prevented
  			// by a handler lower down the tree; reflect the correct value.
  			this.isDefaultPrevented = src.defaultPrevented ||
  					src.defaultPrevented === undefined &&

  					// Support: Android <=2.3 only
  					src.returnValue === false ?
  				returnTrue :
  				returnFalse;

  			// Create target properties
  			// Support: Safari <=6 - 7 only
  			// Target should not be a text node (trac-504, trac-13143)
  			this.target = ( src.target && src.target.nodeType === 3 ) ?
  				src.target.parentNode :
  				src.target;

  			this.currentTarget = src.currentTarget;
  			this.relatedTarget = src.relatedTarget;

  		// Event type
  		} else {
  			this.type = src;
  		}

  		// Put explicitly provided properties onto the event object
  		if ( props ) {
  			jQuery.extend( this, props );
  		}

  		// Create a timestamp if incoming event doesn't have one
  		this.timeStamp = src && src.timeStamp || Date.now();

  		// Mark it as fixed
  		this[ jQuery.expando ] = true;
  	};

  	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  	jQuery.Event.prototype = {
  		constructor: jQuery.Event,
  		isDefaultPrevented: returnFalse,
  		isPropagationStopped: returnFalse,
  		isImmediatePropagationStopped: returnFalse,
  		isSimulated: false,

  		preventDefault: function() {
  			var e = this.originalEvent;

  			this.isDefaultPrevented = returnTrue;

  			if ( e && !this.isSimulated ) {
  				e.preventDefault();
  			}
  		},
  		stopPropagation: function() {
  			var e = this.originalEvent;

  			this.isPropagationStopped = returnTrue;

  			if ( e && !this.isSimulated ) {
  				e.stopPropagation();
  			}
  		},
  		stopImmediatePropagation: function() {
  			var e = this.originalEvent;

  			this.isImmediatePropagationStopped = returnTrue;

  			if ( e && !this.isSimulated ) {
  				e.stopImmediatePropagation();
  			}

  			this.stopPropagation();
  		}
  	};

  	// Includes all common event props including KeyEvent and MouseEvent specific props
  	jQuery.each( {
  		altKey: true,
  		bubbles: true,
  		cancelable: true,
  		changedTouches: true,
  		ctrlKey: true,
  		detail: true,
  		eventPhase: true,
  		metaKey: true,
  		pageX: true,
  		pageY: true,
  		shiftKey: true,
  		view: true,
  		"char": true,
  		code: true,
  		charCode: true,
  		key: true,
  		keyCode: true,
  		button: true,
  		buttons: true,
  		clientX: true,
  		clientY: true,
  		offsetX: true,
  		offsetY: true,
  		pointerId: true,
  		pointerType: true,
  		screenX: true,
  		screenY: true,
  		targetTouches: true,
  		toElement: true,
  		touches: true,
  		which: true
  	}, jQuery.event.addProp );

  	jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

  		function focusMappedHandler( nativeEvent ) {
  			if ( document.documentMode ) {

  				// Support: IE 11+
  				// Attach a single focusin/focusout handler on the document while someone wants
  				// focus/blur. This is because the former are synchronous in IE while the latter
  				// are async. In other browsers, all those handlers are invoked synchronously.

  				// `handle` from private data would already wrap the event, but we need
  				// to change the `type` here.
  				var handle = dataPriv.get( this, "handle" ),
  					event = jQuery.event.fix( nativeEvent );
  				event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
  				event.isSimulated = true;

  				// First, handle focusin/focusout
  				handle( nativeEvent );

  				// ...then, handle focus/blur
  				//
  				// focus/blur don't bubble while focusin/focusout do; simulate the former by only
  				// invoking the handler at the lower level.
  				if ( event.target === event.currentTarget ) {

  					// The setup part calls `leverageNative`, which, in turn, calls
  					// `jQuery.event.add`, so event handle will already have been set
  					// by this point.
  					handle( event );
  				}
  			} else {

  				// For non-IE browsers, attach a single capturing handler on the document
  				// while someone wants focusin/focusout.
  				jQuery.event.simulate( delegateType, nativeEvent.target,
  					jQuery.event.fix( nativeEvent ) );
  			}
  		}

  		jQuery.event.special[ type ] = {

  			// Utilize native event if possible so blur/focus sequence is correct
  			setup: function() {

  				var attaches;

  				// Claim the first handler
  				// dataPriv.set( this, "focus", ... )
  				// dataPriv.set( this, "blur", ... )
  				leverageNative( this, type, true );

  				if ( document.documentMode ) {

  					// Support: IE 9 - 11+
  					// We use the same native handler for focusin & focus (and focusout & blur)
  					// so we need to coordinate setup & teardown parts between those events.
  					// Use `delegateType` as the key as `type` is already used by `leverageNative`.
  					attaches = dataPriv.get( this, delegateType );
  					if ( !attaches ) {
  						this.addEventListener( delegateType, focusMappedHandler );
  					}
  					dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
  				} else {

  					// Return false to allow normal processing in the caller
  					return false;
  				}
  			},
  			trigger: function() {

  				// Force setup before trigger
  				leverageNative( this, type );

  				// Return non-false to allow normal event-path propagation
  				return true;
  			},

  			teardown: function() {
  				var attaches;

  				if ( document.documentMode ) {
  					attaches = dataPriv.get( this, delegateType ) - 1;
  					if ( !attaches ) {
  						this.removeEventListener( delegateType, focusMappedHandler );
  						dataPriv.remove( this, delegateType );
  					} else {
  						dataPriv.set( this, delegateType, attaches );
  					}
  				} else {

  					// Return false to indicate standard teardown should be applied
  					return false;
  				}
  			},

  			// Suppress native focus or blur if we're currently inside
  			// a leveraged native-event stack
  			_default: function( event ) {
  				return dataPriv.get( event.target, type );
  			},

  			delegateType: delegateType
  		};

  		// Support: Firefox <=44
  		// Firefox doesn't have focus(in | out) events
  		// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  		//
  		// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  		// focus(in | out) events fire after focus & blur events,
  		// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  		// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
  		//
  		// Support: IE 9 - 11+
  		// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
  		// attach a single handler for both events in IE.
  		jQuery.event.special[ delegateType ] = {
  			setup: function() {

  				// Handle: regular nodes (via `this.ownerDocument`), window
  				// (via `this.document`) & document (via `this`).
  				var doc = this.ownerDocument || this.document || this,
  					dataHolder = document.documentMode ? this : doc,
  					attaches = dataPriv.get( dataHolder, delegateType );

  				// Support: IE 9 - 11+
  				// We use the same native handler for focusin & focus (and focusout & blur)
  				// so we need to coordinate setup & teardown parts between those events.
  				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
  				if ( !attaches ) {
  					if ( document.documentMode ) {
  						this.addEventListener( delegateType, focusMappedHandler );
  					} else {
  						doc.addEventListener( type, focusMappedHandler, true );
  					}
  				}
  				dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
  			},
  			teardown: function() {
  				var doc = this.ownerDocument || this.document || this,
  					dataHolder = document.documentMode ? this : doc,
  					attaches = dataPriv.get( dataHolder, delegateType ) - 1;

  				if ( !attaches ) {
  					if ( document.documentMode ) {
  						this.removeEventListener( delegateType, focusMappedHandler );
  					} else {
  						doc.removeEventListener( type, focusMappedHandler, true );
  					}
  					dataPriv.remove( dataHolder, delegateType );
  				} else {
  					dataPriv.set( dataHolder, delegateType, attaches );
  				}
  			}
  		};
  	} );

  	// Create mouseenter/leave events using mouseover/out and event-time checks
  	// so that event delegation works in jQuery.
  	// Do the same for pointerenter/pointerleave and pointerover/pointerout
  	//
  	// Support: Safari 7 only
  	// Safari sends mouseenter too often; see:
  	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  	// for the description of the bug (it existed in older Chrome versions as well).
  	jQuery.each( {
  		mouseenter: "mouseover",
  		mouseleave: "mouseout",
  		pointerenter: "pointerover",
  		pointerleave: "pointerout"
  	}, function( orig, fix ) {
  		jQuery.event.special[ orig ] = {
  			delegateType: fix,
  			bindType: fix,

  			handle: function( event ) {
  				var ret,
  					target = this,
  					related = event.relatedTarget,
  					handleObj = event.handleObj;

  				// For mouseenter/leave call the handler if related is outside the target.
  				// NB: No relatedTarget if the mouse left/entered the browser window
  				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
  					event.type = handleObj.origType;
  					ret = handleObj.handler.apply( this, arguments );
  					event.type = fix;
  				}
  				return ret;
  			}
  		};
  	} );

  	jQuery.fn.extend( {

  		on: function( types, selector, data, fn ) {
  			return on( this, types, selector, data, fn );
  		},
  		one: function( types, selector, data, fn ) {
  			return on( this, types, selector, data, fn, 1 );
  		},
  		off: function( types, selector, fn ) {
  			var handleObj, type;
  			if ( types && types.preventDefault && types.handleObj ) {

  				// ( event )  dispatched jQuery.Event
  				handleObj = types.handleObj;
  				jQuery( types.delegateTarget ).off(
  					handleObj.namespace ?
  						handleObj.origType + "." + handleObj.namespace :
  						handleObj.origType,
  					handleObj.selector,
  					handleObj.handler
  				);
  				return this;
  			}
  			if ( typeof types === "object" ) {

  				// ( types-object [, selector] )
  				for ( type in types ) {
  					this.off( type, selector, types[ type ] );
  				}
  				return this;
  			}
  			if ( selector === false || typeof selector === "function" ) {

  				// ( types [, fn] )
  				fn = selector;
  				selector = undefined;
  			}
  			if ( fn === false ) {
  				fn = returnFalse;
  			}
  			return this.each( function() {
  				jQuery.event.remove( this, types, fn, selector );
  			} );
  		}
  	} );


  	var

  		// Support: IE <=10 - 11, Edge 12 - 13 only
  		// In IE/Edge using regex groups here causes severe slowdowns.
  		// See https://connect.microsoft.com/IE/feedback/details/1736512/
  		rnoInnerhtml = /<script|<style|<link/i,

  		// checked="checked" or checked
  		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

  		rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

  	// Prefer a tbody over its parent table for containing new rows
  	function manipulationTarget( elem, content ) {
  		if ( nodeName( elem, "table" ) &&
  			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

  			return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
  		}

  		return elem;
  	}

  	// Replace/restore the type attribute of script elements for safe DOM manipulation
  	function disableScript( elem ) {
  		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
  		return elem;
  	}
  	function restoreScript( elem ) {
  		if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
  			elem.type = elem.type.slice( 5 );
  		} else {
  			elem.removeAttribute( "type" );
  		}

  		return elem;
  	}

  	function cloneCopyEvent( src, dest ) {
  		var i, l, type, pdataOld, udataOld, udataCur, events;

  		if ( dest.nodeType !== 1 ) {
  			return;
  		}

  		// 1. Copy private data: events, handlers, etc.
  		if ( dataPriv.hasData( src ) ) {
  			pdataOld = dataPriv.get( src );
  			events = pdataOld.events;

  			if ( events ) {
  				dataPriv.remove( dest, "handle events" );

  				for ( type in events ) {
  					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
  						jQuery.event.add( dest, type, events[ type ][ i ] );
  					}
  				}
  			}
  		}

  		// 2. Copy user data
  		if ( dataUser.hasData( src ) ) {
  			udataOld = dataUser.access( src );
  			udataCur = jQuery.extend( {}, udataOld );

  			dataUser.set( dest, udataCur );
  		}
  	}

  	// Fix IE bugs, see support tests
  	function fixInput( src, dest ) {
  		var nodeName = dest.nodeName.toLowerCase();

  		// Fails to persist the checked state of a cloned checkbox or radio button.
  		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
  			dest.checked = src.checked;

  		// Fails to return the selected option to the default selected state when cloning options
  		} else if ( nodeName === "input" || nodeName === "textarea" ) {
  			dest.defaultValue = src.defaultValue;
  		}
  	}

  	function domManip( collection, args, callback, ignored ) {

  		// Flatten any nested arrays
  		args = flat( args );

  		var fragment, first, scripts, hasScripts, node, doc,
  			i = 0,
  			l = collection.length,
  			iNoClone = l - 1,
  			value = args[ 0 ],
  			valueIsFunction = isFunction( value );

  		// We can't cloneNode fragments that contain checked, in WebKit
  		if ( valueIsFunction ||
  				( l > 1 && typeof value === "string" &&
  					!support.checkClone && rchecked.test( value ) ) ) {
  			return collection.each( function( index ) {
  				var self = collection.eq( index );
  				if ( valueIsFunction ) {
  					args[ 0 ] = value.call( this, index, self.html() );
  				}
  				domManip( self, args, callback, ignored );
  			} );
  		}

  		if ( l ) {
  			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
  			first = fragment.firstChild;

  			if ( fragment.childNodes.length === 1 ) {
  				fragment = first;
  			}

  			// Require either new content or an interest in ignored elements to invoke the callback
  			if ( first || ignored ) {
  				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
  				hasScripts = scripts.length;

  				// Use the original fragment for the last item
  				// instead of the first because it can end up
  				// being emptied incorrectly in certain situations (trac-8070).
  				for ( ; i < l; i++ ) {
  					node = fragment;

  					if ( i !== iNoClone ) {
  						node = jQuery.clone( node, true, true );

  						// Keep references to cloned scripts for later restoration
  						if ( hasScripts ) {

  							// Support: Android <=4.0 only, PhantomJS 1 only
  							// push.apply(_, arraylike) throws on ancient WebKit
  							jQuery.merge( scripts, getAll( node, "script" ) );
  						}
  					}

  					callback.call( collection[ i ], node, i );
  				}

  				if ( hasScripts ) {
  					doc = scripts[ scripts.length - 1 ].ownerDocument;

  					// Re-enable scripts
  					jQuery.map( scripts, restoreScript );

  					// Evaluate executable scripts on first document insertion
  					for ( i = 0; i < hasScripts; i++ ) {
  						node = scripts[ i ];
  						if ( rscriptType.test( node.type || "" ) &&
  							!dataPriv.access( node, "globalEval" ) &&
  							jQuery.contains( doc, node ) ) {

  							if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

  								// Optional AJAX dependency, but won't run scripts if not present
  								if ( jQuery._evalUrl && !node.noModule ) {
  									jQuery._evalUrl( node.src, {
  										nonce: node.nonce || node.getAttribute( "nonce" )
  									}, doc );
  								}
  							} else {

  								// Unwrap a CDATA section containing script contents. This shouldn't be
  								// needed as in XML documents they're already not visible when
  								// inspecting element contents and in HTML documents they have no
  								// meaning but we're preserving that logic for backwards compatibility.
  								// This will be removed completely in 4.0. See gh-4904.
  								DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
  							}
  						}
  					}
  				}
  			}
  		}

  		return collection;
  	}

  	function remove( elem, selector, keepData ) {
  		var node,
  			nodes = selector ? jQuery.filter( selector, elem ) : elem,
  			i = 0;

  		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
  			if ( !keepData && node.nodeType === 1 ) {
  				jQuery.cleanData( getAll( node ) );
  			}

  			if ( node.parentNode ) {
  				if ( keepData && isAttached( node ) ) {
  					setGlobalEval( getAll( node, "script" ) );
  				}
  				node.parentNode.removeChild( node );
  			}
  		}

  		return elem;
  	}

  	jQuery.extend( {
  		htmlPrefilter: function( html ) {
  			return html;
  		},

  		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
  			var i, l, srcElements, destElements,
  				clone = elem.cloneNode( true ),
  				inPage = isAttached( elem );

  			// Fix IE cloning issues
  			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
  					!jQuery.isXMLDoc( elem ) ) {

  				// We eschew jQuery#find here for performance reasons:
  				// https://jsperf.com/getall-vs-sizzle/2
  				destElements = getAll( clone );
  				srcElements = getAll( elem );

  				for ( i = 0, l = srcElements.length; i < l; i++ ) {
  					fixInput( srcElements[ i ], destElements[ i ] );
  				}
  			}

  			// Copy the events from the original to the clone
  			if ( dataAndEvents ) {
  				if ( deepDataAndEvents ) {
  					srcElements = srcElements || getAll( elem );
  					destElements = destElements || getAll( clone );

  					for ( i = 0, l = srcElements.length; i < l; i++ ) {
  						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
  					}
  				} else {
  					cloneCopyEvent( elem, clone );
  				}
  			}

  			// Preserve script evaluation history
  			destElements = getAll( clone, "script" );
  			if ( destElements.length > 0 ) {
  				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
  			}

  			// Return the cloned set
  			return clone;
  		},

  		cleanData: function( elems ) {
  			var data, elem, type,
  				special = jQuery.event.special,
  				i = 0;

  			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
  				if ( acceptData( elem ) ) {
  					if ( ( data = elem[ dataPriv.expando ] ) ) {
  						if ( data.events ) {
  							for ( type in data.events ) {
  								if ( special[ type ] ) {
  									jQuery.event.remove( elem, type );

  								// This is a shortcut to avoid jQuery.event.remove's overhead
  								} else {
  									jQuery.removeEvent( elem, type, data.handle );
  								}
  							}
  						}

  						// Support: Chrome <=35 - 45+
  						// Assign undefined instead of using delete, see Data#remove
  						elem[ dataPriv.expando ] = undefined;
  					}
  					if ( elem[ dataUser.expando ] ) {

  						// Support: Chrome <=35 - 45+
  						// Assign undefined instead of using delete, see Data#remove
  						elem[ dataUser.expando ] = undefined;
  					}
  				}
  			}
  		}
  	} );

  	jQuery.fn.extend( {
  		detach: function( selector ) {
  			return remove( this, selector, true );
  		},

  		remove: function( selector ) {
  			return remove( this, selector );
  		},

  		text: function( value ) {
  			return access( this, function( value ) {
  				return value === undefined ?
  					jQuery.text( this ) :
  					this.empty().each( function() {
  						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  							this.textContent = value;
  						}
  					} );
  			}, null, value, arguments.length );
  		},

  		append: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  					var target = manipulationTarget( this, elem );
  					target.appendChild( elem );
  				}
  			} );
  		},

  		prepend: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  					var target = manipulationTarget( this, elem );
  					target.insertBefore( elem, target.firstChild );
  				}
  			} );
  		},

  		before: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.parentNode ) {
  					this.parentNode.insertBefore( elem, this );
  				}
  			} );
  		},

  		after: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.parentNode ) {
  					this.parentNode.insertBefore( elem, this.nextSibling );
  				}
  			} );
  		},

  		empty: function() {
  			var elem,
  				i = 0;

  			for ( ; ( elem = this[ i ] ) != null; i++ ) {
  				if ( elem.nodeType === 1 ) {

  					// Prevent memory leaks
  					jQuery.cleanData( getAll( elem, false ) );

  					// Remove any remaining nodes
  					elem.textContent = "";
  				}
  			}

  			return this;
  		},

  		clone: function( dataAndEvents, deepDataAndEvents ) {
  			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
  			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

  			return this.map( function() {
  				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
  			} );
  		},

  		html: function( value ) {
  			return access( this, function( value ) {
  				var elem = this[ 0 ] || {},
  					i = 0,
  					l = this.length;

  				if ( value === undefined && elem.nodeType === 1 ) {
  					return elem.innerHTML;
  				}

  				// See if we can take a shortcut and just use innerHTML
  				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
  					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

  					value = jQuery.htmlPrefilter( value );

  					try {
  						for ( ; i < l; i++ ) {
  							elem = this[ i ] || {};

  							// Remove element nodes and prevent memory leaks
  							if ( elem.nodeType === 1 ) {
  								jQuery.cleanData( getAll( elem, false ) );
  								elem.innerHTML = value;
  							}
  						}

  						elem = 0;

  					// If using innerHTML throws an exception, use the fallback method
  					} catch ( e ) {}
  				}

  				if ( elem ) {
  					this.empty().append( value );
  				}
  			}, null, value, arguments.length );
  		},

  		replaceWith: function() {
  			var ignored = [];

  			// Make the changes, replacing each non-ignored context element with the new content
  			return domManip( this, arguments, function( elem ) {
  				var parent = this.parentNode;

  				if ( jQuery.inArray( this, ignored ) < 0 ) {
  					jQuery.cleanData( getAll( this ) );
  					if ( parent ) {
  						parent.replaceChild( elem, this );
  					}
  				}

  			// Force callback invocation
  			}, ignored );
  		}
  	} );

  	jQuery.each( {
  		appendTo: "append",
  		prependTo: "prepend",
  		insertBefore: "before",
  		insertAfter: "after",
  		replaceAll: "replaceWith"
  	}, function( name, original ) {
  		jQuery.fn[ name ] = function( selector ) {
  			var elems,
  				ret = [],
  				insert = jQuery( selector ),
  				last = insert.length - 1,
  				i = 0;

  			for ( ; i <= last; i++ ) {
  				elems = i === last ? this : this.clone( true );
  				jQuery( insert[ i ] )[ original ]( elems );

  				// Support: Android <=4.0 only, PhantomJS 1 only
  				// .get() because push.apply(_, arraylike) throws on ancient WebKit
  				push.apply( ret, elems.get() );
  			}

  			return this.pushStack( ret );
  		};
  	} );
  	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

  	var rcustomProp = /^--/;


  	var getStyles = function( elem ) {

  			// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
  			// IE throws on elements created in popups
  			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
  			var view = elem.ownerDocument.defaultView;

  			if ( !view || !view.opener ) {
  				view = window;
  			}

  			return view.getComputedStyle( elem );
  		};

  	var swap = function( elem, options, callback ) {
  		var ret, name,
  			old = {};

  		// Remember the old values, and insert the new ones
  		for ( name in options ) {
  			old[ name ] = elem.style[ name ];
  			elem.style[ name ] = options[ name ];
  		}

  		ret = callback.call( elem );

  		// Revert the old values
  		for ( name in options ) {
  			elem.style[ name ] = old[ name ];
  		}

  		return ret;
  	};


  	var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



  	( function() {

  		// Executing both pixelPosition & boxSizingReliable tests require only one layout
  		// so they're executed at the same time to save the second computation.
  		function computeStyleTests() {

  			// This is a singleton, we need to execute it only once
  			if ( !div ) {
  				return;
  			}

  			container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
  				"margin-top:1px;padding:0;border:0";
  			div.style.cssText =
  				"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
  				"margin:auto;border:1px;padding:1px;" +
  				"width:60%;top:1%";
  			documentElement.appendChild( container ).appendChild( div );

  			var divStyle = window.getComputedStyle( div );
  			pixelPositionVal = divStyle.top !== "1%";

  			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
  			reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

  			// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
  			// Some styles come back with percentage values, even though they shouldn't
  			div.style.right = "60%";
  			pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

  			// Support: IE 9 - 11 only
  			// Detect misreporting of content dimensions for box-sizing:border-box elements
  			boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

  			// Support: IE 9 only
  			// Detect overflow:scroll screwiness (gh-3699)
  			// Support: Chrome <=64
  			// Don't get tricked when zoom affects offsetWidth (gh-4029)
  			div.style.position = "absolute";
  			scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

  			documentElement.removeChild( container );

  			// Nullify the div so it wouldn't be stored in the memory and
  			// it will also be a sign that checks already performed
  			div = null;
  		}

  		function roundPixelMeasures( measure ) {
  			return Math.round( parseFloat( measure ) );
  		}

  		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
  			reliableTrDimensionsVal, reliableMarginLeftVal,
  			container = document.createElement( "div" ),
  			div = document.createElement( "div" );

  		// Finish early in limited (non-browser) environments
  		if ( !div.style ) {
  			return;
  		}

  		// Support: IE <=9 - 11 only
  		// Style of cloned element affects source element cloned (trac-8908)
  		div.style.backgroundClip = "content-box";
  		div.cloneNode( true ).style.backgroundClip = "";
  		support.clearCloneStyle = div.style.backgroundClip === "content-box";

  		jQuery.extend( support, {
  			boxSizingReliable: function() {
  				computeStyleTests();
  				return boxSizingReliableVal;
  			},
  			pixelBoxStyles: function() {
  				computeStyleTests();
  				return pixelBoxStylesVal;
  			},
  			pixelPosition: function() {
  				computeStyleTests();
  				return pixelPositionVal;
  			},
  			reliableMarginLeft: function() {
  				computeStyleTests();
  				return reliableMarginLeftVal;
  			},
  			scrollboxSize: function() {
  				computeStyleTests();
  				return scrollboxSizeVal;
  			},

  			// Support: IE 9 - 11+, Edge 15 - 18+
  			// IE/Edge misreport `getComputedStyle` of table rows with width/height
  			// set in CSS while `offset*` properties report correct values.
  			// Behavior in IE 9 is more subtle than in newer versions & it passes
  			// some versions of this test; make sure not to make it pass there!
  			//
  			// Support: Firefox 70+
  			// Only Firefox includes border widths
  			// in computed dimensions. (gh-4529)
  			reliableTrDimensions: function() {
  				var table, tr, trChild, trStyle;
  				if ( reliableTrDimensionsVal == null ) {
  					table = document.createElement( "table" );
  					tr = document.createElement( "tr" );
  					trChild = document.createElement( "div" );

  					table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
  					tr.style.cssText = "box-sizing:content-box;border:1px solid";

  					// Support: Chrome 86+
  					// Height set through cssText does not get applied.
  					// Computed height then comes back as 0.
  					tr.style.height = "1px";
  					trChild.style.height = "9px";

  					// Support: Android 8 Chrome 86+
  					// In our bodyBackground.html iframe,
  					// display for all div elements is set to "inline",
  					// which causes a problem only in Android 8 Chrome 86.
  					// Ensuring the div is `display: block`
  					// gets around this issue.
  					trChild.style.display = "block";

  					documentElement
  						.appendChild( table )
  						.appendChild( tr )
  						.appendChild( trChild );

  					trStyle = window.getComputedStyle( tr );
  					reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
  						parseInt( trStyle.borderTopWidth, 10 ) +
  						parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

  					documentElement.removeChild( table );
  				}
  				return reliableTrDimensionsVal;
  			}
  		} );
  	} )();


  	function curCSS( elem, name, computed ) {
  		var width, minWidth, maxWidth, ret,
  			isCustomProp = rcustomProp.test( name ),

  			// Support: Firefox 51+
  			// Retrieving style before computed somehow
  			// fixes an issue with getting wrong values
  			// on detached elements
  			style = elem.style;

  		computed = computed || getStyles( elem );

  		// getPropertyValue is needed for:
  		//   .css('filter') (IE 9 only, trac-12537)
  		//   .css('--customProperty) (gh-3144)
  		if ( computed ) {

  			// Support: IE <=9 - 11+
  			// IE only supports `"float"` in `getPropertyValue`; in computed styles
  			// it's only available as `"cssFloat"`. We no longer modify properties
  			// sent to `.css()` apart from camelCasing, so we need to check both.
  			// Normally, this would create difference in behavior: if
  			// `getPropertyValue` returns an empty string, the value returned
  			// by `.css()` would be `undefined`. This is usually the case for
  			// disconnected elements. However, in IE even disconnected elements
  			// with no styles return `"none"` for `getPropertyValue( "float" )`
  			ret = computed.getPropertyValue( name ) || computed[ name ];

  			if ( isCustomProp && ret ) {

  				// Support: Firefox 105+, Chrome <=105+
  				// Spec requires trimming whitespace for custom properties (gh-4926).
  				// Firefox only trims leading whitespace. Chrome just collapses
  				// both leading & trailing whitespace to a single space.
  				//
  				// Fall back to `undefined` if empty string returned.
  				// This collapses a missing definition with property defined
  				// and set to an empty string but there's no standard API
  				// allowing us to differentiate them without a performance penalty
  				// and returning `undefined` aligns with older jQuery.
  				//
  				// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
  				// as whitespace while CSS does not, but this is not a problem
  				// because CSS preprocessing replaces them with U+000A LINE FEED
  				// (which *is* CSS whitespace)
  				// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
  				ret = ret.replace( rtrimCSS, "$1" ) || undefined;
  			}

  			if ( ret === "" && !isAttached( elem ) ) {
  				ret = jQuery.style( elem, name );
  			}

  			// A tribute to the "awesome hack by Dean Edwards"
  			// Android Browser returns percentage for some values,
  			// but width seems to be reliably pixels.
  			// This is against the CSSOM draft spec:
  			// https://drafts.csswg.org/cssom/#resolved-values
  			if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

  				// Remember the original values
  				width = style.width;
  				minWidth = style.minWidth;
  				maxWidth = style.maxWidth;

  				// Put in the new values to get a computed value out
  				style.minWidth = style.maxWidth = style.width = ret;
  				ret = computed.width;

  				// Revert the changed values
  				style.width = width;
  				style.minWidth = minWidth;
  				style.maxWidth = maxWidth;
  			}
  		}

  		return ret !== undefined ?

  			// Support: IE <=9 - 11 only
  			// IE returns zIndex value as an integer.
  			ret + "" :
  			ret;
  	}


  	function addGetHookIf( conditionFn, hookFn ) {

  		// Define the hook, we'll check on the first run if it's really needed.
  		return {
  			get: function() {
  				if ( conditionFn() ) {

  					// Hook not needed (or it's not possible to use it due
  					// to missing dependency), remove it.
  					delete this.get;
  					return;
  				}

  				// Hook needed; redefine it so that the support test is not executed again.
  				return ( this.get = hookFn ).apply( this, arguments );
  			}
  		};
  	}


  	var cssPrefixes = [ "Webkit", "Moz", "ms" ],
  		emptyStyle = document.createElement( "div" ).style,
  		vendorProps = {};

  	// Return a vendor-prefixed property or undefined
  	function vendorPropName( name ) {

  		// Check for vendor prefixed names
  		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
  			i = cssPrefixes.length;

  		while ( i-- ) {
  			name = cssPrefixes[ i ] + capName;
  			if ( name in emptyStyle ) {
  				return name;
  			}
  		}
  	}

  	// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
  	function finalPropName( name ) {
  		var final = jQuery.cssProps[ name ] || vendorProps[ name ];

  		if ( final ) {
  			return final;
  		}
  		if ( name in emptyStyle ) {
  			return name;
  		}
  		return vendorProps[ name ] = vendorPropName( name ) || name;
  	}


  	var

  		// Swappable if display is none or starts with table
  		// except "table", "table-cell", or "table-caption"
  		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  		cssNormalTransform = {
  			letterSpacing: "0",
  			fontWeight: "400"
  		};

  	function setPositiveNumber( _elem, value, subtract ) {

  		// Any relative (+/-) values have already been
  		// normalized at this point
  		var matches = rcssNum.exec( value );
  		return matches ?

  			// Guard against undefined "subtract", e.g., when used as in cssHooks
  			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
  			value;
  	}

  	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
  		var i = dimension === "width" ? 1 : 0,
  			extra = 0,
  			delta = 0,
  			marginDelta = 0;

  		// Adjustment may not be necessary
  		if ( box === ( isBorderBox ? "border" : "content" ) ) {
  			return 0;
  		}

  		for ( ; i < 4; i += 2 ) {

  			// Both box models exclude margin
  			// Count margin delta separately to only add it after scroll gutter adjustment.
  			// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
  			if ( box === "margin" ) {
  				marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
  			}

  			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
  			if ( !isBorderBox ) {

  				// Add padding
  				delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

  				// For "border" or "margin", add border
  				if ( box !== "padding" ) {
  					delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

  				// But still keep track of it otherwise
  				} else {
  					extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  				}

  			// If we get here with a border-box (content + padding + border), we're seeking "content" or
  			// "padding" or "margin"
  			} else {

  				// For "content", subtract padding
  				if ( box === "content" ) {
  					delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
  				}

  				// For "content" or "padding", subtract border
  				if ( box !== "margin" ) {
  					delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  				}
  			}
  		}

  		// Account for positive content-box scroll gutter when requested by providing computedVal
  		if ( !isBorderBox && computedVal >= 0 ) {

  			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
  			// Assuming integer scroll gutter, subtract the rest and round down
  			delta += Math.max( 0, Math.ceil(
  				elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  				computedVal -
  				delta -
  				extra -
  				0.5

  			// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
  			// Use an explicit zero to avoid NaN (gh-3964)
  			) ) || 0;
  		}

  		return delta + marginDelta;
  	}

  	function getWidthOrHeight( elem, dimension, extra ) {

  		// Start with computed style
  		var styles = getStyles( elem ),

  			// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
  			// Fake content-box until we know it's needed to know the true value.
  			boxSizingNeeded = !support.boxSizingReliable() || extra,
  			isBorderBox = boxSizingNeeded &&
  				jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  			valueIsBorderBox = isBorderBox,

  			val = curCSS( elem, dimension, styles ),
  			offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

  		// Support: Firefox <=54
  		// Return a confounding non-pixel value or feign ignorance, as appropriate.
  		if ( rnumnonpx.test( val ) ) {
  			if ( !extra ) {
  				return val;
  			}
  			val = "auto";
  		}


  		// Support: IE 9 - 11 only
  		// Use offsetWidth/offsetHeight for when box sizing is unreliable.
  		// In those cases, the computed value can be trusted to be border-box.
  		if ( ( !support.boxSizingReliable() && isBorderBox ||

  			// Support: IE 10 - 11+, Edge 15 - 18+
  			// IE/Edge misreport `getComputedStyle` of table rows with width/height
  			// set in CSS while `offset*` properties report correct values.
  			// Interestingly, in some cases IE 9 doesn't suffer from this issue.
  			!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

  			// Fall back to offsetWidth/offsetHeight when value is "auto"
  			// This happens for inline elements with no explicit setting (gh-3571)
  			val === "auto" ||

  			// Support: Android <=4.1 - 4.3 only
  			// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
  			!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

  			// Make sure the element is visible & connected
  			elem.getClientRects().length ) {

  			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

  			// Where available, offsetWidth/offsetHeight approximate border box dimensions.
  			// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
  			// retrieved value as a content box dimension.
  			valueIsBorderBox = offsetProp in elem;
  			if ( valueIsBorderBox ) {
  				val = elem[ offsetProp ];
  			}
  		}

  		// Normalize "" and auto
  		val = parseFloat( val ) || 0;

  		// Adjust for the element's box model
  		return ( val +
  			boxModelAdjustment(
  				elem,
  				dimension,
  				extra || ( isBorderBox ? "border" : "content" ),
  				valueIsBorderBox,
  				styles,

  				// Provide the current computed size to request scroll gutter calculation (gh-3589)
  				val
  			)
  		) + "px";
  	}

  	jQuery.extend( {

  		// Add in style property hooks for overriding the default
  		// behavior of getting and setting a style property
  		cssHooks: {
  			opacity: {
  				get: function( elem, computed ) {
  					if ( computed ) {

  						// We should always get a number back from opacity
  						var ret = curCSS( elem, "opacity" );
  						return ret === "" ? "1" : ret;
  					}
  				}
  			}
  		},

  		// Don't automatically add "px" to these possibly-unitless properties
  		cssNumber: {
  			animationIterationCount: true,
  			aspectRatio: true,
  			borderImageSlice: true,
  			columnCount: true,
  			flexGrow: true,
  			flexShrink: true,
  			fontWeight: true,
  			gridArea: true,
  			gridColumn: true,
  			gridColumnEnd: true,
  			gridColumnStart: true,
  			gridRow: true,
  			gridRowEnd: true,
  			gridRowStart: true,
  			lineHeight: true,
  			opacity: true,
  			order: true,
  			orphans: true,
  			scale: true,
  			widows: true,
  			zIndex: true,
  			zoom: true,

  			// SVG-related
  			fillOpacity: true,
  			floodOpacity: true,
  			stopOpacity: true,
  			strokeMiterlimit: true,
  			strokeOpacity: true
  		},

  		// Add in properties whose names you wish to fix before
  		// setting or getting the value
  		cssProps: {},

  		// Get and set the style property on a DOM Node
  		style: function( elem, name, value, extra ) {

  			// Don't set styles on text and comment nodes
  			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
  				return;
  			}

  			// Make sure that we're working with the right name
  			var ret, type, hooks,
  				origName = camelCase( name ),
  				isCustomProp = rcustomProp.test( name ),
  				style = elem.style;

  			// Make sure that we're working with the right name. We don't
  			// want to query the value if it is a CSS custom property
  			// since they are user-defined.
  			if ( !isCustomProp ) {
  				name = finalPropName( origName );
  			}

  			// Gets hook for the prefixed version, then unprefixed version
  			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  			// Check if we're setting a value
  			if ( value !== undefined ) {
  				type = typeof value;

  				// Convert "+=" or "-=" to relative numbers (trac-7345)
  				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
  					value = adjustCSS( elem, name, ret );

  					// Fixes bug trac-9237
  					type = "number";
  				}

  				// Make sure that null and NaN values aren't set (trac-7116)
  				if ( value == null || value !== value ) {
  					return;
  				}

  				// If a number was passed in, add the unit (except for certain CSS properties)
  				// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
  				// "px" to a few hardcoded values.
  				if ( type === "number" && !isCustomProp ) {
  					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
  				}

  				// background-* props affect original clone's values
  				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
  					style[ name ] = "inherit";
  				}

  				// If a hook was provided, use that value, otherwise just set the specified value
  				if ( !hooks || !( "set" in hooks ) ||
  					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

  					if ( isCustomProp ) {
  						style.setProperty( name, value );
  					} else {
  						style[ name ] = value;
  					}
  				}

  			} else {

  				// If a hook was provided get the non-computed value from there
  				if ( hooks && "get" in hooks &&
  					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

  					return ret;
  				}

  				// Otherwise just get the value from the style object
  				return style[ name ];
  			}
  		},

  		css: function( elem, name, extra, styles ) {
  			var val, num, hooks,
  				origName = camelCase( name ),
  				isCustomProp = rcustomProp.test( name );

  			// Make sure that we're working with the right name. We don't
  			// want to modify the value if it is a CSS custom property
  			// since they are user-defined.
  			if ( !isCustomProp ) {
  				name = finalPropName( origName );
  			}

  			// Try prefixed name followed by the unprefixed name
  			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  			// If a hook was provided get the computed value from there
  			if ( hooks && "get" in hooks ) {
  				val = hooks.get( elem, true, extra );
  			}

  			// Otherwise, if a way to get the computed value exists, use that
  			if ( val === undefined ) {
  				val = curCSS( elem, name, styles );
  			}

  			// Convert "normal" to computed value
  			if ( val === "normal" && name in cssNormalTransform ) {
  				val = cssNormalTransform[ name ];
  			}

  			// Make numeric if forced or a qualifier was provided and val looks numeric
  			if ( extra === "" || extra ) {
  				num = parseFloat( val );
  				return extra === true || isFinite( num ) ? num || 0 : val;
  			}

  			return val;
  		}
  	} );

  	jQuery.each( [ "height", "width" ], function( _i, dimension ) {
  		jQuery.cssHooks[ dimension ] = {
  			get: function( elem, computed, extra ) {
  				if ( computed ) {

  					// Certain elements can have dimension info if we invisibly show them
  					// but it must have a current display style that would benefit
  					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

  						// Support: Safari 8+
  						// Table columns in Safari have non-zero offsetWidth & zero
  						// getBoundingClientRect().width unless display is changed.
  						// Support: IE <=11 only
  						// Running getBoundingClientRect on a disconnected node
  						// in IE throws an error.
  						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
  						swap( elem, cssShow, function() {
  							return getWidthOrHeight( elem, dimension, extra );
  						} ) :
  						getWidthOrHeight( elem, dimension, extra );
  				}
  			},

  			set: function( elem, value, extra ) {
  				var matches,
  					styles = getStyles( elem ),

  					// Only read styles.position if the test has a chance to fail
  					// to avoid forcing a reflow.
  					scrollboxSizeBuggy = !support.scrollboxSize() &&
  						styles.position === "absolute",

  					// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
  					boxSizingNeeded = scrollboxSizeBuggy || extra,
  					isBorderBox = boxSizingNeeded &&
  						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  					subtract = extra ?
  						boxModelAdjustment(
  							elem,
  							dimension,
  							extra,
  							isBorderBox,
  							styles
  						) :
  						0;

  				// Account for unreliable border-box dimensions by comparing offset* to computed and
  				// faking a content-box to get border and padding (gh-3699)
  				if ( isBorderBox && scrollboxSizeBuggy ) {
  					subtract -= Math.ceil(
  						elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  						parseFloat( styles[ dimension ] ) -
  						boxModelAdjustment( elem, dimension, "border", false, styles ) -
  						0.5
  					);
  				}

  				// Convert to pixels if value adjustment is needed
  				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
  					( matches[ 3 ] || "px" ) !== "px" ) {

  					elem.style[ dimension ] = value;
  					value = jQuery.css( elem, dimension );
  				}

  				return setPositiveNumber( elem, value, subtract );
  			}
  		};
  	} );

  	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
  		function( elem, computed ) {
  			if ( computed ) {
  				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
  					elem.getBoundingClientRect().left -
  						swap( elem, { marginLeft: 0 }, function() {
  							return elem.getBoundingClientRect().left;
  						} )
  				) + "px";
  			}
  		}
  	);

  	// These hooks are used by animate to expand properties
  	jQuery.each( {
  		margin: "",
  		padding: "",
  		border: "Width"
  	}, function( prefix, suffix ) {
  		jQuery.cssHooks[ prefix + suffix ] = {
  			expand: function( value ) {
  				var i = 0,
  					expanded = {},

  					// Assumes a single number if not a string
  					parts = typeof value === "string" ? value.split( " " ) : [ value ];

  				for ( ; i < 4; i++ ) {
  					expanded[ prefix + cssExpand[ i ] + suffix ] =
  						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
  				}

  				return expanded;
  			}
  		};

  		if ( prefix !== "margin" ) {
  			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  		}
  	} );

  	jQuery.fn.extend( {
  		css: function( name, value ) {
  			return access( this, function( elem, name, value ) {
  				var styles, len,
  					map = {},
  					i = 0;

  				if ( Array.isArray( name ) ) {
  					styles = getStyles( elem );
  					len = name.length;

  					for ( ; i < len; i++ ) {
  						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
  					}

  					return map;
  				}

  				return value !== undefined ?
  					jQuery.style( elem, name, value ) :
  					jQuery.css( elem, name );
  			}, name, value, arguments.length > 1 );
  		}
  	} );


  	function Tween( elem, options, prop, end, easing ) {
  		return new Tween.prototype.init( elem, options, prop, end, easing );
  	}
  	jQuery.Tween = Tween;

  	Tween.prototype = {
  		constructor: Tween,
  		init: function( elem, options, prop, end, easing, unit ) {
  			this.elem = elem;
  			this.prop = prop;
  			this.easing = easing || jQuery.easing._default;
  			this.options = options;
  			this.start = this.now = this.cur();
  			this.end = end;
  			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
  		},
  		cur: function() {
  			var hooks = Tween.propHooks[ this.prop ];

  			return hooks && hooks.get ?
  				hooks.get( this ) :
  				Tween.propHooks._default.get( this );
  		},
  		run: function( percent ) {
  			var eased,
  				hooks = Tween.propHooks[ this.prop ];

  			if ( this.options.duration ) {
  				this.pos = eased = jQuery.easing[ this.easing ](
  					percent, this.options.duration * percent, 0, 1, this.options.duration
  				);
  			} else {
  				this.pos = eased = percent;
  			}
  			this.now = ( this.end - this.start ) * eased + this.start;

  			if ( this.options.step ) {
  				this.options.step.call( this.elem, this.now, this );
  			}

  			if ( hooks && hooks.set ) {
  				hooks.set( this );
  			} else {
  				Tween.propHooks._default.set( this );
  			}
  			return this;
  		}
  	};

  	Tween.prototype.init.prototype = Tween.prototype;

  	Tween.propHooks = {
  		_default: {
  			get: function( tween ) {
  				var result;

  				// Use a property on the element directly when it is not a DOM element,
  				// or when there is no matching style property that exists.
  				if ( tween.elem.nodeType !== 1 ||
  					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
  					return tween.elem[ tween.prop ];
  				}

  				// Passing an empty string as a 3rd parameter to .css will automatically
  				// attempt a parseFloat and fallback to a string if the parse fails.
  				// Simple values such as "10px" are parsed to Float;
  				// complex values such as "rotate(1rad)" are returned as-is.
  				result = jQuery.css( tween.elem, tween.prop, "" );

  				// Empty strings, null, undefined and "auto" are converted to 0.
  				return !result || result === "auto" ? 0 : result;
  			},
  			set: function( tween ) {

  				// Use step hook for back compat.
  				// Use cssHook if its there.
  				// Use .style if available and use plain properties where available.
  				if ( jQuery.fx.step[ tween.prop ] ) {
  					jQuery.fx.step[ tween.prop ]( tween );
  				} else if ( tween.elem.nodeType === 1 && (
  					jQuery.cssHooks[ tween.prop ] ||
  						tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
  					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
  				} else {
  					tween.elem[ tween.prop ] = tween.now;
  				}
  			}
  		}
  	};

  	// Support: IE <=9 only
  	// Panic based approach to setting things on disconnected nodes
  	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
  		set: function( tween ) {
  			if ( tween.elem.nodeType && tween.elem.parentNode ) {
  				tween.elem[ tween.prop ] = tween.now;
  			}
  		}
  	};

  	jQuery.easing = {
  		linear: function( p ) {
  			return p;
  		},
  		swing: function( p ) {
  			return 0.5 - Math.cos( p * Math.PI ) / 2;
  		},
  		_default: "swing"
  	};

  	jQuery.fx = Tween.prototype.init;

  	// Back compat <1.8 extension point
  	jQuery.fx.step = {};




  	var
  		fxNow, inProgress,
  		rfxtypes = /^(?:toggle|show|hide)$/,
  		rrun = /queueHooks$/;

  	function schedule() {
  		if ( inProgress ) {
  			if ( document.hidden === false && window.requestAnimationFrame ) {
  				window.requestAnimationFrame( schedule );
  			} else {
  				window.setTimeout( schedule, jQuery.fx.interval );
  			}

  			jQuery.fx.tick();
  		}
  	}

  	// Animations created synchronously will run synchronously
  	function createFxNow() {
  		window.setTimeout( function() {
  			fxNow = undefined;
  		} );
  		return ( fxNow = Date.now() );
  	}

  	// Generate parameters to create a standard animation
  	function genFx( type, includeWidth ) {
  		var which,
  			i = 0,
  			attrs = { height: type };

  		// If we include width, step value is 1 to do all cssExpand values,
  		// otherwise step value is 2 to skip over Left and Right
  		includeWidth = includeWidth ? 1 : 0;
  		for ( ; i < 4; i += 2 - includeWidth ) {
  			which = cssExpand[ i ];
  			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
  		}

  		if ( includeWidth ) {
  			attrs.opacity = attrs.width = type;
  		}

  		return attrs;
  	}

  	function createTween( value, prop, animation ) {
  		var tween,
  			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
  			index = 0,
  			length = collection.length;
  		for ( ; index < length; index++ ) {
  			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

  				// We're done with this property
  				return tween;
  			}
  		}
  	}

  	function defaultPrefilter( elem, props, opts ) {
  		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
  			isBox = "width" in props || "height" in props,
  			anim = this,
  			orig = {},
  			style = elem.style,
  			hidden = elem.nodeType && isHiddenWithinTree( elem ),
  			dataShow = dataPriv.get( elem, "fxshow" );

  		// Queue-skipping animations hijack the fx hooks
  		if ( !opts.queue ) {
  			hooks = jQuery._queueHooks( elem, "fx" );
  			if ( hooks.unqueued == null ) {
  				hooks.unqueued = 0;
  				oldfire = hooks.empty.fire;
  				hooks.empty.fire = function() {
  					if ( !hooks.unqueued ) {
  						oldfire();
  					}
  				};
  			}
  			hooks.unqueued++;

  			anim.always( function() {

  				// Ensure the complete handler is called before this completes
  				anim.always( function() {
  					hooks.unqueued--;
  					if ( !jQuery.queue( elem, "fx" ).length ) {
  						hooks.empty.fire();
  					}
  				} );
  			} );
  		}

  		// Detect show/hide animations
  		for ( prop in props ) {
  			value = props[ prop ];
  			if ( rfxtypes.test( value ) ) {
  				delete props[ prop ];
  				toggle = toggle || value === "toggle";
  				if ( value === ( hidden ? "hide" : "show" ) ) {

  					// Pretend to be hidden if this is a "show" and
  					// there is still data from a stopped show/hide
  					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
  						hidden = true;

  					// Ignore all other no-op show/hide data
  					} else {
  						continue;
  					}
  				}
  				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
  			}
  		}

  		// Bail out if this is a no-op like .hide().hide()
  		propTween = !jQuery.isEmptyObject( props );
  		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
  			return;
  		}

  		// Restrict "overflow" and "display" styles during box animations
  		if ( isBox && elem.nodeType === 1 ) {

  			// Support: IE <=9 - 11, Edge 12 - 15
  			// Record all 3 overflow attributes because IE does not infer the shorthand
  			// from identically-valued overflowX and overflowY and Edge just mirrors
  			// the overflowX value there.
  			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

  			// Identify a display type, preferring old show/hide data over the CSS cascade
  			restoreDisplay = dataShow && dataShow.display;
  			if ( restoreDisplay == null ) {
  				restoreDisplay = dataPriv.get( elem, "display" );
  			}
  			display = jQuery.css( elem, "display" );
  			if ( display === "none" ) {
  				if ( restoreDisplay ) {
  					display = restoreDisplay;
  				} else {

  					// Get nonempty value(s) by temporarily forcing visibility
  					showHide( [ elem ], true );
  					restoreDisplay = elem.style.display || restoreDisplay;
  					display = jQuery.css( elem, "display" );
  					showHide( [ elem ] );
  				}
  			}

  			// Animate inline elements as inline-block
  			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
  				if ( jQuery.css( elem, "float" ) === "none" ) {

  					// Restore the original display value at the end of pure show/hide animations
  					if ( !propTween ) {
  						anim.done( function() {
  							style.display = restoreDisplay;
  						} );
  						if ( restoreDisplay == null ) {
  							display = style.display;
  							restoreDisplay = display === "none" ? "" : display;
  						}
  					}
  					style.display = "inline-block";
  				}
  			}
  		}

  		if ( opts.overflow ) {
  			style.overflow = "hidden";
  			anim.always( function() {
  				style.overflow = opts.overflow[ 0 ];
  				style.overflowX = opts.overflow[ 1 ];
  				style.overflowY = opts.overflow[ 2 ];
  			} );
  		}

  		// Implement show/hide animations
  		propTween = false;
  		for ( prop in orig ) {

  			// General show/hide setup for this element animation
  			if ( !propTween ) {
  				if ( dataShow ) {
  					if ( "hidden" in dataShow ) {
  						hidden = dataShow.hidden;
  					}
  				} else {
  					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
  				}

  				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
  				if ( toggle ) {
  					dataShow.hidden = !hidden;
  				}

  				// Show elements before animating them
  				if ( hidden ) {
  					showHide( [ elem ], true );
  				}

  				/* eslint-disable no-loop-func */

  				anim.done( function() {

  					/* eslint-enable no-loop-func */

  					// The final step of a "hide" animation is actually hiding the element
  					if ( !hidden ) {
  						showHide( [ elem ] );
  					}
  					dataPriv.remove( elem, "fxshow" );
  					for ( prop in orig ) {
  						jQuery.style( elem, prop, orig[ prop ] );
  					}
  				} );
  			}

  			// Per-property setup
  			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
  			if ( !( prop in dataShow ) ) {
  				dataShow[ prop ] = propTween.start;
  				if ( hidden ) {
  					propTween.end = propTween.start;
  					propTween.start = 0;
  				}
  			}
  		}
  	}

  	function propFilter( props, specialEasing ) {
  		var index, name, easing, value, hooks;

  		// camelCase, specialEasing and expand cssHook pass
  		for ( index in props ) {
  			name = camelCase( index );
  			easing = specialEasing[ name ];
  			value = props[ index ];
  			if ( Array.isArray( value ) ) {
  				easing = value[ 1 ];
  				value = props[ index ] = value[ 0 ];
  			}

  			if ( index !== name ) {
  				props[ name ] = value;
  				delete props[ index ];
  			}

  			hooks = jQuery.cssHooks[ name ];
  			if ( hooks && "expand" in hooks ) {
  				value = hooks.expand( value );
  				delete props[ name ];

  				// Not quite $.extend, this won't overwrite existing keys.
  				// Reusing 'index' because we have the correct "name"
  				for ( index in value ) {
  					if ( !( index in props ) ) {
  						props[ index ] = value[ index ];
  						specialEasing[ index ] = easing;
  					}
  				}
  			} else {
  				specialEasing[ name ] = easing;
  			}
  		}
  	}

  	function Animation( elem, properties, options ) {
  		var result,
  			stopped,
  			index = 0,
  			length = Animation.prefilters.length,
  			deferred = jQuery.Deferred().always( function() {

  				// Don't match elem in the :animated selector
  				delete tick.elem;
  			} ),
  			tick = function() {
  				if ( stopped ) {
  					return false;
  				}
  				var currentTime = fxNow || createFxNow(),
  					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

  					// Support: Android 2.3 only
  					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
  					temp = remaining / animation.duration || 0,
  					percent = 1 - temp,
  					index = 0,
  					length = animation.tweens.length;

  				for ( ; index < length; index++ ) {
  					animation.tweens[ index ].run( percent );
  				}

  				deferred.notifyWith( elem, [ animation, percent, remaining ] );

  				// If there's more to do, yield
  				if ( percent < 1 && length ) {
  					return remaining;
  				}

  				// If this was an empty animation, synthesize a final progress notification
  				if ( !length ) {
  					deferred.notifyWith( elem, [ animation, 1, 0 ] );
  				}

  				// Resolve the animation and report its conclusion
  				deferred.resolveWith( elem, [ animation ] );
  				return false;
  			},
  			animation = deferred.promise( {
  				elem: elem,
  				props: jQuery.extend( {}, properties ),
  				opts: jQuery.extend( true, {
  					specialEasing: {},
  					easing: jQuery.easing._default
  				}, options ),
  				originalProperties: properties,
  				originalOptions: options,
  				startTime: fxNow || createFxNow(),
  				duration: options.duration,
  				tweens: [],
  				createTween: function( prop, end ) {
  					var tween = jQuery.Tween( elem, animation.opts, prop, end,
  						animation.opts.specialEasing[ prop ] || animation.opts.easing );
  					animation.tweens.push( tween );
  					return tween;
  				},
  				stop: function( gotoEnd ) {
  					var index = 0,

  						// If we are going to the end, we want to run all the tweens
  						// otherwise we skip this part
  						length = gotoEnd ? animation.tweens.length : 0;
  					if ( stopped ) {
  						return this;
  					}
  					stopped = true;
  					for ( ; index < length; index++ ) {
  						animation.tweens[ index ].run( 1 );
  					}

  					// Resolve when we played the last frame; otherwise, reject
  					if ( gotoEnd ) {
  						deferred.notifyWith( elem, [ animation, 1, 0 ] );
  						deferred.resolveWith( elem, [ animation, gotoEnd ] );
  					} else {
  						deferred.rejectWith( elem, [ animation, gotoEnd ] );
  					}
  					return this;
  				}
  			} ),
  			props = animation.props;

  		propFilter( props, animation.opts.specialEasing );

  		for ( ; index < length; index++ ) {
  			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
  			if ( result ) {
  				if ( isFunction( result.stop ) ) {
  					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
  						result.stop.bind( result );
  				}
  				return result;
  			}
  		}

  		jQuery.map( props, createTween, animation );

  		if ( isFunction( animation.opts.start ) ) {
  			animation.opts.start.call( elem, animation );
  		}

  		// Attach callbacks from options
  		animation
  			.progress( animation.opts.progress )
  			.done( animation.opts.done, animation.opts.complete )
  			.fail( animation.opts.fail )
  			.always( animation.opts.always );

  		jQuery.fx.timer(
  			jQuery.extend( tick, {
  				elem: elem,
  				anim: animation,
  				queue: animation.opts.queue
  			} )
  		);

  		return animation;
  	}

  	jQuery.Animation = jQuery.extend( Animation, {

  		tweeners: {
  			"*": [ function( prop, value ) {
  				var tween = this.createTween( prop, value );
  				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
  				return tween;
  			} ]
  		},

  		tweener: function( props, callback ) {
  			if ( isFunction( props ) ) {
  				callback = props;
  				props = [ "*" ];
  			} else {
  				props = props.match( rnothtmlwhite );
  			}

  			var prop,
  				index = 0,
  				length = props.length;

  			for ( ; index < length; index++ ) {
  				prop = props[ index ];
  				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
  				Animation.tweeners[ prop ].unshift( callback );
  			}
  		},

  		prefilters: [ defaultPrefilter ],

  		prefilter: function( callback, prepend ) {
  			if ( prepend ) {
  				Animation.prefilters.unshift( callback );
  			} else {
  				Animation.prefilters.push( callback );
  			}
  		}
  	} );

  	jQuery.speed = function( speed, easing, fn ) {
  		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
  			complete: fn || !fn && easing ||
  				isFunction( speed ) && speed,
  			duration: speed,
  			easing: fn && easing || easing && !isFunction( easing ) && easing
  		};

  		// Go to the end state if fx are off
  		if ( jQuery.fx.off ) {
  			opt.duration = 0;

  		} else {
  			if ( typeof opt.duration !== "number" ) {
  				if ( opt.duration in jQuery.fx.speeds ) {
  					opt.duration = jQuery.fx.speeds[ opt.duration ];

  				} else {
  					opt.duration = jQuery.fx.speeds._default;
  				}
  			}
  		}

  		// Normalize opt.queue - true/undefined/null -> "fx"
  		if ( opt.queue == null || opt.queue === true ) {
  			opt.queue = "fx";
  		}

  		// Queueing
  		opt.old = opt.complete;

  		opt.complete = function() {
  			if ( isFunction( opt.old ) ) {
  				opt.old.call( this );
  			}

  			if ( opt.queue ) {
  				jQuery.dequeue( this, opt.queue );
  			}
  		};

  		return opt;
  	};

  	jQuery.fn.extend( {
  		fadeTo: function( speed, to, easing, callback ) {

  			// Show any hidden elements after setting opacity to 0
  			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

  				// Animate to the value specified
  				.end().animate( { opacity: to }, speed, easing, callback );
  		},
  		animate: function( prop, speed, easing, callback ) {
  			var empty = jQuery.isEmptyObject( prop ),
  				optall = jQuery.speed( speed, easing, callback ),
  				doAnimation = function() {

  					// Operate on a copy of prop so per-property easing won't be lost
  					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

  					// Empty animations, or finishing resolves immediately
  					if ( empty || dataPriv.get( this, "finish" ) ) {
  						anim.stop( true );
  					}
  				};

  			doAnimation.finish = doAnimation;

  			return empty || optall.queue === false ?
  				this.each( doAnimation ) :
  				this.queue( optall.queue, doAnimation );
  		},
  		stop: function( type, clearQueue, gotoEnd ) {
  			var stopQueue = function( hooks ) {
  				var stop = hooks.stop;
  				delete hooks.stop;
  				stop( gotoEnd );
  			};

  			if ( typeof type !== "string" ) {
  				gotoEnd = clearQueue;
  				clearQueue = type;
  				type = undefined;
  			}
  			if ( clearQueue ) {
  				this.queue( type || "fx", [] );
  			}

  			return this.each( function() {
  				var dequeue = true,
  					index = type != null && type + "queueHooks",
  					timers = jQuery.timers,
  					data = dataPriv.get( this );

  				if ( index ) {
  					if ( data[ index ] && data[ index ].stop ) {
  						stopQueue( data[ index ] );
  					}
  				} else {
  					for ( index in data ) {
  						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
  							stopQueue( data[ index ] );
  						}
  					}
  				}

  				for ( index = timers.length; index--; ) {
  					if ( timers[ index ].elem === this &&
  						( type == null || timers[ index ].queue === type ) ) {

  						timers[ index ].anim.stop( gotoEnd );
  						dequeue = false;
  						timers.splice( index, 1 );
  					}
  				}

  				// Start the next in the queue if the last step wasn't forced.
  				// Timers currently will call their complete callbacks, which
  				// will dequeue but only if they were gotoEnd.
  				if ( dequeue || !gotoEnd ) {
  					jQuery.dequeue( this, type );
  				}
  			} );
  		},
  		finish: function( type ) {
  			if ( type !== false ) {
  				type = type || "fx";
  			}
  			return this.each( function() {
  				var index,
  					data = dataPriv.get( this ),
  					queue = data[ type + "queue" ],
  					hooks = data[ type + "queueHooks" ],
  					timers = jQuery.timers,
  					length = queue ? queue.length : 0;

  				// Enable finishing flag on private data
  				data.finish = true;

  				// Empty the queue first
  				jQuery.queue( this, type, [] );

  				if ( hooks && hooks.stop ) {
  					hooks.stop.call( this, true );
  				}

  				// Look for any active animations, and finish them
  				for ( index = timers.length; index--; ) {
  					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
  						timers[ index ].anim.stop( true );
  						timers.splice( index, 1 );
  					}
  				}

  				// Look for any animations in the old queue and finish them
  				for ( index = 0; index < length; index++ ) {
  					if ( queue[ index ] && queue[ index ].finish ) {
  						queue[ index ].finish.call( this );
  					}
  				}

  				// Turn off finishing flag
  				delete data.finish;
  			} );
  		}
  	} );

  	jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
  		var cssFn = jQuery.fn[ name ];
  		jQuery.fn[ name ] = function( speed, easing, callback ) {
  			return speed == null || typeof speed === "boolean" ?
  				cssFn.apply( this, arguments ) :
  				this.animate( genFx( name, true ), speed, easing, callback );
  		};
  	} );

  	// Generate shortcuts for custom animations
  	jQuery.each( {
  		slideDown: genFx( "show" ),
  		slideUp: genFx( "hide" ),
  		slideToggle: genFx( "toggle" ),
  		fadeIn: { opacity: "show" },
  		fadeOut: { opacity: "hide" },
  		fadeToggle: { opacity: "toggle" }
  	}, function( name, props ) {
  		jQuery.fn[ name ] = function( speed, easing, callback ) {
  			return this.animate( props, speed, easing, callback );
  		};
  	} );

  	jQuery.timers = [];
  	jQuery.fx.tick = function() {
  		var timer,
  			i = 0,
  			timers = jQuery.timers;

  		fxNow = Date.now();

  		for ( ; i < timers.length; i++ ) {
  			timer = timers[ i ];

  			// Run the timer and safely remove it when done (allowing for external removal)
  			if ( !timer() && timers[ i ] === timer ) {
  				timers.splice( i--, 1 );
  			}
  		}

  		if ( !timers.length ) {
  			jQuery.fx.stop();
  		}
  		fxNow = undefined;
  	};

  	jQuery.fx.timer = function( timer ) {
  		jQuery.timers.push( timer );
  		jQuery.fx.start();
  	};

  	jQuery.fx.interval = 13;
  	jQuery.fx.start = function() {
  		if ( inProgress ) {
  			return;
  		}

  		inProgress = true;
  		schedule();
  	};

  	jQuery.fx.stop = function() {
  		inProgress = null;
  	};

  	jQuery.fx.speeds = {
  		slow: 600,
  		fast: 200,

  		// Default speed
  		_default: 400
  	};


  	// Based off of the plugin by Clint Helfers, with permission.
  	jQuery.fn.delay = function( time, type ) {
  		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
  		type = type || "fx";

  		return this.queue( type, function( next, hooks ) {
  			var timeout = window.setTimeout( next, time );
  			hooks.stop = function() {
  				window.clearTimeout( timeout );
  			};
  		} );
  	};


  	( function() {
  		var input = document.createElement( "input" ),
  			select = document.createElement( "select" ),
  			opt = select.appendChild( document.createElement( "option" ) );

  		input.type = "checkbox";

  		// Support: Android <=4.3 only
  		// Default value for a checkbox should be "on"
  		support.checkOn = input.value !== "";

  		// Support: IE <=11 only
  		// Must access selectedIndex to make default options select
  		support.optSelected = opt.selected;

  		// Support: IE <=11 only
  		// An input loses its value after becoming a radio
  		input = document.createElement( "input" );
  		input.value = "t";
  		input.type = "radio";
  		support.radioValue = input.value === "t";
  	} )();


  	var boolHook,
  		attrHandle = jQuery.expr.attrHandle;

  	jQuery.fn.extend( {
  		attr: function( name, value ) {
  			return access( this, jQuery.attr, name, value, arguments.length > 1 );
  		},

  		removeAttr: function( name ) {
  			return this.each( function() {
  				jQuery.removeAttr( this, name );
  			} );
  		}
  	} );

  	jQuery.extend( {
  		attr: function( elem, name, value ) {
  			var ret, hooks,
  				nType = elem.nodeType;

  			// Don't get/set attributes on text, comment and attribute nodes
  			if ( nType === 3 || nType === 8 || nType === 2 ) {
  				return;
  			}

  			// Fallback to prop when attributes are not supported
  			if ( typeof elem.getAttribute === "undefined" ) {
  				return jQuery.prop( elem, name, value );
  			}

  			// Attribute hooks are determined by the lowercase version
  			// Grab necessary hook if one is defined
  			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
  				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
  					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
  			}

  			if ( value !== undefined ) {
  				if ( value === null ) {
  					jQuery.removeAttr( elem, name );
  					return;
  				}

  				if ( hooks && "set" in hooks &&
  					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  					return ret;
  				}

  				elem.setAttribute( name, value + "" );
  				return value;
  			}

  			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  				return ret;
  			}

  			ret = jQuery.find.attr( elem, name );

  			// Non-existent attributes return null, we normalize to undefined
  			return ret == null ? undefined : ret;
  		},

  		attrHooks: {
  			type: {
  				set: function( elem, value ) {
  					if ( !support.radioValue && value === "radio" &&
  						nodeName( elem, "input" ) ) {
  						var val = elem.value;
  						elem.setAttribute( "type", value );
  						if ( val ) {
  							elem.value = val;
  						}
  						return value;
  					}
  				}
  			}
  		},

  		removeAttr: function( elem, value ) {
  			var name,
  				i = 0,

  				// Attribute names can contain non-HTML whitespace characters
  				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
  				attrNames = value && value.match( rnothtmlwhite );

  			if ( attrNames && elem.nodeType === 1 ) {
  				while ( ( name = attrNames[ i++ ] ) ) {
  					elem.removeAttribute( name );
  				}
  			}
  		}
  	} );

  	// Hooks for boolean attributes
  	boolHook = {
  		set: function( elem, value, name ) {
  			if ( value === false ) {

  				// Remove boolean attributes when set to false
  				jQuery.removeAttr( elem, name );
  			} else {
  				elem.setAttribute( name, name );
  			}
  			return name;
  		}
  	};

  	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
  		var getter = attrHandle[ name ] || jQuery.find.attr;

  		attrHandle[ name ] = function( elem, name, isXML ) {
  			var ret, handle,
  				lowercaseName = name.toLowerCase();

  			if ( !isXML ) {

  				// Avoid an infinite loop by temporarily removing this function from the getter
  				handle = attrHandle[ lowercaseName ];
  				attrHandle[ lowercaseName ] = ret;
  				ret = getter( elem, name, isXML ) != null ?
  					lowercaseName :
  					null;
  				attrHandle[ lowercaseName ] = handle;
  			}
  			return ret;
  		};
  	} );




  	var rfocusable = /^(?:input|select|textarea|button)$/i,
  		rclickable = /^(?:a|area)$/i;

  	jQuery.fn.extend( {
  		prop: function( name, value ) {
  			return access( this, jQuery.prop, name, value, arguments.length > 1 );
  		},

  		removeProp: function( name ) {
  			return this.each( function() {
  				delete this[ jQuery.propFix[ name ] || name ];
  			} );
  		}
  	} );

  	jQuery.extend( {
  		prop: function( elem, name, value ) {
  			var ret, hooks,
  				nType = elem.nodeType;

  			// Don't get/set properties on text, comment and attribute nodes
  			if ( nType === 3 || nType === 8 || nType === 2 ) {
  				return;
  			}

  			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

  				// Fix name and attach hooks
  				name = jQuery.propFix[ name ] || name;
  				hooks = jQuery.propHooks[ name ];
  			}

  			if ( value !== undefined ) {
  				if ( hooks && "set" in hooks &&
  					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  					return ret;
  				}

  				return ( elem[ name ] = value );
  			}

  			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  				return ret;
  			}

  			return elem[ name ];
  		},

  		propHooks: {
  			tabIndex: {
  				get: function( elem ) {

  					// Support: IE <=9 - 11 only
  					// elem.tabIndex doesn't always return the
  					// correct value when it hasn't been explicitly set
  					// Use proper attribute retrieval (trac-12072)
  					var tabindex = jQuery.find.attr( elem, "tabindex" );

  					if ( tabindex ) {
  						return parseInt( tabindex, 10 );
  					}

  					if (
  						rfocusable.test( elem.nodeName ) ||
  						rclickable.test( elem.nodeName ) &&
  						elem.href
  					) {
  						return 0;
  					}

  					return -1;
  				}
  			}
  		},

  		propFix: {
  			"for": "htmlFor",
  			"class": "className"
  		}
  	} );

  	// Support: IE <=11 only
  	// Accessing the selectedIndex property
  	// forces the browser to respect setting selected
  	// on the option
  	// The getter ensures a default option is selected
  	// when in an optgroup
  	// eslint rule "no-unused-expressions" is disabled for this code
  	// since it considers such accessions noop
  	if ( !support.optSelected ) {
  		jQuery.propHooks.selected = {
  			get: function( elem ) {

  				/* eslint no-unused-expressions: "off" */

  				var parent = elem.parentNode;
  				if ( parent && parent.parentNode ) {
  					parent.parentNode.selectedIndex;
  				}
  				return null;
  			},
  			set: function( elem ) {

  				/* eslint no-unused-expressions: "off" */

  				var parent = elem.parentNode;
  				if ( parent ) {
  					parent.selectedIndex;

  					if ( parent.parentNode ) {
  						parent.parentNode.selectedIndex;
  					}
  				}
  			}
  		};
  	}

  	jQuery.each( [
  		"tabIndex",
  		"readOnly",
  		"maxLength",
  		"cellSpacing",
  		"cellPadding",
  		"rowSpan",
  		"colSpan",
  		"useMap",
  		"frameBorder",
  		"contentEditable"
  	], function() {
  		jQuery.propFix[ this.toLowerCase() ] = this;
  	} );




  		// Strip and collapse whitespace according to HTML spec
  		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
  		function stripAndCollapse( value ) {
  			var tokens = value.match( rnothtmlwhite ) || [];
  			return tokens.join( " " );
  		}


  	function getClass( elem ) {
  		return elem.getAttribute && elem.getAttribute( "class" ) || "";
  	}

  	function classesToArray( value ) {
  		if ( Array.isArray( value ) ) {
  			return value;
  		}
  		if ( typeof value === "string" ) {
  			return value.match( rnothtmlwhite ) || [];
  		}
  		return [];
  	}

  	jQuery.fn.extend( {
  		addClass: function( value ) {
  			var classNames, cur, curValue, className, i, finalValue;

  			if ( isFunction( value ) ) {
  				return this.each( function( j ) {
  					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
  				} );
  			}

  			classNames = classesToArray( value );

  			if ( classNames.length ) {
  				return this.each( function() {
  					curValue = getClass( this );
  					cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  					if ( cur ) {
  						for ( i = 0; i < classNames.length; i++ ) {
  							className = classNames[ i ];
  							if ( cur.indexOf( " " + className + " " ) < 0 ) {
  								cur += className + " ";
  							}
  						}

  						// Only assign if different to avoid unneeded rendering.
  						finalValue = stripAndCollapse( cur );
  						if ( curValue !== finalValue ) {
  							this.setAttribute( "class", finalValue );
  						}
  					}
  				} );
  			}

  			return this;
  		},

  		removeClass: function( value ) {
  			var classNames, cur, curValue, className, i, finalValue;

  			if ( isFunction( value ) ) {
  				return this.each( function( j ) {
  					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
  				} );
  			}

  			if ( !arguments.length ) {
  				return this.attr( "class", "" );
  			}

  			classNames = classesToArray( value );

  			if ( classNames.length ) {
  				return this.each( function() {
  					curValue = getClass( this );

  					// This expression is here for better compressibility (see addClass)
  					cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  					if ( cur ) {
  						for ( i = 0; i < classNames.length; i++ ) {
  							className = classNames[ i ];

  							// Remove *all* instances
  							while ( cur.indexOf( " " + className + " " ) > -1 ) {
  								cur = cur.replace( " " + className + " ", " " );
  							}
  						}

  						// Only assign if different to avoid unneeded rendering.
  						finalValue = stripAndCollapse( cur );
  						if ( curValue !== finalValue ) {
  							this.setAttribute( "class", finalValue );
  						}
  					}
  				} );
  			}

  			return this;
  		},

  		toggleClass: function( value, stateVal ) {
  			var classNames, className, i, self,
  				type = typeof value,
  				isValidValue = type === "string" || Array.isArray( value );

  			if ( isFunction( value ) ) {
  				return this.each( function( i ) {
  					jQuery( this ).toggleClass(
  						value.call( this, i, getClass( this ), stateVal ),
  						stateVal
  					);
  				} );
  			}

  			if ( typeof stateVal === "boolean" && isValidValue ) {
  				return stateVal ? this.addClass( value ) : this.removeClass( value );
  			}

  			classNames = classesToArray( value );

  			return this.each( function() {
  				if ( isValidValue ) {

  					// Toggle individual class names
  					self = jQuery( this );

  					for ( i = 0; i < classNames.length; i++ ) {
  						className = classNames[ i ];

  						// Check each className given, space separated list
  						if ( self.hasClass( className ) ) {
  							self.removeClass( className );
  						} else {
  							self.addClass( className );
  						}
  					}

  				// Toggle whole class name
  				} else if ( value === undefined || type === "boolean" ) {
  					className = getClass( this );
  					if ( className ) {

  						// Store className if set
  						dataPriv.set( this, "__className__", className );
  					}

  					// If the element has a class name or if we're passed `false`,
  					// then remove the whole classname (if there was one, the above saved it).
  					// Otherwise bring back whatever was previously saved (if anything),
  					// falling back to the empty string if nothing was stored.
  					if ( this.setAttribute ) {
  						this.setAttribute( "class",
  							className || value === false ?
  								"" :
  								dataPriv.get( this, "__className__" ) || ""
  						);
  					}
  				}
  			} );
  		},

  		hasClass: function( selector ) {
  			var className, elem,
  				i = 0;

  			className = " " + selector + " ";
  			while ( ( elem = this[ i++ ] ) ) {
  				if ( elem.nodeType === 1 &&
  					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
  					return true;
  				}
  			}

  			return false;
  		}
  	} );




  	var rreturn = /\r/g;

  	jQuery.fn.extend( {
  		val: function( value ) {
  			var hooks, ret, valueIsFunction,
  				elem = this[ 0 ];

  			if ( !arguments.length ) {
  				if ( elem ) {
  					hooks = jQuery.valHooks[ elem.type ] ||
  						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

  					if ( hooks &&
  						"get" in hooks &&
  						( ret = hooks.get( elem, "value" ) ) !== undefined
  					) {
  						return ret;
  					}

  					ret = elem.value;

  					// Handle most common string cases
  					if ( typeof ret === "string" ) {
  						return ret.replace( rreturn, "" );
  					}

  					// Handle cases where value is null/undef or number
  					return ret == null ? "" : ret;
  				}

  				return;
  			}

  			valueIsFunction = isFunction( value );

  			return this.each( function( i ) {
  				var val;

  				if ( this.nodeType !== 1 ) {
  					return;
  				}

  				if ( valueIsFunction ) {
  					val = value.call( this, i, jQuery( this ).val() );
  				} else {
  					val = value;
  				}

  				// Treat null/undefined as ""; convert numbers to string
  				if ( val == null ) {
  					val = "";

  				} else if ( typeof val === "number" ) {
  					val += "";

  				} else if ( Array.isArray( val ) ) {
  					val = jQuery.map( val, function( value ) {
  						return value == null ? "" : value + "";
  					} );
  				}

  				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

  				// If set returns undefined, fall back to normal setting
  				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
  					this.value = val;
  				}
  			} );
  		}
  	} );

  	jQuery.extend( {
  		valHooks: {
  			option: {
  				get: function( elem ) {

  					var val = jQuery.find.attr( elem, "value" );
  					return val != null ?
  						val :

  						// Support: IE <=10 - 11 only
  						// option.text throws exceptions (trac-14686, trac-14858)
  						// Strip and collapse whitespace
  						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
  						stripAndCollapse( jQuery.text( elem ) );
  				}
  			},
  			select: {
  				get: function( elem ) {
  					var value, option, i,
  						options = elem.options,
  						index = elem.selectedIndex,
  						one = elem.type === "select-one",
  						values = one ? null : [],
  						max = one ? index + 1 : options.length;

  					if ( index < 0 ) {
  						i = max;

  					} else {
  						i = one ? index : 0;
  					}

  					// Loop through all the selected options
  					for ( ; i < max; i++ ) {
  						option = options[ i ];

  						// Support: IE <=9 only
  						// IE8-9 doesn't update selected after form reset (trac-2551)
  						if ( ( option.selected || i === index ) &&

  								// Don't return options that are disabled or in a disabled optgroup
  								!option.disabled &&
  								( !option.parentNode.disabled ||
  									!nodeName( option.parentNode, "optgroup" ) ) ) {

  							// Get the specific value for the option
  							value = jQuery( option ).val();

  							// We don't need an array for one selects
  							if ( one ) {
  								return value;
  							}

  							// Multi-Selects return an array
  							values.push( value );
  						}
  					}

  					return values;
  				},

  				set: function( elem, value ) {
  					var optionSet, option,
  						options = elem.options,
  						values = jQuery.makeArray( value ),
  						i = options.length;

  					while ( i-- ) {
  						option = options[ i ];

  						/* eslint-disable no-cond-assign */

  						if ( option.selected =
  							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
  						) {
  							optionSet = true;
  						}

  						/* eslint-enable no-cond-assign */
  					}

  					// Force browsers to behave consistently when non-matching value is set
  					if ( !optionSet ) {
  						elem.selectedIndex = -1;
  					}
  					return values;
  				}
  			}
  		}
  	} );

  	// Radios and checkboxes getter/setter
  	jQuery.each( [ "radio", "checkbox" ], function() {
  		jQuery.valHooks[ this ] = {
  			set: function( elem, value ) {
  				if ( Array.isArray( value ) ) {
  					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
  				}
  			}
  		};
  		if ( !support.checkOn ) {
  			jQuery.valHooks[ this ].get = function( elem ) {
  				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
  			};
  		}
  	} );




  	// Return jQuery for attributes-only inclusion
  	var location = window.location;

  	var nonce = { guid: Date.now() };

  	var rquery = ( /\?/ );



  	// Cross-browser xml parsing
  	jQuery.parseXML = function( data ) {
  		var xml, parserErrorElem;
  		if ( !data || typeof data !== "string" ) {
  			return null;
  		}

  		// Support: IE 9 - 11 only
  		// IE throws on parseFromString with invalid input.
  		try {
  			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
  		} catch ( e ) {}

  		parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
  		if ( !xml || parserErrorElem ) {
  			jQuery.error( "Invalid XML: " + (
  				parserErrorElem ?
  					jQuery.map( parserErrorElem.childNodes, function( el ) {
  						return el.textContent;
  					} ).join( "\n" ) :
  					data
  			) );
  		}
  		return xml;
  	};


  	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  		stopPropagationCallback = function( e ) {
  			e.stopPropagation();
  		};

  	jQuery.extend( jQuery.event, {

  		trigger: function( event, data, elem, onlyHandlers ) {

  			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
  				eventPath = [ elem || document ],
  				type = hasOwn.call( event, "type" ) ? event.type : event,
  				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

  			cur = lastElement = tmp = elem = elem || document;

  			// Don't do events on text and comment nodes
  			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
  				return;
  			}

  			// focus/blur morphs to focusin/out; ensure we're not firing them right now
  			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
  				return;
  			}

  			if ( type.indexOf( "." ) > -1 ) {

  				// Namespaced trigger; create a regexp to match event type in handle()
  				namespaces = type.split( "." );
  				type = namespaces.shift();
  				namespaces.sort();
  			}
  			ontype = type.indexOf( ":" ) < 0 && "on" + type;

  			// Caller can pass in a jQuery.Event object, Object, or just an event type string
  			event = event[ jQuery.expando ] ?
  				event :
  				new jQuery.Event( type, typeof event === "object" && event );

  			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
  			event.isTrigger = onlyHandlers ? 2 : 3;
  			event.namespace = namespaces.join( "." );
  			event.rnamespace = event.namespace ?
  				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
  				null;

  			// Clean up the event in case it is being reused
  			event.result = undefined;
  			if ( !event.target ) {
  				event.target = elem;
  			}

  			// Clone any incoming data and prepend the event, creating the handler arg list
  			data = data == null ?
  				[ event ] :
  				jQuery.makeArray( data, [ event ] );

  			// Allow special events to draw outside the lines
  			special = jQuery.event.special[ type ] || {};
  			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
  				return;
  			}

  			// Determine event propagation path in advance, per W3C events spec (trac-9951)
  			// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
  			if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

  				bubbleType = special.delegateType || type;
  				if ( !rfocusMorph.test( bubbleType + type ) ) {
  					cur = cur.parentNode;
  				}
  				for ( ; cur; cur = cur.parentNode ) {
  					eventPath.push( cur );
  					tmp = cur;
  				}

  				// Only add window if we got to document (e.g., not plain obj or detached DOM)
  				if ( tmp === ( elem.ownerDocument || document ) ) {
  					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
  				}
  			}

  			// Fire handlers on the event path
  			i = 0;
  			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
  				lastElement = cur;
  				event.type = i > 1 ?
  					bubbleType :
  					special.bindType || type;

  				// jQuery handler
  				handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
  					dataPriv.get( cur, "handle" );
  				if ( handle ) {
  					handle.apply( cur, data );
  				}

  				// Native handler
  				handle = ontype && cur[ ontype ];
  				if ( handle && handle.apply && acceptData( cur ) ) {
  					event.result = handle.apply( cur, data );
  					if ( event.result === false ) {
  						event.preventDefault();
  					}
  				}
  			}
  			event.type = type;

  			// If nobody prevented the default action, do it now
  			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

  				if ( ( !special._default ||
  					special._default.apply( eventPath.pop(), data ) === false ) &&
  					acceptData( elem ) ) {

  					// Call a native DOM method on the target with the same name as the event.
  					// Don't do default actions on window, that's where global variables be (trac-6170)
  					if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

  						// Don't re-trigger an onFOO event when we call its FOO() method
  						tmp = elem[ ontype ];

  						if ( tmp ) {
  							elem[ ontype ] = null;
  						}

  						// Prevent re-triggering of the same event, since we already bubbled it above
  						jQuery.event.triggered = type;

  						if ( event.isPropagationStopped() ) {
  							lastElement.addEventListener( type, stopPropagationCallback );
  						}

  						elem[ type ]();

  						if ( event.isPropagationStopped() ) {
  							lastElement.removeEventListener( type, stopPropagationCallback );
  						}

  						jQuery.event.triggered = undefined;

  						if ( tmp ) {
  							elem[ ontype ] = tmp;
  						}
  					}
  				}
  			}

  			return event.result;
  		},

  		// Piggyback on a donor event to simulate a different one
  		// Used only for `focus(in | out)` events
  		simulate: function( type, elem, event ) {
  			var e = jQuery.extend(
  				new jQuery.Event(),
  				event,
  				{
  					type: type,
  					isSimulated: true
  				}
  			);

  			jQuery.event.trigger( e, null, elem );
  		}

  	} );

  	jQuery.fn.extend( {

  		trigger: function( type, data ) {
  			return this.each( function() {
  				jQuery.event.trigger( type, data, this );
  			} );
  		},
  		triggerHandler: function( type, data ) {
  			var elem = this[ 0 ];
  			if ( elem ) {
  				return jQuery.event.trigger( type, data, elem, true );
  			}
  		}
  	} );


  	var
  		rbracket = /\[\]$/,
  		rCRLF = /\r?\n/g,
  		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  		rsubmittable = /^(?:input|select|textarea|keygen)/i;

  	function buildParams( prefix, obj, traditional, add ) {
  		var name;

  		if ( Array.isArray( obj ) ) {

  			// Serialize array item.
  			jQuery.each( obj, function( i, v ) {
  				if ( traditional || rbracket.test( prefix ) ) {

  					// Treat each array item as a scalar.
  					add( prefix, v );

  				} else {

  					// Item is non-scalar (array or object), encode its numeric index.
  					buildParams(
  						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
  						v,
  						traditional,
  						add
  					);
  				}
  			} );

  		} else if ( !traditional && toType( obj ) === "object" ) {

  			// Serialize object item.
  			for ( name in obj ) {
  				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
  			}

  		} else {

  			// Serialize scalar item.
  			add( prefix, obj );
  		}
  	}

  	// Serialize an array of form elements or a set of
  	// key/values into a query string
  	jQuery.param = function( a, traditional ) {
  		var prefix,
  			s = [],
  			add = function( key, valueOrFunction ) {

  				// If value is a function, invoke it and use its return value
  				var value = isFunction( valueOrFunction ) ?
  					valueOrFunction() :
  					valueOrFunction;

  				s[ s.length ] = encodeURIComponent( key ) + "=" +
  					encodeURIComponent( value == null ? "" : value );
  			};

  		if ( a == null ) {
  			return "";
  		}

  		// If an array was passed in, assume that it is an array of form elements.
  		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

  			// Serialize the form elements
  			jQuery.each( a, function() {
  				add( this.name, this.value );
  			} );

  		} else {

  			// If traditional, encode the "old" way (the way 1.3.2 or older
  			// did it), otherwise encode params recursively.
  			for ( prefix in a ) {
  				buildParams( prefix, a[ prefix ], traditional, add );
  			}
  		}

  		// Return the resulting serialization
  		return s.join( "&" );
  	};

  	jQuery.fn.extend( {
  		serialize: function() {
  			return jQuery.param( this.serializeArray() );
  		},
  		serializeArray: function() {
  			return this.map( function() {

  				// Can add propHook for "elements" to filter or add form elements
  				var elements = jQuery.prop( this, "elements" );
  				return elements ? jQuery.makeArray( elements ) : this;
  			} ).filter( function() {
  				var type = this.type;

  				// Use .is( ":disabled" ) so that fieldset[disabled] works
  				return this.name && !jQuery( this ).is( ":disabled" ) &&
  					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
  					( this.checked || !rcheckableType.test( type ) );
  			} ).map( function( _i, elem ) {
  				var val = jQuery( this ).val();

  				if ( val == null ) {
  					return null;
  				}

  				if ( Array.isArray( val ) ) {
  					return jQuery.map( val, function( val ) {
  						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  					} );
  				}

  				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  			} ).get();
  		}
  	} );


  	var
  		r20 = /%20/g,
  		rhash = /#.*$/,
  		rantiCache = /([?&])_=[^&]*/,
  		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

  		// trac-7653, trac-8125, trac-8152: local protocol detection
  		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
  		rnoContent = /^(?:GET|HEAD)$/,
  		rprotocol = /^\/\//,

  		/* Prefilters
  		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  		 * 2) These are called:
  		 *    - BEFORE asking for a transport
  		 *    - AFTER param serialization (s.data is a string if s.processData is true)
  		 * 3) key is the dataType
  		 * 4) the catchall symbol "*" can be used
  		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  		 */
  		prefilters = {},

  		/* Transports bindings
  		 * 1) key is the dataType
  		 * 2) the catchall symbol "*" can be used
  		 * 3) selection will start with transport dataType and THEN go to "*" if needed
  		 */
  		transports = {},

  		// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
  		allTypes = "*/".concat( "*" ),

  		// Anchor tag for parsing the document origin
  		originAnchor = document.createElement( "a" );

  	originAnchor.href = location.href;

  	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  	function addToPrefiltersOrTransports( structure ) {

  		// dataTypeExpression is optional and defaults to "*"
  		return function( dataTypeExpression, func ) {

  			if ( typeof dataTypeExpression !== "string" ) {
  				func = dataTypeExpression;
  				dataTypeExpression = "*";
  			}

  			var dataType,
  				i = 0,
  				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

  			if ( isFunction( func ) ) {

  				// For each dataType in the dataTypeExpression
  				while ( ( dataType = dataTypes[ i++ ] ) ) {

  					// Prepend if requested
  					if ( dataType[ 0 ] === "+" ) {
  						dataType = dataType.slice( 1 ) || "*";
  						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

  					// Otherwise append
  					} else {
  						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
  					}
  				}
  			}
  		};
  	}

  	// Base inspection function for prefilters and transports
  	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

  		var inspected = {},
  			seekingTransport = ( structure === transports );

  		function inspect( dataType ) {
  			var selected;
  			inspected[ dataType ] = true;
  			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
  				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
  				if ( typeof dataTypeOrTransport === "string" &&
  					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

  					options.dataTypes.unshift( dataTypeOrTransport );
  					inspect( dataTypeOrTransport );
  					return false;
  				} else if ( seekingTransport ) {
  					return !( selected = dataTypeOrTransport );
  				}
  			} );
  			return selected;
  		}

  		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
  	}

  	// A special extend for ajax options
  	// that takes "flat" options (not to be deep extended)
  	// Fixes trac-9887
  	function ajaxExtend( target, src ) {
  		var key, deep,
  			flatOptions = jQuery.ajaxSettings.flatOptions || {};

  		for ( key in src ) {
  			if ( src[ key ] !== undefined ) {
  				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
  			}
  		}
  		if ( deep ) {
  			jQuery.extend( true, target, deep );
  		}

  		return target;
  	}

  	/* Handles responses to an ajax request:
  	 * - finds the right dataType (mediates between content-type and expected dataType)
  	 * - returns the corresponding response
  	 */
  	function ajaxHandleResponses( s, jqXHR, responses ) {

  		var ct, type, finalDataType, firstDataType,
  			contents = s.contents,
  			dataTypes = s.dataTypes;

  		// Remove auto dataType and get content-type in the process
  		while ( dataTypes[ 0 ] === "*" ) {
  			dataTypes.shift();
  			if ( ct === undefined ) {
  				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
  			}
  		}

  		// Check if we're dealing with a known content-type
  		if ( ct ) {
  			for ( type in contents ) {
  				if ( contents[ type ] && contents[ type ].test( ct ) ) {
  					dataTypes.unshift( type );
  					break;
  				}
  			}
  		}

  		// Check to see if we have a response for the expected dataType
  		if ( dataTypes[ 0 ] in responses ) {
  			finalDataType = dataTypes[ 0 ];
  		} else {

  			// Try convertible dataTypes
  			for ( type in responses ) {
  				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
  					finalDataType = type;
  					break;
  				}
  				if ( !firstDataType ) {
  					firstDataType = type;
  				}
  			}

  			// Or just use first one
  			finalDataType = finalDataType || firstDataType;
  		}

  		// If we found a dataType
  		// We add the dataType to the list if needed
  		// and return the corresponding response
  		if ( finalDataType ) {
  			if ( finalDataType !== dataTypes[ 0 ] ) {
  				dataTypes.unshift( finalDataType );
  			}
  			return responses[ finalDataType ];
  		}
  	}

  	/* Chain conversions given the request and the original response
  	 * Also sets the responseXXX fields on the jqXHR instance
  	 */
  	function ajaxConvert( s, response, jqXHR, isSuccess ) {
  		var conv2, current, conv, tmp, prev,
  			converters = {},

  			// Work with a copy of dataTypes in case we need to modify it for conversion
  			dataTypes = s.dataTypes.slice();

  		// Create converters map with lowercased keys
  		if ( dataTypes[ 1 ] ) {
  			for ( conv in s.converters ) {
  				converters[ conv.toLowerCase() ] = s.converters[ conv ];
  			}
  		}

  		current = dataTypes.shift();

  		// Convert to each sequential dataType
  		while ( current ) {

  			if ( s.responseFields[ current ] ) {
  				jqXHR[ s.responseFields[ current ] ] = response;
  			}

  			// Apply the dataFilter if provided
  			if ( !prev && isSuccess && s.dataFilter ) {
  				response = s.dataFilter( response, s.dataType );
  			}

  			prev = current;
  			current = dataTypes.shift();

  			if ( current ) {

  				// There's only work to do if current dataType is non-auto
  				if ( current === "*" ) {

  					current = prev;

  				// Convert response if prev dataType is non-auto and differs from current
  				} else if ( prev !== "*" && prev !== current ) {

  					// Seek a direct converter
  					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

  					// If none found, seek a pair
  					if ( !conv ) {
  						for ( conv2 in converters ) {

  							// If conv2 outputs current
  							tmp = conv2.split( " " );
  							if ( tmp[ 1 ] === current ) {

  								// If prev can be converted to accepted input
  								conv = converters[ prev + " " + tmp[ 0 ] ] ||
  									converters[ "* " + tmp[ 0 ] ];
  								if ( conv ) {

  									// Condense equivalence converters
  									if ( conv === true ) {
  										conv = converters[ conv2 ];

  									// Otherwise, insert the intermediate dataType
  									} else if ( converters[ conv2 ] !== true ) {
  										current = tmp[ 0 ];
  										dataTypes.unshift( tmp[ 1 ] );
  									}
  									break;
  								}
  							}
  						}
  					}

  					// Apply converter (if not an equivalence)
  					if ( conv !== true ) {

  						// Unless errors are allowed to bubble, catch and return them
  						if ( conv && s.throws ) {
  							response = conv( response );
  						} else {
  							try {
  								response = conv( response );
  							} catch ( e ) {
  								return {
  									state: "parsererror",
  									error: conv ? e : "No conversion from " + prev + " to " + current
  								};
  							}
  						}
  					}
  				}
  			}
  		}

  		return { state: "success", data: response };
  	}

  	jQuery.extend( {

  		// Counter for holding the number of active queries
  		active: 0,

  		// Last-Modified header cache for next request
  		lastModified: {},
  		etag: {},

  		ajaxSettings: {
  			url: location.href,
  			type: "GET",
  			isLocal: rlocalProtocol.test( location.protocol ),
  			global: true,
  			processData: true,
  			async: true,
  			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

  			/*
  			timeout: 0,
  			data: null,
  			dataType: null,
  			username: null,
  			password: null,
  			cache: null,
  			throws: false,
  			traditional: false,
  			headers: {},
  			*/

  			accepts: {
  				"*": allTypes,
  				text: "text/plain",
  				html: "text/html",
  				xml: "application/xml, text/xml",
  				json: "application/json, text/javascript"
  			},

  			contents: {
  				xml: /\bxml\b/,
  				html: /\bhtml/,
  				json: /\bjson\b/
  			},

  			responseFields: {
  				xml: "responseXML",
  				text: "responseText",
  				json: "responseJSON"
  			},

  			// Data converters
  			// Keys separate source (or catchall "*") and destination types with a single space
  			converters: {

  				// Convert anything to text
  				"* text": String,

  				// Text to html (true = no transformation)
  				"text html": true,

  				// Evaluate text as a json expression
  				"text json": JSON.parse,

  				// Parse text as xml
  				"text xml": jQuery.parseXML
  			},

  			// For options that shouldn't be deep extended:
  			// you can add your own custom options here if
  			// and when you create one that shouldn't be
  			// deep extended (see ajaxExtend)
  			flatOptions: {
  				url: true,
  				context: true
  			}
  		},

  		// Creates a full fledged settings object into target
  		// with both ajaxSettings and settings fields.
  		// If target is omitted, writes into ajaxSettings.
  		ajaxSetup: function( target, settings ) {
  			return settings ?

  				// Building a settings object
  				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

  				// Extending ajaxSettings
  				ajaxExtend( jQuery.ajaxSettings, target );
  		},

  		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  		ajaxTransport: addToPrefiltersOrTransports( transports ),

  		// Main method
  		ajax: function( url, options ) {

  			// If url is an object, simulate pre-1.5 signature
  			if ( typeof url === "object" ) {
  				options = url;
  				url = undefined;
  			}

  			// Force options to be an object
  			options = options || {};

  			var transport,

  				// URL without anti-cache param
  				cacheURL,

  				// Response headers
  				responseHeadersString,
  				responseHeaders,

  				// timeout handle
  				timeoutTimer,

  				// Url cleanup var
  				urlAnchor,

  				// Request state (becomes false upon send and true upon completion)
  				completed,

  				// To know if global events are to be dispatched
  				fireGlobals,

  				// Loop variable
  				i,

  				// uncached part of the url
  				uncached,

  				// Create the final options object
  				s = jQuery.ajaxSetup( {}, options ),

  				// Callbacks context
  				callbackContext = s.context || s,

  				// Context for global events is callbackContext if it is a DOM node or jQuery collection
  				globalEventContext = s.context &&
  					( callbackContext.nodeType || callbackContext.jquery ) ?
  					jQuery( callbackContext ) :
  					jQuery.event,

  				// Deferreds
  				deferred = jQuery.Deferred(),
  				completeDeferred = jQuery.Callbacks( "once memory" ),

  				// Status-dependent callbacks
  				statusCode = s.statusCode || {},

  				// Headers (they are sent all at once)
  				requestHeaders = {},
  				requestHeadersNames = {},

  				// Default abort message
  				strAbort = "canceled",

  				// Fake xhr
  				jqXHR = {
  					readyState: 0,

  					// Builds headers hashtable if needed
  					getResponseHeader: function( key ) {
  						var match;
  						if ( completed ) {
  							if ( !responseHeaders ) {
  								responseHeaders = {};
  								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
  									responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
  										( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
  											.concat( match[ 2 ] );
  								}
  							}
  							match = responseHeaders[ key.toLowerCase() + " " ];
  						}
  						return match == null ? null : match.join( ", " );
  					},

  					// Raw string
  					getAllResponseHeaders: function() {
  						return completed ? responseHeadersString : null;
  					},

  					// Caches the header
  					setRequestHeader: function( name, value ) {
  						if ( completed == null ) {
  							name = requestHeadersNames[ name.toLowerCase() ] =
  								requestHeadersNames[ name.toLowerCase() ] || name;
  							requestHeaders[ name ] = value;
  						}
  						return this;
  					},

  					// Overrides response content-type header
  					overrideMimeType: function( type ) {
  						if ( completed == null ) {
  							s.mimeType = type;
  						}
  						return this;
  					},

  					// Status-dependent callbacks
  					statusCode: function( map ) {
  						var code;
  						if ( map ) {
  							if ( completed ) {

  								// Execute the appropriate callbacks
  								jqXHR.always( map[ jqXHR.status ] );
  							} else {

  								// Lazy-add the new callbacks in a way that preserves old ones
  								for ( code in map ) {
  									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
  								}
  							}
  						}
  						return this;
  					},

  					// Cancel the request
  					abort: function( statusText ) {
  						var finalText = statusText || strAbort;
  						if ( transport ) {
  							transport.abort( finalText );
  						}
  						done( 0, finalText );
  						return this;
  					}
  				};

  			// Attach deferreds
  			deferred.promise( jqXHR );

  			// Add protocol if not provided (prefilters might expect it)
  			// Handle falsy url in the settings object (trac-10093: consistency with old signature)
  			// We also use the url parameter if available
  			s.url = ( ( url || s.url || location.href ) + "" )
  				.replace( rprotocol, location.protocol + "//" );

  			// Alias method option to type as per ticket trac-12004
  			s.type = options.method || options.type || s.method || s.type;

  			// Extract dataTypes list
  			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

  			// A cross-domain request is in order when the origin doesn't match the current origin.
  			if ( s.crossDomain == null ) {
  				urlAnchor = document.createElement( "a" );

  				// Support: IE <=8 - 11, Edge 12 - 15
  				// IE throws exception on accessing the href property if url is malformed,
  				// e.g. http://example.com:80x/
  				try {
  					urlAnchor.href = s.url;

  					// Support: IE <=8 - 11 only
  					// Anchor's host property isn't correctly set when s.url is relative
  					urlAnchor.href = urlAnchor.href;
  					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
  						urlAnchor.protocol + "//" + urlAnchor.host;
  				} catch ( e ) {

  					// If there is an error parsing the URL, assume it is crossDomain,
  					// it can be rejected by the transport if it is invalid
  					s.crossDomain = true;
  				}
  			}

  			// Convert data if not already a string
  			if ( s.data && s.processData && typeof s.data !== "string" ) {
  				s.data = jQuery.param( s.data, s.traditional );
  			}

  			// Apply prefilters
  			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

  			// If request was aborted inside a prefilter, stop there
  			if ( completed ) {
  				return jqXHR;
  			}

  			// We can fire global events as of now if asked to
  			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
  			fireGlobals = jQuery.event && s.global;

  			// Watch for a new set of requests
  			if ( fireGlobals && jQuery.active++ === 0 ) {
  				jQuery.event.trigger( "ajaxStart" );
  			}

  			// Uppercase the type
  			s.type = s.type.toUpperCase();

  			// Determine if request has content
  			s.hasContent = !rnoContent.test( s.type );

  			// Save the URL in case we're toying with the If-Modified-Since
  			// and/or If-None-Match header later on
  			// Remove hash to simplify url manipulation
  			cacheURL = s.url.replace( rhash, "" );

  			// More options handling for requests with no content
  			if ( !s.hasContent ) {

  				// Remember the hash so we can put it back
  				uncached = s.url.slice( cacheURL.length );

  				// If data is available and should be processed, append data to url
  				if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
  					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

  					// trac-9682: remove data so that it's not used in an eventual retry
  					delete s.data;
  				}

  				// Add or update anti-cache param if needed
  				if ( s.cache === false ) {
  					cacheURL = cacheURL.replace( rantiCache, "$1" );
  					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
  						uncached;
  				}

  				// Put hash and anti-cache on the URL that will be requested (gh-1732)
  				s.url = cacheURL + uncached;

  			// Change '%20' to '+' if this is encoded form body content (gh-2658)
  			} else if ( s.data && s.processData &&
  				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
  				s.data = s.data.replace( r20, "+" );
  			}

  			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  			if ( s.ifModified ) {
  				if ( jQuery.lastModified[ cacheURL ] ) {
  					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
  				}
  				if ( jQuery.etag[ cacheURL ] ) {
  					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
  				}
  			}

  			// Set the correct header, if data is being sent
  			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
  				jqXHR.setRequestHeader( "Content-Type", s.contentType );
  			}

  			// Set the Accepts header for the server, depending on the dataType
  			jqXHR.setRequestHeader(
  				"Accept",
  				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
  					s.accepts[ s.dataTypes[ 0 ] ] +
  						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
  					s.accepts[ "*" ]
  			);

  			// Check for headers option
  			for ( i in s.headers ) {
  				jqXHR.setRequestHeader( i, s.headers[ i ] );
  			}

  			// Allow custom headers/mimetypes and early abort
  			if ( s.beforeSend &&
  				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

  				// Abort if not done already and return
  				return jqXHR.abort();
  			}

  			// Aborting is no longer a cancellation
  			strAbort = "abort";

  			// Install callbacks on deferreds
  			completeDeferred.add( s.complete );
  			jqXHR.done( s.success );
  			jqXHR.fail( s.error );

  			// Get transport
  			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

  			// If no transport, we auto-abort
  			if ( !transport ) {
  				done( -1, "No Transport" );
  			} else {
  				jqXHR.readyState = 1;

  				// Send global event
  				if ( fireGlobals ) {
  					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
  				}

  				// If request was aborted inside ajaxSend, stop there
  				if ( completed ) {
  					return jqXHR;
  				}

  				// Timeout
  				if ( s.async && s.timeout > 0 ) {
  					timeoutTimer = window.setTimeout( function() {
  						jqXHR.abort( "timeout" );
  					}, s.timeout );
  				}

  				try {
  					completed = false;
  					transport.send( requestHeaders, done );
  				} catch ( e ) {

  					// Rethrow post-completion exceptions
  					if ( completed ) {
  						throw e;
  					}

  					// Propagate others as results
  					done( -1, e );
  				}
  			}

  			// Callback for when everything is done
  			function done( status, nativeStatusText, responses, headers ) {
  				var isSuccess, success, error, response, modified,
  					statusText = nativeStatusText;

  				// Ignore repeat invocations
  				if ( completed ) {
  					return;
  				}

  				completed = true;

  				// Clear timeout if it exists
  				if ( timeoutTimer ) {
  					window.clearTimeout( timeoutTimer );
  				}

  				// Dereference transport for early garbage collection
  				// (no matter how long the jqXHR object will be used)
  				transport = undefined;

  				// Cache response headers
  				responseHeadersString = headers || "";

  				// Set readyState
  				jqXHR.readyState = status > 0 ? 4 : 0;

  				// Determine if successful
  				isSuccess = status >= 200 && status < 300 || status === 304;

  				// Get response data
  				if ( responses ) {
  					response = ajaxHandleResponses( s, jqXHR, responses );
  				}

  				// Use a noop converter for missing script but not if jsonp
  				if ( !isSuccess &&
  					jQuery.inArray( "script", s.dataTypes ) > -1 &&
  					jQuery.inArray( "json", s.dataTypes ) < 0 ) {
  					s.converters[ "text script" ] = function() {};
  				}

  				// Convert no matter what (that way responseXXX fields are always set)
  				response = ajaxConvert( s, response, jqXHR, isSuccess );

  				// If successful, handle type chaining
  				if ( isSuccess ) {

  					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  					if ( s.ifModified ) {
  						modified = jqXHR.getResponseHeader( "Last-Modified" );
  						if ( modified ) {
  							jQuery.lastModified[ cacheURL ] = modified;
  						}
  						modified = jqXHR.getResponseHeader( "etag" );
  						if ( modified ) {
  							jQuery.etag[ cacheURL ] = modified;
  						}
  					}

  					// if no content
  					if ( status === 204 || s.type === "HEAD" ) {
  						statusText = "nocontent";

  					// if not modified
  					} else if ( status === 304 ) {
  						statusText = "notmodified";

  					// If we have data, let's convert it
  					} else {
  						statusText = response.state;
  						success = response.data;
  						error = response.error;
  						isSuccess = !error;
  					}
  				} else {

  					// Extract error from statusText and normalize for non-aborts
  					error = statusText;
  					if ( status || !statusText ) {
  						statusText = "error";
  						if ( status < 0 ) {
  							status = 0;
  						}
  					}
  				}

  				// Set data for the fake xhr object
  				jqXHR.status = status;
  				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

  				// Success/Error
  				if ( isSuccess ) {
  					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
  				} else {
  					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
  				}

  				// Status-dependent callbacks
  				jqXHR.statusCode( statusCode );
  				statusCode = undefined;

  				if ( fireGlobals ) {
  					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
  						[ jqXHR, s, isSuccess ? success : error ] );
  				}

  				// Complete
  				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

  				if ( fireGlobals ) {
  					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

  					// Handle the global AJAX counter
  					if ( !( --jQuery.active ) ) {
  						jQuery.event.trigger( "ajaxStop" );
  					}
  				}
  			}

  			return jqXHR;
  		},

  		getJSON: function( url, data, callback ) {
  			return jQuery.get( url, data, callback, "json" );
  		},

  		getScript: function( url, callback ) {
  			return jQuery.get( url, undefined, callback, "script" );
  		}
  	} );

  	jQuery.each( [ "get", "post" ], function( _i, method ) {
  		jQuery[ method ] = function( url, data, callback, type ) {

  			// Shift arguments if data argument was omitted
  			if ( isFunction( data ) ) {
  				type = type || callback;
  				callback = data;
  				data = undefined;
  			}

  			// The url can be an options object (which then must have .url)
  			return jQuery.ajax( jQuery.extend( {
  				url: url,
  				type: method,
  				dataType: type,
  				data: data,
  				success: callback
  			}, jQuery.isPlainObject( url ) && url ) );
  		};
  	} );

  	jQuery.ajaxPrefilter( function( s ) {
  		var i;
  		for ( i in s.headers ) {
  			if ( i.toLowerCase() === "content-type" ) {
  				s.contentType = s.headers[ i ] || "";
  			}
  		}
  	} );


  	jQuery._evalUrl = function( url, options, doc ) {
  		return jQuery.ajax( {
  			url: url,

  			// Make this explicit, since user can override this through ajaxSetup (trac-11264)
  			type: "GET",
  			dataType: "script",
  			cache: true,
  			async: false,
  			global: false,

  			// Only evaluate the response if it is successful (gh-4126)
  			// dataFilter is not invoked for failure responses, so using it instead
  			// of the default converter is kludgy but it works.
  			converters: {
  				"text script": function() {}
  			},
  			dataFilter: function( response ) {
  				jQuery.globalEval( response, options, doc );
  			}
  		} );
  	};


  	jQuery.fn.extend( {
  		wrapAll: function( html ) {
  			var wrap;

  			if ( this[ 0 ] ) {
  				if ( isFunction( html ) ) {
  					html = html.call( this[ 0 ] );
  				}

  				// The elements to wrap the target around
  				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

  				if ( this[ 0 ].parentNode ) {
  					wrap.insertBefore( this[ 0 ] );
  				}

  				wrap.map( function() {
  					var elem = this;

  					while ( elem.firstElementChild ) {
  						elem = elem.firstElementChild;
  					}

  					return elem;
  				} ).append( this );
  			}

  			return this;
  		},

  		wrapInner: function( html ) {
  			if ( isFunction( html ) ) {
  				return this.each( function( i ) {
  					jQuery( this ).wrapInner( html.call( this, i ) );
  				} );
  			}

  			return this.each( function() {
  				var self = jQuery( this ),
  					contents = self.contents();

  				if ( contents.length ) {
  					contents.wrapAll( html );

  				} else {
  					self.append( html );
  				}
  			} );
  		},

  		wrap: function( html ) {
  			var htmlIsFunction = isFunction( html );

  			return this.each( function( i ) {
  				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
  			} );
  		},

  		unwrap: function( selector ) {
  			this.parent( selector ).not( "body" ).each( function() {
  				jQuery( this ).replaceWith( this.childNodes );
  			} );
  			return this;
  		}
  	} );


  	jQuery.expr.pseudos.hidden = function( elem ) {
  		return !jQuery.expr.pseudos.visible( elem );
  	};
  	jQuery.expr.pseudos.visible = function( elem ) {
  		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
  	};




  	jQuery.ajaxSettings.xhr = function() {
  		try {
  			return new window.XMLHttpRequest();
  		} catch ( e ) {}
  	};

  	var xhrSuccessStatus = {

  			// File protocol always yields status code 0, assume 200
  			0: 200,

  			// Support: IE <=9 only
  			// trac-1450: sometimes IE returns 1223 when it should be 204
  			1223: 204
  		},
  		xhrSupported = jQuery.ajaxSettings.xhr();

  	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
  	support.ajax = xhrSupported = !!xhrSupported;

  	jQuery.ajaxTransport( function( options ) {
  		var callback, errorCallback;

  		// Cross domain only allowed if supported through XMLHttpRequest
  		if ( support.cors || xhrSupported && !options.crossDomain ) {
  			return {
  				send: function( headers, complete ) {
  					var i,
  						xhr = options.xhr();

  					xhr.open(
  						options.type,
  						options.url,
  						options.async,
  						options.username,
  						options.password
  					);

  					// Apply custom fields if provided
  					if ( options.xhrFields ) {
  						for ( i in options.xhrFields ) {
  							xhr[ i ] = options.xhrFields[ i ];
  						}
  					}

  					// Override mime type if needed
  					if ( options.mimeType && xhr.overrideMimeType ) {
  						xhr.overrideMimeType( options.mimeType );
  					}

  					// X-Requested-With header
  					// For cross-domain requests, seeing as conditions for a preflight are
  					// akin to a jigsaw puzzle, we simply never set it to be sure.
  					// (it can always be set on a per-request basis or even using ajaxSetup)
  					// For same-domain requests, won't change header if already provided.
  					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
  						headers[ "X-Requested-With" ] = "XMLHttpRequest";
  					}

  					// Set headers
  					for ( i in headers ) {
  						xhr.setRequestHeader( i, headers[ i ] );
  					}

  					// Callback
  					callback = function( type ) {
  						return function() {
  							if ( callback ) {
  								callback = errorCallback = xhr.onload =
  									xhr.onerror = xhr.onabort = xhr.ontimeout =
  										xhr.onreadystatechange = null;

  								if ( type === "abort" ) {
  									xhr.abort();
  								} else if ( type === "error" ) {

  									// Support: IE <=9 only
  									// On a manual native abort, IE9 throws
  									// errors on any property access that is not readyState
  									if ( typeof xhr.status !== "number" ) {
  										complete( 0, "error" );
  									} else {
  										complete(

  											// File: protocol always yields status 0; see trac-8605, trac-14207
  											xhr.status,
  											xhr.statusText
  										);
  									}
  								} else {
  									complete(
  										xhrSuccessStatus[ xhr.status ] || xhr.status,
  										xhr.statusText,

  										// Support: IE <=9 only
  										// IE9 has no XHR2 but throws on binary (trac-11426)
  										// For XHR2 non-text, let the caller handle it (gh-2498)
  										( xhr.responseType || "text" ) !== "text"  ||
  										typeof xhr.responseText !== "string" ?
  											{ binary: xhr.response } :
  											{ text: xhr.responseText },
  										xhr.getAllResponseHeaders()
  									);
  								}
  							}
  						};
  					};

  					// Listen to events
  					xhr.onload = callback();
  					errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

  					// Support: IE 9 only
  					// Use onreadystatechange to replace onabort
  					// to handle uncaught aborts
  					if ( xhr.onabort !== undefined ) {
  						xhr.onabort = errorCallback;
  					} else {
  						xhr.onreadystatechange = function() {

  							// Check readyState before timeout as it changes
  							if ( xhr.readyState === 4 ) {

  								// Allow onerror to be called first,
  								// but that will not handle a native abort
  								// Also, save errorCallback to a variable
  								// as xhr.onerror cannot be accessed
  								window.setTimeout( function() {
  									if ( callback ) {
  										errorCallback();
  									}
  								} );
  							}
  						};
  					}

  					// Create the abort callback
  					callback = callback( "abort" );

  					try {

  						// Do send the request (this may raise an exception)
  						xhr.send( options.hasContent && options.data || null );
  					} catch ( e ) {

  						// trac-14683: Only rethrow if this hasn't been notified as an error yet
  						if ( callback ) {
  							throw e;
  						}
  					}
  				},

  				abort: function() {
  					if ( callback ) {
  						callback();
  					}
  				}
  			};
  		}
  	} );




  	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
  	jQuery.ajaxPrefilter( function( s ) {
  		if ( s.crossDomain ) {
  			s.contents.script = false;
  		}
  	} );

  	// Install script dataType
  	jQuery.ajaxSetup( {
  		accepts: {
  			script: "text/javascript, application/javascript, " +
  				"application/ecmascript, application/x-ecmascript"
  		},
  		contents: {
  			script: /\b(?:java|ecma)script\b/
  		},
  		converters: {
  			"text script": function( text ) {
  				jQuery.globalEval( text );
  				return text;
  			}
  		}
  	} );

  	// Handle cache's special case and crossDomain
  	jQuery.ajaxPrefilter( "script", function( s ) {
  		if ( s.cache === undefined ) {
  			s.cache = false;
  		}
  		if ( s.crossDomain ) {
  			s.type = "GET";
  		}
  	} );

  	// Bind script tag hack transport
  	jQuery.ajaxTransport( "script", function( s ) {

  		// This transport only deals with cross domain or forced-by-attrs requests
  		if ( s.crossDomain || s.scriptAttrs ) {
  			var script, callback;
  			return {
  				send: function( _, complete ) {
  					script = jQuery( "<script>" )
  						.attr( s.scriptAttrs || {} )
  						.prop( { charset: s.scriptCharset, src: s.url } )
  						.on( "load error", callback = function( evt ) {
  							script.remove();
  							callback = null;
  							if ( evt ) {
  								complete( evt.type === "error" ? 404 : 200, evt.type );
  							}
  						} );

  					// Use native DOM manipulation to avoid our domManip AJAX trickery
  					document.head.appendChild( script[ 0 ] );
  				},
  				abort: function() {
  					if ( callback ) {
  						callback();
  					}
  				}
  			};
  		}
  	} );




  	var oldCallbacks = [],
  		rjsonp = /(=)\?(?=&|$)|\?\?/;

  	// Default jsonp settings
  	jQuery.ajaxSetup( {
  		jsonp: "callback",
  		jsonpCallback: function() {
  			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
  			this[ callback ] = true;
  			return callback;
  		}
  	} );

  	// Detect, normalize options and install callbacks for jsonp requests
  	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  		var callbackName, overwritten, responseContainer,
  			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
  				"url" :
  				typeof s.data === "string" &&
  					( s.contentType || "" )
  						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
  					rjsonp.test( s.data ) && "data"
  			);

  		// Handle iff the expected data type is "jsonp" or we have a parameter to set
  		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

  			// Get callback name, remembering preexisting value associated with it
  			callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
  				s.jsonpCallback() :
  				s.jsonpCallback;

  			// Insert callback into url or form data
  			if ( jsonProp ) {
  				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
  			} else if ( s.jsonp !== false ) {
  				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
  			}

  			// Use data converter to retrieve json after script execution
  			s.converters[ "script json" ] = function() {
  				if ( !responseContainer ) {
  					jQuery.error( callbackName + " was not called" );
  				}
  				return responseContainer[ 0 ];
  			};

  			// Force json dataType
  			s.dataTypes[ 0 ] = "json";

  			// Install callback
  			overwritten = window[ callbackName ];
  			window[ callbackName ] = function() {
  				responseContainer = arguments;
  			};

  			// Clean-up function (fires after converters)
  			jqXHR.always( function() {

  				// If previous value didn't exist - remove it
  				if ( overwritten === undefined ) {
  					jQuery( window ).removeProp( callbackName );

  				// Otherwise restore preexisting value
  				} else {
  					window[ callbackName ] = overwritten;
  				}

  				// Save back as free
  				if ( s[ callbackName ] ) {

  					// Make sure that re-using the options doesn't screw things around
  					s.jsonpCallback = originalSettings.jsonpCallback;

  					// Save the callback name for future use
  					oldCallbacks.push( callbackName );
  				}

  				// Call if it was a function and we have a response
  				if ( responseContainer && isFunction( overwritten ) ) {
  					overwritten( responseContainer[ 0 ] );
  				}

  				responseContainer = overwritten = undefined;
  			} );

  			// Delegate to script
  			return "script";
  		}
  	} );




  	// Support: Safari 8 only
  	// In Safari 8 documents created via document.implementation.createHTMLDocument
  	// collapse sibling forms: the second one becomes a child of the first one.
  	// Because of that, this security measure has to be disabled in Safari 8.
  	// https://bugs.webkit.org/show_bug.cgi?id=137337
  	support.createHTMLDocument = ( function() {
  		var body = document.implementation.createHTMLDocument( "" ).body;
  		body.innerHTML = "<form></form><form></form>";
  		return body.childNodes.length === 2;
  	} )();


  	// Argument "data" should be string of html
  	// context (optional): If specified, the fragment will be created in this context,
  	// defaults to document
  	// keepScripts (optional): If true, will include scripts passed in the html string
  	jQuery.parseHTML = function( data, context, keepScripts ) {
  		if ( typeof data !== "string" ) {
  			return [];
  		}
  		if ( typeof context === "boolean" ) {
  			keepScripts = context;
  			context = false;
  		}

  		var base, parsed, scripts;

  		if ( !context ) {

  			// Stop scripts or inline event handlers from being executed immediately
  			// by using document.implementation
  			if ( support.createHTMLDocument ) {
  				context = document.implementation.createHTMLDocument( "" );

  				// Set the base href for the created document
  				// so any parsed elements with URLs
  				// are based on the document's URL (gh-2965)
  				base = context.createElement( "base" );
  				base.href = document.location.href;
  				context.head.appendChild( base );
  			} else {
  				context = document;
  			}
  		}

  		parsed = rsingleTag.exec( data );
  		scripts = !keepScripts && [];

  		// Single tag
  		if ( parsed ) {
  			return [ context.createElement( parsed[ 1 ] ) ];
  		}

  		parsed = buildFragment( [ data ], context, scripts );

  		if ( scripts && scripts.length ) {
  			jQuery( scripts ).remove();
  		}

  		return jQuery.merge( [], parsed.childNodes );
  	};


  	/**
  	 * Load a url into a page
  	 */
  	jQuery.fn.load = function( url, params, callback ) {
  		var selector, type, response,
  			self = this,
  			off = url.indexOf( " " );

  		if ( off > -1 ) {
  			selector = stripAndCollapse( url.slice( off ) );
  			url = url.slice( 0, off );
  		}

  		// If it's a function
  		if ( isFunction( params ) ) {

  			// We assume that it's the callback
  			callback = params;
  			params = undefined;

  		// Otherwise, build a param string
  		} else if ( params && typeof params === "object" ) {
  			type = "POST";
  		}

  		// If we have elements to modify, make the request
  		if ( self.length > 0 ) {
  			jQuery.ajax( {
  				url: url,

  				// If "type" variable is undefined, then "GET" method will be used.
  				// Make value of this field explicit since
  				// user can override it through ajaxSetup method
  				type: type || "GET",
  				dataType: "html",
  				data: params
  			} ).done( function( responseText ) {

  				// Save response for use in complete callback
  				response = arguments;

  				self.html( selector ?

  					// If a selector was specified, locate the right elements in a dummy div
  					// Exclude scripts to avoid IE 'Permission Denied' errors
  					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

  					// Otherwise use the full result
  					responseText );

  			// If the request succeeds, this function gets "data", "status", "jqXHR"
  			// but they are ignored because response was set above.
  			// If it fails, this function gets "jqXHR", "status", "error"
  			} ).always( callback && function( jqXHR, status ) {
  				self.each( function() {
  					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
  				} );
  			} );
  		}

  		return this;
  	};




  	jQuery.expr.pseudos.animated = function( elem ) {
  		return jQuery.grep( jQuery.timers, function( fn ) {
  			return elem === fn.elem;
  		} ).length;
  	};




  	jQuery.offset = {
  		setOffset: function( elem, options, i ) {
  			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
  				position = jQuery.css( elem, "position" ),
  				curElem = jQuery( elem ),
  				props = {};

  			// Set position first, in-case top/left are set even on static elem
  			if ( position === "static" ) {
  				elem.style.position = "relative";
  			}

  			curOffset = curElem.offset();
  			curCSSTop = jQuery.css( elem, "top" );
  			curCSSLeft = jQuery.css( elem, "left" );
  			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
  				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

  			// Need to be able to calculate position if either
  			// top or left is auto and position is either absolute or fixed
  			if ( calculatePosition ) {
  				curPosition = curElem.position();
  				curTop = curPosition.top;
  				curLeft = curPosition.left;

  			} else {
  				curTop = parseFloat( curCSSTop ) || 0;
  				curLeft = parseFloat( curCSSLeft ) || 0;
  			}

  			if ( isFunction( options ) ) {

  				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
  				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
  			}

  			if ( options.top != null ) {
  				props.top = ( options.top - curOffset.top ) + curTop;
  			}
  			if ( options.left != null ) {
  				props.left = ( options.left - curOffset.left ) + curLeft;
  			}

  			if ( "using" in options ) {
  				options.using.call( elem, props );

  			} else {
  				curElem.css( props );
  			}
  		}
  	};

  	jQuery.fn.extend( {

  		// offset() relates an element's border box to the document origin
  		offset: function( options ) {

  			// Preserve chaining for setter
  			if ( arguments.length ) {
  				return options === undefined ?
  					this :
  					this.each( function( i ) {
  						jQuery.offset.setOffset( this, options, i );
  					} );
  			}

  			var rect, win,
  				elem = this[ 0 ];

  			if ( !elem ) {
  				return;
  			}

  			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
  			// Support: IE <=11 only
  			// Running getBoundingClientRect on a
  			// disconnected node in IE throws an error
  			if ( !elem.getClientRects().length ) {
  				return { top: 0, left: 0 };
  			}

  			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
  			rect = elem.getBoundingClientRect();
  			win = elem.ownerDocument.defaultView;
  			return {
  				top: rect.top + win.pageYOffset,
  				left: rect.left + win.pageXOffset
  			};
  		},

  		// position() relates an element's margin box to its offset parent's padding box
  		// This corresponds to the behavior of CSS absolute positioning
  		position: function() {
  			if ( !this[ 0 ] ) {
  				return;
  			}

  			var offsetParent, offset, doc,
  				elem = this[ 0 ],
  				parentOffset = { top: 0, left: 0 };

  			// position:fixed elements are offset from the viewport, which itself always has zero offset
  			if ( jQuery.css( elem, "position" ) === "fixed" ) {

  				// Assume position:fixed implies availability of getBoundingClientRect
  				offset = elem.getBoundingClientRect();

  			} else {
  				offset = this.offset();

  				// Account for the *real* offset parent, which can be the document or its root element
  				// when a statically positioned element is identified
  				doc = elem.ownerDocument;
  				offsetParent = elem.offsetParent || doc.documentElement;
  				while ( offsetParent &&
  					( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
  					jQuery.css( offsetParent, "position" ) === "static" ) {

  					offsetParent = offsetParent.parentNode;
  				}
  				if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

  					// Incorporate borders into its offset, since they are outside its content origin
  					parentOffset = jQuery( offsetParent ).offset();
  					parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
  					parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
  				}
  			}

  			// Subtract parent offsets and element margins
  			return {
  				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
  				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
  			};
  		},

  		// This method will return documentElement in the following cases:
  		// 1) For the element inside the iframe without offsetParent, this method will return
  		//    documentElement of the parent window
  		// 2) For the hidden or detached element
  		// 3) For body or html element, i.e. in case of the html node - it will return itself
  		//
  		// but those exceptions were never presented as a real life use-cases
  		// and might be considered as more preferable results.
  		//
  		// This logic, however, is not guaranteed and can change at any point in the future
  		offsetParent: function() {
  			return this.map( function() {
  				var offsetParent = this.offsetParent;

  				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
  					offsetParent = offsetParent.offsetParent;
  				}

  				return offsetParent || documentElement;
  			} );
  		}
  	} );

  	// Create scrollLeft and scrollTop methods
  	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
  		var top = "pageYOffset" === prop;

  		jQuery.fn[ method ] = function( val ) {
  			return access( this, function( elem, method, val ) {

  				// Coalesce documents and windows
  				var win;
  				if ( isWindow( elem ) ) {
  					win = elem;
  				} else if ( elem.nodeType === 9 ) {
  					win = elem.defaultView;
  				}

  				if ( val === undefined ) {
  					return win ? win[ prop ] : elem[ method ];
  				}

  				if ( win ) {
  					win.scrollTo(
  						!top ? val : win.pageXOffset,
  						top ? val : win.pageYOffset
  					);

  				} else {
  					elem[ method ] = val;
  				}
  			}, method, val, arguments.length );
  		};
  	} );

  	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
  	// Add the top/left cssHooks using jQuery.fn.position
  	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  	// getComputedStyle returns percent when specified for top/left/bottom/right;
  	// rather than make the css module depend on the offset module, just check for it here
  	jQuery.each( [ "top", "left" ], function( _i, prop ) {
  		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
  			function( elem, computed ) {
  				if ( computed ) {
  					computed = curCSS( elem, prop );

  					// If curCSS returns percentage, fallback to offset
  					return rnumnonpx.test( computed ) ?
  						jQuery( elem ).position()[ prop ] + "px" :
  						computed;
  				}
  			}
  		);
  	} );


  	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  		jQuery.each( {
  			padding: "inner" + name,
  			content: type,
  			"": "outer" + name
  		}, function( defaultExtra, funcName ) {

  			// Margin is only for outerHeight, outerWidth
  			jQuery.fn[ funcName ] = function( margin, value ) {
  				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
  					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

  				return access( this, function( elem, type, value ) {
  					var doc;

  					if ( isWindow( elem ) ) {

  						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
  						return funcName.indexOf( "outer" ) === 0 ?
  							elem[ "inner" + name ] :
  							elem.document.documentElement[ "client" + name ];
  					}

  					// Get document width or height
  					if ( elem.nodeType === 9 ) {
  						doc = elem.documentElement;

  						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
  						// whichever is greatest
  						return Math.max(
  							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
  							elem.body[ "offset" + name ], doc[ "offset" + name ],
  							doc[ "client" + name ]
  						);
  					}

  					return value === undefined ?

  						// Get width or height on the element, requesting but not forcing parseFloat
  						jQuery.css( elem, type, extra ) :

  						// Set width or height on the element
  						jQuery.style( elem, type, value, extra );
  				}, type, chainable ? margin : undefined, chainable );
  			};
  		} );
  	} );


  	jQuery.each( [
  		"ajaxStart",
  		"ajaxStop",
  		"ajaxComplete",
  		"ajaxError",
  		"ajaxSuccess",
  		"ajaxSend"
  	], function( _i, type ) {
  		jQuery.fn[ type ] = function( fn ) {
  			return this.on( type, fn );
  		};
  	} );




  	jQuery.fn.extend( {

  		bind: function( types, data, fn ) {
  			return this.on( types, null, data, fn );
  		},
  		unbind: function( types, fn ) {
  			return this.off( types, null, fn );
  		},

  		delegate: function( selector, types, data, fn ) {
  			return this.on( types, selector, data, fn );
  		},
  		undelegate: function( selector, types, fn ) {

  			// ( namespace ) or ( selector, types [, fn] )
  			return arguments.length === 1 ?
  				this.off( selector, "**" ) :
  				this.off( types, selector || "**", fn );
  		},

  		hover: function( fnOver, fnOut ) {
  			return this
  				.on( "mouseenter", fnOver )
  				.on( "mouseleave", fnOut || fnOver );
  		}
  	} );

  	jQuery.each(
  		( "blur focus focusin focusout resize scroll click dblclick " +
  		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
  		function( _i, name ) {

  			// Handle event binding
  			jQuery.fn[ name ] = function( data, fn ) {
  				return arguments.length > 0 ?
  					this.on( name, null, data, fn ) :
  					this.trigger( name );
  			};
  		}
  	);




  	// Support: Android <=4.0 only
  	// Make sure we trim BOM and NBSP
  	// Require that the "whitespace run" starts from a non-whitespace
  	// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
  	var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

  	// Bind a function to a context, optionally partially applying any
  	// arguments.
  	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  	// However, it is not slated for removal any time soon
  	jQuery.proxy = function( fn, context ) {
  		var tmp, args, proxy;

  		if ( typeof context === "string" ) {
  			tmp = fn[ context ];
  			context = fn;
  			fn = tmp;
  		}

  		// Quick check to determine if target is callable, in the spec
  		// this throws a TypeError, but we will just return undefined.
  		if ( !isFunction( fn ) ) {
  			return undefined;
  		}

  		// Simulated bind
  		args = slice.call( arguments, 2 );
  		proxy = function() {
  			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
  		};

  		// Set the guid of unique handler to the same of original handler, so it can be removed
  		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

  		return proxy;
  	};

  	jQuery.holdReady = function( hold ) {
  		if ( hold ) {
  			jQuery.readyWait++;
  		} else {
  			jQuery.ready( true );
  		}
  	};
  	jQuery.isArray = Array.isArray;
  	jQuery.parseJSON = JSON.parse;
  	jQuery.nodeName = nodeName;
  	jQuery.isFunction = isFunction;
  	jQuery.isWindow = isWindow;
  	jQuery.camelCase = camelCase;
  	jQuery.type = toType;

  	jQuery.now = Date.now;

  	jQuery.isNumeric = function( obj ) {

  		// As of jQuery 3.0, isNumeric is limited to
  		// strings and numbers (primitives or objects)
  		// that can be coerced to finite numbers (gh-2662)
  		var type = jQuery.type( obj );
  		return ( type === "number" || type === "string" ) &&

  			// parseFloat NaNs numeric-cast false positives ("")
  			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
  			// subtraction forces infinities to NaN
  			!isNaN( obj - parseFloat( obj ) );
  	};

  	jQuery.trim = function( text ) {
  		return text == null ?
  			"" :
  			( text + "" ).replace( rtrim, "$1" );
  	};




  	var

  		// Map over jQuery in case of overwrite
  		_jQuery = window.jQuery,

  		// Map over the $ in case of overwrite
  		_$ = window.$;

  	jQuery.noConflict = function( deep ) {
  		if ( window.$ === jQuery ) {
  			window.$ = _$;
  		}

  		if ( deep && window.jQuery === jQuery ) {
  			window.jQuery = _jQuery;
  		}

  		return jQuery;
  	};

  	// Expose jQuery and $ identifiers, even in AMD
  	// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
  	// and CommonJS for browser emulators (trac-13566)
  	if ( typeof noGlobal === "undefined" ) {
  		window.jQuery = window.$ = jQuery;
  	}




  	return jQuery;
  	} ); 
  } (jquery$1));

  var jqueryExports = jquery$1.exports;
  var jquery = /*@__PURE__*/getDefaultExportFromCjs$1(jqueryExports);

  window.jQuery = window.$ = jquery;

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var urlToolkit = {exports: {}};

  (function (module, exports) {
  	// see https://tools.ietf.org/html/rfc1808

  	(function (root) {
  	  var URL_REGEX =
  	    /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
  	  var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
  	  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  	  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;

  	  var URLToolkit = {
  	    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
  	    // E.g
  	    // With opts.alwaysNormalize = false (default, spec compliant)
  	    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
  	    // With opts.alwaysNormalize = true (not spec compliant)
  	    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
  	    buildAbsoluteURL: function (baseURL, relativeURL, opts) {
  	      opts = opts || {};
  	      // remove any remaining space and CRLF
  	      baseURL = baseURL.trim();
  	      relativeURL = relativeURL.trim();
  	      if (!relativeURL) {
  	        // 2a) If the embedded URL is entirely empty, it inherits the
  	        // entire base URL (i.e., is set equal to the base URL)
  	        // and we are done.
  	        if (!opts.alwaysNormalize) {
  	          return baseURL;
  	        }
  	        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
  	        if (!basePartsForNormalise) {
  	          throw new Error('Error trying to parse base URL.');
  	        }
  	        basePartsForNormalise.path = URLToolkit.normalizePath(
  	          basePartsForNormalise.path
  	        );
  	        return URLToolkit.buildURLFromParts(basePartsForNormalise);
  	      }
  	      var relativeParts = URLToolkit.parseURL(relativeURL);
  	      if (!relativeParts) {
  	        throw new Error('Error trying to parse relative URL.');
  	      }
  	      if (relativeParts.scheme) {
  	        // 2b) If the embedded URL starts with a scheme name, it is
  	        // interpreted as an absolute URL and we are done.
  	        if (!opts.alwaysNormalize) {
  	          return relativeURL;
  	        }
  	        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
  	        return URLToolkit.buildURLFromParts(relativeParts);
  	      }
  	      var baseParts = URLToolkit.parseURL(baseURL);
  	      if (!baseParts) {
  	        throw new Error('Error trying to parse base URL.');
  	      }
  	      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
  	        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
  	        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
  	        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
  	        baseParts.netLoc = pathParts[1];
  	        baseParts.path = pathParts[2];
  	      }
  	      if (baseParts.netLoc && !baseParts.path) {
  	        baseParts.path = '/';
  	      }
  	      var builtParts = {
  	        // 2c) Otherwise, the embedded URL inherits the scheme of
  	        // the base URL.
  	        scheme: baseParts.scheme,
  	        netLoc: relativeParts.netLoc,
  	        path: null,
  	        params: relativeParts.params,
  	        query: relativeParts.query,
  	        fragment: relativeParts.fragment,
  	      };
  	      if (!relativeParts.netLoc) {
  	        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
  	        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
  	        // (if any) of the base URL.
  	        builtParts.netLoc = baseParts.netLoc;
  	        // 4) If the embedded URL path is preceded by a slash "/", the
  	        // path is not relative and we skip to Step 7.
  	        if (relativeParts.path[0] !== '/') {
  	          if (!relativeParts.path) {
  	            // 5) If the embedded URL path is empty (and not preceded by a
  	            // slash), then the embedded URL inherits the base URL path
  	            builtParts.path = baseParts.path;
  	            // 5a) if the embedded URL's <params> is non-empty, we skip to
  	            // step 7; otherwise, it inherits the <params> of the base
  	            // URL (if any) and
  	            if (!relativeParts.params) {
  	              builtParts.params = baseParts.params;
  	              // 5b) if the embedded URL's <query> is non-empty, we skip to
  	              // step 7; otherwise, it inherits the <query> of the base
  	              // URL (if any) and we skip to step 7.
  	              if (!relativeParts.query) {
  	                builtParts.query = baseParts.query;
  	              }
  	            }
  	          } else {
  	            // 6) The last segment of the base URL's path (anything
  	            // following the rightmost slash "/", or the entire path if no
  	            // slash is present) is removed and the embedded URL's path is
  	            // appended in its place.
  	            var baseURLPath = baseParts.path;
  	            var newPath =
  	              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +
  	              relativeParts.path;
  	            builtParts.path = URLToolkit.normalizePath(newPath);
  	          }
  	        }
  	      }
  	      if (builtParts.path === null) {
  	        builtParts.path = opts.alwaysNormalize
  	          ? URLToolkit.normalizePath(relativeParts.path)
  	          : relativeParts.path;
  	      }
  	      return URLToolkit.buildURLFromParts(builtParts);
  	    },
  	    parseURL: function (url) {
  	      var parts = URL_REGEX.exec(url);
  	      if (!parts) {
  	        return null;
  	      }
  	      return {
  	        scheme: parts[1] || '',
  	        netLoc: parts[2] || '',
  	        path: parts[3] || '',
  	        params: parts[4] || '',
  	        query: parts[5] || '',
  	        fragment: parts[6] || '',
  	      };
  	    },
  	    normalizePath: function (path) {
  	      // The following operations are
  	      // then applied, in order, to the new path:
  	      // 6a) All occurrences of "./", where "." is a complete path
  	      // segment, are removed.
  	      // 6b) If the path ends with "." as a complete path segment,
  	      // that "." is removed.
  	      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
  	      // 6c) All occurrences of "<segment>/../", where <segment> is a
  	      // complete path segment not equal to "..", are removed.
  	      // Removal of these path segments is performed iteratively,
  	      // removing the leftmost matching pattern on each iteration,
  	      // until no matching pattern remains.
  	      // 6d) If the path ends with "<segment>/..", where <segment> is a
  	      // complete path segment not equal to "..", that
  	      // "<segment>/.." is removed.
  	      while (
  	        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length
  	      ) {}
  	      return path.split('').reverse().join('');
  	    },
  	    buildURLFromParts: function (parts) {
  	      return (
  	        parts.scheme +
  	        parts.netLoc +
  	        parts.path +
  	        parts.params +
  	        parts.query +
  	        parts.fragment
  	      );
  	    },
  	  };

  	  module.exports = URLToolkit;
  	})(); 
  } (urlToolkit));

  var urlToolkitExports = urlToolkit.exports;

  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : String(i);
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _extends$2() {
    _extends$2 = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }

  // https://caniuse.com/mdn-javascript_builtins_number_isfinite
  const isFiniteNumber = Number.isFinite || function (value) {
    return typeof value === 'number' && isFinite(value);
  };

  // https://caniuse.com/mdn-javascript_builtins_number_issafeinteger
  const isSafeInteger = Number.isSafeInteger || function (value) {
    return typeof value === 'number' && Math.abs(value) <= MAX_SAFE_INTEGER;
  };
  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

  let Events$1 = /*#__PURE__*/function (Events) {
    Events["MEDIA_ATTACHING"] = "hlsMediaAttaching";
    Events["MEDIA_ATTACHED"] = "hlsMediaAttached";
    Events["MEDIA_DETACHING"] = "hlsMediaDetaching";
    Events["MEDIA_DETACHED"] = "hlsMediaDetached";
    Events["BUFFER_RESET"] = "hlsBufferReset";
    Events["BUFFER_CODECS"] = "hlsBufferCodecs";
    Events["BUFFER_CREATED"] = "hlsBufferCreated";
    Events["BUFFER_APPENDING"] = "hlsBufferAppending";
    Events["BUFFER_APPENDED"] = "hlsBufferAppended";
    Events["BUFFER_EOS"] = "hlsBufferEos";
    Events["BUFFER_FLUSHING"] = "hlsBufferFlushing";
    Events["BUFFER_FLUSHED"] = "hlsBufferFlushed";
    Events["MANIFEST_LOADING"] = "hlsManifestLoading";
    Events["MANIFEST_LOADED"] = "hlsManifestLoaded";
    Events["MANIFEST_PARSED"] = "hlsManifestParsed";
    Events["LEVEL_SWITCHING"] = "hlsLevelSwitching";
    Events["LEVEL_SWITCHED"] = "hlsLevelSwitched";
    Events["LEVEL_LOADING"] = "hlsLevelLoading";
    Events["LEVEL_LOADED"] = "hlsLevelLoaded";
    Events["LEVEL_UPDATED"] = "hlsLevelUpdated";
    Events["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
    Events["LEVELS_UPDATED"] = "hlsLevelsUpdated";
    Events["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
    Events["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
    Events["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
    Events["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
    Events["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
    Events["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
    Events["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
    Events["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
    Events["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
    Events["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
    Events["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
    Events["CUES_PARSED"] = "hlsCuesParsed";
    Events["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
    Events["INIT_PTS_FOUND"] = "hlsInitPtsFound";
    Events["FRAG_LOADING"] = "hlsFragLoading";
    Events["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
    Events["FRAG_LOADED"] = "hlsFragLoaded";
    Events["FRAG_DECRYPTED"] = "hlsFragDecrypted";
    Events["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
    Events["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
    Events["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
    Events["FRAG_PARSED"] = "hlsFragParsed";
    Events["FRAG_BUFFERED"] = "hlsFragBuffered";
    Events["FRAG_CHANGED"] = "hlsFragChanged";
    Events["FPS_DROP"] = "hlsFpsDrop";
    Events["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
    Events["MAX_AUTO_LEVEL_UPDATED"] = "hlsMaxAutoLevelUpdated";
    Events["ERROR"] = "hlsError";
    Events["DESTROYING"] = "hlsDestroying";
    Events["KEY_LOADING"] = "hlsKeyLoading";
    Events["KEY_LOADED"] = "hlsKeyLoaded";
    Events["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
    Events["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
    Events["STEERING_MANIFEST_LOADED"] = "hlsSteeringManifestLoaded";
    return Events;
  }({});

  /**
   * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.
   */

  let ErrorTypes = /*#__PURE__*/function (ErrorTypes) {
    ErrorTypes["NETWORK_ERROR"] = "networkError";
    ErrorTypes["MEDIA_ERROR"] = "mediaError";
    ErrorTypes["KEY_SYSTEM_ERROR"] = "keySystemError";
    ErrorTypes["MUX_ERROR"] = "muxError";
    ErrorTypes["OTHER_ERROR"] = "otherError";
    return ErrorTypes;
  }({});
  let ErrorDetails = /*#__PURE__*/function (ErrorDetails) {
    ErrorDetails["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
    ErrorDetails["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
    ErrorDetails["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
    ErrorDetails["KEY_SYSTEM_NO_CONFIGURED_LICENSE"] = "keySystemNoConfiguredLicense";
    ErrorDetails["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
    ErrorDetails["KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED"] = "keySystemServerCertificateRequestFailed";
    ErrorDetails["KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED"] = "keySystemServerCertificateUpdateFailed";
    ErrorDetails["KEY_SYSTEM_SESSION_UPDATE_FAILED"] = "keySystemSessionUpdateFailed";
    ErrorDetails["KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED"] = "keySystemStatusOutputRestricted";
    ErrorDetails["KEY_SYSTEM_STATUS_INTERNAL_ERROR"] = "keySystemStatusInternalError";
    ErrorDetails["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
    ErrorDetails["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
    ErrorDetails["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
    ErrorDetails["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
    ErrorDetails["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
    ErrorDetails["LEVEL_LOAD_ERROR"] = "levelLoadError";
    ErrorDetails["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
    ErrorDetails["LEVEL_PARSING_ERROR"] = "levelParsingError";
    ErrorDetails["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
    ErrorDetails["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
    ErrorDetails["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
    ErrorDetails["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
    ErrorDetails["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
    ErrorDetails["FRAG_LOAD_ERROR"] = "fragLoadError";
    ErrorDetails["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
    ErrorDetails["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
    ErrorDetails["FRAG_PARSING_ERROR"] = "fragParsingError";
    ErrorDetails["FRAG_GAP"] = "fragGap";
    ErrorDetails["REMUX_ALLOC_ERROR"] = "remuxAllocError";
    ErrorDetails["KEY_LOAD_ERROR"] = "keyLoadError";
    ErrorDetails["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
    ErrorDetails["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
    ErrorDetails["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
    ErrorDetails["BUFFER_APPEND_ERROR"] = "bufferAppendError";
    ErrorDetails["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
    ErrorDetails["BUFFER_STALLED_ERROR"] = "bufferStalledError";
    ErrorDetails["BUFFER_FULL_ERROR"] = "bufferFullError";
    ErrorDetails["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
    ErrorDetails["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
    ErrorDetails["INTERNAL_EXCEPTION"] = "internalException";
    ErrorDetails["INTERNAL_ABORTED"] = "aborted";
    ErrorDetails["UNKNOWN"] = "unknown";
    return ErrorDetails;
  }({});

  const noop$1 = function noop() {};
  const fakeLogger = {
    trace: noop$1,
    debug: noop$1,
    log: noop$1,
    warn: noop$1,
    info: noop$1,
    error: noop$1
  };
  let exportedLogger = fakeLogger;

  // let lastCallTime;
  // function formatMsgWithTimeInfo(type, msg) {
  //   const now = Date.now();
  //   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
  //   lastCallTime = now;
  //   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
  //   return msg;
  // }

  function consolePrintFn(type) {
    const func = self.console[type];
    if (func) {
      return func.bind(self.console, `[${type}] >`);
    }
    return noop$1;
  }
  function exportLoggerFunctions(debugConfig, ...functions) {
    functions.forEach(function (type) {
      exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
    });
  }
  function enableLogs(debugConfig, id) {
    // check that console is available
    if (typeof console === 'object' && debugConfig === true || typeof debugConfig === 'object') {
      exportLoggerFunctions(debugConfig,
      // Remove out from list here to hard-disable a log-level
      // 'trace',
      'debug', 'log', 'info', 'warn', 'error');
      // Some browsers don't allow to use bind on console object anyway
      // fallback to default if needed
      try {
        exportedLogger.log(`Debug logs enabled for "${id}" in hls.js version ${"1.5.15"}`);
      } catch (e) {
        exportedLogger = fakeLogger;
      }
    } else {
      exportedLogger = fakeLogger;
    }
  }
  const logger = exportedLogger;

  const DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
  const ATTR_LIST_REGEX = /(.+?)=(".*?"|.*?)(?:,|$)/g;

  // adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js
  class AttrList {
    constructor(attrs) {
      if (typeof attrs === 'string') {
        attrs = AttrList.parseAttrList(attrs);
      }
      _extends$2(this, attrs);
    }
    get clientAttrs() {
      return Object.keys(this).filter(attr => attr.substring(0, 2) === 'X-');
    }
    decimalInteger(attrName) {
      const intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
    hexadecimalInteger(attrName) {
      if (this[attrName]) {
        let stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;
        const value = new Uint8Array(stringValue.length / 2);
        for (let i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }
        return value;
      } else {
        return null;
      }
    }
    hexadecimalIntegerAsNumber(attrName) {
      const intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
    decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
    optionalFloat(attrName, defaultValue) {
      const value = this[attrName];
      return value ? parseFloat(value) : defaultValue;
    }
    enumeratedString(attrName) {
      return this[attrName];
    }
    bool(attrName) {
      return this[attrName] === 'YES';
    }
    decimalResolution(attrName) {
      const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }
      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
    static parseAttrList(input) {
      let match;
      const attrs = {};
      const quote = '"';
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        let value = match[2];
        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }
        const name = match[1].trim();
        attrs[name] = value;
      }
      return attrs;
    }
  }

  // Avoid exporting const enum so that these values can be inlined

  function isDateRangeCueAttribute(attrName) {
    return attrName !== "ID" && attrName !== "CLASS" && attrName !== "START-DATE" && attrName !== "DURATION" && attrName !== "END-DATE" && attrName !== "END-ON-NEXT";
  }
  function isSCTE35Attribute(attrName) {
    return attrName === "SCTE35-OUT" || attrName === "SCTE35-IN";
  }
  class DateRange {
    constructor(dateRangeAttr, dateRangeWithSameId) {
      this.attr = void 0;
      this._startDate = void 0;
      this._endDate = void 0;
      this._badValueForSameId = void 0;
      if (dateRangeWithSameId) {
        const previousAttr = dateRangeWithSameId.attr;
        for (const key in previousAttr) {
          if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {
            logger.warn(`DATERANGE tag attribute: "${key}" does not match for tags with ID: "${dateRangeAttr.ID}"`);
            this._badValueForSameId = key;
            break;
          }
        }
        // Merge DateRange tags with the same ID
        dateRangeAttr = _extends$2(new AttrList({}), previousAttr, dateRangeAttr);
      }
      this.attr = dateRangeAttr;
      this._startDate = new Date(dateRangeAttr["START-DATE"]);
      if ("END-DATE" in this.attr) {
        const endDate = new Date(this.attr["END-DATE"]);
        if (isFiniteNumber(endDate.getTime())) {
          this._endDate = endDate;
        }
      }
    }
    get id() {
      return this.attr.ID;
    }
    get class() {
      return this.attr.CLASS;
    }
    get startDate() {
      return this._startDate;
    }
    get endDate() {
      if (this._endDate) {
        return this._endDate;
      }
      const duration = this.duration;
      if (duration !== null) {
        return new Date(this._startDate.getTime() + duration * 1000);
      }
      return null;
    }
    get duration() {
      if ("DURATION" in this.attr) {
        const duration = this.attr.decimalFloatingPoint("DURATION");
        if (isFiniteNumber(duration)) {
          return duration;
        }
      } else if (this._endDate) {
        return (this._endDate.getTime() - this._startDate.getTime()) / 1000;
      }
      return null;
    }
    get plannedDuration() {
      if ("PLANNED-DURATION" in this.attr) {
        return this.attr.decimalFloatingPoint("PLANNED-DURATION");
      }
      return null;
    }
    get endOnNext() {
      return this.attr.bool("END-ON-NEXT");
    }
    get isValid() {
      return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);
    }
  }

  class LoadStats {
    constructor() {
      this.aborted = false;
      this.loaded = 0;
      this.retry = 0;
      this.total = 0;
      this.chunkCount = 0;
      this.bwEstimate = 0;
      this.loading = {
        start: 0,
        first: 0,
        end: 0
      };
      this.parsing = {
        start: 0,
        end: 0
      };
      this.buffering = {
        start: 0,
        first: 0,
        end: 0
      };
    }
  }

  var ElementaryStreamTypes = {
    AUDIO: "audio",
    VIDEO: "video",
    AUDIOVIDEO: "audiovideo"
  };
  class BaseSegment {
    constructor(baseurl) {
      this._byteRange = null;
      this._url = null;
      // baseurl is the URL to the playlist
      this.baseurl = void 0;
      // relurl is the portion of the URL that comes from inside the playlist.
      this.relurl = void 0;
      // Holds the types of data this fragment supports
      this.elementaryStreams = {
        [ElementaryStreamTypes.AUDIO]: null,
        [ElementaryStreamTypes.VIDEO]: null,
        [ElementaryStreamTypes.AUDIOVIDEO]: null
      };
      this.baseurl = baseurl;
    }

    // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
    setByteRange(value, previous) {
      const params = value.split('@', 2);
      let start;
      if (params.length === 1) {
        start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;
      } else {
        start = parseInt(params[1]);
      }
      this._byteRange = [start, parseInt(params[0]) + start];
    }
    get byteRange() {
      if (!this._byteRange) {
        return [];
      }
      return this._byteRange;
    }
    get byteRangeStartOffset() {
      return this.byteRange[0];
    }
    get byteRangeEndOffset() {
      return this.byteRange[1];
    }
    get url() {
      if (!this._url && this.baseurl && this.relurl) {
        this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {
          alwaysNormalize: true
        });
      }
      return this._url || '';
    }
    set url(value) {
      this._url = value;
    }
  }

  /**
   * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.
   */
  class Fragment extends BaseSegment {
    constructor(type, baseurl) {
      super(baseurl);
      this._decryptdata = null;
      this.rawProgramDateTime = null;
      this.programDateTime = null;
      this.tagList = [];
      // EXTINF has to be present for a m3u8 to be considered valid
      this.duration = 0;
      // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'
      this.sn = 0;
      // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption
      // core difference from the private field _decryptdata is the lack of the initialized IV
      // _decryptdata will set the IV for this segment based on the segment number in the fragment
      this.levelkeys = void 0;
      // A string representing the fragment type
      this.type = void 0;
      // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading
      this.loader = null;
      // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading
      this.keyLoader = null;
      // The level/track index to which the fragment belongs
      this.level = -1;
      // The continuity counter of the fragment
      this.cc = 0;
      // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
      this.startPTS = void 0;
      // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
      this.endPTS = void 0;
      // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
      this.startDTS = void 0;
      // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
      this.endDTS = void 0;
      // The start time of the fragment, as listed in the manifest. Updated after transmux complete.
      this.start = 0;
      // Set by `updateFragPTSDTS` in level-helper
      this.deltaPTS = void 0;
      // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
      this.maxStartPTS = void 0;
      // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
      this.minEndPTS = void 0;
      // Load/parse timing information
      this.stats = new LoadStats();
      // Init Segment bytes (unset for media segments)
      this.data = void 0;
      // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered
      this.bitrateTest = false;
      // #EXTINF  segment title
      this.title = null;
      // The Media Initialization Section for this segment
      this.initSegment = null;
      // Fragment is the last fragment in the media playlist
      this.endList = void 0;
      // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded
      this.gap = void 0;
      // Deprecated
      this.urlId = 0;
      this.type = type;
    }
    get decryptdata() {
      const {
        levelkeys
      } = this;
      if (!levelkeys && !this._decryptdata) {
        return null;
      }
      if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
        const key = this.levelkeys.identity;
        if (key) {
          this._decryptdata = key.getDecryptData(this.sn);
        } else {
          const keyFormats = Object.keys(this.levelkeys);
          if (keyFormats.length === 1) {
            return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);
          }
        }
      }
      return this._decryptdata;
    }
    get end() {
      return this.start + this.duration;
    }
    get endProgramDateTime() {
      if (this.programDateTime === null) {
        return null;
      }
      if (!isFiniteNumber(this.programDateTime)) {
        return null;
      }
      const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;
      return this.programDateTime + duration * 1000;
    }
    get encrypted() {
      var _this$_decryptdata;
      // At the m3u8-parser level we need to add support for manifest signalled keyformats
      // when we want the fragment to start reporting that it is encrypted.
      // Currently, keyFormat will only be set for identity keys
      if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {
        return true;
      } else if (this.levelkeys) {
        const keyFormats = Object.keys(this.levelkeys);
        const len = keyFormats.length;
        if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {
          return true;
        }
      }
      return false;
    }
    setKeyFormat(keyFormat) {
      if (this.levelkeys) {
        const key = this.levelkeys[keyFormat];
        if (key && !this._decryptdata) {
          this._decryptdata = key.getDecryptData(this.sn);
        }
      }
    }
    abortRequests() {
      var _this$loader, _this$keyLoader;
      (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();
      (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();
    }
    setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {
      const {
        elementaryStreams
      } = this;
      const info = elementaryStreams[type];
      if (!info) {
        elementaryStreams[type] = {
          startPTS,
          endPTS,
          startDTS,
          endDTS,
          partial
        };
        return;
      }
      info.startPTS = Math.min(info.startPTS, startPTS);
      info.endPTS = Math.max(info.endPTS, endPTS);
      info.startDTS = Math.min(info.startDTS, startDTS);
      info.endDTS = Math.max(info.endDTS, endDTS);
    }
    clearElementaryStreamInfo() {
      const {
        elementaryStreams
      } = this;
      elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
      elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
      elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
    }
  }

  /**
   * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.
   */
  class Part extends BaseSegment {
    constructor(partAttrs, frag, baseurl, index, previous) {
      super(baseurl);
      this.fragOffset = 0;
      this.duration = 0;
      this.gap = false;
      this.independent = false;
      this.relurl = void 0;
      this.fragment = void 0;
      this.index = void 0;
      this.stats = new LoadStats();
      this.duration = partAttrs.decimalFloatingPoint('DURATION');
      this.gap = partAttrs.bool('GAP');
      this.independent = partAttrs.bool('INDEPENDENT');
      this.relurl = partAttrs.enumeratedString('URI');
      this.fragment = frag;
      this.index = index;
      const byteRange = partAttrs.enumeratedString('BYTERANGE');
      if (byteRange) {
        this.setByteRange(byteRange, previous);
      }
      if (previous) {
        this.fragOffset = previous.fragOffset + previous.duration;
      }
    }
    get start() {
      return this.fragment.start + this.fragOffset;
    }
    get end() {
      return this.start + this.duration;
    }
    get loaded() {
      const {
        elementaryStreams
      } = this;
      return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
    }
  }

  const DEFAULT_TARGET_DURATION = 10;

  /**
   * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.
   */
  class LevelDetails {
    constructor(baseUrl) {
      this.PTSKnown = false;
      this.alignedSliding = false;
      this.averagetargetduration = void 0;
      this.endCC = 0;
      this.endSN = 0;
      this.fragments = void 0;
      this.fragmentHint = void 0;
      this.partList = null;
      this.dateRanges = void 0;
      this.live = true;
      this.ageHeader = 0;
      this.advancedDateTime = void 0;
      this.updated = true;
      this.advanced = true;
      this.availabilityDelay = void 0;
      // Manifest reload synchronization
      this.misses = 0;
      this.startCC = 0;
      this.startSN = 0;
      this.startTimeOffset = null;
      this.targetduration = 0;
      this.totalduration = 0;
      this.type = null;
      this.url = void 0;
      this.m3u8 = '';
      this.version = null;
      this.canBlockReload = false;
      this.canSkipUntil = 0;
      this.canSkipDateRanges = false;
      this.skippedSegments = 0;
      this.recentlyRemovedDateranges = void 0;
      this.partHoldBack = 0;
      this.holdBack = 0;
      this.partTarget = 0;
      this.preloadHint = void 0;
      this.renditionReports = void 0;
      this.tuneInGoal = 0;
      this.deltaUpdateFailed = void 0;
      this.driftStartTime = 0;
      this.driftEndTime = 0;
      this.driftStart = 0;
      this.driftEnd = 0;
      this.encryptedFragments = void 0;
      this.playlistParsingError = null;
      this.variableList = null;
      this.hasVariableRefs = false;
      this.fragments = [];
      this.encryptedFragments = [];
      this.dateRanges = {};
      this.url = baseUrl;
    }
    reloaded(previous) {
      if (!previous) {
        this.advanced = true;
        this.updated = true;
        return;
      }
      const partSnDiff = this.lastPartSn - previous.lastPartSn;
      const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
      this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;
      this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;
      if (this.updated || this.advanced) {
        this.misses = Math.floor(previous.misses * 0.6);
      } else {
        this.misses = previous.misses + 1;
      }
      this.availabilityDelay = previous.availabilityDelay;
    }
    get hasProgramDateTime() {
      if (this.fragments.length) {
        return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);
      }
      return false;
    }
    get levelTargetDuration() {
      return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
    }
    get drift() {
      const runTime = this.driftEndTime - this.driftStartTime;
      if (runTime > 0) {
        const runDuration = this.driftEnd - this.driftStart;
        return runDuration * 1000 / runTime;
      }
      return 1;
    }
    get edge() {
      return this.partEnd || this.fragmentEnd;
    }
    get partEnd() {
      var _this$partList;
      if ((_this$partList = this.partList) != null && _this$partList.length) {
        return this.partList[this.partList.length - 1].end;
      }
      return this.fragmentEnd;
    }
    get fragmentEnd() {
      var _this$fragments;
      if ((_this$fragments = this.fragments) != null && _this$fragments.length) {
        return this.fragments[this.fragments.length - 1].end;
      }
      return 0;
    }
    get age() {
      if (this.advancedDateTime) {
        return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;
      }
      return 0;
    }
    get lastPartIndex() {
      var _this$partList2;
      if ((_this$partList2 = this.partList) != null && _this$partList2.length) {
        return this.partList[this.partList.length - 1].index;
      }
      return -1;
    }
    get lastPartSn() {
      var _this$partList3;
      if ((_this$partList3 = this.partList) != null && _this$partList3.length) {
        return this.partList[this.partList.length - 1].fragment.sn;
      }
      return this.endSN;
    }
  }

  function base64Decode(base64encodedStr) {
    return Uint8Array.from(atob(base64encodedStr), c => c.charCodeAt(0));
  }

  function getKeyIdBytes(str) {
    const keyIdbytes = strToUtf8array(str).subarray(0, 16);
    const paddedkeyIdbytes = new Uint8Array(16);
    paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);
    return paddedkeyIdbytes;
  }
  function changeEndianness(keyId) {
    const swap = function swap(array, from, to) {
      const cur = array[from];
      array[from] = array[to];
      array[to] = cur;
    };
    swap(keyId, 0, 3);
    swap(keyId, 1, 2);
    swap(keyId, 4, 5);
    swap(keyId, 6, 7);
  }
  function convertDataUriToArrayBytes(uri) {
    // data:[<media type][;attribute=value][;base64],<data>
    const colonsplit = uri.split(':');
    let keydata = null;
    if (colonsplit[0] === 'data' && colonsplit.length === 2) {
      const semicolonsplit = colonsplit[1].split(';');
      const commasplit = semicolonsplit[semicolonsplit.length - 1].split(',');
      if (commasplit.length === 2) {
        const isbase64 = commasplit[0] === 'base64';
        const data = commasplit[1];
        if (isbase64) {
          semicolonsplit.splice(-1, 1); // remove from processing
          keydata = base64Decode(data);
        } else {
          keydata = getKeyIdBytes(data);
        }
      }
    }
    return keydata;
  }
  function strToUtf8array(str) {
    return Uint8Array.from(unescape(encodeURIComponent(str)), c => c.charCodeAt(0));
  }

  /** returns `undefined` is `self` is missing, e.g. in node */
  const optionalSelf = typeof self !== 'undefined' ? self : undefined;

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess
   */
  var KeySystems = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.fps",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "com.widevine.alpha"
  };

  // Playlist #EXT-X-KEY KEYFORMAT values
  var KeySystemFormats = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.streamingkeydelivery",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
  };
  function keySystemFormatToKeySystemDomain(format) {
    switch (format) {
      case KeySystemFormats.FAIRPLAY:
        return KeySystems.FAIRPLAY;
      case KeySystemFormats.PLAYREADY:
        return KeySystems.PLAYREADY;
      case KeySystemFormats.WIDEVINE:
        return KeySystems.WIDEVINE;
      case KeySystemFormats.CLEARKEY:
        return KeySystems.CLEARKEY;
    }
  }

  // System IDs for which we can extract a key ID from "encrypted" event PSSH
  var KeySystemIds = {
    CENC: "1077efecc0b24d02ace33c1e52e2fb4b",
    CLEARKEY: "e2719d58a985b3c9781ab030af78d30e",
    FAIRPLAY: "94ce86fb07ff4f43adb893d2fa968ca2",
    PLAYREADY: "9a04f07998404286ab92e65be0885f95",
    WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed"
  };
  function keySystemIdToKeySystemDomain(systemId) {
    if (systemId === KeySystemIds.WIDEVINE) {
      return KeySystems.WIDEVINE;
    } else if (systemId === KeySystemIds.PLAYREADY) {
      return KeySystems.PLAYREADY;
    } else if (systemId === KeySystemIds.CENC || systemId === KeySystemIds.CLEARKEY) {
      return KeySystems.CLEARKEY;
    }
  }
  function keySystemDomainToKeySystemFormat(keySystem) {
    switch (keySystem) {
      case KeySystems.FAIRPLAY:
        return KeySystemFormats.FAIRPLAY;
      case KeySystems.PLAYREADY:
        return KeySystemFormats.PLAYREADY;
      case KeySystems.WIDEVINE:
        return KeySystemFormats.WIDEVINE;
      case KeySystems.CLEARKEY:
        return KeySystemFormats.CLEARKEY;
    }
  }
  function getKeySystemsForConfig(config) {
    const {
      drmSystems,
      widevineLicenseUrl
    } = config;
    const keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(keySystem => !!drmSystems[keySystem]) : [];
    if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {
      keySystemsToAttempt.push(KeySystems.WIDEVINE);
    }
    return keySystemsToAttempt;
  }
  const requestMediaKeySystemAccess = function (_optionalSelf$navigat) {
    if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {
      return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);
    } else {
      return null;
    }
  }();

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration
   */
  function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
    let initDataTypes;
    switch (keySystem) {
      case KeySystems.FAIRPLAY:
        initDataTypes = ['cenc', 'sinf'];
        break;
      case KeySystems.WIDEVINE:
      case KeySystems.PLAYREADY:
        initDataTypes = ['cenc'];
        break;
      case KeySystems.CLEARKEY:
        initDataTypes = ['cenc', 'keyids'];
        break;
      default:
        throw new Error(`Unknown key-system: ${keySystem}`);
    }
    return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);
  }
  function createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {
    const baseConfig = {
      initDataTypes: initDataTypes,
      persistentState: drmSystemOptions.persistentState || 'optional',
      distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || 'optional',
      sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || 'temporary'],
      audioCapabilities: audioCodecs.map(codec => ({
        contentType: `audio/mp4; codecs="${codec}"`,
        robustness: drmSystemOptions.audioRobustness || '',
        encryptionScheme: drmSystemOptions.audioEncryptionScheme || null
      })),
      videoCapabilities: videoCodecs.map(codec => ({
        contentType: `video/mp4; codecs="${codec}"`,
        robustness: drmSystemOptions.videoRobustness || '',
        encryptionScheme: drmSystemOptions.videoEncryptionScheme || null
      }))
    };
    return [baseConfig];
  }

  function sliceUint8(array, start, end) {
    // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.
    // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.
    return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));
  }

  // breaking up those two types in order to clarify what is happening in the decoding path.

  /**
   * Returns true if an ID3 header can be found at offset in data
   * @param data - The data to search
   * @param offset - The offset at which to start searching
   */
  const isHeader$2 = (data, offset) => {
    /*
     * http://id3.org/id3v2.3.0
     * [0]     = 'I'
     * [1]     = 'D'
     * [2]     = '3'
     * [3,4]   = {Version}
     * [5]     = {Flags}
     * [6-9]   = {ID3 Size}
     *
     * An ID3v2 tag can be detected with the following pattern:
     *  $49 44 33 yy yy xx zz zz zz zz
     * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
     */
    if (offset + 10 <= data.length) {
      // look for 'ID3' identifier
      if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
        // check version is within range
        if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {
          // check size is within range
          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
            return true;
          }
        }
      }
    }
    return false;
  };

  /**
   * Returns true if an ID3 footer can be found at offset in data
   * @param data - The data to search
   * @param offset - The offset at which to start searching
   */
  const isFooter = (data, offset) => {
    /*
     * The footer is a copy of the header, but with a different identifier
     */
    if (offset + 10 <= data.length) {
      // look for '3DI' identifier
      if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
        // check version is within range
        if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {
          // check size is within range
          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
            return true;
          }
        }
      }
    }
    return false;
  };

  /**
   * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
   * @param data - The data to search in
   * @param offset - The offset at which to start searching
   * @returns the block of data containing any ID3 tags found
   * or *undefined* if no header is found at the starting offset
   */
  const getID3Data = (data, offset) => {
    const front = offset;
    let length = 0;
    while (isHeader$2(data, offset)) {
      // ID3 header is 10 bytes
      length += 10;
      const size = readSize(data, offset + 6);
      length += size;
      if (isFooter(data, offset + 10)) {
        // ID3 footer is 10 bytes
        length += 10;
      }
      offset += length;
    }
    if (length > 0) {
      return data.subarray(front, front + length);
    }
    return undefined;
  };
  const readSize = (data, offset) => {
    let size = 0;
    size = (data[offset] & 0x7f) << 21;
    size |= (data[offset + 1] & 0x7f) << 14;
    size |= (data[offset + 2] & 0x7f) << 7;
    size |= data[offset + 3] & 0x7f;
    return size;
  };
  const canParse$2 = (data, offset) => {
    return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;
  };

  /**
   * Searches for the Elementary Stream timestamp found in the ID3 data chunk
   * @param data - Block of data containing one or more ID3 tags
   */
  const getTimeStamp = data => {
    const frames = getID3Frames(data);
    for (let i = 0; i < frames.length; i++) {
      const frame = frames[i];
      if (isTimeStampFrame(frame)) {
        return readTimeStamp(frame);
      }
    }
    return undefined;
  };

  /**
   * Returns true if the ID3 frame is an Elementary Stream timestamp frame
   */
  const isTimeStampFrame = frame => {
    return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';
  };
  const getFrameData = data => {
    /*
    Frame ID       $xx xx xx xx (four characters)
    Size           $xx xx xx xx
    Flags          $xx xx
    */
    const type = String.fromCharCode(data[0], data[1], data[2], data[3]);
    const size = readSize(data, 4);

    // skip frame id, size, and flags
    const offset = 10;
    return {
      type,
      size,
      data: data.subarray(offset, offset + size)
    };
  };

  /**
   * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
   * @param id3Data - The ID3 data containing one or more ID3 tags
   */
  const getID3Frames = id3Data => {
    let offset = 0;
    const frames = [];
    while (isHeader$2(id3Data, offset)) {
      const size = readSize(id3Data, offset + 6);
      // skip past ID3 header
      offset += 10;
      const end = offset + size;
      // loop through frames in the ID3 tag
      while (offset + 8 < end) {
        const frameData = getFrameData(id3Data.subarray(offset));
        const frame = decodeFrame(frameData);
        if (frame) {
          frames.push(frame);
        }

        // skip frame header and frame data
        offset += frameData.size + 10;
      }
      if (isFooter(id3Data, offset)) {
        offset += 10;
      }
    }
    return frames;
  };
  const decodeFrame = frame => {
    if (frame.type === 'PRIV') {
      return decodePrivFrame(frame);
    } else if (frame.type[0] === 'W') {
      return decodeURLFrame(frame);
    }
    return decodeTextFrame(frame);
  };
  const decodePrivFrame = frame => {
    /*
    Format: <text string>\0<binary data>
    */
    if (frame.size < 2) {
      return undefined;
    }
    const owner = utf8ArrayToStr(frame.data, true);
    const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
    return {
      key: frame.type,
      info: owner,
      data: privateData.buffer
    };
  };
  const decodeTextFrame = frame => {
    if (frame.size < 2) {
      return undefined;
    }
    if (frame.type === 'TXXX') {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{Value}
      */
      let index = 1;
      const description = utf8ArrayToStr(frame.data.subarray(index), true);
      index += description.length + 1;
      const value = utf8ArrayToStr(frame.data.subarray(index));
      return {
        key: frame.type,
        info: description,
        data: value
      };
    }
    /*
    Format:
    [0]   = {Text Encoding}
    [1-?] = {Value}
    */
    const text = utf8ArrayToStr(frame.data.subarray(1));
    return {
      key: frame.type,
      data: text
    };
  };
  const decodeURLFrame = frame => {
    if (frame.type === 'WXXX') {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{URL}
      */
      if (frame.size < 2) {
        return undefined;
      }
      let index = 1;
      const description = utf8ArrayToStr(frame.data.subarray(index), true);
      index += description.length + 1;
      const value = utf8ArrayToStr(frame.data.subarray(index));
      return {
        key: frame.type,
        info: description,
        data: value
      };
    }
    /*
    Format:
    [0-?] = {URL}
    */
    const url = utf8ArrayToStr(frame.data);
    return {
      key: frame.type,
      data: url
    };
  };
  const readTimeStamp = timeStampFrame => {
    if (timeStampFrame.data.byteLength === 8) {
      const data = new Uint8Array(timeStampFrame.data);
      // timestamp is 33 bit expressed as a big-endian eight-octet number,
      // with the upper 31 bits set to zero.
      const pts33Bit = data[3] & 0x1;
      let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
      timestamp /= 45;
      if (pts33Bit) {
        timestamp += 47721858.84;
      } // 2^32 / 90

      return Math.round(timestamp);
    }
    return undefined;
  };

  // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
  // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
  /* utf.js - UTF-8 <=> UTF-16 convertion
   *
   * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
   * Version: 1.0
   * LastModified: Dec 25 1999
   * This library is free.  You can redistribute it and/or modify it.
   */
  const utf8ArrayToStr = (array, exitOnNull = false) => {
    const decoder = getTextDecoder();
    if (decoder) {
      const decoded = decoder.decode(array);
      if (exitOnNull) {
        // grab up to the first null
        const idx = decoded.indexOf('\0');
        return idx !== -1 ? decoded.substring(0, idx) : decoded;
      }

      // remove any null characters
      return decoded.replace(/\0/g, '');
    }
    const len = array.length;
    let c;
    let char2;
    let char3;
    let out = '';
    let i = 0;
    while (i < len) {
      c = array[i++];
      if (c === 0x00 && exitOnNull) {
        return out;
      } else if (c === 0x00 || c === 0x03) {
        // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
        continue;
      }
      switch (c >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          // 0xxxxxxx
          out += String.fromCharCode(c);
          break;
        case 12:
        case 13:
          // 110x xxxx   10xx xxxx
          char2 = array[i++];
          out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);
          break;
        case 14:
          // 1110 xxxx  10xx xxxx  10xx xxxx
          char2 = array[i++];
          char3 = array[i++];
          out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);
          break;
      }
    }
    return out;
  };
  let decoder;
  function getTextDecoder() {
    // On Play Station 4, TextDecoder is defined but partially implemented.
    // Manual decoding option is preferable
    if (navigator.userAgent.includes('PlayStation 4')) {
      return;
    }
    if (!decoder && typeof self.TextDecoder !== 'undefined') {
      decoder = new self.TextDecoder('utf-8');
    }
    return decoder;
  }

  /**
   *  hex dump helper class
   */

  const Hex = {
    hexDump: function (array) {
      let str = '';
      for (let i = 0; i < array.length; i++) {
        let h = array[i].toString(16);
        if (h.length < 2) {
          h = '0' + h;
        }
        str += h;
      }
      return str;
    }
  };

  const UINT32_MAX$1 = Math.pow(2, 32) - 1;
  const push = [].push;

  // We are using fixed track IDs for driving the MP4 remuxer
  // instead of following the TS PIDs.
  // There is no reason not to do this and some browsers/SourceBuffer-demuxers
  // may not like if there are TrackID "switches"
  // See https://github.com/video-dev/hls.js/issues/1331
  // Here we are mapping our internal track types to constant MP4 track IDs
  // With MSE currently one can only have one track of each, and we are muxing
  // whatever video/audio rendition in them.
  const RemuxerTrackIdConfig = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
  };
  function bin2str(data) {
    return String.fromCharCode.apply(null, data);
  }
  function readUint16(buffer, offset) {
    const val = buffer[offset] << 8 | buffer[offset + 1];
    return val < 0 ? 65536 + val : val;
  }
  function readUint32(buffer, offset) {
    const val = readSint32(buffer, offset);
    return val < 0 ? 4294967296 + val : val;
  }
  function readUint64(buffer, offset) {
    let result = readUint32(buffer, offset);
    result *= Math.pow(2, 32);
    result += readUint32(buffer, offset + 4);
    return result;
  }
  function readSint32(buffer, offset) {
    return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
  }
  function writeUint32(buffer, offset, value) {
    buffer[offset] = value >> 24;
    buffer[offset + 1] = value >> 16 & 0xff;
    buffer[offset + 2] = value >> 8 & 0xff;
    buffer[offset + 3] = value & 0xff;
  }

  // Find "moof" box
  function hasMoofData(data) {
    const end = data.byteLength;
    for (let i = 0; i < end;) {
      const size = readUint32(data, i);
      if (size > 8 && data[i + 4] === 0x6d && data[i + 5] === 0x6f && data[i + 6] === 0x6f && data[i + 7] === 0x66) {
        return true;
      }
      i = size > 1 ? i + size : end;
    }
    return false;
  }

  // Find the data for a box specified by its path
  function findBox(data, path) {
    const results = [];
    if (!path.length) {
      // short-circuit the search for empty paths
      return results;
    }
    const end = data.byteLength;
    for (let i = 0; i < end;) {
      const size = readUint32(data, i);
      const type = bin2str(data.subarray(i + 4, i + 8));
      const endbox = size > 1 ? i + size : end;
      if (type === path[0]) {
        if (path.length === 1) {
          // this is the end of the path and we've found the box we were
          // looking for
          results.push(data.subarray(i + 8, endbox));
        } else {
          // recursively search for the next box along the path
          const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));
          if (subresults.length) {
            push.apply(results, subresults);
          }
        }
      }
      i = endbox;
    }

    // we've finished searching all of data
    return results;
  }
  function parseSegmentIndex(sidx) {
    const references = [];
    const version = sidx[0];

    // set initial offset, we skip the reference ID (not needed)
    let index = 8;
    const timescale = readUint32(sidx, index);
    index += 4;
    let earliestPresentationTime = 0;
    let firstOffset = 0;
    if (version === 0) {
      earliestPresentationTime = readUint32(sidx, index);
      firstOffset = readUint32(sidx, index + 4);
      index += 8;
    } else {
      earliestPresentationTime = readUint64(sidx, index);
      firstOffset = readUint64(sidx, index + 8);
      index += 16;
    }

    // skip reserved
    index += 2;
    let startByte = sidx.length + firstOffset;
    const referencesCount = readUint16(sidx, index);
    index += 2;
    for (let i = 0; i < referencesCount; i++) {
      let referenceIndex = index;
      const referenceInfo = readUint32(sidx, referenceIndex);
      referenceIndex += 4;
      const referenceSize = referenceInfo & 0x7fffffff;
      const referenceType = (referenceInfo & 0x80000000) >>> 31;
      if (referenceType === 1) {
        logger.warn('SIDX has hierarchical references (not supported)');
        return null;
      }
      const subsegmentDuration = readUint32(sidx, referenceIndex);
      referenceIndex += 4;
      references.push({
        referenceSize,
        subsegmentDuration,
        // unscaled
        info: {
          duration: subsegmentDuration / timescale,
          start: startByte,
          end: startByte + referenceSize - 1
        }
      });
      startByte += referenceSize;

      // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
      // for |sapDelta|.
      referenceIndex += 4;

      // skip to next ref
      index = referenceIndex;
    }
    return {
      earliestPresentationTime,
      timescale,
      version,
      referencesCount,
      references
    };
  }

  /**
   * Parses an MP4 initialization segment and extracts stream type and
   * timescale values for any declared tracks. Timescale values indicate the
   * number of clock ticks per second to assume for time-based values
   * elsewhere in the MP4.
   *
   * To determine the start time of an MP4, you need two pieces of
   * information: the timescale unit and the earliest base media decode
   * time. Multiple timescales can be specified within an MP4 but the
   * base media decode time is always expressed in the timescale from
   * the media header box for the track:
   * ```
   * moov > trak > mdia > mdhd.timescale
   * moov > trak > mdia > hdlr
   * ```
   * @param initSegment the bytes of the init segment
   * @returns a hash of track type to timescale values or null if
   * the init segment is malformed.
   */

  function parseInitSegment(initSegment) {
    const result = [];
    const traks = findBox(initSegment, ['moov', 'trak']);
    for (let i = 0; i < traks.length; i++) {
      const trak = traks[i];
      const tkhd = findBox(trak, ['tkhd'])[0];
      if (tkhd) {
        let version = tkhd[0];
        const trackId = readUint32(tkhd, version === 0 ? 12 : 20);
        const mdhd = findBox(trak, ['mdia', 'mdhd'])[0];
        if (mdhd) {
          version = mdhd[0];
          const timescale = readUint32(mdhd, version === 0 ? 12 : 20);
          const hdlr = findBox(trak, ['mdia', 'hdlr'])[0];
          if (hdlr) {
            const hdlrType = bin2str(hdlr.subarray(8, 12));
            const type = {
              soun: ElementaryStreamTypes.AUDIO,
              vide: ElementaryStreamTypes.VIDEO
            }[hdlrType];
            if (type) {
              // Parse codec details
              const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];
              const stsdData = parseStsd(stsd);
              result[trackId] = {
                timescale,
                type
              };
              result[type] = _objectSpread2({
                timescale,
                id: trackId
              }, stsdData);
            }
          }
        }
      }
    }
    const trex = findBox(initSegment, ['moov', 'mvex', 'trex']);
    trex.forEach(trex => {
      const trackId = readUint32(trex, 4);
      const track = result[trackId];
      if (track) {
        track.default = {
          duration: readUint32(trex, 12),
          flags: readUint32(trex, 20)
        };
      }
    });
    return result;
  }
  function parseStsd(stsd) {
    const sampleEntries = stsd.subarray(8);
    const sampleEntriesEnd = sampleEntries.subarray(8 + 78);
    const fourCC = bin2str(sampleEntries.subarray(4, 8));
    let codec = fourCC;
    const encrypted = fourCC === 'enca' || fourCC === 'encv';
    if (encrypted) {
      const encBox = findBox(sampleEntries, [fourCC])[0];
      const encBoxChildren = encBox.subarray(fourCC === 'enca' ? 28 : 78);
      const sinfs = findBox(encBoxChildren, ['sinf']);
      sinfs.forEach(sinf => {
        const schm = findBox(sinf, ['schm'])[0];
        if (schm) {
          const scheme = bin2str(schm.subarray(4, 8));
          if (scheme === 'cbcs' || scheme === 'cenc') {
            const frma = findBox(sinf, ['frma'])[0];
            if (frma) {
              // for encrypted content codec fourCC will be in frma
              codec = bin2str(frma);
            }
          }
        }
      });
    }
    switch (codec) {
      case 'avc1':
      case 'avc2':
      case 'avc3':
      case 'avc4':
        {
          // extract profile + compatibility + level out of avcC box
          const avcCBox = findBox(sampleEntriesEnd, ['avcC'])[0];
          codec += '.' + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);
          break;
        }
      case 'mp4a':
        {
          const codecBox = findBox(sampleEntries, [fourCC])[0];
          const esdsBox = findBox(codecBox.subarray(28), ['esds'])[0];
          if (esdsBox && esdsBox.length > 12) {
            let i = 4;
            // ES Descriptor tag
            if (esdsBox[i++] !== 0x03) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            i += 2; // skip es_id;
            const flags = esdsBox[i++];
            if (flags & 0x80) {
              i += 2; // skip dependency es_id
            }
            if (flags & 0x40) {
              i += esdsBox[i++]; // skip URL
            }
            // Decoder config descriptor
            if (esdsBox[i++] !== 0x04) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            const objectType = esdsBox[i++];
            if (objectType === 0x40) {
              codec += '.' + toHex(objectType);
            } else {
              break;
            }
            i += 12;
            // Decoder specific info
            if (esdsBox[i++] !== 0x05) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            const firstByte = esdsBox[i++];
            let audioObjectType = (firstByte & 0xf8) >> 3;
            if (audioObjectType === 31) {
              audioObjectType += 1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);
            }
            codec += '.' + audioObjectType;
          }
          break;
        }
      case 'hvc1':
      case 'hev1':
        {
          const hvcCBox = findBox(sampleEntriesEnd, ['hvcC'])[0];
          const profileByte = hvcCBox[1];
          const profileSpace = ['', 'A', 'B', 'C'][profileByte >> 6];
          const generalProfileIdc = profileByte & 0x1f;
          const profileCompat = readUint32(hvcCBox, 2);
          const tierFlag = (profileByte & 0x20) >> 5 ? 'H' : 'L';
          const levelIDC = hvcCBox[12];
          const constraintIndicator = hvcCBox.subarray(6, 12);
          codec += '.' + profileSpace + generalProfileIdc;
          codec += '.' + profileCompat.toString(16).toUpperCase();
          codec += '.' + tierFlag + levelIDC;
          let constraintString = '';
          for (let i = constraintIndicator.length; i--;) {
            const byte = constraintIndicator[i];
            if (byte || constraintString) {
              const encodedByte = byte.toString(16).toUpperCase();
              constraintString = '.' + encodedByte + constraintString;
            }
          }
          codec += constraintString;
          break;
        }
      case 'dvh1':
      case 'dvhe':
        {
          const dvcCBox = findBox(sampleEntriesEnd, ['dvcC'])[0];
          const profile = dvcCBox[2] >> 1 & 0x7f;
          const level = dvcCBox[2] << 5 & 0x20 | dvcCBox[3] >> 3 & 0x1f;
          codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level);
          break;
        }
      case 'vp09':
        {
          const vpcCBox = findBox(sampleEntriesEnd, ['vpcC'])[0];
          const profile = vpcCBox[4];
          const level = vpcCBox[5];
          const bitDepth = vpcCBox[6] >> 4 & 0x0f;
          codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level) + '.' + addLeadingZero(bitDepth);
          break;
        }
      case 'av01':
        {
          const av1CBox = findBox(sampleEntriesEnd, ['av1C'])[0];
          const profile = av1CBox[1] >>> 5;
          const level = av1CBox[1] & 0x1f;
          const tierFlag = av1CBox[2] >>> 7 ? 'H' : 'M';
          const highBitDepth = (av1CBox[2] & 0x40) >> 6;
          const twelveBit = (av1CBox[2] & 0x20) >> 5;
          const bitDepth = profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;
          const monochrome = (av1CBox[2] & 0x10) >> 4;
          const chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;
          const chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;
          const chromaSamplePosition = av1CBox[2] & 0x03;
          // TODO: parse color_description_present_flag
          // default it to BT.709/limited range for now
          // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax
          const colorPrimaries = 1;
          const transferCharacteristics = 1;
          const matrixCoefficients = 1;
          const videoFullRangeFlag = 0;
          codec += '.' + profile + '.' + addLeadingZero(level) + tierFlag + '.' + addLeadingZero(bitDepth) + '.' + monochrome + '.' + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + '.' + addLeadingZero(colorPrimaries) + '.' + addLeadingZero(transferCharacteristics) + '.' + addLeadingZero(matrixCoefficients) + '.' + videoFullRangeFlag;
          break;
        }
    }
    return {
      codec,
      encrypted
    };
  }
  function skipBERInteger(bytes, i) {
    const limit = i + 5;
    while (bytes[i++] & 0x80 && i < limit) {}
    return i;
  }
  function toHex(x) {
    return ('0' + x.toString(16).toUpperCase()).slice(-2);
  }
  function addLeadingZero(num) {
    return (num < 10 ? '0' : '') + num;
  }
  function patchEncyptionData(initSegment, decryptdata) {
    if (!initSegment || !decryptdata) {
      return initSegment;
    }
    const keyId = decryptdata.keyId;
    if (keyId && decryptdata.isCommonEncryption) {
      const traks = findBox(initSegment, ['moov', 'trak']);
      traks.forEach(trak => {
        const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];

        // skip the sample entry count
        const sampleEntries = stsd.subarray(8);
        let encBoxes = findBox(sampleEntries, ['enca']);
        const isAudio = encBoxes.length > 0;
        if (!isAudio) {
          encBoxes = findBox(sampleEntries, ['encv']);
        }
        encBoxes.forEach(enc => {
          const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);
          const sinfBoxes = findBox(encBoxChildren, ['sinf']);
          sinfBoxes.forEach(sinf => {
            const tenc = parseSinf(sinf);
            if (tenc) {
              // Look for default key id (keyID offset is always 8 within the tenc box):
              const tencKeyId = tenc.subarray(8, 24);
              if (!tencKeyId.some(b => b !== 0)) {
                logger.log(`[eme] Patching keyId in 'enc${isAudio ? 'a' : 'v'}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);
                tenc.set(keyId, 8);
              }
            }
          });
        });
      });
    }
    return initSegment;
  }
  function parseSinf(sinf) {
    const schm = findBox(sinf, ['schm'])[0];
    if (schm) {
      const scheme = bin2str(schm.subarray(4, 8));
      if (scheme === 'cbcs' || scheme === 'cenc') {
        return findBox(sinf, ['schi', 'tenc'])[0];
      }
    }
    return null;
  }

  /**
   * Determine the base media decode start time, in seconds, for an MP4
   * fragment. If multiple fragments are specified, the earliest time is
   * returned.
   *
   * The base media decode time can be parsed from track fragment
   * metadata:
   * ```
   * moof > traf > tfdt.baseMediaDecodeTime
   * ```
   * It requires the timescale value from the mdhd to interpret.
   *
   * @param initData - a hash of track type to timescale values
   * @param fmp4 - the bytes of the mp4 fragment
   * @returns the earliest base media decode start time for the
   * fragment, in seconds
   */
  function getStartDTS(initData, fmp4) {
    // we need info from two children of each track fragment box
    return findBox(fmp4, ['moof', 'traf']).reduce((result, traf) => {
      const tfdt = findBox(traf, ['tfdt'])[0];
      const version = tfdt[0];
      const start = findBox(traf, ['tfhd']).reduce((result, tfhd) => {
        // get the track id from the tfhd
        const id = readUint32(tfhd, 4);
        const track = initData[id];
        if (track) {
          let baseTime = readUint32(tfdt, 4);
          if (version === 1) {
            // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.
            // This prevents large values from being used for initPTS, which can cause playlist sync issues.
            // https://github.com/video-dev/hls.js/issues/5303
            if (baseTime === UINT32_MAX$1) {
              logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);
              return result;
            }
            baseTime *= UINT32_MAX$1 + 1;
            baseTime += readUint32(tfdt, 8);
          }
          // assume a 90kHz clock if no timescale was specified
          const scale = track.timescale || 90e3;
          // convert base time to seconds
          const startTime = baseTime / scale;
          if (isFiniteNumber(startTime) && (result === null || startTime < result)) {
            return startTime;
          }
        }
        return result;
      }, null);
      if (start !== null && isFiniteNumber(start) && (result === null || start < result)) {
        return start;
      }
      return result;
    }, null);
  }

  /*
    For Reference:
    aligned(8) class TrackFragmentHeaderBox
             extends FullBox(‘tfhd’, 0, tf_flags){
       unsigned int(32)  track_ID;
       // all the following are optional fields
       unsigned int(64)  base_data_offset;
       unsigned int(32)  sample_description_index;
       unsigned int(32)  default_sample_duration;
       unsigned int(32)  default_sample_size;
       unsigned int(32)  default_sample_flags
    }
   */
  function getDuration(data, initData) {
    let rawDuration = 0;
    let videoDuration = 0;
    let audioDuration = 0;
    const trafs = findBox(data, ['moof', 'traf']);
    for (let i = 0; i < trafs.length; i++) {
      const traf = trafs[i];
      // There is only one tfhd & trun per traf
      // This is true for CMAF style content, and we should perhaps check the ftyp
      // and only look for a single trun then, but for ISOBMFF we should check
      // for multiple track runs.
      const tfhd = findBox(traf, ['tfhd'])[0];
      // get the track id from the tfhd
      const id = readUint32(tfhd, 4);
      const track = initData[id];
      if (!track) {
        continue;
      }
      const trackDefault = track.default;
      const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);
      let sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;
      if (tfhdFlags & 0x000008) {
        // 0x000008 indicates the presence of the default_sample_duration field
        if (tfhdFlags & 0x000002) {
          // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration
          // If present, the default_sample_duration exists at byte offset 12
          sampleDuration = readUint32(tfhd, 12);
        } else {
          // Otherwise, the duration is at byte offset 8
          sampleDuration = readUint32(tfhd, 8);
        }
      }
      // assume a 90kHz clock if no timescale was specified
      const timescale = track.timescale || 90e3;
      const truns = findBox(traf, ['trun']);
      for (let j = 0; j < truns.length; j++) {
        rawDuration = computeRawDurationFromSamples(truns[j]);
        if (!rawDuration && sampleDuration) {
          const sampleCount = readUint32(truns[j], 4);
          rawDuration = sampleDuration * sampleCount;
        }
        if (track.type === ElementaryStreamTypes.VIDEO) {
          videoDuration += rawDuration / timescale;
        } else if (track.type === ElementaryStreamTypes.AUDIO) {
          audioDuration += rawDuration / timescale;
        }
      }
    }
    if (videoDuration === 0 && audioDuration === 0) {
      // If duration samples are not available in the traf use sidx subsegment_duration
      let sidxMinStart = Infinity;
      let sidxMaxEnd = 0;
      let sidxDuration = 0;
      const sidxs = findBox(data, ['sidx']);
      for (let i = 0; i < sidxs.length; i++) {
        const sidx = parseSegmentIndex(sidxs[i]);
        if (sidx != null && sidx.references) {
          sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);
          const subSegmentDuration = sidx.references.reduce((dur, ref) => dur + ref.info.duration || 0, 0);
          sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);
          sidxDuration = sidxMaxEnd - sidxMinStart;
        }
      }
      if (sidxDuration && isFiniteNumber(sidxDuration)) {
        return sidxDuration;
      }
    }
    if (videoDuration) {
      return videoDuration;
    }
    return audioDuration;
  }

  /*
    For Reference:
    aligned(8) class TrackRunBox
             extends FullBox(‘trun’, version, tr_flags) {
       unsigned int(32)  sample_count;
       // the following are optional fields
       signed int(32) data_offset;
       unsigned int(32)  first_sample_flags;
       // all fields in the following array are optional
       {
          unsigned int(32)  sample_duration;
          unsigned int(32)  sample_size;
          unsigned int(32)  sample_flags
          if (version == 0)
             { unsigned int(32)
          else
             { signed int(32)
       }[ sample_count ]
    }
   */
  function computeRawDurationFromSamples(trun) {
    const flags = readUint32(trun, 0);
    // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.
    // Each field is an int32, which is 4 bytes
    let offset = 8;
    // data-offset-present flag
    if (flags & 0x000001) {
      offset += 4;
    }
    // first-sample-flags-present flag
    if (flags & 0x000004) {
      offset += 4;
    }
    let duration = 0;
    const sampleCount = readUint32(trun, 4);
    for (let i = 0; i < sampleCount; i++) {
      // sample-duration-present flag
      if (flags & 0x000100) {
        const sampleDuration = readUint32(trun, offset);
        duration += sampleDuration;
        offset += 4;
      }
      // sample-size-present flag
      if (flags & 0x000200) {
        offset += 4;
      }
      // sample-flags-present flag
      if (flags & 0x000400) {
        offset += 4;
      }
      // sample-composition-time-offsets-present flag
      if (flags & 0x000800) {
        offset += 4;
      }
    }
    return duration;
  }
  function offsetStartDTS(initData, fmp4, timeOffset) {
    findBox(fmp4, ['moof', 'traf']).forEach(traf => {
      findBox(traf, ['tfhd']).forEach(tfhd => {
        // get the track id from the tfhd
        const id = readUint32(tfhd, 4);
        const track = initData[id];
        if (!track) {
          return;
        }
        // assume a 90kHz clock if no timescale was specified
        const timescale = track.timescale || 90e3;
        // get the base media decode time from the tfdt
        findBox(traf, ['tfdt']).forEach(tfdt => {
          const version = tfdt[0];
          const offset = timeOffset * timescale;
          if (offset) {
            let baseMediaDecodeTime = readUint32(tfdt, 4);
            if (version === 0) {
              baseMediaDecodeTime -= offset;
              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
              writeUint32(tfdt, 4, baseMediaDecodeTime);
            } else {
              baseMediaDecodeTime *= Math.pow(2, 32);
              baseMediaDecodeTime += readUint32(tfdt, 8);
              baseMediaDecodeTime -= offset;
              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
              const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));
              const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));
              writeUint32(tfdt, 4, upper);
              writeUint32(tfdt, 8, lower);
            }
          }
        });
      });
    });
  }

  // TODO: Check if the last moof+mdat pair is part of the valid range
  function segmentValidRange(data) {
    const segmentedRange = {
      valid: null,
      remainder: null
    };
    const moofs = findBox(data, ['moof']);
    if (moofs.length < 2) {
      segmentedRange.remainder = data;
      return segmentedRange;
    }
    const last = moofs[moofs.length - 1];
    // Offset by 8 bytes; findBox offsets the start by as much
    segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);
    segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);
    return segmentedRange;
  }
  function appendUint8Array(data1, data2) {
    const temp = new Uint8Array(data1.length + data2.length);
    temp.set(data1);
    temp.set(data2, data1.length);
    return temp;
  }
  function parseSamples(timeOffset, track) {
    const seiSamples = [];
    const videoData = track.samples;
    const timescale = track.timescale;
    const trackId = track.id;
    let isHEVCFlavor = false;
    const moofs = findBox(videoData, ['moof']);
    moofs.map(moof => {
      const moofOffset = moof.byteOffset - 8;
      const trafs = findBox(moof, ['traf']);
      trafs.map(traf => {
        // get the base media decode time from the tfdt
        const baseTime = findBox(traf, ['tfdt']).map(tfdt => {
          const version = tfdt[0];
          let result = readUint32(tfdt, 4);
          if (version === 1) {
            result *= Math.pow(2, 32);
            result += readUint32(tfdt, 8);
          }
          return result / timescale;
        })[0];
        if (baseTime !== undefined) {
          timeOffset = baseTime;
        }
        return findBox(traf, ['tfhd']).map(tfhd => {
          const id = readUint32(tfhd, 4);
          const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;
          const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;
          const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;
          const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;
          let defaultSampleDuration = 0;
          const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;
          let defaultSampleSize = 0;
          const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;
          let tfhdOffset = 8;
          if (id === trackId) {
            if (baseDataOffsetPresent) {
              tfhdOffset += 8;
            }
            if (sampleDescriptionIndexPresent) {
              tfhdOffset += 4;
            }
            if (defaultSampleDurationPresent) {
              defaultSampleDuration = readUint32(tfhd, tfhdOffset);
              tfhdOffset += 4;
            }
            if (defaultSampleSizePresent) {
              defaultSampleSize = readUint32(tfhd, tfhdOffset);
              tfhdOffset += 4;
            }
            if (defaultSampleFlagsPresent) {
              tfhdOffset += 4;
            }
            if (track.type === 'video') {
              isHEVCFlavor = isHEVC(track.codec);
            }
            findBox(traf, ['trun']).map(trun => {
              const version = trun[0];
              const flags = readUint32(trun, 0) & 0xffffff;
              const dataOffsetPresent = (flags & 0x000001) !== 0;
              let dataOffset = 0;
              const firstSampleFlagsPresent = (flags & 0x000004) !== 0;
              const sampleDurationPresent = (flags & 0x000100) !== 0;
              let sampleDuration = 0;
              const sampleSizePresent = (flags & 0x000200) !== 0;
              let sampleSize = 0;
              const sampleFlagsPresent = (flags & 0x000400) !== 0;
              const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;
              let compositionOffset = 0;
              const sampleCount = readUint32(trun, 4);
              let trunOffset = 8; // past version, flags, and sample count

              if (dataOffsetPresent) {
                dataOffset = readUint32(trun, trunOffset);
                trunOffset += 4;
              }
              if (firstSampleFlagsPresent) {
                trunOffset += 4;
              }
              let sampleOffset = dataOffset + moofOffset;
              for (let ix = 0; ix < sampleCount; ix++) {
                if (sampleDurationPresent) {
                  sampleDuration = readUint32(trun, trunOffset);
                  trunOffset += 4;
                } else {
                  sampleDuration = defaultSampleDuration;
                }
                if (sampleSizePresent) {
                  sampleSize = readUint32(trun, trunOffset);
                  trunOffset += 4;
                } else {
                  sampleSize = defaultSampleSize;
                }
                if (sampleFlagsPresent) {
                  trunOffset += 4;
                }
                if (sampleCompositionOffsetsPresent) {
                  if (version === 0) {
                    compositionOffset = readUint32(trun, trunOffset);
                  } else {
                    compositionOffset = readSint32(trun, trunOffset);
                  }
                  trunOffset += 4;
                }
                if (track.type === ElementaryStreamTypes.VIDEO) {
                  let naluTotalSize = 0;
                  while (naluTotalSize < sampleSize) {
                    const naluSize = readUint32(videoData, sampleOffset);
                    sampleOffset += 4;
                    if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {
                      const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);
                      parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);
                    }
                    sampleOffset += naluSize;
                    naluTotalSize += naluSize + 4;
                  }
                }
                timeOffset += sampleDuration / timescale;
              }
            });
          }
        });
      });
    });
    return seiSamples;
  }
  function isHEVC(codec) {
    if (!codec) {
      return false;
    }
    const delimit = codec.indexOf('.');
    const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);
    return baseCodec === 'hvc1' || baseCodec === 'hev1' ||
    // Dolby Vision
    baseCodec === 'dvh1' || baseCodec === 'dvhe';
  }
  function isSEIMessage(isHEVCFlavor, naluHeader) {
    if (isHEVCFlavor) {
      const naluType = naluHeader >> 1 & 0x3f;
      return naluType === 39 || naluType === 40;
    } else {
      const naluType = naluHeader & 0x1f;
      return naluType === 6;
    }
  }
  function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {
    const data = discardEPB(unescapedData);
    let seiPtr = 0;
    // skip nal header
    seiPtr += headerSize;
    let payloadType = 0;
    let payloadSize = 0;
    let b = 0;
    while (seiPtr < data.length) {
      payloadType = 0;
      do {
        if (seiPtr >= data.length) {
          break;
        }
        b = data[seiPtr++];
        payloadType += b;
      } while (b === 0xff);

      // Parse payload size.
      payloadSize = 0;
      do {
        if (seiPtr >= data.length) {
          break;
        }
        b = data[seiPtr++];
        payloadSize += b;
      } while (b === 0xff);
      const leftOver = data.length - seiPtr;
      // Create a variable to process the payload
      let payPtr = seiPtr;

      // Increment the seiPtr to the end of the payload
      if (payloadSize < leftOver) {
        seiPtr += payloadSize;
      } else if (payloadSize > leftOver) {
        // Some type of corruption has happened?
        logger.error(`Malformed SEI payload. ${payloadSize} is too small, only ${leftOver} bytes left to parse.`);
        // We might be able to parse some data, but let's be safe and ignore it.
        break;
      }
      if (payloadType === 4) {
        const countryCode = data[payPtr++];
        if (countryCode === 181) {
          const providerCode = readUint16(data, payPtr);
          payPtr += 2;
          if (providerCode === 49) {
            const userStructure = readUint32(data, payPtr);
            payPtr += 4;
            if (userStructure === 0x47413934) {
              const userDataType = data[payPtr++];

              // Raw CEA-608 bytes wrapped in CEA-708 packet
              if (userDataType === 3) {
                const firstByte = data[payPtr++];
                const totalCCs = 0x1f & firstByte;
                const enabled = 0x40 & firstByte;
                const totalBytes = enabled ? 2 + totalCCs * 3 : 0;
                const byteArray = new Uint8Array(totalBytes);
                if (enabled) {
                  byteArray[0] = firstByte;
                  for (let i = 1; i < totalBytes; i++) {
                    byteArray[i] = data[payPtr++];
                  }
                }
                samples.push({
                  type: userDataType,
                  payloadType,
                  pts,
                  bytes: byteArray
                });
              }
            }
          }
        }
      } else if (payloadType === 5) {
        if (payloadSize > 16) {
          const uuidStrArray = [];
          for (let i = 0; i < 16; i++) {
            const _b = data[payPtr++].toString(16);
            uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);
            if (i === 3 || i === 5 || i === 7 || i === 9) {
              uuidStrArray.push('-');
            }
          }
          const length = payloadSize - 16;
          const userDataBytes = new Uint8Array(length);
          for (let i = 0; i < length; i++) {
            userDataBytes[i] = data[payPtr++];
          }
          samples.push({
            payloadType,
            pts,
            uuid: uuidStrArray.join(''),
            userData: utf8ArrayToStr(userDataBytes),
            userDataBytes
          });
        }
      }
    }
  }

  /**
   * remove Emulation Prevention bytes from a RBSP
   */
  function discardEPB(data) {
    const length = data.byteLength;
    const EPBPositions = [];
    let i = 1;

    // Find all `Emulation Prevention Bytes`
    while (i < length - 2) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
        EPBPositions.push(i + 2);
        i += 2;
      } else {
        i++;
      }
    }

    // If no Emulation Prevention Bytes were found just return the original
    // array
    if (EPBPositions.length === 0) {
      return data;
    }

    // Create a new array to hold the NAL unit data
    const newLength = length - EPBPositions.length;
    const newData = new Uint8Array(newLength);
    let sourceIndex = 0;
    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === EPBPositions[0]) {
        // Skip this byte
        sourceIndex++;
        // Remove this position index
        EPBPositions.shift();
      }
      newData[i] = data[sourceIndex];
    }
    return newData;
  }
  function parseEmsg(data) {
    const version = data[0];
    let schemeIdUri = '';
    let value = '';
    let timeScale = 0;
    let presentationTimeDelta = 0;
    let presentationTime = 0;
    let eventDuration = 0;
    let id = 0;
    let offset = 0;
    if (version === 0) {
      while (bin2str(data.subarray(offset, offset + 1)) !== '\0') {
        schemeIdUri += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
      while (bin2str(data.subarray(offset, offset + 1)) !== '\0') {
        value += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      value += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
      timeScale = readUint32(data, 12);
      presentationTimeDelta = readUint32(data, 16);
      eventDuration = readUint32(data, 20);
      id = readUint32(data, 24);
      offset = 28;
    } else if (version === 1) {
      offset += 4;
      timeScale = readUint32(data, offset);
      offset += 4;
      const leftPresentationTime = readUint32(data, offset);
      offset += 4;
      const rightPresentationTime = readUint32(data, offset);
      offset += 4;
      presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;
      if (!isSafeInteger(presentationTime)) {
        presentationTime = Number.MAX_SAFE_INTEGER;
        logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');
      }
      eventDuration = readUint32(data, offset);
      offset += 4;
      id = readUint32(data, offset);
      offset += 4;
      while (bin2str(data.subarray(offset, offset + 1)) !== '\0') {
        schemeIdUri += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
      while (bin2str(data.subarray(offset, offset + 1)) !== '\0') {
        value += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      value += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
    }
    const payload = data.subarray(offset, data.byteLength);
    return {
      schemeIdUri,
      value,
      timeScale,
      presentationTime,
      presentationTimeDelta,
      eventDuration,
      id,
      payload
    };
  }
  function mp4Box(type, ...payload) {
    const len = payload.length;
    let size = 8;
    let i = len;
    while (i--) {
      size += payload[i].byteLength;
    }
    const result = new Uint8Array(size);
    result[0] = size >> 24 & 0xff;
    result[1] = size >> 16 & 0xff;
    result[2] = size >> 8 & 0xff;
    result[3] = size & 0xff;
    result.set(type, 4);
    for (i = 0, size = 8; i < len; i++) {
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }
    return result;
  }
  function mp4pssh(systemId, keyids, data) {
    if (systemId.byteLength !== 16) {
      throw new RangeError('Invalid system id');
    }
    let version;
    let kids;
    {
      version = 0;
      kids = new Uint8Array();
    }
    let kidCount;
    if (version > 0) {
      kidCount = new Uint8Array(4);
      if (keyids.length > 0) {
        new DataView(kidCount.buffer).setUint32(0, keyids.length, false);
      }
    } else {
      kidCount = new Uint8Array();
    }
    const dataSize = new Uint8Array(4);
    if (data && data.byteLength > 0) {
      new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);
    }
    return mp4Box([112, 115, 115, 104], new Uint8Array([version, 0x00, 0x00, 0x00 // Flags
    ]), systemId,
    // 16 bytes
    kidCount, kids, dataSize, data || new Uint8Array());
  }
  function parseMultiPssh(initData) {
    const results = [];
    if (initData instanceof ArrayBuffer) {
      const length = initData.byteLength;
      let offset = 0;
      while (offset + 32 < length) {
        const view = new DataView(initData, offset);
        const pssh = parsePssh(view);
        results.push(pssh);
        offset += pssh.size;
      }
    }
    return results;
  }
  function parsePssh(view) {
    const size = view.getUint32(0);
    const offset = view.byteOffset;
    const length = view.byteLength;
    if (length < size) {
      return {
        offset,
        size: length
      };
    }
    const type = view.getUint32(4);
    if (type !== 0x70737368) {
      return {
        offset,
        size
      };
    }
    const version = view.getUint32(8) >>> 24;
    if (version !== 0 && version !== 1) {
      return {
        offset,
        size
      };
    }
    const buffer = view.buffer;
    const systemId = Hex.hexDump(new Uint8Array(buffer, offset + 12, 16));
    const dataSizeOrKidCount = view.getUint32(28);
    let kids = null;
    let data = null;
    if (version === 0) {
      if (size - 32 < dataSizeOrKidCount || dataSizeOrKidCount < 22) {
        return {
          offset,
          size
        };
      }
      data = new Uint8Array(buffer, offset + 32, dataSizeOrKidCount);
    } else if (version === 1) {
      if (!dataSizeOrKidCount || length < offset + 32 + dataSizeOrKidCount * 16 + 16) {
        return {
          offset,
          size
        };
      }
      kids = [];
      for (let i = 0; i < dataSizeOrKidCount; i++) {
        kids.push(new Uint8Array(buffer, offset + 32 + i * 16, 16));
      }
    }
    return {
      version,
      systemId,
      kids,
      data,
      offset,
      size
    };
  }

  let keyUriToKeyIdMap = {};
  class LevelKey {
    static clearKeyUriToKeyIdMap() {
      keyUriToKeyIdMap = {};
    }
    constructor(method, uri, format, formatversions = [1], iv = null) {
      this.uri = void 0;
      this.method = void 0;
      this.keyFormat = void 0;
      this.keyFormatVersions = void 0;
      this.encrypted = void 0;
      this.isCommonEncryption = void 0;
      this.iv = null;
      this.key = null;
      this.keyId = null;
      this.pssh = null;
      this.method = method;
      this.uri = uri;
      this.keyFormat = format;
      this.keyFormatVersions = formatversions;
      this.iv = iv;
      this.encrypted = method ? method !== 'NONE' : false;
      this.isCommonEncryption = this.encrypted && method !== 'AES-128';
    }
    isSupported() {
      // If it's Segment encryption or No encryption, just select that key system
      if (this.method) {
        if (this.method === 'AES-128' || this.method === 'NONE') {
          return true;
        }
        if (this.keyFormat === 'identity') {
          // Maintain support for clear SAMPLE-AES with MPEG-3 TS
          return this.method === 'SAMPLE-AES';
        } else {
          switch (this.keyFormat) {
            case KeySystemFormats.FAIRPLAY:
            case KeySystemFormats.WIDEVINE:
            case KeySystemFormats.PLAYREADY:
            case KeySystemFormats.CLEARKEY:
              return ['ISO-23001-7', 'SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(this.method) !== -1;
          }
        }
      }
      return false;
    }
    getDecryptData(sn) {
      if (!this.encrypted || !this.uri) {
        return null;
      }
      if (this.method === 'AES-128' && this.uri && !this.iv) {
        if (typeof sn !== 'number') {
          // We are fetching decryption data for a initialization segment
          // If the segment was encrypted with AES-128
          // It must have an IV defined. We cannot substitute the Segment Number in.
          if (this.method === 'AES-128' && !this.iv) {
            logger.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`);
          }
          // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.
          sn = 0;
        }
        const iv = createInitializationVector(sn);
        const decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);
        return decryptdata;
      }

      // Initialize keyId if possible
      const keyBytes = convertDataUriToArrayBytes(this.uri);
      if (keyBytes) {
        switch (this.keyFormat) {
          case KeySystemFormats.WIDEVINE:
            this.pssh = keyBytes;
            // In case of widevine keyID is embedded in PSSH box. Read Key ID.
            if (keyBytes.length >= 22) {
              this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);
            }
            break;
          case KeySystemFormats.PLAYREADY:
            {
              const PlayReadyKeySystemUUID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);
              this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);
              const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);
              const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));

              // Parse Playready WRMHeader XML
              const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf('<'), keyByteStr.length);
              const parser = new DOMParser();
              const xmlDoc = parser.parseFromString(xmlKeyBytes, 'text/xml');
              const keyData = xmlDoc.getElementsByTagName('KID')[0];
              if (keyData) {
                const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute('VALUE');
                if (keyId) {
                  const keyIdArray = base64Decode(keyId).subarray(0, 16);
                  // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID
                  // KID value in ‘tenc’ is a big endian UUID GUID interpretation of UUID
                  changeEndianness(keyIdArray);
                  this.keyId = keyIdArray;
                }
              }
              break;
            }
          default:
            {
              let keydata = keyBytes.subarray(0, 16);
              if (keydata.length !== 16) {
                const padded = new Uint8Array(16);
                padded.set(keydata, 16 - keydata.length);
                keydata = padded;
              }
              this.keyId = keydata;
              break;
            }
        }
      }

      // Default behavior: assign a new keyId for each uri
      if (!this.keyId || this.keyId.byteLength !== 16) {
        let keyId = keyUriToKeyIdMap[this.uri];
        if (!keyId) {
          const val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;
          keyId = new Uint8Array(16);
          const dv = new DataView(keyId.buffer, 12, 4); // Just set the last 4 bytes
          dv.setUint32(0, val);
          keyUriToKeyIdMap[this.uri] = keyId;
        }
        this.keyId = keyId;
      }
      return this;
    }
  }
  function createInitializationVector(segmentNumber) {
    const uint8View = new Uint8Array(16);
    for (let i = 12; i < 16; i++) {
      uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
    }
    return uint8View;
  }

  const VARIABLE_REPLACEMENT_REGEX = /\{\$([a-zA-Z0-9-_]+)\}/g;
  function hasVariableReferences(str) {
    return VARIABLE_REPLACEMENT_REGEX.test(str);
  }
  function substituteVariablesInAttributes(parsed, attr, attributeNames) {
    if (parsed.variableList !== null || parsed.hasVariableRefs) {
      for (let i = attributeNames.length; i--;) {
        const name = attributeNames[i];
        const value = attr[name];
        if (value) {
          attr[name] = substituteVariables(parsed, value);
        }
      }
    }
  }
  function substituteVariables(parsed, value) {
    if (parsed.variableList !== null || parsed.hasVariableRefs) {
      const variableList = parsed.variableList;
      return value.replace(VARIABLE_REPLACEMENT_REGEX, variableReference => {
        const variableName = variableReference.substring(2, variableReference.length - 1);
        const variableValue = variableList == null ? void 0 : variableList[variableName];
        if (variableValue === undefined) {
          parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${variableName}"`));
          return variableReference;
        }
        return variableValue;
      });
    }
    return value;
  }
  function addVariableDefinition(parsed, attr, parentUrl) {
    let variableList = parsed.variableList;
    if (!variableList) {
      parsed.variableList = variableList = {};
    }
    let NAME;
    let VALUE;
    if ('QUERYPARAM' in attr) {
      NAME = attr.QUERYPARAM;
      try {
        const searchParams = new self.URL(parentUrl).searchParams;
        if (searchParams.has(NAME)) {
          VALUE = searchParams.get(NAME);
        } else {
          throw new Error(`"${NAME}" does not match any query parameter in URI: "${parentUrl}"`);
        }
      } catch (error) {
        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));
      }
    } else {
      NAME = attr.NAME;
      VALUE = attr.VALUE;
    }
    if (NAME in variableList) {
      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${NAME}"`));
    } else {
      variableList[NAME] = VALUE || '';
    }
  }
  function importVariableDefinition(parsed, attr, sourceVariableList) {
    const IMPORT = attr.IMPORT;
    if (sourceVariableList && IMPORT in sourceVariableList) {
      let variableList = parsed.variableList;
      if (!variableList) {
        parsed.variableList = variableList = {};
      }
      variableList[IMPORT] = sourceVariableList[IMPORT];
    } else {
      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${IMPORT}"`));
    }
  }

  /**
   * MediaSource helper
   */

  function getMediaSource(preferManagedMediaSource = true) {
    if (typeof self === 'undefined') return undefined;
    const mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;
    return mms || self.MediaSource || self.WebKitMediaSource;
  }
  function isManagedMediaSource(source) {
    return typeof self !== 'undefined' && source === self.ManagedMediaSource;
  }

  // from http://mp4ra.org/codecs.html
  // values indicate codec selection preference (lower is higher priority)
  const sampleEntryCodesISO = {
    audio: {
      a3ds: 1,
      'ac-3': 0.95,
      'ac-4': 1,
      alac: 0.9,
      alaw: 1,
      dra1: 1,
      'dts+': 1,
      'dts-': 1,
      dtsc: 1,
      dtse: 1,
      dtsh: 1,
      'ec-3': 0.9,
      enca: 1,
      fLaC: 0.9,
      // MP4-RA listed codec entry for FLAC
      flac: 0.9,
      // legacy browser codec name for FLAC
      FLAC: 0.9,
      // some manifests may list "FLAC" with Apple's tools
      g719: 1,
      g726: 1,
      m4ae: 1,
      mha1: 1,
      mha2: 1,
      mhm1: 1,
      mhm2: 1,
      mlpa: 1,
      mp4a: 1,
      'raw ': 1,
      Opus: 1,
      opus: 1,
      // browsers expect this to be lowercase despite MP4RA says 'Opus'
      samr: 1,
      sawb: 1,
      sawp: 1,
      sevc: 1,
      sqcp: 1,
      ssmv: 1,
      twos: 1,
      ulaw: 1
    },
    video: {
      avc1: 1,
      avc2: 1,
      avc3: 1,
      avc4: 1,
      avcp: 1,
      av01: 0.8,
      drac: 1,
      dva1: 1,
      dvav: 1,
      dvh1: 0.7,
      dvhe: 0.7,
      encv: 1,
      hev1: 0.75,
      hvc1: 0.75,
      mjp2: 1,
      mp4v: 1,
      mvc1: 1,
      mvc2: 1,
      mvc3: 1,
      mvc4: 1,
      resv: 1,
      rv60: 1,
      s263: 1,
      svc1: 1,
      svc2: 1,
      'vc-1': 1,
      vp08: 1,
      vp09: 0.9
    },
    text: {
      stpp: 1,
      wvtt: 1
    }
  };
  function isCodecType(codec, type) {
    const typeCodes = sampleEntryCodesISO[type];
    return !!typeCodes && !!typeCodes[codec.slice(0, 4)];
  }
  function areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource = true) {
    return !codecs.split(',').some(codec => !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource));
  }
  function isCodecMediaSourceSupported(codec, type, preferManagedMediaSource = true) {
    var _MediaSource$isTypeSu;
    const MediaSource = getMediaSource(preferManagedMediaSource);
    return (_MediaSource$isTypeSu = MediaSource == null ? void 0 : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;
  }
  function mimeTypeForCodec(codec, type) {
    return `${type}/mp4;codecs="${codec}"`;
  }
  function videoCodecPreferenceValue(videoCodec) {
    if (videoCodec) {
      const fourCC = videoCodec.substring(0, 4);
      return sampleEntryCodesISO.video[fourCC];
    }
    return 2;
  }
  function codecsSetSelectionPreferenceValue(codecSet) {
    return codecSet.split(',').reduce((num, fourCC) => {
      const preferenceValue = sampleEntryCodesISO.video[fourCC];
      if (preferenceValue) {
        return (preferenceValue * 2 + num) / (num ? 3 : 2);
      }
      return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);
    }, 0);
  }
  const CODEC_COMPATIBLE_NAMES = {};
  function getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource = true) {
    if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {
      return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];
    }

    // Idealy fLaC and Opus would be first (spec-compliant) but
    // some browsers will report that fLaC is supported then fail.
    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728
    const codecsToCheck = {
      flac: ['flac', 'fLaC', 'FLAC'],
      opus: ['opus', 'Opus']
    }[lowerCaseCodec];
    for (let i = 0; i < codecsToCheck.length; i++) {
      if (isCodecMediaSourceSupported(codecsToCheck[i], 'audio', preferManagedMediaSource)) {
        CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];
        return codecsToCheck[i];
      }
    }
    return lowerCaseCodec;
  }
  const AUDIO_CODEC_REGEXP = /flac|opus/i;
  function getCodecCompatibleName(codec, preferManagedMediaSource = true) {
    return codec.replace(AUDIO_CODEC_REGEXP, m => getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource));
  }
  function pickMostCompleteCodecName(parsedCodec, levelCodec) {
    // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a
    // so use level codec is parsed codec is unavailable or incomplete
    if (parsedCodec && parsedCodec !== 'mp4a') {
      return parsedCodec;
    }
    return levelCodec ? levelCodec.split(',')[0] : levelCodec;
  }
  function convertAVC1ToAVCOTI(codec) {
    // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported
    // Examples: avc1.66.30 to avc1.42001e and avc1.77.30,avc1.66.30 to avc1.4d001e,avc1.42001e.
    const codecs = codec.split(',');
    for (let i = 0; i < codecs.length; i++) {
      const avcdata = codecs[i].split('.');
      if (avcdata.length > 2) {
        let result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).slice(-4);
        codecs[i] = result;
      }
    }
    return codecs.join(',');
  }

  const MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g;
  const MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
  const IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)

  const LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
  // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
  /(?!#) *(\S[^\r\n]*)/.source,
  // segment URI, group 3 => the URI (note newline is not eaten)
  /#EXT-X-BYTERANGE:*(.+)/.source,
  // next segment's byterange, group 4 => range spec (x@y)
  /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
  // next segment's program date/time group 5 => the datetime spec
  /#.*/.source // All other non-segment oriented tags will match with all groups empty
  ].join('|'), 'g');
  const LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join('|'));
  class M3U8Parser {
    static findGroup(groups, mediaGroupId) {
      for (let i = 0; i < groups.length; i++) {
        const group = groups[i];
        if (group.id === mediaGroupId) {
          return group;
        }
      }
    }
    static resolve(url, baseUrl) {
      return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {
        alwaysNormalize: true
      });
    }
    static isMediaPlaylist(str) {
      return IS_MEDIA_PLAYLIST.test(str);
    }
    static parseMasterPlaylist(string, baseurl) {
      const hasVariableRefs = hasVariableReferences(string) ;
      const parsed = {
        contentSteering: null,
        levels: [],
        playlistParsingError: null,
        sessionData: null,
        sessionKeys: null,
        startTimeOffset: null,
        variableList: null,
        hasVariableRefs
      };
      const levelsWithKnownCodecs = [];
      MASTER_PLAYLIST_REGEX.lastIndex = 0;
      let result;
      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
        if (result[1]) {
          var _level$unknownCodecs;
          // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1
          const attrs = new AttrList(result[1]);
          {
            substituteVariablesInAttributes(parsed, attrs, ['CODECS', 'SUPPLEMENTAL-CODECS', 'ALLOWED-CPC', 'PATHWAY-ID', 'STABLE-VARIANT-ID', 'AUDIO', 'VIDEO', 'SUBTITLES', 'CLOSED-CAPTIONS', 'NAME']);
          }
          const uri = substituteVariables(parsed, result[2]) ;
          const level = {
            attrs,
            bitrate: attrs.decimalInteger('BANDWIDTH') || attrs.decimalInteger('AVERAGE-BANDWIDTH'),
            name: attrs.NAME,
            url: M3U8Parser.resolve(uri, baseurl)
          };
          const resolution = attrs.decimalResolution('RESOLUTION');
          if (resolution) {
            level.width = resolution.width;
            level.height = resolution.height;
          }
          setCodecs(attrs.CODECS, level);
          if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {
            levelsWithKnownCodecs.push(level);
          }
          parsed.levels.push(level);
        } else if (result[3]) {
          const tag = result[3];
          const attributes = result[4];
          switch (tag) {
            case 'SESSION-DATA':
              {
                // #EXT-X-SESSION-DATA
                const sessionAttrs = new AttrList(attributes);
                {
                  substituteVariablesInAttributes(parsed, sessionAttrs, ['DATA-ID', 'LANGUAGE', 'VALUE', 'URI']);
                }
                const dataId = sessionAttrs['DATA-ID'];
                if (dataId) {
                  if (parsed.sessionData === null) {
                    parsed.sessionData = {};
                  }
                  parsed.sessionData[dataId] = sessionAttrs;
                }
                break;
              }
            case 'SESSION-KEY':
              {
                // #EXT-X-SESSION-KEY
                const sessionKey = parseKey(attributes, baseurl, parsed);
                if (sessionKey.encrypted && sessionKey.isSupported()) {
                  if (parsed.sessionKeys === null) {
                    parsed.sessionKeys = [];
                  }
                  parsed.sessionKeys.push(sessionKey);
                } else {
                  logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${attributes}"`);
                }
                break;
              }
            case 'DEFINE':
              {
                // #EXT-X-DEFINE
                {
                  const variableAttributes = new AttrList(attributes);
                  substituteVariablesInAttributes(parsed, variableAttributes, ['NAME', 'VALUE', 'QUERYPARAM']);
                  addVariableDefinition(parsed, variableAttributes, baseurl);
                }
                break;
              }
            case 'CONTENT-STEERING':
              {
                // #EXT-X-CONTENT-STEERING
                const contentSteeringAttributes = new AttrList(attributes);
                {
                  substituteVariablesInAttributes(parsed, contentSteeringAttributes, ['SERVER-URI', 'PATHWAY-ID']);
                }
                parsed.contentSteering = {
                  uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),
                  pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'
                };
                break;
              }
            case 'START':
              {
                // #EXT-X-START
                parsed.startTimeOffset = parseStartTimeOffset(attributes);
                break;
              }
          }
        }
      }
      // Filter out levels with unknown codecs if it does not remove all levels
      const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;
      parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;
      if (parsed.levels.length === 0) {
        parsed.playlistParsingError = new Error('no levels found in manifest');
      }
      return parsed;
    }
    static parseMasterPlaylistMedia(string, baseurl, parsed) {
      let result;
      const results = {};
      const levels = parsed.levels;
      const groupsByType = {
        AUDIO: levels.map(level => ({
          id: level.attrs.AUDIO,
          audioCodec: level.audioCodec
        })),
        SUBTITLES: levels.map(level => ({
          id: level.attrs.SUBTITLES,
          textCodec: level.textCodec
        })),
        'CLOSED-CAPTIONS': []
      };
      let id = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
        const attrs = new AttrList(result[1]);
        const type = attrs.TYPE;
        if (type) {
          const groups = groupsByType[type];
          const medias = results[type] || [];
          results[type] = medias;
          {
            substituteVariablesInAttributes(parsed, attrs, ['URI', 'GROUP-ID', 'LANGUAGE', 'ASSOC-LANGUAGE', 'STABLE-RENDITION-ID', 'NAME', 'INSTREAM-ID', 'CHARACTERISTICS', 'CHANNELS']);
          }
          const lang = attrs.LANGUAGE;
          const assocLang = attrs['ASSOC-LANGUAGE'];
          const channels = attrs.CHANNELS;
          const characteristics = attrs.CHARACTERISTICS;
          const instreamId = attrs['INSTREAM-ID'];
          const media = {
            attrs,
            bitrate: 0,
            id: id++,
            groupId: attrs['GROUP-ID'] || '',
            name: attrs.NAME || lang || '',
            type,
            default: attrs.bool('DEFAULT'),
            autoselect: attrs.bool('AUTOSELECT'),
            forced: attrs.bool('FORCED'),
            lang,
            url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''
          };
          if (assocLang) {
            media.assocLang = assocLang;
          }
          if (channels) {
            media.channels = channels;
          }
          if (characteristics) {
            media.characteristics = characteristics;
          }
          if (instreamId) {
            media.instreamId = instreamId;
          }
          if (groups != null && groups.length) {
            // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track
            // If we don't find the track signalled, lets use the first audio groups codec we have
            // Acting as a best guess
            const groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];
            assignCodec(media, groupCodec, 'audioCodec');
            assignCodec(media, groupCodec, 'textCodec');
          }
          medias.push(media);
        }
      }
      return results;
    }
    static parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {
      const level = new LevelDetails(baseurl);
      const fragments = level.fragments;
      // The most recent init segment seen (applies to all subsequent segments)
      let currentInitSegment = null;
      let currentSN = 0;
      let currentPart = 0;
      let totalduration = 0;
      let discontinuityCounter = 0;
      let prevFrag = null;
      let frag = new Fragment(type, baseurl);
      let result;
      let i;
      let levelkeys;
      let firstPdtIndex = -1;
      let createNextFrag = false;
      let nextByteRange = null;
      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
      level.m3u8 = string;
      level.hasVariableRefs = hasVariableReferences(string) ;
      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
        if (createNextFrag) {
          createNextFrag = false;
          frag = new Fragment(type, baseurl);
          // setup the next fragment for part loading
          frag.start = totalduration;
          frag.sn = currentSN;
          frag.cc = discontinuityCounter;
          frag.level = id;
          if (currentInitSegment) {
            frag.initSegment = currentInitSegment;
            frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
            currentInitSegment.rawProgramDateTime = null;
            if (nextByteRange) {
              frag.setByteRange(nextByteRange);
              nextByteRange = null;
            }
          }
        }
        const duration = result[1];
        if (duration) {
          // INF
          frag.duration = parseFloat(duration);
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          const title = (' ' + result[2]).slice(1);
          frag.title = title || null;
          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
        } else if (result[3]) {
          // url
          if (isFiniteNumber(frag.duration)) {
            frag.start = totalduration;
            if (levelkeys) {
              setFragLevelKeys(frag, levelkeys, level);
            }
            frag.sn = currentSN;
            frag.level = id;
            frag.cc = discontinuityCounter;
            fragments.push(frag);
            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
            const uri = (' ' + result[3]).slice(1);
            frag.relurl = substituteVariables(level, uri) ;
            assignProgramDateTime(frag, prevFrag);
            prevFrag = frag;
            totalduration += frag.duration;
            currentSN++;
            currentPart = 0;
            createNextFrag = true;
          }
        } else if (result[4]) {
          // X-BYTERANGE
          const data = (' ' + result[4]).slice(1);
          if (prevFrag) {
            frag.setByteRange(data, prevFrag);
          } else {
            frag.setByteRange(data);
          }
        } else if (result[5]) {
          // PROGRAM-DATE-TIME
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          frag.rawProgramDateTime = (' ' + result[5]).slice(1);
          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
          if (firstPdtIndex === -1) {
            firstPdtIndex = fragments.length;
          }
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          if (!result) {
            logger.warn('No matches on slow regex match for level playlist!');
            continue;
          }
          for (i = 1; i < result.length; i++) {
            if (typeof result[i] !== 'undefined') {
              break;
            }
          }

          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          const tag = (' ' + result[i]).slice(1);
          const value1 = (' ' + result[i + 1]).slice(1);
          const value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';
          switch (tag) {
            case 'PLAYLIST-TYPE':
              level.type = value1.toUpperCase();
              break;
            case 'MEDIA-SEQUENCE':
              currentSN = level.startSN = parseInt(value1);
              break;
            case 'SKIP':
              {
                const skipAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, skipAttrs, ['RECENTLY-REMOVED-DATERANGES']);
                }
                const skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');
                if (isFiniteNumber(skippedSegments)) {
                  level.skippedSegments = skippedSegments;
                  // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`
                  for (let _i = skippedSegments; _i--;) {
                    fragments.unshift(null);
                  }
                  currentSN += skippedSegments;
                }
                const recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');
                if (recentlyRemovedDateranges) {
                  level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\t');
                }
                break;
              }
            case 'TARGETDURATION':
              level.targetduration = Math.max(parseInt(value1), 1);
              break;
            case 'VERSION':
              level.version = parseInt(value1);
              break;
            case 'INDEPENDENT-SEGMENTS':
            case 'EXTM3U':
              break;
            case 'ENDLIST':
              level.live = false;
              break;
            case '#':
              if (value1 || value2) {
                frag.tagList.push(value2 ? [value1, value2] : [value1]);
              }
              break;
            case 'DISCONTINUITY':
              discontinuityCounter++;
              frag.tagList.push(['DIS']);
              break;
            case 'GAP':
              frag.gap = true;
              frag.tagList.push([tag]);
              break;
            case 'BITRATE':
              frag.tagList.push([tag, value1]);
              break;
            case 'DATERANGE':
              {
                const dateRangeAttr = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, dateRangeAttr, ['ID', 'CLASS', 'START-DATE', 'END-DATE', 'SCTE35-CMD', 'SCTE35-OUT', 'SCTE35-IN']);
                  substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);
                }
                const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);
                if (dateRange.isValid || level.skippedSegments) {
                  level.dateRanges[dateRange.id] = dateRange;
                } else {
                  logger.warn(`Ignoring invalid DATERANGE tag: "${value1}"`);
                }
                // Add to fragment tag list for backwards compatibility (< v1.2.0)
                frag.tagList.push(['EXT-X-DATERANGE', value1]);
                break;
              }
            case 'DEFINE':
              {
                {
                  const variableAttributes = new AttrList(value1);
                  substituteVariablesInAttributes(level, variableAttributes, ['NAME', 'VALUE', 'IMPORT', 'QUERYPARAM']);
                  if ('IMPORT' in variableAttributes) {
                    importVariableDefinition(level, variableAttributes, multivariantVariableList);
                  } else {
                    addVariableDefinition(level, variableAttributes, baseurl);
                  }
                }
                break;
              }
            case 'DISCONTINUITY-SEQUENCE':
              discontinuityCounter = parseInt(value1);
              break;
            case 'KEY':
              {
                const levelKey = parseKey(value1, baseurl, level);
                if (levelKey.isSupported()) {
                  if (levelKey.method === 'NONE') {
                    levelkeys = undefined;
                    break;
                  }
                  if (!levelkeys) {
                    levelkeys = {};
                  }
                  if (levelkeys[levelKey.keyFormat]) {
                    levelkeys = _extends$2({}, levelkeys);
                  }
                  levelkeys[levelKey.keyFormat] = levelKey;
                } else {
                  logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${value1}"`);
                }
                break;
              }
            case 'START':
              level.startTimeOffset = parseStartTimeOffset(value1);
              break;
            case 'MAP':
              {
                const mapAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, mapAttrs, ['BYTERANGE', 'URI']);
                }
                if (frag.duration) {
                  // Initial segment tag is after segment duration tag.
                  //   #EXTINF: 6.0
                  //   #EXT-X-MAP:URI="init.mp4
                  const init = new Fragment(type, baseurl);
                  setInitSegment(init, mapAttrs, id, levelkeys);
                  currentInitSegment = init;
                  frag.initSegment = currentInitSegment;
                  if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {
                    frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                  }
                } else {
                  // Initial segment tag is before segment duration tag
                  // Handle case where EXT-X-MAP is declared after EXT-X-BYTERANGE
                  const end = frag.byteRangeEndOffset;
                  if (end) {
                    const start = frag.byteRangeStartOffset;
                    nextByteRange = `${end - start}@${start}`;
                  } else {
                    nextByteRange = null;
                  }
                  setInitSegment(frag, mapAttrs, id, levelkeys);
                  currentInitSegment = frag;
                  createNextFrag = true;
                }
                break;
              }
            case 'SERVER-CONTROL':
              {
                const serverControlAttrs = new AttrList(value1);
                level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');
                level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);
                level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');
                level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);
                level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);
                break;
              }
            case 'PART-INF':
              {
                const partInfAttrs = new AttrList(value1);
                level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');
                break;
              }
            case 'PART':
              {
                let partList = level.partList;
                if (!partList) {
                  partList = level.partList = [];
                }
                const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;
                const index = currentPart++;
                const partAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, partAttrs, ['BYTERANGE', 'URI']);
                }
                const part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);
                partList.push(part);
                frag.duration += part.duration;
                break;
              }
            case 'PRELOAD-HINT':
              {
                const preloadHintAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, preloadHintAttrs, ['URI']);
                }
                level.preloadHint = preloadHintAttrs;
                break;
              }
            case 'RENDITION-REPORT':
              {
                const renditionReportAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, renditionReportAttrs, ['URI']);
                }
                level.renditionReports = level.renditionReports || [];
                level.renditionReports.push(renditionReportAttrs);
                break;
              }
            default:
              logger.warn(`line parsed but not handled: ${result}`);
              break;
          }
        }
      }
      if (prevFrag && !prevFrag.relurl) {
        fragments.pop();
        totalduration -= prevFrag.duration;
        if (level.partList) {
          level.fragmentHint = prevFrag;
        }
      } else if (level.partList) {
        assignProgramDateTime(frag, prevFrag);
        frag.cc = discontinuityCounter;
        level.fragmentHint = frag;
        if (levelkeys) {
          setFragLevelKeys(frag, levelkeys, level);
        }
      }
      const fragmentLength = fragments.length;
      const firstFragment = fragments[0];
      const lastFragment = fragments[fragmentLength - 1];
      totalduration += level.skippedSegments * level.targetduration;
      if (totalduration > 0 && fragmentLength && lastFragment) {
        level.averagetargetduration = totalduration / fragmentLength;
        const lastSn = lastFragment.sn;
        level.endSN = lastSn !== 'initSegment' ? lastSn : 0;
        if (!level.live) {
          lastFragment.endList = true;
        }
        if (firstFragment) {
          level.startCC = firstFragment.cc;
        }
      } else {
        level.endSN = 0;
        level.startCC = 0;
      }
      if (level.fragmentHint) {
        totalduration += level.fragmentHint.duration;
      }
      level.totalduration = totalduration;
      level.endCC = discontinuityCounter;

      /**
       * Backfill any missing PDT values
       * "If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after
       * one or more Media Segment URIs, the client SHOULD extrapolate
       * backward from that tag (using EXTINF durations and/or media
       * timestamps) to associate dates with those segments."
       * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs
       * computed.
       */
      if (firstPdtIndex > 0) {
        backfillProgramDateTimes(fragments, firstPdtIndex);
      }
      return level;
    }
  }
  function parseKey(keyTagAttributes, baseurl, parsed) {
    var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;
    // https://tools.ietf.org/html/rfc8216#section-4.3.2.4
    const keyAttrs = new AttrList(keyTagAttributes);
    {
      substituteVariablesInAttributes(parsed, keyAttrs, ['KEYFORMAT', 'KEYFORMATVERSIONS', 'URI', 'IV', 'URI']);
    }
    const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';
    const decrypturi = keyAttrs.URI;
    const decryptiv = keyAttrs.hexadecimalInteger('IV');
    const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;
    // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of "identity".
    const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';
    if (decrypturi && keyAttrs.IV && !decryptiv) {
      logger.error(`Invalid IV: ${keyAttrs.IV}`);
    }
    // If decrypturi is a URI with a scheme, then baseurl will be ignored
    // No uri is allowed when METHOD is NONE
    const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';
    const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);
    return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);
  }
  function parseStartTimeOffset(startAttributes) {
    const startAttrs = new AttrList(startAttributes);
    const startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
    if (isFiniteNumber(startTimeOffset)) {
      return startTimeOffset;
    }
    return null;
  }
  function setCodecs(codecsAttributeValue, level) {
    let codecs = (codecsAttributeValue || '').split(/[ ,]+/).filter(c => c);
    ['video', 'audio', 'text'].forEach(type => {
      const filtered = codecs.filter(codec => isCodecType(codec, type));
      if (filtered.length) {
        // Comma separated list of all codecs for type
        level[`${type}Codec`] = filtered.join(',');
        // Remove known codecs so that only unknownCodecs are left after iterating through each type
        codecs = codecs.filter(codec => filtered.indexOf(codec) === -1);
      }
    });
    level.unknownCodecs = codecs;
  }
  function assignCodec(media, groupItem, codecProperty) {
    const codecValue = groupItem[codecProperty];
    if (codecValue) {
      media[codecProperty] = codecValue;
    }
  }
  function backfillProgramDateTimes(fragments, firstPdtIndex) {
    let fragPrev = fragments[firstPdtIndex];
    for (let i = firstPdtIndex; i--;) {
      const frag = fragments[i];
      // Exit on delta-playlist skipped segments
      if (!frag) {
        return;
      }
      frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;
      fragPrev = frag;
    }
  }
  function assignProgramDateTime(frag, prevFrag) {
    if (frag.rawProgramDateTime) {
      frag.programDateTime = Date.parse(frag.rawProgramDateTime);
    } else if (prevFrag != null && prevFrag.programDateTime) {
      frag.programDateTime = prevFrag.endProgramDateTime;
    }
    if (!isFiniteNumber(frag.programDateTime)) {
      frag.programDateTime = null;
      frag.rawProgramDateTime = null;
    }
  }
  function setInitSegment(frag, mapAttrs, id, levelkeys) {
    frag.relurl = mapAttrs.URI;
    if (mapAttrs.BYTERANGE) {
      frag.setByteRange(mapAttrs.BYTERANGE);
    }
    frag.level = id;
    frag.sn = 'initSegment';
    if (levelkeys) {
      frag.levelkeys = levelkeys;
    }
    frag.initSegment = null;
  }
  function setFragLevelKeys(frag, levelkeys, level) {
    frag.levelkeys = levelkeys;
    const {
      encryptedFragments
    } = level;
    if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(format => levelkeys[format].isCommonEncryption)) {
      encryptedFragments.push(frag);
    }
  }

  var PlaylistContextType = {
    MANIFEST: "manifest",
    LEVEL: "level",
    AUDIO_TRACK: "audioTrack",
    SUBTITLE_TRACK: "subtitleTrack"
  };
  var PlaylistLevelType = {
    MAIN: "main",
    AUDIO: "audio",
    SUBTITLE: "subtitle"
  };

  function mapContextToLevelType(context) {
    const {
      type
    } = context;
    switch (type) {
      case PlaylistContextType.AUDIO_TRACK:
        return PlaylistLevelType.AUDIO;
      case PlaylistContextType.SUBTITLE_TRACK:
        return PlaylistLevelType.SUBTITLE;
      default:
        return PlaylistLevelType.MAIN;
    }
  }
  function getResponseUrl(response, context) {
    let url = response.url;
    // responseURL not supported on some browsers (it is used to detect URL redirection)
    // data-uri mode also not supported (but no need to detect redirection)
    if (url === undefined || url.indexOf('data:') === 0) {
      // fallback to initial URL
      url = context.url;
    }
    return url;
  }
  class PlaylistLoader {
    constructor(hls) {
      this.hls = void 0;
      this.loaders = Object.create(null);
      this.variableList = null;
      this.hls = hls;
      this.registerListeners();
    }
    startLoad(startPosition) {}
    stopLoad() {
      this.destroyInternalLoaders();
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events$1.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
      hls.on(Events$1.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.LEVEL_LOADING, this.onLevelLoading, this);
      hls.off(Events$1.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
      hls.off(Events$1.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
    }

    /**
     * Returns defaults or configured loader-type overloads (pLoader and loader config params)
     */
    createInternalLoader(context) {
      const config = this.hls.config;
      const PLoader = config.pLoader;
      const Loader = config.loader;
      const InternalLoader = PLoader || Loader;
      const loader = new InternalLoader(config);
      this.loaders[context.type] = loader;
      return loader;
    }
    getInternalLoader(context) {
      return this.loaders[context.type];
    }
    resetInternalLoader(contextType) {
      if (this.loaders[contextType]) {
        delete this.loaders[contextType];
      }
    }

    /**
     * Call `destroy` on all internal loader instances mapped (one per context type)
     */
    destroyInternalLoaders() {
      for (const contextType in this.loaders) {
        const loader = this.loaders[contextType];
        if (loader) {
          loader.destroy();
        }
        this.resetInternalLoader(contextType);
      }
    }
    destroy() {
      this.variableList = null;
      this.unregisterListeners();
      this.destroyInternalLoaders();
    }
    onManifestLoading(event, data) {
      const {
        url
      } = data;
      this.variableList = null;
      this.load({
        id: null,
        level: 0,
        responseType: 'text',
        type: PlaylistContextType.MANIFEST,
        url,
        deliveryDirectives: null
      });
    }
    onLevelLoading(event, data) {
      const {
        id,
        level,
        pathwayId,
        url,
        deliveryDirectives
      } = data;
      this.load({
        id,
        level,
        pathwayId,
        responseType: 'text',
        type: PlaylistContextType.LEVEL,
        url,
        deliveryDirectives
      });
    }
    onAudioTrackLoading(event, data) {
      const {
        id,
        groupId,
        url,
        deliveryDirectives
      } = data;
      this.load({
        id,
        groupId,
        level: null,
        responseType: 'text',
        type: PlaylistContextType.AUDIO_TRACK,
        url,
        deliveryDirectives
      });
    }
    onSubtitleTrackLoading(event, data) {
      const {
        id,
        groupId,
        url,
        deliveryDirectives
      } = data;
      this.load({
        id,
        groupId,
        level: null,
        responseType: 'text',
        type: PlaylistContextType.SUBTITLE_TRACK,
        url,
        deliveryDirectives
      });
    }
    load(context) {
      var _context$deliveryDire;
      const config = this.hls.config;

      // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);

      // Check if a loader for this context already exists
      let loader = this.getInternalLoader(context);
      if (loader) {
        const loaderContext = loader.context;
        if (loaderContext && loaderContext.url === context.url && loaderContext.level === context.level) {
          // same URL can't overlap
          logger.trace('[playlist-loader]: playlist request ongoing');
          return;
        }
        logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);
        loader.abort();
      }

      // apply different configs for retries depending on
      // context (manifest, level, audio/subs playlist)
      let loadPolicy;
      if (context.type === PlaylistContextType.MANIFEST) {
        loadPolicy = config.manifestLoadPolicy.default;
      } else {
        loadPolicy = _extends$2({}, config.playlistLoadPolicy.default, {
          timeoutRetry: null,
          errorRetry: null
        });
      }
      loader = this.createInternalLoader(context);

      // Override level/track timeout for LL-HLS requests
      // (the default of 10000ms is counter productive to blocking playlist reload requests)
      if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {
        let levelDetails;
        if (context.type === PlaylistContextType.LEVEL && context.level !== null) {
          levelDetails = this.hls.levels[context.level].details;
        } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {
          levelDetails = this.hls.audioTracks[context.id].details;
        } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {
          levelDetails = this.hls.subtitleTracks[context.id].details;
        }
        if (levelDetails) {
          const partTarget = levelDetails.partTarget;
          const targetDuration = levelDetails.targetduration;
          if (partTarget && targetDuration) {
            const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;
            loadPolicy = _extends$2({}, loadPolicy, {
              maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),
              maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)
            });
          }
        }
      }
      const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
        retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
        maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
      };
      const loaderCallbacks = {
        onSuccess: (response, stats, context, networkDetails) => {
          const loader = this.getInternalLoader(context);
          this.resetInternalLoader(context.type);
          const string = response.data;

          // Validate if it is an M3U8 at all
          if (string.indexOf('#EXTM3U') !== 0) {
            this.handleManifestParsingError(response, context, new Error('no EXTM3U delimiter'), networkDetails || null, stats);
            return;
          }
          stats.parsing.start = performance.now();
          if (M3U8Parser.isMediaPlaylist(string)) {
            this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);
          } else {
            this.handleMasterPlaylist(response, stats, context, networkDetails);
          }
        },
        onError: (response, context, networkDetails, stats) => {
          this.handleNetworkError(context, networkDetails, false, response, stats);
        },
        onTimeout: (stats, context, networkDetails) => {
          this.handleNetworkError(context, networkDetails, true, undefined, stats);
        }
      };

      // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);

      loader.load(context, loaderConfig, loaderCallbacks);
    }
    handleMasterPlaylist(response, stats, context, networkDetails) {
      const hls = this.hls;
      const string = response.data;
      const url = getResponseUrl(response, context);
      const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);
      if (parsedResult.playlistParsingError) {
        this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);
        return;
      }
      const {
        contentSteering,
        levels,
        sessionData,
        sessionKeys,
        startTimeOffset,
        variableList
      } = parsedResult;
      this.variableList = variableList;
      const {
        AUDIO: audioTracks = [],
        SUBTITLES: subtitles,
        'CLOSED-CAPTIONS': captions
      } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);
      if (audioTracks.length) {
        // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
        const embeddedAudioFound = audioTracks.some(audioTrack => !audioTrack.url);

        // if no embedded audio track defined, but audio codec signaled in quality level,
        // we need to signal this main audio track this could happen with playlists with
        // alt audio rendition in which quality levels (main)
        // contains both audio+video. but with mixed audio track not signaled
        if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
          logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');
          audioTracks.unshift({
            type: 'main',
            name: 'main',
            groupId: 'main',
            default: false,
            autoselect: false,
            forced: false,
            id: -1,
            attrs: new AttrList({}),
            bitrate: 0,
            url: ''
          });
        }
      }
      hls.trigger(Events$1.MANIFEST_LOADED, {
        levels,
        audioTracks,
        subtitles,
        captions,
        contentSteering,
        url,
        stats,
        networkDetails,
        sessionData,
        sessionKeys,
        startTimeOffset,
        variableList
      });
    }
    handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {
      const hls = this.hls;
      const {
        id,
        level,
        type
      } = context;
      const url = getResponseUrl(response, context);
      const levelUrlId = 0;
      const levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;
      const levelType = mapContextToLevelType(context);
      const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);

      // We have done our first request (Manifest-type) and receive
      // not a master playlist but a chunk-list (track/level)
      // We fire the manifest-loaded event anyway with the parsed level-details
      // by creating a single-level structure for it.
      if (type === PlaylistContextType.MANIFEST) {
        const singleLevel = {
          attrs: new AttrList({}),
          bitrate: 0,
          details: levelDetails,
          name: '',
          url
        };
        hls.trigger(Events$1.MANIFEST_LOADED, {
          levels: [singleLevel],
          audioTracks: [],
          url,
          stats,
          networkDetails,
          sessionData: null,
          sessionKeys: null,
          contentSteering: null,
          startTimeOffset: null,
          variableList: null
        });
      }

      // save parsing time
      stats.parsing.end = performance.now();

      // extend the context with the new levelDetails property
      context.levelDetails = levelDetails;
      this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);
    }
    handleManifestParsingError(response, context, error, networkDetails, stats) {
      this.hls.trigger(Events$1.ERROR, {
        type: ErrorTypes.NETWORK_ERROR,
        details: ErrorDetails.MANIFEST_PARSING_ERROR,
        fatal: context.type === PlaylistContextType.MANIFEST,
        url: response.url,
        err: error,
        error,
        reason: error.message,
        response,
        context,
        networkDetails,
        stats
      });
    }
    handleNetworkError(context, networkDetails, timeout = false, response, stats) {
      let message = `A network ${timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')} occurred while loading ${context.type}`;
      if (context.type === PlaylistContextType.LEVEL) {
        message += `: ${context.level} id: ${context.id}`;
      } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {
        message += ` id: ${context.id} group-id: "${context.groupId}"`;
      }
      const error = new Error(message);
      logger.warn(`[playlist-loader]: ${message}`);
      let details = ErrorDetails.UNKNOWN;
      let fatal = false;
      const loader = this.getInternalLoader(context);
      switch (context.type) {
        case PlaylistContextType.MANIFEST:
          details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case PlaylistContextType.LEVEL:
          details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case PlaylistContextType.AUDIO_TRACK:
          details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
        case PlaylistContextType.SUBTITLE_TRACK:
          details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;
          fatal = false;
          break;
      }
      if (loader) {
        this.resetInternalLoader(context.type);
      }
      const errorData = {
        type: ErrorTypes.NETWORK_ERROR,
        details,
        fatal,
        url: context.url,
        loader,
        context,
        error,
        networkDetails,
        stats
      };
      if (response) {
        const url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;
        errorData.response = _objectSpread2({
          url,
          data: undefined
        }, response);
      }
      this.hls.trigger(Events$1.ERROR, errorData);
    }
    handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {
      const hls = this.hls;
      const {
        type,
        level,
        id,
        groupId,
        deliveryDirectives
      } = context;
      const url = getResponseUrl(response, context);
      const parent = mapContextToLevelType(context);
      const levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;
      if (!levelDetails.fragments.length) {
        const _error = new Error('No Segments found in Playlist');
        hls.trigger(Events$1.ERROR, {
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.LEVEL_EMPTY_ERROR,
          fatal: false,
          url,
          error: _error,
          reason: _error.message,
          response,
          context,
          level: levelIndex,
          parent,
          networkDetails,
          stats
        });
        return;
      }
      if (!levelDetails.targetduration) {
        levelDetails.playlistParsingError = new Error('Missing Target Duration');
      }
      const error = levelDetails.playlistParsingError;
      if (error) {
        hls.trigger(Events$1.ERROR, {
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.LEVEL_PARSING_ERROR,
          fatal: false,
          url,
          error,
          reason: error.message,
          response,
          context,
          level: levelIndex,
          parent,
          networkDetails,
          stats
        });
        return;
      }
      if (levelDetails.live && loader) {
        if (loader.getCacheAge) {
          levelDetails.ageHeader = loader.getCacheAge() || 0;
        }
        if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {
          levelDetails.ageHeader = 0;
        }
      }
      switch (type) {
        case PlaylistContextType.MANIFEST:
        case PlaylistContextType.LEVEL:
          hls.trigger(Events$1.LEVEL_LOADED, {
            details: levelDetails,
            level: levelIndex || 0,
            id: id || 0,
            stats,
            networkDetails,
            deliveryDirectives
          });
          break;
        case PlaylistContextType.AUDIO_TRACK:
          hls.trigger(Events$1.AUDIO_TRACK_LOADED, {
            details: levelDetails,
            id: id || 0,
            groupId: groupId || '',
            stats,
            networkDetails,
            deliveryDirectives
          });
          break;
        case PlaylistContextType.SUBTITLE_TRACK:
          hls.trigger(Events$1.SUBTITLE_TRACK_LOADED, {
            details: levelDetails,
            id: id || 0,
            groupId: groupId || '',
            stats,
            networkDetails,
            deliveryDirectives
          });
          break;
      }
    }
  }

  function sendAddTrackEvent(track, videoEl) {
    let event;
    try {
      event = new Event('addtrack');
    } catch (err) {
      // for IE11
      event = document.createEvent('Event');
      event.initEvent('addtrack', false, false);
    }
    event.track = track;
    videoEl.dispatchEvent(event);
  }
  function addCueToTrack(track, cue) {
    // Sometimes there are cue overlaps on segmented vtts so the same
    // cue can appear more than once in different vtt files.
    // This avoid showing duplicated cues with same timecode and text.
    const mode = track.mode;
    if (mode === 'disabled') {
      track.mode = 'hidden';
    }
    if (track.cues && !track.cues.getCueById(cue.id)) {
      try {
        track.addCue(cue);
        if (!track.cues.getCueById(cue.id)) {
          throw new Error(`addCue is failed for: ${cue}`);
        }
      } catch (err) {
        logger.debug(`[texttrack-utils]: ${err}`);
        try {
          const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);
          textTrackCue.id = cue.id;
          track.addCue(textTrackCue);
        } catch (err2) {
          logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);
        }
      }
    }
    if (mode === 'disabled') {
      track.mode = mode;
    }
  }
  function clearCurrentCues(track) {
    // When track.mode is disabled, track.cues will be null.
    // To guarantee the removal of cues, we need to temporarily
    // change the mode to hidden
    const mode = track.mode;
    if (mode === 'disabled') {
      track.mode = 'hidden';
    }
    if (track.cues) {
      for (let i = track.cues.length; i--;) {
        track.removeCue(track.cues[i]);
      }
    }
    if (mode === 'disabled') {
      track.mode = mode;
    }
  }
  function removeCuesInRange(track, start, end, predicate) {
    const mode = track.mode;
    if (mode === 'disabled') {
      track.mode = 'hidden';
    }
    if (track.cues && track.cues.length > 0) {
      const cues = getCuesInRange(track.cues, start, end);
      for (let i = 0; i < cues.length; i++) {
        if (!predicate || predicate(cues[i])) {
          track.removeCue(cues[i]);
        }
      }
    }
    if (mode === 'disabled') {
      track.mode = mode;
    }
  }

  // Find first cue starting after given time.
  // Modified version of binary search O(log(n)).
  function getFirstCueIndexAfterTime(cues, time) {
    // If first cue starts after time, start there
    if (time < cues[0].startTime) {
      return 0;
    }
    // If the last cue ends before time there is no overlap
    const len = cues.length - 1;
    if (time > cues[len].endTime) {
      return -1;
    }
    let left = 0;
    let right = len;
    while (left <= right) {
      const mid = Math.floor((right + left) / 2);
      if (time < cues[mid].startTime) {
        right = mid - 1;
      } else if (time > cues[mid].startTime && left < len) {
        left = mid + 1;
      } else {
        // If it's not lower or higher, it must be equal.
        return mid;
      }
    }
    // At this point, left and right have swapped.
    // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.
    return cues[left].startTime - time < time - cues[right].startTime ? left : right;
  }
  function getCuesInRange(cues, start, end) {
    const cuesFound = [];
    const firstCueInRange = getFirstCueIndexAfterTime(cues, start);
    if (firstCueInRange > -1) {
      for (let i = firstCueInRange, len = cues.length; i < len; i++) {
        const cue = cues[i];
        if (cue.startTime >= start && cue.endTime <= end) {
          cuesFound.push(cue);
        } else if (cue.startTime > end) {
          return cuesFound;
        }
      }
    }
    return cuesFound;
  }
  function filterSubtitleTracks(textTrackList) {
    const tracks = [];
    for (let i = 0; i < textTrackList.length; i++) {
      const track = textTrackList[i];
      // Edge adds a track without a label; we don't want to use it
      if ((track.kind === 'subtitles' || track.kind === 'captions') && track.label) {
        tracks.push(textTrackList[i]);
      }
    }
    return tracks;
  }

  var MetadataSchema = {
    audioId3: "org.id3",
    dateRange: "com.apple.quicktime.HLS",
    emsg: "https://aomedia.org/emsg/ID3"
  };

  const MIN_CUE_DURATION = 0.25;
  function getCueClass() {
    if (typeof self === 'undefined') return undefined;
    return self.VTTCue || self.TextTrackCue;
  }
  function createCueWithDataFields(Cue, startTime, endTime, data, type) {
    let cue = new Cue(startTime, endTime, '');
    try {
      cue.value = data;
      if (type) {
        cue.type = type;
      }
    } catch (e) {
      cue = new Cue(startTime, endTime, JSON.stringify(type ? _objectSpread2({
        type
      }, data) : data));
    }
    return cue;
  }

  // VTTCue latest draft allows an infinite duration, fallback
  // to MAX_VALUE if necessary
  const MAX_CUE_ENDTIME = (() => {
    const Cue = getCueClass();
    try {
      Cue && new Cue(0, Number.POSITIVE_INFINITY, '');
    } catch (e) {
      return Number.MAX_VALUE;
    }
    return Number.POSITIVE_INFINITY;
  })();
  function dateRangeDateToTimelineSeconds(date, offset) {
    return date.getTime() / 1000 - offset;
  }
  function hexToArrayBuffer(str) {
    return Uint8Array.from(str.replace(/^0x/, '').replace(/([\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;
  }
  class ID3TrackController {
    constructor(hls) {
      this.hls = void 0;
      this.id3Track = null;
      this.media = null;
      this.dateRangeCuesAppended = {};
      this.hls = hls;
      this._registerListeners();
    }
    destroy() {
      this._unregisterListeners();
      this.id3Track = null;
      this.media = null;
      this.dateRangeCuesAppended = {};
      // @ts-ignore
      this.hls = null;
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
      hls.on(Events$1.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.on(Events$1.LEVEL_UPDATED, this.onLevelUpdated, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
      hls.off(Events$1.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.off(Events$1.LEVEL_UPDATED, this.onLevelUpdated, this);
    }

    // Add ID3 metatadata text track.
    onMediaAttached(event, data) {
      this.media = data.media;
    }
    onMediaDetaching() {
      if (!this.id3Track) {
        return;
      }
      clearCurrentCues(this.id3Track);
      this.id3Track = null;
      this.media = null;
      this.dateRangeCuesAppended = {};
    }
    onManifestLoading() {
      this.dateRangeCuesAppended = {};
    }
    createTrack(media) {
      const track = this.getID3Track(media.textTracks);
      track.mode = 'hidden';
      return track;
    }
    getID3Track(textTracks) {
      if (!this.media) {
        return;
      }
      for (let i = 0; i < textTracks.length; i++) {
        const textTrack = textTracks[i];
        if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {
          // send 'addtrack' when reusing the textTrack for metadata,
          // same as what we do for captions
          sendAddTrackEvent(textTrack, this.media);
          return textTrack;
        }
      }
      return this.media.addTextTrack('metadata', 'id3');
    }
    onFragParsingMetadata(event, data) {
      if (!this.media) {
        return;
      }
      const {
        hls: {
          config: {
            enableEmsgMetadataCues,
            enableID3MetadataCues
          }
        }
      } = this;
      if (!enableEmsgMetadataCues && !enableID3MetadataCues) {
        return;
      }
      const {
        samples
      } = data;

      // create track dynamically
      if (!this.id3Track) {
        this.id3Track = this.createTrack(this.media);
      }
      const Cue = getCueClass();
      if (!Cue) {
        return;
      }
      for (let i = 0; i < samples.length; i++) {
        const type = samples[i].type;
        if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {
          continue;
        }
        const frames = getID3Frames(samples[i].data);
        if (frames) {
          const startTime = samples[i].pts;
          let endTime = startTime + samples[i].duration;
          if (endTime > MAX_CUE_ENDTIME) {
            endTime = MAX_CUE_ENDTIME;
          }
          const timeDiff = endTime - startTime;
          if (timeDiff <= 0) {
            endTime = startTime + MIN_CUE_DURATION;
          }
          for (let j = 0; j < frames.length; j++) {
            const frame = frames[j];
            // Safari doesn't put the timestamp frame in the TextTrack
            if (!isTimeStampFrame(frame)) {
              // add a bounds to any unbounded cues
              this.updateId3CueEnds(startTime, type);
              const cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);
              if (cue) {
                this.id3Track.addCue(cue);
              }
            }
          }
        }
      }
    }
    updateId3CueEnds(startTime, type) {
      var _this$id3Track;
      const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;
      if (cues) {
        for (let i = cues.length; i--;) {
          const cue = cues[i];
          if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {
            cue.endTime = startTime;
          }
        }
      }
    }
    onBufferFlushing(event, {
      startOffset,
      endOffset,
      type
    }) {
      const {
        id3Track,
        hls
      } = this;
      if (!hls) {
        return;
      }
      const {
        config: {
          enableEmsgMetadataCues,
          enableID3MetadataCues
        }
      } = hls;
      if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {
        let predicate;
        if (type === 'audio') {
          predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;
        } else if (type === 'video') {
          predicate = cue => cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
        } else {
          predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
        }
        removeCuesInRange(id3Track, startOffset, endOffset, predicate);
      }
    }
    onLevelUpdated(event, {
      details
    }) {
      if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {
        return;
      }
      const {
        dateRangeCuesAppended,
        id3Track
      } = this;
      const {
        dateRanges
      } = details;
      const ids = Object.keys(dateRanges);
      // Remove cues from track not found in details.dateRanges
      if (id3Track) {
        const idsToRemove = Object.keys(dateRangeCuesAppended).filter(id => !ids.includes(id));
        for (let i = idsToRemove.length; i--;) {
          const id = idsToRemove[i];
          Object.keys(dateRangeCuesAppended[id].cues).forEach(key => {
            id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);
          });
          delete dateRangeCuesAppended[id];
        }
      }
      // Exit if the playlist does not have Date Ranges or does not have Program Date Time
      const lastFragment = details.fragments[details.fragments.length - 1];
      if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {
        return;
      }
      if (!this.id3Track) {
        this.id3Track = this.createTrack(this.media);
      }
      const dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;
      const Cue = getCueClass();
      for (let i = 0; i < ids.length; i++) {
        const id = ids[i];
        const dateRange = dateRanges[id];
        const startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);

        // Process DateRanges to determine end-time (known DURATION, END-DATE, or END-ON-NEXT)
        const appendedDateRangeCues = dateRangeCuesAppended[id];
        const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};
        let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;
        let endTime = MAX_CUE_ENDTIME;
        const endDate = dateRange.endDate;
        if (endDate) {
          endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);
          durationKnown = true;
        } else if (dateRange.endOnNext && !durationKnown) {
          const nextDateRangeWithSameClass = ids.reduce((candidateDateRange, id) => {
            if (id !== dateRange.id) {
              const otherDateRange = dateRanges[id];
              if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {
                return otherDateRange;
              }
            }
            return candidateDateRange;
          }, null);
          if (nextDateRangeWithSameClass) {
            endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);
            durationKnown = true;
          }
        }

        // Create TextTrack Cues for each MetadataGroup Item (select DateRange attribute)
        // This is to emulate Safari HLS playback handling of DateRange tags
        const attributes = Object.keys(dateRange.attr);
        for (let j = 0; j < attributes.length; j++) {
          const key = attributes[j];
          if (!isDateRangeCueAttribute(key)) {
            continue;
          }
          const cue = cues[key];
          if (cue) {
            if (durationKnown && !appendedDateRangeCues.durationKnown) {
              cue.endTime = endTime;
            }
          } else if (Cue) {
            let data = dateRange.attr[key];
            if (isSCTE35Attribute(key)) {
              data = hexToArrayBuffer(data);
            }
            const _cue = createCueWithDataFields(Cue, startTime, endTime, {
              key,
              data
            }, MetadataSchema.dateRange);
            if (_cue) {
              _cue.id = id;
              this.id3Track.addCue(_cue);
              cues[key] = _cue;
            }
          }
        }

        // Keep track of processed DateRanges by ID for updating cues with new DateRange tag attributes
        dateRangeCuesAppended[id] = {
          cues,
          dateRange,
          durationKnown
        };
      }
    }
  }

  class LatencyController {
    constructor(hls) {
      this.hls = void 0;
      this.config = void 0;
      this.media = null;
      this.levelDetails = null;
      this.currentTime = 0;
      this.stallCount = 0;
      this._latency = null;
      this.timeupdateHandler = () => this.timeupdate();
      this.hls = hls;
      this.config = hls.config;
      this.registerListeners();
    }
    get latency() {
      return this._latency || 0;
    }
    get maxLatency() {
      const {
        config,
        levelDetails
      } = this;
      if (config.liveMaxLatencyDuration !== undefined) {
        return config.liveMaxLatencyDuration;
      }
      return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
    }
    get targetLatency() {
      const {
        levelDetails
      } = this;
      if (levelDetails === null) {
        return null;
      }
      const {
        holdBack,
        partHoldBack,
        targetduration
      } = levelDetails;
      const {
        liveSyncDuration,
        liveSyncDurationCount,
        lowLatencyMode
      } = this.config;
      const userConfig = this.hls.userConfig;
      let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;
      if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
        targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;
      }
      const maxLiveSyncOnStallIncrease = targetduration;
      const liveSyncOnStallIncrease = 1.0;
      return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
    }
    get liveSyncPosition() {
      const liveEdge = this.estimateLiveEdge();
      const targetLatency = this.targetLatency;
      const levelDetails = this.levelDetails;
      if (liveEdge === null || targetLatency === null || levelDetails === null) {
        return null;
      }
      const edge = levelDetails.edge;
      const syncPosition = liveEdge - targetLatency - this.edgeStalled;
      const min = edge - levelDetails.totalduration;
      const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);
      return Math.min(Math.max(min, syncPosition), max);
    }
    get drift() {
      const {
        levelDetails
      } = this;
      if (levelDetails === null) {
        return 1;
      }
      return levelDetails.drift;
    }
    get edgeStalled() {
      const {
        levelDetails
      } = this;
      if (levelDetails === null) {
        return 0;
      }
      const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;
      return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
    }
    get forwardBufferLength() {
      const {
        media,
        levelDetails
      } = this;
      if (!media || !levelDetails) {
        return 0;
      }
      const bufferedRanges = media.buffered.length;
      return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;
    }
    destroy() {
      this.unregisterListeners();
      this.onMediaDetaching();
      this.levelDetails = null;
      // @ts-ignore
      this.hls = this.timeupdateHandler = null;
    }
    registerListeners() {
      this.hls.on(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.on(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      this.hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.on(Events$1.LEVEL_UPDATED, this.onLevelUpdated, this);
      this.hls.on(Events$1.ERROR, this.onError, this);
    }
    unregisterListeners() {
      this.hls.off(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.off(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      this.hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.off(Events$1.LEVEL_UPDATED, this.onLevelUpdated, this);
      this.hls.off(Events$1.ERROR, this.onError, this);
    }
    onMediaAttached(event, data) {
      this.media = data.media;
      this.media.addEventListener('timeupdate', this.timeupdateHandler);
    }
    onMediaDetaching() {
      if (this.media) {
        this.media.removeEventListener('timeupdate', this.timeupdateHandler);
        this.media = null;
      }
    }
    onManifestLoading() {
      this.levelDetails = null;
      this._latency = null;
      this.stallCount = 0;
    }
    onLevelUpdated(event, {
      details
    }) {
      this.levelDetails = details;
      if (details.advanced) {
        this.timeupdate();
      }
      if (!details.live && this.media) {
        this.media.removeEventListener('timeupdate', this.timeupdateHandler);
      }
    }
    onError(event, data) {
      var _this$levelDetails;
      if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {
        return;
      }
      this.stallCount++;
      if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {
        logger.warn('[playback-rate-controller]: Stall detected, adjusting target latency');
      }
    }
    timeupdate() {
      const {
        media,
        levelDetails
      } = this;
      if (!media || !levelDetails) {
        return;
      }
      this.currentTime = media.currentTime;
      const latency = this.computeLatency();
      if (latency === null) {
        return;
      }
      this._latency = latency;

      // Adapt playbackRate to meet target latency in low-latency mode
      const {
        lowLatencyMode,
        maxLiveSyncPlaybackRate
      } = this.config;
      if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {
        return;
      }
      const targetLatency = this.targetLatency;
      if (targetLatency === null) {
        return;
      }
      const distanceFromTarget = latency - targetLatency;
      // Only adjust playbackRate when within one target duration of targetLatency
      // and more than one second from under-buffering.
      // Playback further than one target duration from target can be considered DVR playback.
      const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);
      const inLiveRange = distanceFromTarget < liveMinLatencyDuration;
      if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {
        const max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));
        const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;
        media.playbackRate = Math.min(max, Math.max(1, rate));
      } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
        media.playbackRate = 1;
      }
    }
    estimateLiveEdge() {
      const {
        levelDetails
      } = this;
      if (levelDetails === null) {
        return null;
      }
      return levelDetails.edge + levelDetails.age;
    }
    computeLatency() {
      const liveEdge = this.estimateLiveEdge();
      if (liveEdge === null) {
        return null;
      }
      return liveEdge - this.currentTime;
    }
  }

  const HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];
  function isHdcpLevel(value) {
    return HdcpLevels.indexOf(value) > -1;
  }
  const VideoRangeValues = ['SDR', 'PQ', 'HLG'];
  function isVideoRange(value) {
    return !!value && VideoRangeValues.indexOf(value) > -1;
  }
  var HlsSkip = {
    No: "",
    Yes: "YES",
    v2: "v2"
  };
  function getSkipValue(details) {
    const {
      canSkipUntil,
      canSkipDateRanges,
      age
    } = details;
    // A Client SHOULD NOT request a Playlist Delta Update unless it already
    // has a version of the Playlist that is no older than one-half of the Skip Boundary.
    // @see: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-6.3.7
    const playlistRecentEnough = age < canSkipUntil / 2;
    if (canSkipUntil && playlistRecentEnough) {
      if (canSkipDateRanges) {
        return HlsSkip.v2;
      }
      return HlsSkip.Yes;
    }
    return HlsSkip.No;
  }
  class HlsUrlParameters {
    constructor(msn, part, skip) {
      this.msn = void 0;
      this.part = void 0;
      this.skip = void 0;
      this.msn = msn;
      this.part = part;
      this.skip = skip;
    }
    addDirectives(uri) {
      const url = new self.URL(uri);
      if (this.msn !== undefined) {
        url.searchParams.set('_HLS_msn', this.msn.toString());
      }
      if (this.part !== undefined) {
        url.searchParams.set('_HLS_part', this.part.toString());
      }
      if (this.skip) {
        url.searchParams.set('_HLS_skip', this.skip);
      }
      return url.href;
    }
  }
  class Level {
    constructor(data) {
      this._attrs = void 0;
      this.audioCodec = void 0;
      this.bitrate = void 0;
      this.codecSet = void 0;
      this.url = void 0;
      this.frameRate = void 0;
      this.height = void 0;
      this.id = void 0;
      this.name = void 0;
      this.videoCodec = void 0;
      this.width = void 0;
      this.details = void 0;
      this.fragmentError = 0;
      this.loadError = 0;
      this.loaded = void 0;
      this.realBitrate = 0;
      this.supportedPromise = void 0;
      this.supportedResult = void 0;
      this._avgBitrate = 0;
      this._audioGroups = void 0;
      this._subtitleGroups = void 0;
      // Deprecated (retained for backwards compatibility)
      this._urlId = 0;
      this.url = [data.url];
      this._attrs = [data.attrs];
      this.bitrate = data.bitrate;
      if (data.details) {
        this.details = data.details;
      }
      this.id = data.id || 0;
      this.name = data.name;
      this.width = data.width || 0;
      this.height = data.height || 0;
      this.frameRate = data.attrs.optionalFloat('FRAME-RATE', 0);
      this._avgBitrate = data.attrs.decimalInteger('AVERAGE-BANDWIDTH');
      this.audioCodec = data.audioCodec;
      this.videoCodec = data.videoCodec;
      this.codecSet = [data.videoCodec, data.audioCodec].filter(c => !!c).map(s => s.substring(0, 4)).join(',');
      this.addGroupId('audio', data.attrs.AUDIO);
      this.addGroupId('text', data.attrs.SUBTITLES);
    }
    get maxBitrate() {
      return Math.max(this.realBitrate, this.bitrate);
    }
    get averageBitrate() {
      return this._avgBitrate || this.realBitrate || this.bitrate;
    }
    get attrs() {
      return this._attrs[0];
    }
    get codecs() {
      return this.attrs.CODECS || '';
    }
    get pathwayId() {
      return this.attrs['PATHWAY-ID'] || '.';
    }
    get videoRange() {
      return this.attrs['VIDEO-RANGE'] || 'SDR';
    }
    get score() {
      return this.attrs.optionalFloat('SCORE', 0);
    }
    get uri() {
      return this.url[0] || '';
    }
    hasAudioGroup(groupId) {
      return hasGroup(this._audioGroups, groupId);
    }
    hasSubtitleGroup(groupId) {
      return hasGroup(this._subtitleGroups, groupId);
    }
    get audioGroups() {
      return this._audioGroups;
    }
    get subtitleGroups() {
      return this._subtitleGroups;
    }
    addGroupId(type, groupId) {
      if (!groupId) {
        return;
      }
      if (type === 'audio') {
        let audioGroups = this._audioGroups;
        if (!audioGroups) {
          audioGroups = this._audioGroups = [];
        }
        if (audioGroups.indexOf(groupId) === -1) {
          audioGroups.push(groupId);
        }
      } else if (type === 'text') {
        let subtitleGroups = this._subtitleGroups;
        if (!subtitleGroups) {
          subtitleGroups = this._subtitleGroups = [];
        }
        if (subtitleGroups.indexOf(groupId) === -1) {
          subtitleGroups.push(groupId);
        }
      }
    }

    // Deprecated methods (retained for backwards compatibility)
    get urlId() {
      return 0;
    }
    set urlId(value) {}
    get audioGroupIds() {
      return this.audioGroups ? [this.audioGroupId] : undefined;
    }
    get textGroupIds() {
      return this.subtitleGroups ? [this.textGroupId] : undefined;
    }
    get audioGroupId() {
      var _this$audioGroups;
      return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];
    }
    get textGroupId() {
      var _this$subtitleGroups;
      return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];
    }
    addFallback() {}
  }
  function hasGroup(groups, groupId) {
    if (!groupId || !groups) {
      return false;
    }
    return groups.indexOf(groupId) !== -1;
  }

  function updateFromToPTS(fragFrom, fragTo) {
    const fragToPTS = fragTo.startPTS;
    // if we know startPTS[toIdx]
    if (isFiniteNumber(fragToPTS)) {
      // update fragment duration.
      // it helps to fix drifts between playlist reported duration and fragment real duration
      let duration = 0;
      let frag;
      if (fragTo.sn > fragFrom.sn) {
        duration = fragToPTS - fragFrom.start;
        frag = fragFrom;
      } else {
        duration = fragFrom.start - fragToPTS;
        frag = fragTo;
      }
      if (frag.duration !== duration) {
        frag.duration = duration;
      }
      // we dont know startPTS[toIdx]
    } else if (fragTo.sn > fragFrom.sn) {
      const contiguous = fragFrom.cc === fragTo.cc;
      // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS
      if (contiguous && fragFrom.minEndPTS) {
        fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);
      } else {
        fragTo.start = fragFrom.start + fragFrom.duration;
      }
    } else {
      fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
    }
  }
  function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
    const parsedMediaDuration = endPTS - startPTS;
    if (parsedMediaDuration <= 0) {
      logger.warn('Fragment should have a positive duration', frag);
      endPTS = startPTS + frag.duration;
      endDTS = startDTS + frag.duration;
    }
    let maxStartPTS = startPTS;
    let minEndPTS = endPTS;
    const fragStartPts = frag.startPTS;
    const fragEndPts = frag.endPTS;
    if (isFiniteNumber(fragStartPts)) {
      // delta PTS between audio and video
      const deltaPTS = Math.abs(fragStartPts - startPTS);
      if (!isFiniteNumber(frag.deltaPTS)) {
        frag.deltaPTS = deltaPTS;
      } else {
        frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
      }
      maxStartPTS = Math.max(startPTS, fragStartPts);
      startPTS = Math.min(startPTS, fragStartPts);
      startDTS = Math.min(startDTS, frag.startDTS);
      minEndPTS = Math.min(endPTS, fragEndPts);
      endPTS = Math.max(endPTS, fragEndPts);
      endDTS = Math.max(endDTS, frag.endDTS);
    }
    const drift = startPTS - frag.start;
    if (frag.start !== 0) {
      frag.start = startPTS;
    }
    frag.duration = endPTS - frag.start;
    frag.startPTS = startPTS;
    frag.maxStartPTS = maxStartPTS;
    frag.startDTS = startDTS;
    frag.endPTS = endPTS;
    frag.minEndPTS = minEndPTS;
    frag.endDTS = endDTS;
    const sn = frag.sn; // 'initSegment'
    // exit if sn out of range
    if (!details || sn < details.startSN || sn > details.endSN) {
      return 0;
    }
    let i;
    const fragIdx = sn - details.startSN;
    const fragments = details.fragments;
    // update frag reference in fragments array
    // rationale is that fragments array might not contain this frag object.
    // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
    // if we don't update frag, we won't be able to propagate PTS info on the playlist
    // resulting in invalid sliding computation
    fragments[fragIdx] = frag;
    // adjust fragment PTS/duration from seqnum-1 to frag 0
    for (i = fragIdx; i > 0; i--) {
      updateFromToPTS(fragments[i], fragments[i - 1]);
    }

    // adjust fragment PTS/duration from seqnum to last frag
    for (i = fragIdx; i < fragments.length - 1; i++) {
      updateFromToPTS(fragments[i], fragments[i + 1]);
    }
    if (details.fragmentHint) {
      updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
    }
    details.PTSKnown = details.alignedSliding = true;
    return drift;
  }
  function mergeDetails(oldDetails, newDetails) {
    // Track the last initSegment processed. Initialize it to the last one on the timeline.
    let currentInitSegment = null;
    const oldFragments = oldDetails.fragments;
    for (let i = oldFragments.length - 1; i >= 0; i--) {
      const oldInit = oldFragments[i].initSegment;
      if (oldInit) {
        currentInitSegment = oldInit;
        break;
      }
    }
    if (oldDetails.fragmentHint) {
      // prevent PTS and duration from being adjusted on the next hint
      delete oldDetails.fragmentHint.endPTS;
    }
    // check if old/new playlists have fragments in common
    // loop through overlapping SN and update startPTS , cc, and duration if any found
    let ccOffset = 0;
    let PTSFrag;
    mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag) => {
      if (oldFrag.relurl) {
        // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.
        // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end
        // of the playlist.
        ccOffset = oldFrag.cc - newFrag.cc;
      }
      if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {
        newFrag.start = newFrag.startPTS = oldFrag.startPTS;
        newFrag.startDTS = oldFrag.startDTS;
        newFrag.maxStartPTS = oldFrag.maxStartPTS;
        newFrag.endPTS = oldFrag.endPTS;
        newFrag.endDTS = oldFrag.endDTS;
        newFrag.minEndPTS = oldFrag.minEndPTS;
        newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;
        if (newFrag.duration) {
          PTSFrag = newFrag;
        }

        // PTS is known when any segment has startPTS and endPTS
        newDetails.PTSKnown = newDetails.alignedSliding = true;
      }
      newFrag.elementaryStreams = oldFrag.elementaryStreams;
      newFrag.loader = oldFrag.loader;
      newFrag.stats = oldFrag.stats;
      if (oldFrag.initSegment) {
        newFrag.initSegment = oldFrag.initSegment;
        currentInitSegment = oldFrag.initSegment;
      }
    });
    if (currentInitSegment) {
      const fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
      fragmentsToCheck.forEach(frag => {
        var _currentInitSegment;
        if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {
          frag.initSegment = currentInitSegment;
        }
      });
    }
    if (newDetails.skippedSegments) {
      newDetails.deltaUpdateFailed = newDetails.fragments.some(frag => !frag);
      if (newDetails.deltaUpdateFailed) {
        logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');
        for (let i = newDetails.skippedSegments; i--;) {
          newDetails.fragments.shift();
        }
        newDetails.startSN = newDetails.fragments[0].sn;
        newDetails.startCC = newDetails.fragments[0].cc;
      } else if (newDetails.canSkipDateRanges) {
        newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);
      }
    }
    const newFragments = newDetails.fragments;
    if (ccOffset) {
      logger.warn('discontinuity sliding from playlist, take drift into account');
      for (let i = 0; i < newFragments.length; i++) {
        newFragments[i].cc += ccOffset;
      }
    }
    if (newDetails.skippedSegments) {
      newDetails.startCC = newDetails.fragments[0].cc;
    }

    // Merge parts
    mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart) => {
      newPart.elementaryStreams = oldPart.elementaryStreams;
      newPart.stats = oldPart.stats;
    });

    // if at least one fragment contains PTS info, recompute PTS information for all fragments
    if (PTSFrag) {
      updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
    } else {
      // ensure that delta is within oldFragments range
      // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
      // in that case we also need to adjust start offset of all fragments
      adjustSliding(oldDetails, newDetails);
    }
    if (newFragments.length) {
      newDetails.totalduration = newDetails.edge - newFragments[0].start;
    }
    newDetails.driftStartTime = oldDetails.driftStartTime;
    newDetails.driftStart = oldDetails.driftStart;
    const advancedDateTime = newDetails.advancedDateTime;
    if (newDetails.advanced && advancedDateTime) {
      const edge = newDetails.edge;
      if (!newDetails.driftStart) {
        newDetails.driftStartTime = advancedDateTime;
        newDetails.driftStart = edge;
      }
      newDetails.driftEndTime = advancedDateTime;
      newDetails.driftEnd = edge;
    } else {
      newDetails.driftEndTime = oldDetails.driftEndTime;
      newDetails.driftEnd = oldDetails.driftEnd;
      newDetails.advancedDateTime = oldDetails.advancedDateTime;
    }
  }
  function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {
    const dateRanges = _extends$2({}, oldDateRanges);
    if (recentlyRemovedDateranges) {
      recentlyRemovedDateranges.forEach(id => {
        delete dateRanges[id];
      });
    }
    Object.keys(deltaDateRanges).forEach(id => {
      const dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);
      if (dateRange.isValid) {
        dateRanges[id] = dateRange;
      } else {
        logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(deltaDateRanges[id].attr)}"`);
      }
    });
    return dateRanges;
  }
  function mapPartIntersection(oldParts, newParts, intersectionFn) {
    if (oldParts && newParts) {
      let delta = 0;
      for (let i = 0, len = oldParts.length; i <= len; i++) {
        const oldPart = oldParts[i];
        const newPart = newParts[i + delta];
        if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {
          intersectionFn(oldPart, newPart);
        } else {
          delta--;
        }
      }
    }
  }
  function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
    const skippedSegments = newDetails.skippedSegments;
    const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
    const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
    const delta = newDetails.startSN - oldDetails.startSN;
    const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
    const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;
    for (let i = start; i <= end; i++) {
      const oldFrag = oldFrags[delta + i];
      let newFrag = newFrags[i];
      if (skippedSegments && !newFrag && i < skippedSegments) {
        // Fill in skipped segments in delta playlist
        newFrag = newDetails.fragments[i] = oldFrag;
      }
      if (oldFrag && newFrag) {
        intersectionFn(oldFrag, newFrag);
      }
    }
  }
  function adjustSliding(oldDetails, newDetails) {
    const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
    const oldFragments = oldDetails.fragments;
    if (delta < 0 || delta >= oldFragments.length) {
      return;
    }
    addSliding(newDetails, oldFragments[delta].start);
  }
  function addSliding(details, start) {
    if (start) {
      const fragments = details.fragments;
      for (let i = details.skippedSegments; i < fragments.length; i++) {
        fragments[i].start += start;
      }
      if (details.fragmentHint) {
        details.fragmentHint.start += start;
      }
    }
  }
  function computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {
    let reloadInterval = 1000 * newDetails.targetduration;
    if (newDetails.updated) {
      // Use last segment duration when shorter than target duration and near live edge
      const fragments = newDetails.fragments;
      const liveEdgeMaxTargetDurations = 4;
      if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {
        const lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;
        if (lastSegmentDuration < reloadInterval) {
          reloadInterval = lastSegmentDuration;
        }
      }
    } else {
      // estimate = 'miss half average';
      // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
      // changed then it MUST wait for a period of one-half the target
      // duration before retrying.
      reloadInterval /= 2;
    }
    return Math.round(reloadInterval);
  }
  function getFragmentWithSN(level, sn, fragCurrent) {
    if (!(level != null && level.details)) {
      return null;
    }
    const levelDetails = level.details;
    let fragment = levelDetails.fragments[sn - levelDetails.startSN];
    if (fragment) {
      return fragment;
    }
    fragment = levelDetails.fragmentHint;
    if (fragment && fragment.sn === sn) {
      return fragment;
    }
    if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {
      return fragCurrent;
    }
    return null;
  }
  function getPartWith(level, sn, partIndex) {
    var _level$details;
    if (!(level != null && level.details)) {
      return null;
    }
    return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);
  }
  function findPart(partList, sn, partIndex) {
    if (partList) {
      for (let i = partList.length; i--;) {
        const part = partList[i];
        if (part.index === partIndex && part.fragment.sn === sn) {
          return part;
        }
      }
    }
    return null;
  }
  function reassignFragmentLevelIndexes(levels) {
    levels.forEach((level, index) => {
      const {
        details
      } = level;
      if (details != null && details.fragments) {
        details.fragments.forEach(fragment => {
          fragment.level = index;
        });
      }
    });
  }

  function isTimeoutError(error) {
    switch (error.details) {
      case ErrorDetails.FRAG_LOAD_TIMEOUT:
      case ErrorDetails.KEY_LOAD_TIMEOUT:
      case ErrorDetails.LEVEL_LOAD_TIMEOUT:
      case ErrorDetails.MANIFEST_LOAD_TIMEOUT:
        return true;
    }
    return false;
  }
  function getRetryConfig(loadPolicy, error) {
    const isTimeout = isTimeoutError(error);
    return loadPolicy.default[`${isTimeout ? 'timeout' : 'error'}Retry`];
  }
  function getRetryDelay(retryConfig, retryCount) {
    // exponential backoff capped to max retry delay
    const backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);
    return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);
  }
  function getLoaderConfigWithoutReties(loderConfig) {
    return _objectSpread2(_objectSpread2({}, loderConfig), {
      errorRetry: null,
      timeoutRetry: null
    });
  }
  function shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {
    if (!retryConfig) {
      return false;
    }
    const httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;
    const retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);
    return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;
  }
  function retryForHttpStatus(httpStatus) {
    // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)
    return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);
  }

  const BinarySearch = {
    /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param list The array to search.
     * @param comparisonFn
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @returns the object if found, otherwise returns null
     */
    search: function (list, comparisonFn) {
      let minIndex = 0;
      let maxIndex = list.length - 1;
      let currentIndex = null;
      let currentElement = null;
      while (minIndex <= maxIndex) {
        currentIndex = (minIndex + maxIndex) / 2 | 0;
        currentElement = list[currentIndex];
        const comparisonResult = comparisonFn(currentElement);
        if (comparisonResult > 0) {
          minIndex = currentIndex + 1;
        } else if (comparisonResult < 0) {
          maxIndex = currentIndex - 1;
        } else {
          return currentElement;
        }
      }
      return null;
    }
  };

  /**
   * Returns first fragment whose endPdt value exceeds the given PDT, or null.
   * @param fragments - The array of candidate fragments
   * @param PDTValue - The PDT value which must be exceeded
   * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
   */
  function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
    if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {
      return null;
    }

    // if less than start
    const startPDT = fragments[0].programDateTime;
    if (PDTValue < (startPDT || 0)) {
      return null;
    }
    const endPDT = fragments[fragments.length - 1].endProgramDateTime;
    if (PDTValue >= (endPDT || 0)) {
      return null;
    }
    maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
    for (let seg = 0; seg < fragments.length; ++seg) {
      const frag = fragments[seg];
      if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
        return frag;
      }
    }
    return null;
  }

  /**
   * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.
   * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus
   * breaking any traps which would cause the same fragment to be continuously selected within a small range.
   * @param fragPrevious - The last frag successfully appended
   * @param fragments - The array of candidate fragments
   * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within
   * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
   * @returns a matching fragment or null
   */
  function findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0, nextFragLookupTolerance = 0.005) {
    let fragNext = null;
    if (fragPrevious) {
      fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;
      // check for buffer-end rounding error
      const bufferEdgeError = fragPrevious.endDTS - bufferEnd;
      if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {
        bufferEnd += 0.0000015;
      }
    } else if (bufferEnd === 0 && fragments[0].start === 0) {
      fragNext = fragments[0];
    }
    // Prefer the next fragment if it's within tolerance
    if (fragNext && ((!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0 || fragmentWithinFastStartSwitch(fragNext, fragPrevious, Math.min(nextFragLookupTolerance, maxFragLookUpTolerance)))) {
      return fragNext;
    }
    // We might be seeking past the tolerance so find the best match
    const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
    if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {
      return foundFragment;
    }
    // If no match was found return the next fragment after fragPrevious, or null
    return fragNext;
  }
  function fragmentWithinFastStartSwitch(fragNext, fragPrevious, nextFragLookupTolerance) {
    if (fragPrevious && fragPrevious.start === 0 && fragPrevious.level < fragNext.level && (fragPrevious.endPTS || 0) > 0) {
      const firstDuration = fragPrevious.tagList.reduce((duration, tag) => {
        if (tag[0] === 'INF') {
          duration += parseFloat(tag[1]);
        }
        return duration;
      }, nextFragLookupTolerance);
      return fragNext.start <= firstDuration;
    }
    return false;
  }

  /**
   * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.
   * @param candidate - The fragment to test
   * @param bufferEnd - The end of the current buffered range the playhead is currently within
   * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous
   * @returns 0 if it matches, 1 if too low, -1 if too high
   */
  function fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {
    // eagerly accept an accurate match (no tolerance)
    if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {
      return 0;
    }
    // offset should be within fragment boundary - config.maxFragLookUpTolerance
    // this is to cope with situations like
    // bufferEnd = 9.991
    // frag[Ø] : [0,10]
    // frag[1] : [10,20]
    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
    //              frag start               frag start+duration
    //                  |-----------------------------|
    //              <--->                         <--->
    //  ...--------><-----------------------------><---------....
    // previous frag         matching fragment         next frag
    //  return -1             return 0                 return 1
    // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
    // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
    const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
      return 1;
    } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
      // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
      return -1;
    }
    return 0;
  }

  /**
   * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.
   * This function tests the candidate's program date time values, as represented in Unix time
   * @param candidate - The fragment to test
   * @param pdtBufferEnd - The Unix time representing the end of the current buffered range
   * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous
   * @returns true if contiguous, false otherwise
   */
  function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
    const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;

    // endProgramDateTime can be null, default to zero
    const endProgramDateTime = candidate.endProgramDateTime || 0;
    return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
  }
  function findFragWithCC(fragments, cc) {
    return BinarySearch.search(fragments, candidate => {
      if (candidate.cc < cc) {
        return 1;
      } else if (candidate.cc > cc) {
        return -1;
      } else {
        return 0;
      }
    });
  }

  var NetworkErrorAction = {
    DoNothing: 0,
    SendEndCallback: 1,
    SendAlternateToPenaltyBox: 2,
    RemoveAlternatePermanently: 3,
    InsertDiscontinuity: 4,
    RetryRequest: 5
  };
  var ErrorActionFlags = {
    None: 0,
    MoveAllAlternatesMatchingHost: 1,
    MoveAllAlternatesMatchingHDCP: 2,
    SwitchToSDR: 4
  }; // Reserved for future use
  class ErrorController {
    constructor(hls) {
      this.hls = void 0;
      this.playlistError = 0;
      this.penalizedRenditions = {};
      this.log = void 0;
      this.warn = void 0;
      this.error = void 0;
      this.hls = hls;
      this.log = logger.log.bind(logger, `[info]:`);
      this.warn = logger.warn.bind(logger, `[warning]:`);
      this.error = logger.error.bind(logger, `[error]:`);
      this.registerListeners();
    }
    registerListeners() {
      const hls = this.hls;
      hls.on(Events$1.ERROR, this.onError, this);
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.LEVEL_UPDATED, this.onLevelUpdated, this);
    }
    unregisterListeners() {
      const hls = this.hls;
      if (!hls) {
        return;
      }
      hls.off(Events$1.ERROR, this.onError, this);
      hls.off(Events$1.ERROR, this.onErrorOut, this);
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.LEVEL_UPDATED, this.onLevelUpdated, this);
    }
    destroy() {
      this.unregisterListeners();
      // @ts-ignore
      this.hls = null;
      this.penalizedRenditions = {};
    }
    startLoad(startPosition) {}
    stopLoad() {
      this.playlistError = 0;
    }
    getVariantLevelIndex(frag) {
      return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;
    }
    onManifestLoading() {
      this.playlistError = 0;
      this.penalizedRenditions = {};
    }
    onLevelUpdated() {
      this.playlistError = 0;
    }
    onError(event, data) {
      var _data$frag, _data$level;
      if (data.fatal) {
        return;
      }
      const hls = this.hls;
      const context = data.context;
      switch (data.details) {
        case ErrorDetails.FRAG_LOAD_ERROR:
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
        case ErrorDetails.KEY_LOAD_ERROR:
        case ErrorDetails.KEY_LOAD_TIMEOUT:
          data.errorAction = this.getFragRetryOrSwitchAction(data);
          return;
        case ErrorDetails.FRAG_PARSING_ERROR:
          // ignore empty segment errors marked as gap
          if ((_data$frag = data.frag) != null && _data$frag.gap) {
            data.errorAction = {
              action: NetworkErrorAction.DoNothing,
              flags: ErrorActionFlags.None
            };
            return;
          }
        // falls through
        case ErrorDetails.FRAG_GAP:
        case ErrorDetails.FRAG_DECRYPT_ERROR:
          {
            // Switch level if possible, otherwise allow retry count to reach max error retries
            data.errorAction = this.getFragRetryOrSwitchAction(data);
            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
            return;
          }
        case ErrorDetails.LEVEL_EMPTY_ERROR:
        case ErrorDetails.LEVEL_PARSING_ERROR:
          {
            var _data$context, _data$context$levelDe;
            // Only retry when empty and live
            const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;
            if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {
              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);
            } else {
              // Escalate to fatal if not retrying or switching
              data.levelRetry = false;
              data.errorAction = this.getLevelSwitchAction(data, levelIndex);
            }
          }
          return;
        case ErrorDetails.LEVEL_LOAD_ERROR:
        case ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (typeof (context == null ? void 0 : context.level) === 'number') {
            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);
          }
          return;
        case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case ErrorDetails.SUBTITLE_LOAD_ERROR:
        case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:
          if (context) {
            const level = hls.levels[hls.loadLevel];
            if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {
              // Perform Pathway switch or Redundant failover if possible for fastest recovery
              // otherwise allow playlist retry count to reach max error retries
              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);
              data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
              data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;
              return;
            }
          }
          return;
        case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
          {
            const level = hls.levels[hls.loadLevel];
            const restrictedHdcpLevel = level == null ? void 0 : level.attrs['HDCP-LEVEL'];
            if (restrictedHdcpLevel) {
              data.errorAction = {
                action: NetworkErrorAction.SendAlternateToPenaltyBox,
                flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,
                hdcpLevel: restrictedHdcpLevel
              };
            } else {
              this.keySystemError(data);
            }
          }
          return;
        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
        case ErrorDetails.REMUX_ALLOC_ERROR:
        case ErrorDetails.BUFFER_APPEND_ERROR:
          data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);
          return;
        case ErrorDetails.INTERNAL_EXCEPTION:
        case ErrorDetails.BUFFER_APPENDING_ERROR:
        case ErrorDetails.BUFFER_FULL_ERROR:
        case ErrorDetails.LEVEL_SWITCH_ERROR:
        case ErrorDetails.BUFFER_STALLED_ERROR:
        case ErrorDetails.BUFFER_SEEK_OVER_HOLE:
        case ErrorDetails.BUFFER_NUDGE_ON_STALL:
          data.errorAction = {
            action: NetworkErrorAction.DoNothing,
            flags: ErrorActionFlags.None
          };
          return;
      }
      if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {
        this.keySystemError(data);
      }
    }
    keySystemError(data) {
      const levelIndex = this.getVariantLevelIndex(data.frag);
      // Do not retry level. Escalate to fatal if switching levels fails.
      data.levelRetry = false;
      data.errorAction = this.getLevelSwitchAction(data, levelIndex);
    }
    getPlaylistRetryOrSwitchAction(data, levelIndex) {
      const hls = this.hls;
      const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);
      const retryCount = this.playlistError++;
      const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);
      if (retry) {
        return {
          action: NetworkErrorAction.RetryRequest,
          flags: ErrorActionFlags.None,
          retryConfig,
          retryCount
        };
      }
      const errorAction = this.getLevelSwitchAction(data, levelIndex);
      if (retryConfig) {
        errorAction.retryConfig = retryConfig;
        errorAction.retryCount = retryCount;
      }
      return errorAction;
    }
    getFragRetryOrSwitchAction(data) {
      const hls = this.hls;
      // Share fragment error count accross media options (main, audio, subs)
      // This allows for level based rendition switching when media option assets fail
      const variantLevelIndex = this.getVariantLevelIndex(data.frag);
      const level = hls.levels[variantLevelIndex];
      const {
        fragLoadPolicy,
        keyLoadPolicy
      } = hls.config;
      const retryConfig = getRetryConfig(data.details.startsWith('key') ? keyLoadPolicy : fragLoadPolicy, data);
      const fragmentErrors = hls.levels.reduce((acc, level) => acc + level.fragmentError, 0);
      // Switch levels when out of retried or level index out of bounds
      if (level) {
        if (data.details !== ErrorDetails.FRAG_GAP) {
          level.fragmentError++;
        }
        const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);
        if (retry) {
          return {
            action: NetworkErrorAction.RetryRequest,
            flags: ErrorActionFlags.None,
            retryConfig,
            retryCount: fragmentErrors
          };
        }
      }
      // Reach max retry count, or Missing level reference
      // Switch to valid index
      const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);
      // Add retry details to allow skipping of FRAG_PARSING_ERROR
      if (retryConfig) {
        errorAction.retryConfig = retryConfig;
        errorAction.retryCount = fragmentErrors;
      }
      return errorAction;
    }
    getLevelSwitchAction(data, levelIndex) {
      const hls = this.hls;
      if (levelIndex === null || levelIndex === undefined) {
        levelIndex = hls.loadLevel;
      }
      const level = this.hls.levels[levelIndex];
      if (level) {
        var _data$frag2, _data$context2;
        const errorDetails = data.details;
        level.loadError++;
        if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {
          level.fragmentError++;
        }
        // Search for next level to retry
        let nextLevel = -1;
        const {
          levels,
          loadLevel,
          minAutoLevel,
          maxAutoLevel
        } = hls;
        if (!hls.autoLevelEnabled) {
          hls.loadLevel = -1;
        }
        const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;
        // Find alternate audio codec if available on audio codec error
        const isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === 'audio' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
        const findAudioCodecAlternate = isAudioCodecError && levels.some(({
          audioCodec
        }) => level.audioCodec !== audioCodec);
        // Find alternate video codec if available on video codec error
        const isVideoCodecError = data.sourceBufferName === 'video' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
        const findVideoCodecAlternate = isVideoCodecError && levels.some(({
          codecSet,
          audioCodec
        }) => level.codecSet !== codecSet && level.audioCodec === audioCodec);
        const {
          type: playlistErrorType,
          groupId: playlistErrorGroupId
        } = (_data$context2 = data.context) != null ? _data$context2 : {};
        for (let i = levels.length; i--;) {
          const candidate = (i + loadLevel) % levels.length;
          if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {
            var _level$audioGroups, _level$subtitleGroups;
            const levelCandidate = levels[candidate];
            // Skip level switch if GAP tag is found in next level at same position
            if (errorDetails === ErrorDetails.FRAG_GAP && fragErrorType === PlaylistLevelType.MAIN && data.frag) {
              const levelDetails = levels[candidate].details;
              if (levelDetails) {
                const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);
                if (fragCandidate != null && fragCandidate.gap) {
                  continue;
                }
              }
            } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {
              // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over
              continue;
            } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some(groupId => levelCandidate.hasAudioGroup(groupId)) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some(groupId => levelCandidate.hasSubtitleGroup(groupId)) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {
              // For video/audio/subs frag errors find another group ID or fallthrough to redundant fail-over
              continue;
            }
            nextLevel = candidate;
            break;
          }
        }
        if (nextLevel > -1 && hls.loadLevel !== nextLevel) {
          data.levelRetry = true;
          this.playlistError = 0;
          return {
            action: NetworkErrorAction.SendAlternateToPenaltyBox,
            flags: ErrorActionFlags.None,
            nextAutoLevel: nextLevel
          };
        }
      }
      // No levels to switch / Manual level selection / Level not found
      // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level
      return {
        action: NetworkErrorAction.SendAlternateToPenaltyBox,
        flags: ErrorActionFlags.MoveAllAlternatesMatchingHost
      };
    }
    onErrorOut(event, data) {
      var _data$errorAction;
      switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {
        case NetworkErrorAction.DoNothing:
          break;
        case NetworkErrorAction.SendAlternateToPenaltyBox:
          this.sendAlternateToPenaltyBox(data);
          if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {
            data.fatal = true;
          } else if (/MediaSource readyState: ended/.test(data.error.message)) {
            this.warn(`MediaSource ended after "${data.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`);
            this.hls.recoverMediaError();
          }
          break;
      }
      if (data.fatal) {
        this.hls.stopLoad();
        return;
      }
    }
    sendAlternateToPenaltyBox(data) {
      const hls = this.hls;
      const errorAction = data.errorAction;
      if (!errorAction) {
        return;
      }
      const {
        flags,
        hdcpLevel,
        nextAutoLevel
      } = errorAction;
      switch (flags) {
        case ErrorActionFlags.None:
          this.switchLevel(data, nextAutoLevel);
          break;
        case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:
          if (hdcpLevel) {
            hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];
            errorAction.resolved = true;
          }
          this.warn(`Restricting playback to HDCP-LEVEL of "${hls.maxHdcpLevel}" or lower`);
          break;
      }
      // If not resolved by previous actions try to switch to next level
      if (!errorAction.resolved) {
        this.switchLevel(data, nextAutoLevel);
      }
    }
    switchLevel(data, levelIndex) {
      if (levelIndex !== undefined && data.errorAction) {
        this.warn(`switching to level ${levelIndex} after ${data.details}`);
        this.hls.nextAutoLevel = levelIndex;
        data.errorAction.resolved = true;
        // Stream controller is responsible for this but won't switch on false start
        this.hls.nextLoadLevel = this.hls.nextAutoLevel;
      }
    }
  }

  class BasePlaylistController {
    constructor(hls, logPrefix) {
      this.hls = void 0;
      this.timer = -1;
      this.requestScheduled = -1;
      this.canLoad = false;
      this.log = void 0;
      this.warn = void 0;
      this.log = logger.log.bind(logger, `${logPrefix}:`);
      this.warn = logger.warn.bind(logger, `${logPrefix}:`);
      this.hls = hls;
    }
    destroy() {
      this.clearTimer();
      // @ts-ignore
      this.hls = this.log = this.warn = null;
    }
    clearTimer() {
      if (this.timer !== -1) {
        self.clearTimeout(this.timer);
        this.timer = -1;
      }
    }
    startLoad() {
      this.canLoad = true;
      this.requestScheduled = -1;
      this.loadPlaylist();
    }
    stopLoad() {
      this.canLoad = false;
      this.clearTimer();
    }
    switchParams(playlistUri, previous, current) {
      const renditionReports = previous == null ? void 0 : previous.renditionReports;
      if (renditionReports) {
        let foundIndex = -1;
        for (let i = 0; i < renditionReports.length; i++) {
          const attr = renditionReports[i];
          let uri;
          try {
            uri = new self.URL(attr.URI, previous.url).href;
          } catch (error) {
            logger.warn(`Could not construct new URL for Rendition Report: ${error}`);
            uri = attr.URI || '';
          }
          // Use exact match. Otherwise, the last partial match, if any, will be used
          // (Playlist URI includes a query string that the Rendition Report does not)
          if (uri === playlistUri) {
            foundIndex = i;
            break;
          } else if (uri === playlistUri.substring(0, uri.length)) {
            foundIndex = i;
          }
        }
        if (foundIndex !== -1) {
          const attr = renditionReports[foundIndex];
          const msn = parseInt(attr['LAST-MSN']) || (previous == null ? void 0 : previous.lastPartSn);
          let part = parseInt(attr['LAST-PART']) || (previous == null ? void 0 : previous.lastPartIndex);
          if (this.hls.config.lowLatencyMode) {
            const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);
            if (part >= 0 && currentGoal > previous.partTarget) {
              part += 1;
            }
          }
          const skip = current && getSkipValue(current);
          return new HlsUrlParameters(msn, part >= 0 ? part : undefined, skip);
        }
      }
    }
    loadPlaylist(hlsUrlParameters) {
      if (this.requestScheduled === -1) {
        this.requestScheduled = self.performance.now();
      }
      // Loading is handled by the subclasses
    }
    shouldLoadPlaylist(playlist) {
      return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);
    }
    shouldReloadPlaylist(playlist) {
      return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);
    }
    playlistLoaded(index, data, previousDetails) {
      const {
        details,
        stats
      } = data;

      // Set last updated date-time
      const now = self.performance.now();
      const elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;
      details.advancedDateTime = Date.now() - elapsed;

      // if current playlist is a live playlist, arm a timer to reload it
      if (details.live || previousDetails != null && previousDetails.live) {
        details.reloaded(previousDetails);
        if (previousDetails) {
          this.log(`live playlist ${index} ${details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : details.updated ? 'UPDATED' : 'MISSED'}`);
        }
        // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments
        if (previousDetails && details.fragments.length > 0) {
          mergeDetails(previousDetails, details);
        }
        if (!this.canLoad || !details.live) {
          return;
        }
        let deliveryDirectives;
        let msn = undefined;
        let part = undefined;
        if (details.canBlockReload && details.endSN && details.advanced) {
          // Load level with LL-HLS delivery directives
          const lowLatencyMode = this.hls.config.lowLatencyMode;
          const lastPartSn = details.lastPartSn;
          const endSn = details.endSN;
          const lastPartIndex = details.lastPartIndex;
          const hasParts = lastPartIndex !== -1;
          const lastPart = lastPartSn === endSn;
          // When low latency mode is disabled, we'll skip part requests once the last part index is found
          const nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;
          if (hasParts) {
            msn = lastPart ? endSn + 1 : lastPartSn;
            part = lastPart ? nextSnStartIndex : lastPartIndex + 1;
          } else {
            msn = endSn + 1;
          }
          // Low-Latency CDN Tune-in: "age" header and time since load indicates we're behind by more than one part
          // Update directives to obtain the Playlist that has the estimated additional duration of media
          const lastAdvanced = details.age;
          const cdnAge = lastAdvanced + details.ageHeader;
          let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);
          if (currentGoal > 0) {
            if (previousDetails && currentGoal > previousDetails.tuneInGoal) {
              // If we attempted to get the next or latest playlist update, but currentGoal increased,
              // then we either can't catchup, or the "age" header cannot be trusted.
              this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);
              currentGoal = 0;
            } else {
              const segments = Math.floor(currentGoal / details.targetduration);
              msn += segments;
              if (part !== undefined) {
                const parts = Math.round(currentGoal % details.targetduration / details.partTarget);
                part += parts;
              }
              this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);
            }
            details.tuneInGoal = currentGoal;
          }
          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
          if (lowLatencyMode || !lastPart) {
            this.loadPlaylist(deliveryDirectives);
            return;
          }
        } else if (details.canBlockReload || details.canSkipUntil) {
          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
        }
        const bufferInfo = this.hls.mainForwardBufferInfo;
        const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;
        const distanceToLiveEdgeMs = (details.edge - position) * 1000;
        const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);
        if (details.updated && now > this.requestScheduled + reloadInterval) {
          this.requestScheduled = stats.loading.start;
        }
        if (msn !== undefined && details.canBlockReload) {
          this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);
        } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {
          this.requestScheduled = now;
        } else if (this.requestScheduled - now <= 0) {
          this.requestScheduled += reloadInterval;
        }
        let estimatedTimeUntilUpdate = this.requestScheduled - now;
        estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);
        this.log(`reload live playlist ${index} in ${Math.round(estimatedTimeUntilUpdate)} ms`);
        // this.log(
        //   `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}
        // reload in ${estimatedTimeUntilUpdate / 1000}
        // round trip ${(stats.loading.end - stats.loading.start) / 1000}
        // diff ${
        //   (reloadInterval -
        //     (estimatedTimeUntilUpdate +
        //       stats.loading.end -
        //       stats.loading.start)) /
        //   1000
        // }
        // reload interval ${reloadInterval / 1000}
        // target duration ${details.targetduration}
        // distance to edge ${distanceToLiveEdgeMs / 1000}`
        // );

        this.timer = self.setTimeout(() => this.loadPlaylist(deliveryDirectives), estimatedTimeUntilUpdate);
      } else {
        this.clearTimer();
      }
    }
    getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {
      let skip = getSkipValue(details);
      if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {
        msn = previousDeliveryDirectives.msn;
        part = previousDeliveryDirectives.part;
        skip = HlsSkip.No;
      }
      return new HlsUrlParameters(msn, part, skip);
    }
    checkRetry(errorEvent) {
      const errorDetails = errorEvent.details;
      const isTimeout = isTimeoutError(errorEvent);
      const errorAction = errorEvent.errorAction;
      const {
        action,
        retryCount = 0,
        retryConfig
      } = errorAction || {};
      const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);
      if (retry) {
        var _errorEvent$context;
        this.requestScheduled = -1;
        if (retryCount >= retryConfig.maxNumRetry) {
          return false;
        }
        if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {
          // The LL-HLS request already timed out so retry immediately
          this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after "${errorDetails}" without delivery-directives`);
          this.loadPlaylist();
        } else {
          const delay = getRetryDelay(retryConfig, retryCount);
          // Schedule level/track reload
          this.timer = self.setTimeout(() => this.loadPlaylist(), delay);
          this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after "${errorDetails}" in ${delay}ms`);
        }
        // `levelRetry = true` used to inform other controllers that a retry is happening
        errorEvent.levelRetry = true;
        errorAction.resolved = true;
      }
      return retry;
    }
  }

  /*
   * compute an Exponential Weighted moving average
   * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
   *  - heavily inspired from shaka-player
   */

  class EWMA {
    //  About half of the estimated value will be from the last |halfLife| samples by weight.
    constructor(halfLife, estimate = 0, weight = 0) {
      this.halfLife = void 0;
      this.alpha_ = void 0;
      this.estimate_ = void 0;
      this.totalWeight_ = void 0;
      this.halfLife = halfLife;
      // Larger values of alpha expire historical data more slowly.
      this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
      this.estimate_ = estimate;
      this.totalWeight_ = weight;
    }
    sample(weight, value) {
      const adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
    getTotalWeight() {
      return this.totalWeight_;
    }
    getEstimate() {
      if (this.alpha_) {
        const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        if (zeroFactor) {
          return this.estimate_ / zeroFactor;
        }
      }
      return this.estimate_;
    }
  }

  /*
   * EWMA Bandwidth Estimator
   *  - heavily inspired from shaka-player
   * Tracks bandwidth samples and estimates available bandwidth.
   * Based on the minimum of two exponentially-weighted moving averages with
   * different half-lives.
   */

  class EwmaBandWidthEstimator {
    constructor(slow, fast, defaultEstimate, defaultTTFB = 100) {
      this.defaultEstimate_ = void 0;
      this.minWeight_ = void 0;
      this.minDelayMs_ = void 0;
      this.slow_ = void 0;
      this.fast_ = void 0;
      this.defaultTTFB_ = void 0;
      this.ttfb_ = void 0;
      this.defaultEstimate_ = defaultEstimate;
      this.minWeight_ = 0.001;
      this.minDelayMs_ = 50;
      this.slow_ = new EWMA(slow);
      this.fast_ = new EWMA(fast);
      this.defaultTTFB_ = defaultTTFB;
      this.ttfb_ = new EWMA(slow);
    }
    update(slow, fast) {
      const {
        slow_,
        fast_,
        ttfb_
      } = this;
      if (slow_.halfLife !== slow) {
        this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());
      }
      if (fast_.halfLife !== fast) {
        this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());
      }
      if (ttfb_.halfLife !== slow) {
        this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());
      }
    }
    sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      const numBits = 8 * numBytes;
      // weight is duration in seconds
      const durationS = durationMs / 1000;
      // value is bandwidth in bits/s
      const bandwidthInBps = numBits / durationS;
      this.fast_.sample(durationS, bandwidthInBps);
      this.slow_.sample(durationS, bandwidthInBps);
    }
    sampleTTFB(ttfb) {
      // weight is frequency curve applied to TTFB in seconds
      // (longer times have less weight with expected input under 1 second)
      const seconds = ttfb / 1000;
      const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);
      this.ttfb_.sample(weight, Math.max(ttfb, 5));
    }
    canEstimate() {
      return this.fast_.getTotalWeight() >= this.minWeight_;
    }
    getEstimate() {
      if (this.canEstimate()) {
        // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
    getEstimateTTFB() {
      if (this.ttfb_.getTotalWeight() >= this.minWeight_) {
        return this.ttfb_.getEstimate();
      } else {
        return this.defaultTTFB_;
      }
    }
    destroy() {}
  }

  const SUPPORTED_INFO_DEFAULT = {
    supported: true,
    configurations: [],
    decodingInfoResults: [{
      supported: true,
      powerEfficient: true,
      smooth: true
    }]
  };
  const SUPPORTED_INFO_CACHE = {};
  function requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {
    // Only test support when configuration is exceeds minimum options
    const audioGroups = level.audioCodec ? level.audioGroups : null;
    const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;
    const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;
    const maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;
    let audioChannels = null;
    if (audioGroups != null && audioGroups.length) {
      try {
        if (audioGroups.length === 1 && audioGroups[0]) {
          audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;
        } else {
          audioChannels = audioGroups.reduce((acc, groupId) => {
            if (groupId) {
              const audioTrackGroup = audioTracksByGroup.groups[groupId];
              if (!audioTrackGroup) {
                throw new Error(`Audio track group ${groupId} not found`);
              }
              // Sum all channel key values
              Object.keys(audioTrackGroup.channels).forEach(key => {
                acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];
              });
            }
            return acc;
          }, {
            2: 0
          });
        }
      } catch (error) {
        return true;
      }
    }
    return level.videoCodec !== undefined && (level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== 'SDR' && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8e6)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some(channels => parseInt(channels) > maxChannels);
  }
  function getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities) {
    const videoCodecs = level.videoCodec;
    const audioCodecs = level.audioCodec;
    if (!videoCodecs || !audioCodecs || !mediaCapabilities) {
      return Promise.resolve(SUPPORTED_INFO_DEFAULT);
    }
    const baseVideoConfiguration = {
      width: level.width,
      height: level.height,
      bitrate: Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate)),
      // Assume a framerate of 30fps since MediaCapabilities will not accept Level default of 0.
      framerate: level.frameRate || 30
    };
    const videoRange = level.videoRange;
    if (videoRange !== 'SDR') {
      baseVideoConfiguration.transferFunction = videoRange.toLowerCase();
    }
    const configurations = videoCodecs.split(',').map(videoCodec => ({
      type: 'media-source',
      video: _objectSpread2(_objectSpread2({}, baseVideoConfiguration), {}, {
        contentType: mimeTypeForCodec(videoCodec, 'video')
      })
    }));
    if (audioCodecs && level.audioGroups) {
      level.audioGroups.forEach(audioGroupId => {
        var _audioTracksByGroup$g;
        if (!audioGroupId) {
          return;
        }
        (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks.forEach(audioTrack => {
          if (audioTrack.groupId === audioGroupId) {
            const channels = audioTrack.channels || '';
            const channelsNumber = parseFloat(channels);
            if (isFiniteNumber(channelsNumber) && channelsNumber > 2) {
              configurations.push.apply(configurations, audioCodecs.split(',').map(audioCodec => ({
                type: 'media-source',
                audio: {
                  contentType: mimeTypeForCodec(audioCodec, 'audio'),
                  channels: '' + channelsNumber
                  // spatialRendering:
                  //   audioCodec === 'ec-3' && channels.indexOf('JOC'),
                }
              })));
            }
          }
        });
      });
    }
    return Promise.all(configurations.map(configuration => {
      // Cache MediaCapabilities promises
      const decodingInfoKey = getMediaDecodingInfoKey(configuration);
      return SUPPORTED_INFO_CACHE[decodingInfoKey] || (SUPPORTED_INFO_CACHE[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));
    })).then(decodingInfoResults => ({
      supported: !decodingInfoResults.some(info => !info.supported),
      configurations,
      decodingInfoResults
    })).catch(error => ({
      supported: false,
      configurations,
      decodingInfoResults: [],
      error
    }));
  }
  function getMediaDecodingInfoKey(config) {
    const {
      audio,
      video
    } = config;
    const mediaConfig = video || audio;
    if (mediaConfig) {
      const codec = mediaConfig.contentType.split('"')[1];
      if (video) {
        return `r${video.height}x${video.width}f${Math.ceil(video.framerate)}${video.transferFunction || 'sd'}_${codec}_${Math.ceil(video.bitrate / 1e5)}`;
      }
      if (audio) {
        return `c${audio.channels}${audio.spatialRendering ? 's' : 'n'}_${codec}`;
      }
    }
    return '';
  }

  /**
   * @returns Whether we can detect and validate HDR capability within the window context
   */
  function isHdrSupported() {
    if (typeof matchMedia === 'function') {
      const mediaQueryList = matchMedia('(dynamic-range: high)');
      const badQuery = matchMedia('bad query');
      if (mediaQueryList.media !== badQuery.media) {
        return mediaQueryList.matches === true;
      }
    }
    return false;
  }

  /**
   * Sanitizes inputs to return the active video selection options for HDR/SDR.
   * When both inputs are null:
   *
   *    `{ preferHDR: false, allowedVideoRanges: [] }`
   *
   * When `currentVideoRange` non-null, maintain the active range:
   *
   *    `{ preferHDR: currentVideoRange !== 'SDR', allowedVideoRanges: [currentVideoRange] }`
   *
   * When VideoSelectionOption non-null:
   *
   *  - Allow all video ranges if `allowedVideoRanges` unspecified.
   *  - If `preferHDR` is non-null use the value to filter `allowedVideoRanges`.
   *  - Else check window for HDR support and set `preferHDR` to the result.
   *
   * @param currentVideoRange
   * @param videoPreference
   */
  function getVideoSelectionOptions(currentVideoRange, videoPreference) {
    let preferHDR = false;
    let allowedVideoRanges = [];
    if (currentVideoRange) {
      preferHDR = currentVideoRange !== 'SDR';
      allowedVideoRanges = [currentVideoRange];
    }
    if (videoPreference) {
      allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);
      preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : isHdrSupported();
      if (preferHDR) {
        allowedVideoRanges = allowedVideoRanges.filter(range => range !== 'SDR');
      } else {
        allowedVideoRanges = ['SDR'];
      }
    }
    return {
      preferHDR,
      allowedVideoRanges
    };
  }

  function getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {
    const codecSets = Object.keys(codecTiers);
    const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;
    const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;
    const preferStereo = channelsPreference && parseInt(channelsPreference) === 2;
    // Use first level set to determine stereo, and minimum resolution and framerate
    let hasStereo = true;
    let hasCurrentVideoRange = false;
    let minHeight = Infinity;
    let minFramerate = Infinity;
    let minBitrate = Infinity;
    let selectedScore = 0;
    let videoRanges = [];
    const {
      preferHDR,
      allowedVideoRanges
    } = getVideoSelectionOptions(currentVideoRange, videoPreference);
    for (let i = codecSets.length; i--;) {
      const tier = codecTiers[codecSets[i]];
      hasStereo = tier.channels[2] > 0;
      minHeight = Math.min(minHeight, tier.minHeight);
      minFramerate = Math.min(minFramerate, tier.minFramerate);
      minBitrate = Math.min(minBitrate, tier.minBitrate);
      const matchingVideoRanges = allowedVideoRanges.filter(range => tier.videoRanges[range] > 0);
      if (matchingVideoRanges.length > 0) {
        hasCurrentVideoRange = true;
        videoRanges = matchingVideoRanges;
      }
    }
    minHeight = isFiniteNumber(minHeight) ? minHeight : 0;
    minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;
    const maxHeight = Math.max(1080, minHeight);
    const maxFramerate = Math.max(30, minFramerate);
    minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;
    currentBw = Math.max(minBitrate, currentBw);
    // If there are no variants with matching preference, set currentVideoRange to undefined
    if (!hasCurrentVideoRange) {
      currentVideoRange = undefined;
      videoRanges = [];
    }
    const codecSet = codecSets.reduce((selected, candidate) => {
      // Remove candiates which do not meet bitrate, default audio, stereo or channels preference, 1080p or lower, 30fps or lower, or SDR/HDR selection if present
      const candidateTier = codecTiers[candidate];
      if (candidate === selected) {
        return selected;
      }
      if (candidateTier.minBitrate > currentBw) {
        logStartCodecCandidateIgnored(candidate, `min bitrate of ${candidateTier.minBitrate} > current estimate of ${currentBw}`);
        return selected;
      }
      if (!candidateTier.hasDefaultAudio) {
        logStartCodecCandidateIgnored(candidate, `no renditions with default or auto-select sound found`);
        return selected;
      }
      if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {
        logStartCodecCandidateIgnored(candidate, `audio codec preference "${audioCodecPreference}" not found`);
        return selected;
      }
      if (channelsPreference && !preferStereo) {
        if (!candidateTier.channels[channelsPreference]) {
          logStartCodecCandidateIgnored(candidate, `no renditions with ${channelsPreference} channel sound found (channels options: ${Object.keys(candidateTier.channels)})`);
          return selected;
        }
      } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels['2'] === 0) {
        logStartCodecCandidateIgnored(candidate, `no renditions with stereo sound found`);
        return selected;
      }
      if (candidateTier.minHeight > maxHeight) {
        logStartCodecCandidateIgnored(candidate, `min resolution of ${candidateTier.minHeight} > maximum of ${maxHeight}`);
        return selected;
      }
      if (candidateTier.minFramerate > maxFramerate) {
        logStartCodecCandidateIgnored(candidate, `min framerate of ${candidateTier.minFramerate} > maximum of ${maxFramerate}`);
        return selected;
      }
      if (!videoRanges.some(range => candidateTier.videoRanges[range] > 0)) {
        logStartCodecCandidateIgnored(candidate, `no variants with VIDEO-RANGE of ${JSON.stringify(videoRanges)} found`);
        return selected;
      }
      if (candidateTier.maxScore < selectedScore) {
        logStartCodecCandidateIgnored(candidate, `max score of ${candidateTier.maxScore} < selected max of ${selectedScore}`);
        return selected;
      }
      // Remove candiates with less preferred codecs or more errors
      if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {
        return selected;
      }
      selectedScore = candidateTier.maxScore;
      return candidate;
    }, undefined);
    return {
      codecSet,
      videoRanges,
      preferHDR,
      minFramerate,
      minBitrate
    };
  }
  function logStartCodecCandidateIgnored(codeSet, reason) {
    logger.log(`[abr] start candidates with "${codeSet}" ignored because ${reason}`);
  }
  function getAudioTracksByGroup(allAudioTracks) {
    return allAudioTracks.reduce((audioTracksByGroup, track) => {
      let trackGroup = audioTracksByGroup.groups[track.groupId];
      if (!trackGroup) {
        trackGroup = audioTracksByGroup.groups[track.groupId] = {
          tracks: [],
          channels: {
            2: 0
          },
          hasDefault: false,
          hasAutoSelect: false
        };
      }
      trackGroup.tracks.push(track);
      const channelsKey = track.channels || '2';
      trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;
      trackGroup.hasDefault = trackGroup.hasDefault || track.default;
      trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;
      if (trackGroup.hasDefault) {
        audioTracksByGroup.hasDefaultAudio = true;
      }
      if (trackGroup.hasAutoSelect) {
        audioTracksByGroup.hasAutoSelectAudio = true;
      }
      return audioTracksByGroup;
    }, {
      hasDefaultAudio: false,
      hasAutoSelectAudio: false,
      groups: {}
    });
  }
  function getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {
    return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce((tiers, level) => {
      if (!level.codecSet) {
        return tiers;
      }
      const audioGroups = level.audioGroups;
      let tier = tiers[level.codecSet];
      if (!tier) {
        tiers[level.codecSet] = tier = {
          minBitrate: Infinity,
          minHeight: Infinity,
          minFramerate: Infinity,
          maxScore: 0,
          videoRanges: {
            SDR: 0
          },
          channels: {
            '2': 0
          },
          hasDefaultAudio: !audioGroups,
          fragmentError: 0
        };
      }
      tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);
      const lesserWidthOrHeight = Math.min(level.height, level.width);
      tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);
      tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);
      tier.maxScore = Math.max(tier.maxScore, level.score);
      tier.fragmentError += level.fragmentError;
      tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;
      if (audioGroups) {
        audioGroups.forEach(audioGroupId => {
          if (!audioGroupId) {
            return;
          }
          const audioGroup = audioTracksByGroup.groups[audioGroupId];
          if (!audioGroup) {
            return;
          }
          // Default audio is any group with DEFAULT=YES, or if missing then any group with AUTOSELECT=YES, or all variants
          tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;
          Object.keys(audioGroup.channels).forEach(channels => {
            tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];
          });
        });
      }
      return tiers;
    }, {});
  }
  function findMatchingOption(option, tracks, matchPredicate) {
    if ('attrs' in option) {
      const index = tracks.indexOf(option);
      if (index !== -1) {
        return index;
      }
    }
    for (let i = 0; i < tracks.length; i++) {
      const track = tracks[i];
      if (matchesOption(option, track, matchPredicate)) {
        return i;
      }
    }
    return -1;
  }
  function matchesOption(option, track, matchPredicate) {
    const {
      groupId,
      name,
      lang,
      assocLang,
      characteristics,
      default: isDefault
    } = option;
    const forced = option.forced;
    return (groupId === undefined || track.groupId === groupId) && (name === undefined || track.name === name) && (lang === undefined || track.lang === lang) && (lang === undefined || track.assocLang === assocLang) && (isDefault === undefined || track.default === isDefault) && (forced === undefined || track.forced === forced) && (characteristics === undefined || characteristicsMatch(characteristics, track.characteristics)) && (matchPredicate === undefined || matchPredicate(option, track));
  }
  function characteristicsMatch(characteristicsA, characteristicsB = '') {
    const arrA = characteristicsA.split(',');
    const arrB = characteristicsB.split(',');
    // Expects each item to be unique:
    return arrA.length === arrB.length && !arrA.some(el => arrB.indexOf(el) === -1);
  }
  function audioMatchPredicate(option, track) {
    const {
      audioCodec,
      channels
    } = option;
    return (audioCodec === undefined || (track.audioCodec || '').substring(0, 4) === audioCodec.substring(0, 4)) && (channels === undefined || channels === (track.channels || '2'));
  }
  function findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {
    const currentLevel = levels[searchIndex];
    // Are there variants with same URI as current level?
    // If so, find a match that does not require any level URI change
    const variants = levels.reduce((variantMap, level, index) => {
      const uri = level.uri;
      const renditions = variantMap[uri] || (variantMap[uri] = []);
      renditions.push(index);
      return variantMap;
    }, {});
    const renditions = variants[currentLevel.uri];
    if (renditions.length > 1) {
      searchIndex = Math.max.apply(Math, renditions);
    }
    // Find best match
    const currentVideoRange = currentLevel.videoRange;
    const currentFrameRate = currentLevel.frameRate;
    const currentVideoCodec = currentLevel.codecSet.substring(0, 4);
    const matchingVideo = searchDownAndUpList(levels, searchIndex, level => {
      if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {
        return false;
      }
      const audioGroups = level.audioGroups;
      const tracks = allAudioTracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);
      return findMatchingOption(option, tracks, matchPredicate) > -1;
    });
    if (matchingVideo > -1) {
      return matchingVideo;
    }
    return searchDownAndUpList(levels, searchIndex, level => {
      const audioGroups = level.audioGroups;
      const tracks = allAudioTracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);
      return findMatchingOption(option, tracks, matchPredicate) > -1;
    });
  }
  function searchDownAndUpList(arr, searchIndex, predicate) {
    for (let i = searchIndex; i; i--) {
      if (predicate(arr[i])) {
        return i;
      }
    }
    for (let i = searchIndex + 1; i < arr.length; i++) {
      if (predicate(arr[i])) {
        return i;
      }
    }
    return -1;
  }

  class AbrController {
    constructor(_hls) {
      this.hls = void 0;
      this.lastLevelLoadSec = 0;
      this.lastLoadedFragLevel = -1;
      this.firstSelection = -1;
      this._nextAutoLevel = -1;
      this.nextAutoLevelKey = '';
      this.audioTracksByGroup = null;
      this.codecTiers = null;
      this.timer = -1;
      this.fragCurrent = null;
      this.partCurrent = null;
      this.bitrateTestDelay = 0;
      this.bwEstimator = void 0;
      /*
          This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load
          quickly enough to prevent underbuffering
        */
      this._abandonRulesCheck = () => {
        const {
          fragCurrent: frag,
          partCurrent: part,
          hls
        } = this;
        const {
          autoLevelEnabled,
          media
        } = hls;
        if (!frag || !media) {
          return;
        }
        const now = performance.now();
        const stats = part ? part.stats : frag.stats;
        const duration = part ? part.duration : frag.duration;
        const timeLoading = now - stats.loading.start;
        const minAutoLevel = hls.minAutoLevel;
        // If frag loading is aborted, complete, or from lowest level, stop timer and return
        if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level <= minAutoLevel) {
          this.clearTimer();
          // reset forced auto level value so that next level will be selected
          this._nextAutoLevel = -1;
          return;
        }

        // This check only runs if we're in ABR mode and actually playing
        if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {
          return;
        }
        const bufferInfo = hls.mainForwardBufferInfo;
        if (bufferInfo === null) {
          return;
        }
        const ttfbEstimate = this.bwEstimator.getEstimateTTFB();
        const playbackRate = Math.abs(media.playbackRate);
        // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed
        if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {
          return;
        }

        // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer
        const bufferStarvationDelay = bufferInfo.len / playbackRate;
        const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
        const loadedFirstByte = stats.loaded && ttfb > -1;
        const bwEstimate = this.getBwEstimate();
        const levels = hls.levels;
        const level = levels[frag.level];
        const expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.averageBitrate / 8));
        let timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;
        if (timeStreaming < 1 && loadedFirstByte) {
          timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);
        }
        const loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;
        // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment
        const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;
        // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left
        if (fragLoadedDelay <= bufferStarvationDelay) {
          return;
        }
        const bwe = loadRate ? loadRate * 8 : bwEstimate;
        let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
        let nextLoadLevel;
        // Iterate through lower level and try to find the largest one that avoids rebuffering
        for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
          // compute time to load next fragment at lower level
          // 8 = bits per byte (bps/Bps)
          const levelNextBitrate = levels[nextLoadLevel].maxBitrate;
          fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);
          if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
            break;
          }
        }
        // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing
        // to load the current one
        if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
          return;
        }

        // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down
        if (fragLevelNextLoadedDelay > duration * 10) {
          return;
        }
        hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;
        if (loadedFirstByte) {
          // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time
          this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
        } else {
          // If there has been no loading progress, sample TTFB
          this.bwEstimator.sampleTTFB(timeLoading);
        }
        const nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;
        if (this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > nextLoadLevelBitrate) {
          this.resetEstimator(nextLoadLevelBitrate);
        }
        this.clearTimer();
        logger.warn(`[abr] Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${frag.level} is loading too slowly;
      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s
      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s
      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s
      TTFB estimate: ${ttfb | 0} ms
      Current BW estimate: ${isFiniteNumber(bwEstimate) ? bwEstimate | 0 : 'Unknown'} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${nextLoadLevel} @ ${nextLoadLevelBitrate | 0} bps`);
        hls.trigger(Events$1.FRAG_LOAD_EMERGENCY_ABORTED, {
          frag,
          part,
          stats
        });
      };
      this.hls = _hls;
      this.bwEstimator = this.initEstimator();
      this.registerListeners();
    }
    resetEstimator(abrEwmaDefaultEstimate) {
      if (abrEwmaDefaultEstimate) {
        logger.log(`setting initial bwe to ${abrEwmaDefaultEstimate}`);
        this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;
      }
      this.firstSelection = -1;
      this.bwEstimator = this.initEstimator();
    }
    initEstimator() {
      const config = this.hls.config;
      return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.FRAG_LOADING, this.onFragLoading, this);
      hls.on(Events$1.FRAG_LOADED, this.onFragLoaded, this);
      hls.on(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.on(Events$1.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.on(Events$1.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events$1.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.on(Events$1.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
      hls.on(Events$1.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      if (!hls) {
        return;
      }
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.FRAG_LOADING, this.onFragLoading, this);
      hls.off(Events$1.FRAG_LOADED, this.onFragLoaded, this);
      hls.off(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.off(Events$1.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.off(Events$1.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events$1.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.off(Events$1.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
      hls.off(Events$1.ERROR, this.onError, this);
    }
    destroy() {
      this.unregisterListeners();
      this.clearTimer();
      // @ts-ignore
      this.hls = this._abandonRulesCheck = null;
      this.fragCurrent = this.partCurrent = null;
    }
    onManifestLoading(event, data) {
      this.lastLoadedFragLevel = -1;
      this.firstSelection = -1;
      this.lastLevelLoadSec = 0;
      this.fragCurrent = this.partCurrent = null;
      this.onLevelsUpdated();
      this.clearTimer();
    }
    onLevelsUpdated() {
      if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {
        this.lastLoadedFragLevel = this.fragCurrent.level;
      }
      this._nextAutoLevel = -1;
      this.onMaxAutoLevelUpdated();
      this.codecTiers = null;
      this.audioTracksByGroup = null;
    }
    onMaxAutoLevelUpdated() {
      this.firstSelection = -1;
      this.nextAutoLevelKey = '';
    }
    onFragLoading(event, data) {
      const frag = data.frag;
      if (this.ignoreFragment(frag)) {
        return;
      }
      if (!frag.bitrateTest) {
        var _data$part;
        this.fragCurrent = frag;
        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
      }
      this.clearTimer();
      this.timer = self.setInterval(this._abandonRulesCheck, 100);
    }
    onLevelSwitching(event, data) {
      this.clearTimer();
    }
    onError(event, data) {
      if (data.fatal) {
        return;
      }
      switch (data.details) {
        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
        case ErrorDetails.BUFFER_APPEND_ERROR:
          // Reset last loaded level so that a new selection can be made after calling recoverMediaError
          this.lastLoadedFragLevel = -1;
          this.firstSelection = -1;
          break;
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
          {
            const frag = data.frag;
            const {
              fragCurrent,
              partCurrent: part
            } = this;
            if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {
              const now = performance.now();
              const stats = part ? part.stats : frag.stats;
              const timeLoading = now - stats.loading.start;
              const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
              const loadedFirstByte = stats.loaded && ttfb > -1;
              if (loadedFirstByte) {
                const ttfbEstimate = this.bwEstimator.getEstimateTTFB();
                this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
              } else {
                this.bwEstimator.sampleTTFB(timeLoading);
              }
            }
            break;
          }
      }
    }
    getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {
      const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;
      const playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;
      return fragLoadSec + playlistLoadSec;
    }
    onLevelLoaded(event, data) {
      const config = this.hls.config;
      const {
        loading
      } = data.stats;
      const timeLoadingMs = loading.end - loading.start;
      if (isFiniteNumber(timeLoadingMs)) {
        this.lastLevelLoadSec = timeLoadingMs / 1000;
      }
      if (data.details.live) {
        this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);
      } else {
        this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);
      }
    }
    onFragLoaded(event, {
      frag,
      part
    }) {
      const stats = part ? part.stats : frag.stats;
      if (frag.type === PlaylistLevelType.MAIN) {
        this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);
      }
      if (this.ignoreFragment(frag)) {
        return;
      }
      // stop monitoring bw once frag loaded
      this.clearTimer();
      // reset forced auto level value so that next level will be selected
      if (frag.level === this._nextAutoLevel) {
        this._nextAutoLevel = -1;
      }
      this.firstSelection = -1;

      // compute level average bitrate
      if (this.hls.config.abrMaxWithRealBitrate) {
        const duration = part ? part.duration : frag.duration;
        const level = this.hls.levels[frag.level];
        const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
        const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;
        level.loaded = {
          bytes: loadedBytes,
          duration: loadedDuration
        };
        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
      }
      if (frag.bitrateTest) {
        const fragBufferedData = {
          stats,
          frag,
          part,
          id: frag.type
        };
        this.onFragBuffered(Events$1.FRAG_BUFFERED, fragBufferedData);
        frag.bitrateTest = false;
      } else {
        // store level id after successful fragment load for playback
        this.lastLoadedFragLevel = frag.level;
      }
    }
    onFragBuffered(event, data) {
      const {
        frag,
        part
      } = data;
      const stats = part != null && part.stats.loaded ? part.stats : frag.stats;
      if (stats.aborted) {
        return;
      }
      if (this.ignoreFragment(frag)) {
        return;
      }
      // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;
      // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch
      // is used. If we used buffering in that case, our BW estimate sample will be very large.
      const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());
      this.bwEstimator.sample(processingMs, stats.loaded);
      stats.bwEstimate = this.getBwEstimate();
      if (frag.bitrateTest) {
        this.bitrateTestDelay = processingMs / 1000;
      } else {
        this.bitrateTestDelay = 0;
      }
    }
    ignoreFragment(frag) {
      // Only count non-alt-audio frags which were actually buffered in our BW calculations
      return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';
    }
    clearTimer() {
      if (this.timer > -1) {
        self.clearInterval(this.timer);
        this.timer = -1;
      }
    }
    get firstAutoLevel() {
      const {
        maxAutoLevel,
        minAutoLevel
      } = this.hls;
      const bwEstimate = this.getBwEstimate();
      const maxStartDelay = this.hls.config.maxStarvationDelay;
      const abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);
      if (abrAutoLevel > -1) {
        return abrAutoLevel;
      }
      const firstLevel = this.hls.firstLevel;
      const clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);
      logger.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${firstLevel} clamped to ${clamped}`);
      return clamped;
    }
    get forcedAutoLevel() {
      if (this.nextAutoLevelKey) {
        return -1;
      }
      return this._nextAutoLevel;
    }

    // return next auto level
    get nextAutoLevel() {
      const forcedAutoLevel = this.forcedAutoLevel;
      const bwEstimator = this.bwEstimator;
      const useEstimate = bwEstimator.canEstimate();
      const loadedFirstFrag = this.lastLoadedFragLevel > -1;
      // in case next auto level has been forced, and bw not available or not reliable, return forced value
      if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {
        return forcedAutoLevel;
      }

      // compute next level using ABR logic
      const nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;

      // use forced auto level while it hasn't errored more than ABR selection
      if (forcedAutoLevel !== -1) {
        const levels = this.hls.levels;
        if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {
          return forcedAutoLevel;
        }
      }

      // save result until state has changed
      this._nextAutoLevel = nextABRAutoLevel;
      this.nextAutoLevelKey = this.getAutoLevelKey();
      return nextABRAutoLevel;
    }
    getAutoLevelKey() {
      return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;
    }
    getNextABRAutoLevel() {
      const {
        fragCurrent,
        partCurrent,
        hls
      } = this;
      const {
        maxAutoLevel,
        config,
        minAutoLevel
      } = hls;
      const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
      const avgbw = this.getBwEstimate();
      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      const bufferStarvationDelay = this.getStarvationDelay();
      let bwFactor = config.abrBandWidthFactor;
      let bwUpFactor = config.abrBandWidthUpFactor;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      if (bufferStarvationDelay) {
        const _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);
        if (_bestLevel >= 0) {
          return _bestLevel;
        }
      }
      // not possible to get rid of rebuffering... try to find level that will guarantee less than maxStarvationDelay of rebuffering
      let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
      if (!bufferStarvationDelay) {
        // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
        const bitrateTestDelay = this.bitrateTestDelay;
        if (bitrateTestDelay) {
          // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
          // max video loading delay used in  automatic start level selection :
          // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
          // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
          // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
          const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
          maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
          logger.info(`[abr] bitrate test took ${Math.round(1000 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1000 * maxStarvationDelay)} ms`);
          // don't use conservative factor on bitrate test
          bwFactor = bwUpFactor = 1;
        }
      }
      const bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);
      logger.info(`[abr] ${bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty'}, optimal quality level ${bestLevel}`);
      if (bestLevel > -1) {
        return bestLevel;
      }
      // If no matching level found, see if min auto level would be a better option
      const minLevel = hls.levels[minAutoLevel];
      const autoLevel = hls.levels[hls.loadLevel];
      if ((minLevel == null ? void 0 : minLevel.bitrate) < (autoLevel == null ? void 0 : autoLevel.bitrate)) {
        return minAutoLevel;
      }
      // or if bitrate is not lower, continue to use loadLevel
      return hls.loadLevel;
    }
    getStarvationDelay() {
      const hls = this.hls;
      const media = hls.media;
      if (!media) {
        return Infinity;
      }
      // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;
      const bufferInfo = hls.mainForwardBufferInfo;
      return (bufferInfo ? bufferInfo.len : 0) / playbackRate;
    }
    getBwEstimate() {
      return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
    }
    findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {
      var _level$details;
      const maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;
      const lastLoadedFragLevel = this.lastLoadedFragLevel;
      const selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;
      const {
        fragCurrent,
        partCurrent
      } = this;
      const {
        levels,
        allAudioTracks,
        loadLevel,
        config
      } = this.hls;
      if (levels.length === 1) {
        return 0;
      }
      const level = levels[selectionBaseLevel];
      const live = !!(level != null && (_level$details = level.details) != null && _level$details.live);
      const firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;
      let currentCodecSet;
      let currentVideoRange = 'SDR';
      let currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;
      const {
        audioPreference,
        videoPreference
      } = config;
      const audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));
      if (firstSelection) {
        if (this.firstSelection !== -1) {
          return this.firstSelection;
        }
        const codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));
        const startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);
        const {
          codecSet,
          videoRanges,
          minFramerate,
          minBitrate,
          preferHDR
        } = startTier;
        currentCodecSet = codecSet;
        currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];
        currentFrameRate = minFramerate;
        currentBw = Math.max(currentBw, minBitrate);
        logger.log(`[abr] picked start tier ${JSON.stringify(startTier)}`);
      } else {
        currentCodecSet = level == null ? void 0 : level.codecSet;
        currentVideoRange = level == null ? void 0 : level.videoRange;
      }
      const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
      const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;
      const levelsSkipped = [];
      for (let i = maxAutoLevel; i >= minAutoLevel; i--) {
        var _levelInfo$supportedR;
        const levelInfo = levels[i];
        const upSwitch = i > selectionBaseLevel;
        if (!levelInfo) {
          continue;
        }
        if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {
          const mediaCapabilities = navigator.mediaCapabilities;
          if (typeof (mediaCapabilities == null ? void 0 : mediaCapabilities.decodingInfo) === 'function' && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {
            levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities);
            levelInfo.supportedPromise.then(decodingInfo => {
              if (!this.hls) {
                return;
              }
              levelInfo.supportedResult = decodingInfo;
              const levels = this.hls.levels;
              const index = levels.indexOf(levelInfo);
              if (decodingInfo.error) {
                logger.warn(`[abr] MediaCapabilities decodingInfo error: "${decodingInfo.error}" for level ${index} ${JSON.stringify(decodingInfo)}`);
              } else if (!decodingInfo.supported) {
                logger.warn(`[abr] Unsupported MediaCapabilities decodingInfo result for level ${index} ${JSON.stringify(decodingInfo)}`);
                if (index > -1 && levels.length > 1) {
                  logger.log(`[abr] Removing unsupported level ${index}`);
                  this.hls.removeLevel(index);
                }
              }
            });
          } else {
            levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;
          }
        }

        // skip candidates which change codec-family or video-range,
        // and which decrease or increase frame-rate for up and down-switch respectfully
        if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || levelInfo.supportedResult && !((_levelInfo$supportedR = levelInfo.supportedResult.decodingInfoResults) != null && _levelInfo$supportedR[0].smooth)) {
          levelsSkipped.push(i);
          continue;
        }
        const levelDetails = levelInfo.details;
        const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;
        let adjustedbw;
        // follow algorithm captured from stagefright :
        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
        // Pick the highest bandwidth stream below or equal to estimated bandwidth.
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (!upSwitch) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }

        // Use average bitrate when starvation delay (buffer length) is gt or eq two segment durations and rebuffering is not expected (maxStarvationDelay > 0)
        const bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levels[i].averageBitrate : levels[i].maxBitrate;
        const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);
        const canSwitchWithinTolerance =
        // if adjusted bw is greater than level bitrate AND
        adjustedbw >= bitrate && (
        // no level change, or new level has no error history
        i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && (
        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
        fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration);
        if (canSwitchWithinTolerance) {
          const forcedAutoLevel = this.forcedAutoLevel;
          if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {
            if (levelsSkipped.length) {
              logger.trace(`[abr] Skipped level(s) ${levelsSkipped.join(',')} of ${maxAutoLevel} max with CODECS and VIDEO-RANGE:"${levels[levelsSkipped[0]].codecs}" ${levels[levelsSkipped[0]].videoRange}; not compatible with "${level.codecs}" ${currentVideoRange}`);
            }
            logger.info(`[abr] switch candidate:${selectionBaseLevel}->${i} adjustedbw(${Math.round(adjustedbw)})-bitrate=${Math.round(adjustedbw - bitrate)} ttfb:${ttfbEstimateSec.toFixed(1)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)} firstSelection:${firstSelection} codecSet:${currentCodecSet} videoRange:${currentVideoRange} hls.loadLevel:${loadLevel}`);
          }
          if (firstSelection) {
            this.firstSelection = i;
          }
          // as we are looping from highest to lowest, this will return the best achievable quality level
          return i;
        }
      }
      // not enough time budget even with quality level 0 ... rebuffering might happen
      return -1;
    }
    set nextAutoLevel(nextLevel) {
      const {
        maxAutoLevel,
        minAutoLevel
      } = this.hls;
      const value = Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);
      if (this._nextAutoLevel !== value) {
        this.nextAutoLevelKey = '';
        this._nextAutoLevel = value;
      }
    }
  }

  /**
   * @ignore
   * Sub-class specialization of EventHandler base class.
   *
   * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,
   * scheduled asynchroneously, avoiding recursive calls in the same tick.
   *
   * The task itself is implemented in `doTick`. It can be requested and called for single execution
   * using the `tick` method.
   *
   * It will be assured that the task execution method (`tick`) only gets called once per main loop "tick",
   * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.
   *
   * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,
   * and cancelled with `clearNextTick`.
   *
   * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).
   *
   * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.
   *
   * Further explanations:
   *
   * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously
   * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.
   *
   * When the task execution (`tick` method) is called in re-entrant way this is detected and
   * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further
   * task processing on the next main loop iteration (also known as "next tick" in the Node/JS runtime lingo).
   */
  class TaskLoop {
    constructor() {
      this._boundTick = void 0;
      this._tickTimer = null;
      this._tickInterval = null;
      this._tickCallCount = 0;
      this._boundTick = this.tick.bind(this);
    }
    destroy() {
      this.onHandlerDestroying();
      this.onHandlerDestroyed();
    }
    onHandlerDestroying() {
      // clear all timers before unregistering from event bus
      this.clearNextTick();
      this.clearInterval();
    }
    onHandlerDestroyed() {}
    hasInterval() {
      return !!this._tickInterval;
    }
    hasNextTick() {
      return !!this._tickTimer;
    }

    /**
     * @param millis - Interval time (ms)
     * @eturns True when interval has been scheduled, false when already scheduled (no effect)
     */
    setInterval(millis) {
      if (!this._tickInterval) {
        this._tickCallCount = 0;
        this._tickInterval = self.setInterval(this._boundTick, millis);
        return true;
      }
      return false;
    }

    /**
     * @returns True when interval was cleared, false when none was set (no effect)
     */
    clearInterval() {
      if (this._tickInterval) {
        self.clearInterval(this._tickInterval);
        this._tickInterval = null;
        return true;
      }
      return false;
    }

    /**
     * @returns True when timeout was cleared, false when none was set (no effect)
     */
    clearNextTick() {
      if (this._tickTimer) {
        self.clearTimeout(this._tickTimer);
        this._tickTimer = null;
        return true;
      }
      return false;
    }

    /**
     * Will call the subclass doTick implementation in this main loop tick
     * or in the next one (via setTimeout(,0)) in case it has already been called
     * in this tick (in case this is a re-entrant call).
     */
    tick() {
      this._tickCallCount++;
      if (this._tickCallCount === 1) {
        this.doTick();
        // re-entrant call to tick from previous doTick call stack
        // -> schedule a call on the next main loop iteration to process this task processing request
        if (this._tickCallCount > 1) {
          // make sure only one timer exists at any time at max
          this.tickImmediate();
        }
        this._tickCallCount = 0;
      }
    }
    tickImmediate() {
      this.clearNextTick();
      this._tickTimer = self.setTimeout(this._boundTick, 0);
    }

    /**
     * For subclass to implement task logic
     * @abstract
     */
    doTick() {}
  }

  var FragmentState = {
    NOT_LOADED: "NOT_LOADED",
    APPENDING: "APPENDING",
    PARTIAL: "PARTIAL",
    OK: "OK"
  };
  class FragmentTracker {
    constructor(hls) {
      this.activePartLists = Object.create(null);
      this.endListFragments = Object.create(null);
      this.fragments = Object.create(null);
      this.timeRanges = Object.create(null);
      this.bufferPadding = 0.2;
      this.hls = void 0;
      this.hasGaps = false;
      this.hls = hls;
      this._registerListeners();
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.BUFFER_APPENDED, this.onBufferAppended, this);
      hls.on(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.on(Events$1.FRAG_LOADED, this.onFragLoaded, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events$1.BUFFER_APPENDED, this.onBufferAppended, this);
      hls.off(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.off(Events$1.FRAG_LOADED, this.onFragLoaded, this);
    }
    destroy() {
      this._unregisterListeners();
      // @ts-ignore
      this.fragments =
      // @ts-ignore
      this.activePartLists =
      // @ts-ignore
      this.endListFragments = this.timeRanges = null;
    }

    /**
     * Return a Fragment or Part with an appended range that matches the position and levelType
     * Otherwise, return null
     */
    getAppendedFrag(position, levelType) {
      const activeParts = this.activePartLists[levelType];
      if (activeParts) {
        for (let i = activeParts.length; i--;) {
          const activePart = activeParts[i];
          if (!activePart) {
            break;
          }
          const appendedPTS = activePart.end;
          if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {
            return activePart;
          }
        }
      }
      return this.getBufferedFrag(position, levelType);
    }

    /**
     * Return a buffered Fragment that matches the position and levelType.
     * A buffered Fragment is one whose loading, parsing and appending is done (completed or "partial" meaning aborted).
     * If not found any Fragment, return null
     */
    getBufferedFrag(position, levelType) {
      const {
        fragments
      } = this;
      const keys = Object.keys(fragments);
      for (let i = keys.length; i--;) {
        const fragmentEntity = fragments[keys[i]];
        if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {
          const frag = fragmentEntity.body;
          if (frag.start <= position && position <= frag.end) {
            return frag;
          }
        }
      }
      return null;
    }

    /**
     * Partial fragments effected by coded frame eviction will be removed
     * The browser will unload parts of the buffer to free up memory for new buffer data
     * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
     */
    detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {
      if (this.timeRanges) {
        this.timeRanges[elementaryStream] = timeRange;
      }
      // Check if any flagged fragments have been unloaded
      // excluding anything newer than appendedPartSn
      const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;
      Object.keys(this.fragments).forEach(key => {
        const fragmentEntity = this.fragments[key];
        if (!fragmentEntity) {
          return;
        }
        if (appendedPartSn >= fragmentEntity.body.sn) {
          return;
        }
        if (!fragmentEntity.buffered && !fragmentEntity.loaded) {
          if (fragmentEntity.body.type === playlistType) {
            this.removeFragment(fragmentEntity.body);
          }
          return;
        }
        const esData = fragmentEntity.range[elementaryStream];
        if (!esData) {
          return;
        }
        esData.time.some(time => {
          const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);
          if (isNotBuffered) {
            // Unregister partial fragment as it needs to load again to be reused
            this.removeFragment(fragmentEntity.body);
          }
          return isNotBuffered;
        });
      });
    }

    /**
     * Checks if the fragment passed in is loaded in the buffer properly
     * Partially loaded fragments will be registered as a partial fragment
     */
    detectPartialFragments(data) {
      const timeRanges = this.timeRanges;
      const {
        frag,
        part
      } = data;
      if (!timeRanges || frag.sn === 'initSegment') {
        return;
      }
      const fragKey = getFragmentKey(frag);
      const fragmentEntity = this.fragments[fragKey];
      if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {
        return;
      }
      const isFragHint = !frag.relurl;
      Object.keys(timeRanges).forEach(elementaryStream => {
        const streamInfo = frag.elementaryStreams[elementaryStream];
        if (!streamInfo) {
          return;
        }
        const timeRange = timeRanges[elementaryStream];
        const partial = isFragHint || streamInfo.partial === true;
        fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, part, partial, timeRange);
      });
      fragmentEntity.loaded = null;
      if (Object.keys(fragmentEntity.range).length) {
        fragmentEntity.buffered = true;
        const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;
        if (endList) {
          this.endListFragments[fragmentEntity.body.type] = fragmentEntity;
        }
        if (!isPartial(fragmentEntity)) {
          // Remove older fragment parts from lookup after frag is tracked as buffered
          this.removeParts(frag.sn - 1, frag.type);
        }
      } else {
        // remove fragment if nothing was appended
        this.removeFragment(fragmentEntity.body);
      }
    }
    removeParts(snToKeep, levelType) {
      const activeParts = this.activePartLists[levelType];
      if (!activeParts) {
        return;
      }
      this.activePartLists[levelType] = activeParts.filter(part => part.fragment.sn >= snToKeep);
    }
    fragBuffered(frag, force) {
      const fragKey = getFragmentKey(frag);
      let fragmentEntity = this.fragments[fragKey];
      if (!fragmentEntity && force) {
        fragmentEntity = this.fragments[fragKey] = {
          body: frag,
          appendedPTS: null,
          loaded: null,
          buffered: false,
          range: Object.create(null)
        };
        if (frag.gap) {
          this.hasGaps = true;
        }
      }
      if (fragmentEntity) {
        fragmentEntity.loaded = null;
        fragmentEntity.buffered = true;
      }
    }
    getBufferedTimes(fragment, part, partial, timeRange) {
      const buffered = {
        time: [],
        partial
      };
      const startPTS = fragment.start;
      const endPTS = fragment.end;
      const minEndPTS = fragment.minEndPTS || endPTS;
      const maxStartPTS = fragment.maxStartPTS || startPTS;
      for (let i = 0; i < timeRange.length; i++) {
        const startTime = timeRange.start(i) - this.bufferPadding;
        const endTime = timeRange.end(i) + this.bufferPadding;
        if (maxStartPTS >= startTime && minEndPTS <= endTime) {
          // Fragment is entirely contained in buffer
          // No need to check the other timeRange times since it's completely playable
          buffered.time.push({
            startPTS: Math.max(startPTS, timeRange.start(i)),
            endPTS: Math.min(endPTS, timeRange.end(i))
          });
          break;
        } else if (startPTS < endTime && endPTS > startTime) {
          const start = Math.max(startPTS, timeRange.start(i));
          const end = Math.min(endPTS, timeRange.end(i));
          if (end > start) {
            buffered.partial = true;
            // Check for intersection with buffer
            // Get playable sections of the fragment
            buffered.time.push({
              startPTS: start,
              endPTS: end
            });
          }
        } else if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          break;
        }
      }
      return buffered;
    }

    /**
     * Gets the partial fragment for a certain time
     */
    getPartialFragment(time) {
      let bestFragment = null;
      let timePadding;
      let startTime;
      let endTime;
      let bestOverlap = 0;
      const {
        bufferPadding,
        fragments
      } = this;
      Object.keys(fragments).forEach(key => {
        const fragmentEntity = fragments[key];
        if (!fragmentEntity) {
          return;
        }
        if (isPartial(fragmentEntity)) {
          startTime = fragmentEntity.body.start - bufferPadding;
          endTime = fragmentEntity.body.end + bufferPadding;
          if (time >= startTime && time <= endTime) {
            // Use the fragment that has the most padding from start and end time
            timePadding = Math.min(time - startTime, endTime - time);
            if (bestOverlap <= timePadding) {
              bestFragment = fragmentEntity.body;
              bestOverlap = timePadding;
            }
          }
        }
      });
      return bestFragment;
    }
    isEndListAppended(type) {
      const lastFragmentEntity = this.endListFragments[type];
      return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));
    }
    getState(fragment) {
      const fragKey = getFragmentKey(fragment);
      const fragmentEntity = this.fragments[fragKey];
      if (fragmentEntity) {
        if (!fragmentEntity.buffered) {
          return FragmentState.APPENDING;
        } else if (isPartial(fragmentEntity)) {
          return FragmentState.PARTIAL;
        } else {
          return FragmentState.OK;
        }
      }
      return FragmentState.NOT_LOADED;
    }
    isTimeBuffered(startPTS, endPTS, timeRange) {
      let startTime;
      let endTime;
      for (let i = 0; i < timeRange.length; i++) {
        startTime = timeRange.start(i) - this.bufferPadding;
        endTime = timeRange.end(i) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          return true;
        }
        if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          return false;
        }
      }
      return false;
    }
    onFragLoaded(event, data) {
      const {
        frag,
        part
      } = data;
      // don't track initsegment (for which sn is not a number)
      // don't track frags used for bitrateTest, they're irrelevant.
      if (frag.sn === 'initSegment' || frag.bitrateTest) {
        return;
      }

      // Fragment entity `loaded` FragLoadedData is null when loading parts
      const loaded = part ? null : data;
      const fragKey = getFragmentKey(frag);
      this.fragments[fragKey] = {
        body: frag,
        appendedPTS: null,
        loaded,
        buffered: false,
        range: Object.create(null)
      };
    }
    onBufferAppended(event, data) {
      const {
        frag,
        part,
        timeRanges
      } = data;
      if (frag.sn === 'initSegment') {
        return;
      }
      const playlistType = frag.type;
      if (part) {
        let activeParts = this.activePartLists[playlistType];
        if (!activeParts) {
          this.activePartLists[playlistType] = activeParts = [];
        }
        activeParts.push(part);
      }
      // Store the latest timeRanges loaded in the buffer
      this.timeRanges = timeRanges;
      Object.keys(timeRanges).forEach(elementaryStream => {
        const timeRange = timeRanges[elementaryStream];
        this.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);
      });
    }
    onFragBuffered(event, data) {
      this.detectPartialFragments(data);
    }
    hasFragment(fragment) {
      const fragKey = getFragmentKey(fragment);
      return !!this.fragments[fragKey];
    }
    hasParts(type) {
      var _this$activePartLists;
      return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);
    }
    removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {
      if (withGapOnly && !this.hasGaps) {
        return;
      }
      Object.keys(this.fragments).forEach(key => {
        const fragmentEntity = this.fragments[key];
        if (!fragmentEntity) {
          return;
        }
        const frag = fragmentEntity.body;
        if (frag.type !== playlistType || withGapOnly && !frag.gap) {
          return;
        }
        if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {
          this.removeFragment(frag);
        }
      });
    }
    removeFragment(fragment) {
      const fragKey = getFragmentKey(fragment);
      fragment.stats.loaded = 0;
      fragment.clearElementaryStreamInfo();
      const activeParts = this.activePartLists[fragment.type];
      if (activeParts) {
        const snToRemove = fragment.sn;
        this.activePartLists[fragment.type] = activeParts.filter(part => part.fragment.sn !== snToRemove);
      }
      delete this.fragments[fragKey];
      if (fragment.endList) {
        delete this.endListFragments[fragment.type];
      }
    }
    removeAllFragments() {
      this.fragments = Object.create(null);
      this.endListFragments = Object.create(null);
      this.activePartLists = Object.create(null);
      this.hasGaps = false;
    }
  }
  function isPartial(fragmentEntity) {
    var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;
    return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));
  }
  function getFragmentKey(fragment) {
    return `${fragment.type}_${fragment.level}_${fragment.sn}`;
  }

  /**
   * Provides methods dealing with buffer length retrieval for example.
   *
   * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.
   *
   * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered
   */

  const noopBuffered = {
    length: 0,
    start: () => 0,
    end: () => 0
  };
  class BufferHelper {
    /**
     * Return true if `media`'s buffered include `position`
     */
    static isBuffered(media, position) {
      try {
        if (media) {
          const buffered = BufferHelper.getBuffered(media);
          for (let i = 0; i < buffered.length; i++) {
            if (position >= buffered.start(i) && position <= buffered.end(i)) {
              return true;
            }
          }
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return false;
    }
    static bufferInfo(media, pos, maxHoleDuration) {
      try {
        if (media) {
          const vbuffered = BufferHelper.getBuffered(media);
          const buffered = [];
          let i;
          for (i = 0; i < vbuffered.length; i++) {
            buffered.push({
              start: vbuffered.start(i),
              end: vbuffered.end(i)
            });
          }
          return this.bufferedInfo(buffered, pos, maxHoleDuration);
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return {
        len: 0,
        start: pos,
        end: pos,
        nextStart: undefined
      };
    }
    static bufferedInfo(buffered, pos, maxHoleDuration) {
      pos = Math.max(0, pos);
      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
      buffered.sort(function (a, b) {
        const diff = a.start - b.start;
        if (diff) {
          return diff;
        } else {
          return b.end - a.end;
        }
      });
      let buffered2 = [];
      if (maxHoleDuration) {
        // there might be some small holes between buffer time range
        // consider that holes smaller than maxHoleDuration are irrelevant and build another
        // buffer time range representations that discards those holes
        for (let i = 0; i < buffered.length; i++) {
          const buf2len = buffered2.length;
          if (buf2len) {
            const buf2end = buffered2[buf2len - 1].end;
            // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
            if (buffered[i].start - buf2end < maxHoleDuration) {
              // merge overlapping time ranges
              // update lastRange.end only if smaller than item.end
              // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
              // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
              if (buffered[i].end > buf2end) {
                buffered2[buf2len - 1].end = buffered[i].end;
              }
            } else {
              // big hole
              buffered2.push(buffered[i]);
            }
          } else {
            // first value
            buffered2.push(buffered[i]);
          }
        }
      } else {
        buffered2 = buffered;
      }
      let bufferLen = 0;

      // bufferStartNext can possibly be undefined based on the conditional logic below
      let bufferStartNext;

      // bufferStart and bufferEnd are buffer boundaries around current video position
      let bufferStart = pos;
      let bufferEnd = pos;
      for (let i = 0; i < buffered2.length; i++) {
        const start = buffered2[i].start;
        const end = buffered2[i].end;
        // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
        if (pos + maxHoleDuration >= start && pos < end) {
          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          bufferStartNext = start;
          break;
        }
      }
      return {
        len: bufferLen,
        start: bufferStart || 0,
        end: bufferEnd || 0,
        nextStart: bufferStartNext
      };
    }

    /**
     * Safe method to get buffered property.
     * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource
     */
    static getBuffered(media) {
      try {
        return media.buffered;
      } catch (e) {
        logger.log('failed to get media.buffered', e);
        return noopBuffered;
      }
    }
  }

  class ChunkMetadata {
    constructor(level, sn, id, size = 0, part = -1, partial = false) {
      this.level = void 0;
      this.sn = void 0;
      this.part = void 0;
      this.id = void 0;
      this.size = void 0;
      this.partial = void 0;
      this.transmuxing = getNewPerformanceTiming();
      this.buffering = {
        audio: getNewPerformanceTiming(),
        video: getNewPerformanceTiming(),
        audiovideo: getNewPerformanceTiming()
      };
      this.level = level;
      this.sn = sn;
      this.id = id;
      this.size = size;
      this.part = part;
      this.partial = partial;
    }
  }
  function getNewPerformanceTiming() {
    return {
      start: 0,
      executeStart: 0,
      executeEnd: 0,
      end: 0
    };
  }

  function findFirstFragWithCC(fragments, cc) {
    for (let i = 0, len = fragments.length; i < len; i++) {
      var _fragments$i;
      if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {
        return fragments[i];
      }
    }
    return null;
  }
  function shouldAlignOnDiscontinuities(lastFrag, switchDetails, details) {
    if (switchDetails) {
      if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
        return true;
      }
    }
    return false;
  }

  // Find the first frag in the previous level which matches the CC of the first frag of the new level
  function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
    const prevFrags = prevDetails.fragments;
    const curFrags = curDetails.fragments;
    if (!curFrags.length || !prevFrags.length) {
      logger.log('No fragments to align');
      return;
    }
    const prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
    if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
      logger.log('No frag in previous level to align on');
      return;
    }
    return prevStartFrag;
  }
  function adjustFragmentStart(frag, sliding) {
    if (frag) {
      const start = frag.start + sliding;
      frag.start = frag.startPTS = start;
      frag.endPTS = start + frag.duration;
    }
  }
  function adjustSlidingStart(sliding, details) {
    // Update segments
    const fragments = details.fragments;
    for (let i = 0, len = fragments.length; i < len; i++) {
      adjustFragmentStart(fragments[i], sliding);
    }
    // Update LL-HLS parts at the end of the playlist
    if (details.fragmentHint) {
      adjustFragmentStart(details.fragmentHint, sliding);
    }
    details.alignedSliding = true;
  }

  /**
   * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a
   * contiguous stream with the last fragments.
   * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to
   * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time
   * and an extra download.
   * @param lastFrag
   * @param lastLevel
   * @param details
   */
  function alignStream(lastFrag, switchDetails, details) {
    if (!switchDetails) {
      return;
    }
    alignDiscontinuities(lastFrag, details, switchDetails);
    if (!details.alignedSliding && switchDetails) {
      // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.
      // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same
      // discontinuity sequence.
      alignMediaPlaylistByPDT(details, switchDetails);
    }
    if (!details.alignedSliding && switchDetails && !details.skippedSegments) {
      // Try to align on sn so that we pick a better start fragment.
      // Do not perform this on playlists with delta updates as this is only to align levels on switch
      // and adjustSliding only adjusts fragments after skippedSegments.
      adjustSliding(switchDetails, details);
    }
  }

  /**
   * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same
   * discontinuity sequence.
   * @param lastFrag - The last Fragment which shares the same discontinuity sequence
   * @param lastLevel - The details of the last loaded level
   * @param details - The details of the new level
   */
  function alignDiscontinuities(lastFrag, details, switchDetails) {
    if (shouldAlignOnDiscontinuities(lastFrag, switchDetails, details)) {
      const referenceFrag = findDiscontinuousReferenceFrag(switchDetails, details);
      if (referenceFrag && isFiniteNumber(referenceFrag.start)) {
        logger.log(`Adjusting PTS using last level due to CC increase within current level ${details.url}`);
        adjustSlidingStart(referenceFrag.start, details);
      }
    }
  }

  /**
   * Ensures appropriate time-alignment between renditions based on PDT.
   * This function assumes the timelines represented in `refDetails` are accurate, including the PDTs
   * for the last discontinuity sequence number shared by both playlists when present,
   * and uses the "wallclock"/PDT timeline as a cross-reference to `details`, adjusting the presentation
   * times/timelines of `details` accordingly.
   * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,
   * the primary purpose of this function is to ensure the "local timelines" of audio/subtitle tracks
   * are aligned to the main/video timeline, using PDT as the cross-reference/"anchor" that should
   * be consistent across playlists, per the HLS spec.
   * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).
   * @param refDetails - The details of the reference rendition with start and PDT times for alignment.
   */
  function alignMediaPlaylistByPDT(details, refDetails) {
    if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {
      return;
    }
    const fragments = details.fragments;
    const refFragments = refDetails.fragments;
    if (!fragments.length || !refFragments.length) {
      return;
    }

    // Calculate a delta to apply to all fragments according to the delta in PDT times and start times
    // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.
    // If a fragment of the same discontinuity was not found use the middle fragment of both.
    let refFrag;
    let frag;
    const targetCC = Math.min(refDetails.endCC, details.endCC);
    if (refDetails.startCC < targetCC && details.startCC < targetCC) {
      refFrag = findFirstFragWithCC(refFragments, targetCC);
      frag = findFirstFragWithCC(fragments, targetCC);
    }
    if (!refFrag || !frag) {
      refFrag = refFragments[Math.floor(refFragments.length / 2)];
      frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];
    }
    const refPDT = refFrag.programDateTime;
    const targetPDT = frag.programDateTime;
    if (!refPDT || !targetPDT) {
      return;
    }
    const delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);
    adjustSlidingStart(delta, details);
  }

  const MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb

  class FragmentLoader {
    constructor(config) {
      this.config = void 0;
      this.loader = null;
      this.partLoadTimeout = -1;
      this.config = config;
    }
    destroy() {
      if (this.loader) {
        this.loader.destroy();
        this.loader = null;
      }
    }
    abort() {
      if (this.loader) {
        // Abort the loader for current fragment. Only one may load at any given time
        this.loader.abort();
      }
    }
    load(frag, onProgress) {
      const url = frag.url;
      if (!url) {
        return Promise.reject(new LoadError({
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.FRAG_LOAD_ERROR,
          fatal: false,
          frag,
          error: new Error(`Fragment does not have a ${url ? 'part list' : 'url'}`),
          networkDetails: null
        }));
      }
      this.abort();
      const config = this.config;
      const FragmentILoader = config.fLoader;
      const DefaultILoader = config.loader;
      return new Promise((resolve, reject) => {
        if (this.loader) {
          this.loader.destroy();
        }
        if (frag.gap) {
          if (frag.tagList.some(tags => tags[0] === 'GAP')) {
            reject(createGapLoadError(frag));
            return;
          } else {
            // Reset temporary treatment as GAP tag
            frag.gap = false;
          }
        }
        const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
        const loaderContext = createLoaderContext(frag);
        const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE
        };
        // Assign frag stats to the loader's stats reference
        frag.stats = loader.stats;
        loader.load(loaderContext, loaderConfig, {
          onSuccess: (response, stats, context, networkDetails) => {
            this.resetLoader(frag, loader);
            let payload = response.data;
            if (context.resetIV && frag.decryptdata) {
              frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));
              payload = payload.slice(16);
            }
            resolve({
              frag,
              part: null,
              payload,
              networkDetails
            });
          },
          onError: (response, context, networkDetails, stats) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_ERROR,
              fatal: false,
              frag,
              response: _objectSpread2({
                url,
                data: undefined
              }, response),
              error: new Error(`HTTP Error ${response.code} ${response.text}`),
              networkDetails,
              stats
            }));
          },
          onAbort: (stats, context, networkDetails) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.INTERNAL_ABORTED,
              fatal: false,
              frag,
              error: new Error('Aborted'),
              networkDetails,
              stats
            }));
          },
          onTimeout: (stats, context, networkDetails) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_TIMEOUT,
              fatal: false,
              frag,
              error: new Error(`Timeout after ${loaderConfig.timeout}ms`),
              networkDetails,
              stats
            }));
          },
          onProgress: (stats, context, data, networkDetails) => {
            if (onProgress) {
              onProgress({
                frag,
                part: null,
                payload: data,
                networkDetails
              });
            }
          }
        });
      });
    }
    loadPart(frag, part, onProgress) {
      this.abort();
      const config = this.config;
      const FragmentILoader = config.fLoader;
      const DefaultILoader = config.loader;
      return new Promise((resolve, reject) => {
        if (this.loader) {
          this.loader.destroy();
        }
        if (frag.gap || part.gap) {
          reject(createGapLoadError(frag, part));
          return;
        }
        const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
        const loaderContext = createLoaderContext(frag, part);
        // Should we define another load policy for parts?
        const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: MIN_CHUNK_SIZE
        };
        // Assign part stats to the loader's stats reference
        part.stats = loader.stats;
        loader.load(loaderContext, loaderConfig, {
          onSuccess: (response, stats, context, networkDetails) => {
            this.resetLoader(frag, loader);
            this.updateStatsFromPart(frag, part);
            const partLoadedData = {
              frag,
              part,
              payload: response.data,
              networkDetails
            };
            onProgress(partLoadedData);
            resolve(partLoadedData);
          },
          onError: (response, context, networkDetails, stats) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_ERROR,
              fatal: false,
              frag,
              part,
              response: _objectSpread2({
                url: loaderContext.url,
                data: undefined
              }, response),
              error: new Error(`HTTP Error ${response.code} ${response.text}`),
              networkDetails,
              stats
            }));
          },
          onAbort: (stats, context, networkDetails) => {
            frag.stats.aborted = part.stats.aborted;
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.INTERNAL_ABORTED,
              fatal: false,
              frag,
              part,
              error: new Error('Aborted'),
              networkDetails,
              stats
            }));
          },
          onTimeout: (stats, context, networkDetails) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_TIMEOUT,
              fatal: false,
              frag,
              part,
              error: new Error(`Timeout after ${loaderConfig.timeout}ms`),
              networkDetails,
              stats
            }));
          }
        });
      });
    }
    updateStatsFromPart(frag, part) {
      const fragStats = frag.stats;
      const partStats = part.stats;
      const partTotal = partStats.total;
      fragStats.loaded += partStats.loaded;
      if (partTotal) {
        const estTotalParts = Math.round(frag.duration / part.duration);
        const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
        const estRemainingParts = estTotalParts - estLoadedParts;
        const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
        fragStats.total = fragStats.loaded + estRemainingBytes;
      } else {
        fragStats.total = Math.max(fragStats.loaded, fragStats.total);
      }
      const fragLoading = fragStats.loading;
      const partLoading = partStats.loading;
      if (fragLoading.start) {
        // add to fragment loader latency
        fragLoading.first += partLoading.first - partLoading.start;
      } else {
        fragLoading.start = partLoading.start;
        fragLoading.first = partLoading.first;
      }
      fragLoading.end = partLoading.end;
    }
    resetLoader(frag, loader) {
      frag.loader = null;
      if (this.loader === loader) {
        self.clearTimeout(this.partLoadTimeout);
        this.loader = null;
      }
      loader.destroy();
    }
  }
  function createLoaderContext(frag, part = null) {
    const segment = part || frag;
    const loaderContext = {
      frag,
      part,
      responseType: 'arraybuffer',
      url: segment.url,
      headers: {},
      rangeStart: 0,
      rangeEnd: 0
    };
    const start = segment.byteRangeStartOffset;
    const end = segment.byteRangeEndOffset;
    if (isFiniteNumber(start) && isFiniteNumber(end)) {
      var _frag$decryptdata;
      let byteRangeStart = start;
      let byteRangeEnd = end;
      if (frag.sn === 'initSegment' && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === 'AES-128') {
        // MAP segment encrypted with method 'AES-128', when served with HTTP Range,
        // has the unencrypted size specified in the range.
        // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6
        const fragmentLen = end - start;
        if (fragmentLen % 16) {
          byteRangeEnd = end + (16 - fragmentLen % 16);
        }
        if (start !== 0) {
          loaderContext.resetIV = true;
          byteRangeStart = start - 16;
        }
      }
      loaderContext.rangeStart = byteRangeStart;
      loaderContext.rangeEnd = byteRangeEnd;
    }
    return loaderContext;
  }
  function createGapLoadError(frag, part) {
    const error = new Error(`GAP ${frag.gap ? 'tag' : 'attribute'} found`);
    const errorData = {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.FRAG_GAP,
      fatal: false,
      frag,
      error,
      networkDetails: null
    };
    if (part) {
      errorData.part = part;
    }
    (part ? part : frag).stats.aborted = true;
    return new LoadError(errorData);
  }
  class LoadError extends Error {
    constructor(data) {
      super(data.error.message);
      this.data = void 0;
      this.data = data;
    }
  }

  class AESCrypto {
    constructor(subtle, iv) {
      this.subtle = void 0;
      this.aesIV = void 0;
      this.subtle = subtle;
      this.aesIV = iv;
    }
    decrypt(data, key) {
      return this.subtle.decrypt({
        name: 'AES-CBC',
        iv: this.aesIV
      }, key, data);
    }
  }

  class FastAESKey {
    constructor(subtle, key) {
      this.subtle = void 0;
      this.key = void 0;
      this.subtle = subtle;
      this.key = key;
    }
    expandKey() {
      return this.subtle.importKey('raw', this.key, {
        name: 'AES-CBC'
      }, false, ['encrypt', 'decrypt']);
    }
  }

  // PKCS7
  function removePadding(array) {
    const outputBytes = array.byteLength;
    const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);
    if (paddingBytes) {
      return sliceUint8(array, 0, outputBytes - paddingBytes);
    }
    return array;
  }
  class AESDecryptor {
    constructor() {
      this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
      this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.sBox = new Uint32Array(256);
      this.invSBox = new Uint32Array(256);
      this.key = new Uint32Array(0);
      this.ksRows = 0;
      this.keySize = 0;
      this.keySchedule = void 0;
      this.invKeySchedule = void 0;
      this.initTable();
    }

    // Using view.getUint32() also swaps the byte order.
    uint8ArrayToUint32Array_(arrayBuffer) {
      const view = new DataView(arrayBuffer);
      const newArray = new Uint32Array(4);
      for (let i = 0; i < 4; i++) {
        newArray[i] = view.getUint32(i * 4);
      }
      return newArray;
    }
    initTable() {
      const sBox = this.sBox;
      const invSBox = this.invSBox;
      const subMix = this.subMix;
      const subMix0 = subMix[0];
      const subMix1 = subMix[1];
      const subMix2 = subMix[2];
      const subMix3 = subMix[3];
      const invSubMix = this.invSubMix;
      const invSubMix0 = invSubMix[0];
      const invSubMix1 = invSubMix[1];
      const invSubMix2 = invSubMix[2];
      const invSubMix3 = invSubMix[3];
      const d = new Uint32Array(256);
      let x = 0;
      let xi = 0;
      let i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }
      for (i = 0; i < 256; i++) {
        let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x;

        // Compute multiplication
        const x2 = d[x];
        const x4 = d[x2];
        const x8 = d[x4];

        // Compute sub/invSub bytes, mix columns tables
        let t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;

        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;

        // Compute next counter
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    }
    expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      const key = this.uint8ArrayToUint32Array_(keyBuffer);
      let sameKey = true;
      let offset = 0;
      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }
      if (sameKey) {
        return;
      }
      this.key = key;
      const keySize = this.keySize = key.length;
      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }
      const ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      let ksRow;
      let invKsRow;
      const keySchedule = this.keySchedule = new Uint32Array(ksRows);
      const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      const sbox = this.sBox;
      const rcon = this.rcon;
      const invSubMix = this.invSubMix;
      const invSubMix0 = invSubMix[0];
      const invSubMix1 = invSubMix[1];
      const invSubMix2 = invSubMix[2];
      const invSubMix3 = invSubMix[3];
      let prev;
      let t;
      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t = prev;
        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24;

          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

          // Mix Rcon
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }
        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }
      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }
        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }
        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }

    // Adding this as a method greatly improves performance.
    networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    }
    decrypt(inputArrayBuffer, offset, aesIV) {
      const nRounds = this.keySize + 6;
      const invKeySchedule = this.invKeySchedule;
      const invSBOX = this.invSBox;
      const invSubMix = this.invSubMix;
      const invSubMix0 = invSubMix[0];
      const invSubMix1 = invSubMix[1];
      const invSubMix2 = invSubMix[2];
      const invSubMix3 = invSubMix[3];
      const initVector = this.uint8ArrayToUint32Array_(aesIV);
      let initVector0 = initVector[0];
      let initVector1 = initVector[1];
      let initVector2 = initVector[2];
      let initVector3 = initVector[3];
      const inputInt32 = new Int32Array(inputArrayBuffer);
      const outputInt32 = new Int32Array(inputInt32.length);
      let t0, t1, t2, t3;
      let s0, s1, s2, s3;
      let inputWords0, inputWords1, inputWords2, inputWords3;
      let ksRow, i;
      const swapWord = this.networkToHostOrderSwap;
      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);
        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];
        ksRow = 4;

        // Iterate through the rounds of decryption
        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
          // Update state
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;
          ksRow = ksRow + 4;
        }

        // Shift rows, sub bytes, add round key
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];

        // Write
        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);

        // reset initVector to last 4 unsigned int
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;
        offset = offset + 4;
      }
      return outputInt32.buffer;
    }
  }

  const CHUNK_SIZE = 16; // 16 bytes, 128 bits

  class Decrypter {
    constructor(config, {
      removePKCS7Padding = true
    } = {}) {
      this.logEnabled = true;
      this.removePKCS7Padding = void 0;
      this.subtle = null;
      this.softwareDecrypter = null;
      this.key = null;
      this.fastAesKey = null;
      this.remainderData = null;
      this.currentIV = null;
      this.currentResult = null;
      this.useSoftware = void 0;
      this.useSoftware = config.enableSoftwareAES;
      this.removePKCS7Padding = removePKCS7Padding;
      // built in decryptor expects PKCS7 padding
      if (removePKCS7Padding) {
        try {
          const browserCrypto = self.crypto;
          if (browserCrypto) {
            this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
          }
        } catch (e) {
          /* no-op */
        }
      }
      this.useSoftware = !this.subtle;
    }
    destroy() {
      this.subtle = null;
      this.softwareDecrypter = null;
      this.key = null;
      this.fastAesKey = null;
      this.remainderData = null;
      this.currentIV = null;
      this.currentResult = null;
    }
    isSync() {
      return this.useSoftware;
    }
    flush() {
      const {
        currentResult,
        remainderData
      } = this;
      if (!currentResult || remainderData) {
        this.reset();
        return null;
      }
      const data = new Uint8Array(currentResult);
      this.reset();
      if (this.removePKCS7Padding) {
        return removePadding(data);
      }
      return data;
    }
    reset() {
      this.currentResult = null;
      this.currentIV = null;
      this.remainderData = null;
      if (this.softwareDecrypter) {
        this.softwareDecrypter = null;
      }
    }
    decrypt(data, key, iv) {
      if (this.useSoftware) {
        return new Promise((resolve, reject) => {
          this.softwareDecrypt(new Uint8Array(data), key, iv);
          const decryptResult = this.flush();
          if (decryptResult) {
            resolve(decryptResult.buffer);
          } else {
            reject(new Error('[softwareDecrypt] Failed to decrypt data'));
          }
        });
      }
      return this.webCryptoDecrypt(new Uint8Array(data), key, iv);
    }

    // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
    // data is handled in the flush() call
    softwareDecrypt(data, key, iv) {
      const {
        currentIV,
        currentResult,
        remainderData
      } = this;
      this.logOnce('JS AES decrypt');
      // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call
      // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached
      // the end on flush(), but by that time we have already received all bytes for the segment.
      // Progressive decryption does not work with WebCrypto

      if (remainderData) {
        data = appendUint8Array(remainderData, data);
        this.remainderData = null;
      }

      // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)
      const currentChunk = this.getValidChunk(data);
      if (!currentChunk.length) {
        return null;
      }
      if (currentIV) {
        iv = currentIV;
      }
      let softwareDecrypter = this.softwareDecrypter;
      if (!softwareDecrypter) {
        softwareDecrypter = this.softwareDecrypter = new AESDecryptor();
      }
      softwareDecrypter.expandKey(key);
      const result = currentResult;
      this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
      this.currentIV = sliceUint8(currentChunk, -16).buffer;
      if (!result) {
        return null;
      }
      return result;
    }
    webCryptoDecrypt(data, key, iv) {
      if (this.key !== key || !this.fastAesKey) {
        if (!this.subtle) {
          return Promise.resolve(this.onWebCryptoError(data, key, iv));
        }
        this.key = key;
        this.fastAesKey = new FastAESKey(this.subtle, key);
      }
      return this.fastAesKey.expandKey().then(aesKey => {
        // decrypt using web crypto
        if (!this.subtle) {
          return Promise.reject(new Error('web crypto not initialized'));
        }
        this.logOnce('WebCrypto AES decrypt');
        const crypto = new AESCrypto(this.subtle, new Uint8Array(iv));
        return crypto.decrypt(data.buffer, aesKey);
      }).catch(err => {
        logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);
        return this.onWebCryptoError(data, key, iv);
      });
    }
    onWebCryptoError(data, key, iv) {
      this.useSoftware = true;
      this.logEnabled = true;
      this.softwareDecrypt(data, key, iv);
      const decryptResult = this.flush();
      if (decryptResult) {
        return decryptResult.buffer;
      }
      throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');
    }
    getValidChunk(data) {
      let currentChunk = data;
      const splitPoint = data.length - data.length % CHUNK_SIZE;
      if (splitPoint !== data.length) {
        currentChunk = sliceUint8(data, 0, splitPoint);
        this.remainderData = sliceUint8(data, splitPoint);
      }
      return currentChunk;
    }
    logOnce(msg) {
      if (!this.logEnabled) {
        return;
      }
      logger.log(`[decrypter]: ${msg}`);
      this.logEnabled = false;
    }
  }

  /**
   *  TimeRanges to string helper
   */

  const TimeRanges = {
    toString: function (r) {
      let log = '';
      const len = r.length;
      for (let i = 0; i < len; i++) {
        log += `[${r.start(i).toFixed(3)}-${r.end(i).toFixed(3)}]`;
      }
      return log;
    }
  };

  const State = {
    STOPPED: 'STOPPED',
    IDLE: 'IDLE',
    KEY_LOADING: 'KEY_LOADING',
    FRAG_LOADING: 'FRAG_LOADING',
    FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
    WAITING_TRACK: 'WAITING_TRACK',
    PARSING: 'PARSING',
    PARSED: 'PARSED',
    ENDED: 'ENDED',
    ERROR: 'ERROR',
    WAITING_INIT_PTS: 'WAITING_INIT_PTS',
    WAITING_LEVEL: 'WAITING_LEVEL'
  };
  class BaseStreamController extends TaskLoop {
    constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {
      super();
      this.hls = void 0;
      this.fragPrevious = null;
      this.fragCurrent = null;
      this.fragmentTracker = void 0;
      this.transmuxer = null;
      this._state = State.STOPPED;
      this.playlistType = void 0;
      this.media = null;
      this.mediaBuffer = null;
      this.config = void 0;
      this.bitrateTest = false;
      this.lastCurrentTime = 0;
      this.nextLoadPosition = 0;
      this.startPosition = 0;
      this.startTimeOffset = null;
      this.loadedmetadata = false;
      this.retryDate = 0;
      this.levels = null;
      this.fragmentLoader = void 0;
      this.keyLoader = void 0;
      this.levelLastLoaded = null;
      this.startFragRequested = false;
      this.decrypter = void 0;
      this.initPTS = [];
      this.onvseeking = null;
      this.onvended = null;
      this.logPrefix = '';
      this.log = void 0;
      this.warn = void 0;
      this.playlistType = playlistType;
      this.logPrefix = logPrefix;
      this.log = logger.log.bind(logger, `${logPrefix}:`);
      this.warn = logger.warn.bind(logger, `${logPrefix}:`);
      this.hls = hls;
      this.fragmentLoader = new FragmentLoader(hls.config);
      this.keyLoader = keyLoader;
      this.fragmentTracker = fragmentTracker;
      this.config = hls.config;
      this.decrypter = new Decrypter(hls.config);
      hls.on(Events$1.MANIFEST_LOADED, this.onManifestLoaded, this);
    }
    doTick() {
      this.onTickEnd();
    }
    onTickEnd() {}

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    startLoad(startPosition) {}
    stopLoad() {
      this.fragmentLoader.abort();
      this.keyLoader.abort(this.playlistType);
      const frag = this.fragCurrent;
      if (frag != null && frag.loader) {
        frag.abortRequests();
        this.fragmentTracker.removeFragment(frag);
      }
      this.resetTransmuxer();
      this.fragCurrent = null;
      this.fragPrevious = null;
      this.clearInterval();
      this.clearNextTick();
      this.state = State.STOPPED;
    }
    _streamEnded(bufferInfo, levelDetails) {
      // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,
      // of nothing loading/loaded return false
      if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {
        return false;
      }
      const partList = levelDetails.partList;
      // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,
      // check instead if the last part is buffered.
      if (partList != null && partList.length) {
        const lastPart = partList[partList.length - 1];

        // Checking the midpoint of the part for potential margin of error and related issues.
        // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)
        // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream
        // part mismatches for independent audio and video playlists/segments.
        const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);
        return lastPartBuffered;
      }
      const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;
      return this.fragmentTracker.isEndListAppended(playlistType);
    }
    getLevelDetails() {
      if (this.levels && this.levelLastLoaded !== null) {
        var _this$levelLastLoaded;
        return (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details;
      }
    }
    onMediaAttached(event, data) {
      const media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      const config = this.config;
      if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {
        this.startLoad(config.startPosition);
      }
    }
    onMediaDetaching() {
      const media = this.media;
      if (media != null && media.ended) {
        this.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // remove video listeners
      if (media && this.onvseeking && this.onvended) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvended = null;
      }
      if (this.keyLoader) {
        this.keyLoader.detach();
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.fragmentTracker.removeAllFragments();
      this.stopLoad();
    }
    onMediaSeeking() {
      const {
        config,
        fragCurrent,
        media,
        mediaBuffer,
        state
      } = this;
      const currentTime = media ? media.currentTime : 0;
      const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);
      this.log(`media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}`);
      if (this.state === State.ENDED) {
        this.resetLoadingState();
      } else if (fragCurrent) {
        // Seeking while frag load is in progress
        const tolerance = config.maxFragLookUpTolerance;
        const fragStartOffset = fragCurrent.start - tolerance;
        const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
        // if seeking out of buffered range or into new one
        if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {
          const pastFragment = currentTime > fragEndOffset;
          // if the seek position is outside the current fragment range
          if (currentTime < fragStartOffset || pastFragment) {
            if (pastFragment && fragCurrent.loader) {
              this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.abortRequests();
              this.resetLoadingState();
            }
            this.fragPrevious = null;
          }
        }
      }
      if (media) {
        // Remove gap fragments
        this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);
        this.lastCurrentTime = currentTime;
      }

      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
      if (!this.loadedmetadata && !bufferInfo.len) {
        this.nextLoadPosition = this.startPosition = currentTime;
      }

      // Async tick to speed up processing
      this.tickImmediate();
    }
    onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
    onManifestLoaded(event, data) {
      this.startTimeOffset = data.startTimeOffset;
      this.initPTS = [];
    }
    onHandlerDestroying() {
      this.hls.off(Events$1.MANIFEST_LOADED, this.onManifestLoaded, this);
      this.stopLoad();
      super.onHandlerDestroying();
      // @ts-ignore
      this.hls = null;
    }
    onHandlerDestroyed() {
      this.state = State.STOPPED;
      if (this.fragmentLoader) {
        this.fragmentLoader.destroy();
      }
      if (this.keyLoader) {
        this.keyLoader.destroy();
      }
      if (this.decrypter) {
        this.decrypter.destroy();
      }
      this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;
      super.onHandlerDestroyed();
    }
    loadFragment(frag, level, targetBufferTime) {
      this._loadFragForPlayback(frag, level, targetBufferTime);
    }
    _loadFragForPlayback(frag, level, targetBufferTime) {
      const progressCallback = data => {
        if (this.fragContextChanged(frag)) {
          this.warn(`Fragment ${frag.sn}${data.part ? ' p: ' + data.part.index : ''} of level ${frag.level} was dropped during download.`);
          this.fragmentTracker.removeFragment(frag);
          return;
        }
        frag.stats.chunkCount++;
        this._handleFragmentLoadProgress(data);
      };
      this._doFragLoad(frag, level, targetBufferTime, progressCallback).then(data => {
        if (!data) {
          // if we're here we probably needed to backtrack or are waiting for more parts
          return;
        }
        const state = this.state;
        if (this.fragContextChanged(frag)) {
          if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {
            this.fragmentTracker.removeFragment(frag);
            this.state = State.IDLE;
          }
          return;
        }
        if ('payload' in data) {
          this.log(`Loaded fragment ${frag.sn} of level ${frag.level}`);
          this.hls.trigger(Events$1.FRAG_LOADED, data);
        }

        // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback
        this._handleFragmentLoadComplete(data);
      }).catch(reason => {
        if (this.state === State.STOPPED || this.state === State.ERROR) {
          return;
        }
        this.warn(`Frag error: ${(reason == null ? void 0 : reason.message) || reason}`);
        this.resetFragmentLoading(frag);
      });
    }
    clearTrackerIfNeeded(frag) {
      var _this$mediaBuffer;
      const {
        fragmentTracker
      } = this;
      const fragState = fragmentTracker.getState(frag);
      if (fragState === FragmentState.APPENDING) {
        // Lower the max buffer length and try again
        const playlistType = frag.type;
        const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
        const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);
        // If backtracking, always remove from the tracker without reducing max buffer length
        const backtrackFragment = this.backtrackFragment;
        const backtracked = backtrackFragment ? frag.sn - backtrackFragment.sn : 0;
        if (backtracked === 1 || this.reduceMaxBufferLength(minForwardBufferLength, frag.duration)) {
          fragmentTracker.removeFragment(frag);
        }
      } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {
        // Stop gap for bad tracker / buffer flush behavior
        fragmentTracker.removeAllFragments();
      } else if (fragmentTracker.hasParts(frag.type)) {
        // In low latency mode, remove fragments for which only some parts were buffered
        fragmentTracker.detectPartialFragments({
          frag,
          part: null,
          stats: frag.stats,
          id: frag.type
        });
        if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {
          fragmentTracker.removeFragment(frag);
        }
      }
    }
    checkLiveUpdate(details) {
      if (details.updated && !details.live) {
        // Live stream ended, update fragment tracker
        const lastFragment = details.fragments[details.fragments.length - 1];
        this.fragmentTracker.detectPartialFragments({
          frag: lastFragment,
          part: null,
          stats: lastFragment.stats,
          id: lastFragment.type
        });
      }
      if (!details.fragments[0]) {
        details.deltaUpdateFailed = true;
      }
    }
    flushMainBuffer(startOffset, endOffset, type = null) {
      if (!(startOffset - endOffset)) {
        return;
      }
      // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,
      // passing a null type flushes both buffers
      const flushScope = {
        startOffset,
        endOffset,
        type
      };
      this.hls.trigger(Events$1.BUFFER_FLUSHING, flushScope);
    }
    _loadInitSegment(frag, level) {
      this._doFragLoad(frag, level).then(data => {
        if (!data || this.fragContextChanged(frag) || !this.levels) {
          throw new Error('init load aborted');
        }
        return data;
      }).then(data => {
        const {
          hls
        } = this;
        const {
          payload
        } = data;
        const decryptData = frag.decryptdata;

        // check to see if the payload needs to be decrypted
        if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {
          const startTime = self.performance.now();
          // decrypt init segment data
          return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(err => {
            hls.trigger(Events$1.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.FRAG_DECRYPT_ERROR,
              fatal: false,
              error: err,
              reason: err.message,
              frag
            });
            throw err;
          }).then(decryptedData => {
            const endTime = self.performance.now();
            hls.trigger(Events$1.FRAG_DECRYPTED, {
              frag,
              payload: decryptedData,
              stats: {
                tstart: startTime,
                tdecrypt: endTime
              }
            });
            data.payload = decryptedData;
            return this.completeInitSegmentLoad(data);
          });
        }
        return this.completeInitSegmentLoad(data);
      }).catch(reason => {
        if (this.state === State.STOPPED || this.state === State.ERROR) {
          return;
        }
        this.warn(reason);
        this.resetFragmentLoading(frag);
      });
    }
    completeInitSegmentLoad(data) {
      const {
        levels
      } = this;
      if (!levels) {
        throw new Error('init load aborted, missing levels');
      }
      const stats = data.frag.stats;
      this.state = State.IDLE;
      data.frag.data = new Uint8Array(data.payload);
      stats.parsing.start = stats.buffering.start = self.performance.now();
      stats.parsing.end = stats.buffering.end = self.performance.now();
      this.tick();
    }
    fragContextChanged(frag) {
      const {
        fragCurrent
      } = this;
      return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;
    }
    fragBufferedComplete(frag, part) {
      var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;
      const media = this.mediaBuffer ? this.mediaBuffer : this.media;
      this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? ' part: ' + part.index : ''} of ${this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track'} ${frag.level} (frag:[${((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3)}-${((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3)}] > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)'})`);
      if (frag.sn !== 'initSegment') {
        var _this$levels;
        if (frag.type !== PlaylistLevelType.SUBTITLE) {
          const el = frag.elementaryStreams;
          if (!Object.keys(el).some(type => !!el[type])) {
            // empty segment
            this.state = State.IDLE;
            return;
          }
        }
        const level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];
        if (level != null && level.fragmentError) {
          this.log(`Resetting level fragment error count of ${level.fragmentError} on frag buffered`);
          level.fragmentError = 0;
        }
      }
      this.state = State.IDLE;
      if (!media) {
        return;
      }
      if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {
        this.loadedmetadata = true;
        this.seekToStartPos();
      }
      this.tick();
    }
    seekToStartPos() {}
    _handleFragmentLoadComplete(fragLoadedEndData) {
      const {
        transmuxer
      } = this;
      if (!transmuxer) {
        return;
      }
      const {
        frag,
        part,
        partsLoaded
      } = fragLoadedEndData;
      // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data
      const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(fragLoaded => !fragLoaded);
      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
      transmuxer.flush(chunkMeta);
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _handleFragmentLoadProgress(frag) {}
    _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {
      var _frag$decryptdata;
      const details = level == null ? void 0 : level.details;
      if (!this.levels || !details) {
        throw new Error(`frag load aborted, missing level${details ? '' : ' detail'}s`);
      }
      let keyLoadingPromise = null;
      if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {
        this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'} ${frag.level}`);
        this.state = State.KEY_LOADING;
        this.fragCurrent = frag;
        keyLoadingPromise = this.keyLoader.load(frag).then(keyLoadedData => {
          if (!this.fragContextChanged(keyLoadedData.frag)) {
            this.hls.trigger(Events$1.KEY_LOADED, keyLoadedData);
            if (this.state === State.KEY_LOADING) {
              this.state = State.IDLE;
            }
            return keyLoadedData;
          }
        });
        this.hls.trigger(Events$1.KEY_LOADING, {
          frag
        });
        if (this.fragCurrent === null) {
          keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));
        }
      } else if (!frag.encrypted && details.encryptedFragments.length) {
        this.keyLoader.loadClear(frag, details.encryptedFragments);
      }
      targetBufferTime = Math.max(frag.start, targetBufferTime || 0);
      if (this.config.lowLatencyMode && frag.sn !== 'initSegment') {
        const partList = details.partList;
        if (partList && progressCallback) {
          if (targetBufferTime > frag.end && details.fragmentHint) {
            frag = details.fragmentHint;
          }
          const partIndex = this.getNextPart(partList, frag, targetBufferTime);
          if (partIndex > -1) {
            const part = partList[partIndex];
            this.log(`Loading part sn: ${frag.sn} p: ${part.index} cc: ${frag.cc} of playlist [${details.startSN}-${details.endSN}] parts [0-${partIndex}-${partList.length - 1}] ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);
            this.nextLoadPosition = part.start + part.duration;
            this.state = State.FRAG_LOADING;
            let _result;
            if (keyLoadingPromise) {
              _result = keyLoadingPromise.then(keyLoadedData => {
                if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {
                  return null;
                }
                return this.doFragPartsLoad(frag, part, level, progressCallback);
              }).catch(error => this.handleFragLoadError(error));
            } else {
              _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(error => this.handleFragLoadError(error));
            }
            this.hls.trigger(Events$1.FRAG_LOADING, {
              frag,
              part,
              targetBufferTime
            });
            if (this.fragCurrent === null) {
              return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));
            }
            return _result;
          } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
            // Fragment hint has no parts
            return Promise.resolve(null);
          }
        }
      }
      this.log(`Loading fragment ${frag.sn} cc: ${frag.cc} ${details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : ''}${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);
      // Don't update nextLoadPosition for fragments which are not buffered
      if (isFiniteNumber(frag.sn) && !this.bitrateTest) {
        this.nextLoadPosition = frag.start + frag.duration;
      }
      this.state = State.FRAG_LOADING;

      // Load key before streaming fragment data
      const dataOnProgress = this.config.progressive;
      let result;
      if (dataOnProgress && keyLoadingPromise) {
        result = keyLoadingPromise.then(keyLoadedData => {
          if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {
            return null;
          }
          return this.fragmentLoader.load(frag, progressCallback);
        }).catch(error => this.handleFragLoadError(error));
      } else {
        // load unencrypted fragment data with progress event,
        // or handle fragment result after key and fragment are finished loading
        result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(([fragLoadedData]) => {
          if (!dataOnProgress && fragLoadedData && progressCallback) {
            progressCallback(fragLoadedData);
          }
          return fragLoadedData;
        }).catch(error => this.handleFragLoadError(error));
      }
      this.hls.trigger(Events$1.FRAG_LOADING, {
        frag,
        targetBufferTime
      });
      if (this.fragCurrent === null) {
        return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));
      }
      return result;
    }
    doFragPartsLoad(frag, fromPart, level, progressCallback) {
      return new Promise((resolve, reject) => {
        var _level$details;
        const partsLoaded = [];
        const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;
        const loadPart = part => {
          this.fragmentLoader.loadPart(frag, part, progressCallback).then(partLoadedData => {
            partsLoaded[part.index] = partLoadedData;
            const loadedPart = partLoadedData.part;
            this.hls.trigger(Events$1.FRAG_LOADED, partLoadedData);
            const nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);
            if (nextPart) {
              loadPart(nextPart);
            } else {
              return resolve({
                frag,
                part: loadedPart,
                partsLoaded
              });
            }
          }).catch(reject);
        };
        loadPart(fromPart);
      });
    }
    handleFragLoadError(error) {
      if ('data' in error) {
        const data = error.data;
        if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {
          this.handleFragLoadAborted(data.frag, data.part);
        } else {
          this.hls.trigger(Events$1.ERROR, data);
        }
      } else {
        this.hls.trigger(Events$1.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.INTERNAL_EXCEPTION,
          err: error,
          error,
          fatal: true
        });
      }
      return null;
    }
    _handleTransmuxerFlush(chunkMeta) {
      const context = this.getCurrentContext(chunkMeta);
      if (!context || this.state !== State.PARSING) {
        if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {
          this.state = State.IDLE;
        }
        return;
      }
      const {
        frag,
        part,
        level
      } = context;
      const now = self.performance.now();
      frag.stats.parsing.end = now;
      if (part) {
        part.stats.parsing.end = now;
      }
      this.updateLevelTiming(frag, part, level, chunkMeta.partial);
    }
    getCurrentContext(chunkMeta) {
      const {
        levels,
        fragCurrent
      } = this;
      const {
        level: levelIndex,
        sn,
        part: partIndex
      } = chunkMeta;
      if (!(levels != null && levels[levelIndex])) {
        this.warn(`Levels object was unset while buffering fragment ${sn} of level ${levelIndex}. The current chunk will not be buffered.`);
        return null;
      }
      const level = levels[levelIndex];
      const part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;
      const frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);
      if (!frag) {
        return null;
      }
      if (fragCurrent && fragCurrent !== frag) {
        frag.stats = fragCurrent.stats;
      }
      return {
        frag,
        part,
        level
      };
    }
    bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {
      var _buffer;
      if (!data || this.state !== State.PARSING) {
        return;
      }
      const {
        data1,
        data2
      } = data;
      let buffer = data1;
      if (data1 && data2) {
        // Combine the moof + mdat so that we buffer with a single append
        buffer = appendUint8Array(data1, data2);
      }
      if (!((_buffer = buffer) != null && _buffer.length)) {
        return;
      }
      const segment = {
        type: data.type,
        frag,
        part,
        chunkMeta,
        parent: frag.type,
        data: buffer
      };
      this.hls.trigger(Events$1.BUFFER_APPENDING, segment);
      if (data.dropped && data.independent && !part) {
        if (noBacktracking) {
          return;
        }
        // Clear buffer so that we reload previous segments sequentially if required
        this.flushBufferGap(frag);
      }
    }
    flushBufferGap(frag) {
      const media = this.media;
      if (!media) {
        return;
      }
      // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed
      if (!BufferHelper.isBuffered(media, media.currentTime)) {
        this.flushMainBuffer(0, frag.start);
        return;
      }
      // Remove back-buffer without interrupting playback to allow back tracking
      const currentTime = media.currentTime;
      const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
      const fragDuration = frag.duration;
      const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);
      const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);
      if (frag.start - start > segmentFraction) {
        this.flushMainBuffer(start, frag.start);
      }
    }
    getFwdBufferInfo(bufferable, type) {
      const pos = this.getLoadPosition();
      if (!isFiniteNumber(pos)) {
        return null;
      }
      return this.getFwdBufferInfoAtPos(bufferable, pos, type);
    }
    getFwdBufferInfoAtPos(bufferable, pos, type) {
      const {
        config: {
          maxBufferHole
        }
      } = this;
      const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);
      // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos
      if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {
        const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);
        if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {
          return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));
        }
      }
      return bufferInfo;
    }
    getMaxBufferLength(levelBitrate) {
      const {
        config
      } = this;
      let maxBufLen;
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }
      return Math.min(maxBufLen, config.maxMaxBufferLength);
    }
    reduceMaxBufferLength(threshold, fragDuration) {
      const config = this.config;
      const minLength = Math.max(Math.min(threshold - fragDuration, config.maxBufferLength), fragDuration);
      const reducedLength = Math.max(threshold - fragDuration * 3, config.maxMaxBufferLength / 2, minLength);
      if (reducedLength >= minLength) {
        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
        config.maxMaxBufferLength = reducedLength;
        this.warn(`Reduce max buffer length to ${reducedLength}s`);
        return true;
      }
      return false;
    }
    getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {
      const fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);
      if (fragOrPart && 'fragment' in fragOrPart) {
        return fragOrPart.fragment;
      }
      return fragOrPart;
    }
    getNextFragment(pos, levelDetails) {
      const fragments = levelDetails.fragments;
      const fragLen = fragments.length;
      if (!fragLen) {
        return null;
      }

      // find fragment index, contiguous with end of buffer position
      const {
        config
      } = this;
      const start = fragments[0].start;
      let frag;
      if (levelDetails.live) {
        const initialLiveManifestSize = config.initialLiveManifestSize;
        if (fragLen < initialLiveManifestSize) {
          this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);
          return null;
        }
        // The real fragment start times for a live stream are only known after the PTS range for that level is known.
        // In order to discover the range, we load the best matching fragment for that level and demux it.
        // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that
        // we get the fragment matching that start time
        if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {
          frag = this.getInitialLiveFragment(levelDetails, fragments);
          this.startPosition = this.nextLoadPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;
        }
      } else if (pos <= start) {
        // VoD playlist: if loadPosition before start of playlist, load first fragment
        frag = fragments[0];
      }

      // If we haven't run into any special cases already, just load the fragment most closely matching the requested position
      if (!frag) {
        const end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;
        frag = this.getFragmentAtPosition(pos, end, levelDetails);
      }
      return this.mapToInitFragWhenRequired(frag);
    }
    isLoopLoading(frag, targetBufferTime) {
      const trackerState = this.fragmentTracker.getState(frag);
      return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;
    }
    getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {
      const gapStart = frag.gap;
      const nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);
      if (nextFragment === null) {
        return nextFragment;
      }
      frag = nextFragment;
      if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {
        // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length
        const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);
        if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {
          // Returning here might result in not finding an audio and video candiate to skip to
          this.log(`buffer full after gaps in "${playlistType}" playlist starting at sn: ${frag.sn}`);
          return null;
        }
      }
      return frag;
    }
    mapToInitFragWhenRequired(frag) {
      // If an initSegment is present, it must be buffered first
      if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {
        return frag.initSegment;
      }
      return frag;
    }
    getNextPart(partList, frag, targetBufferTime) {
      let nextPart = -1;
      let contiguous = false;
      let independentAttrOmitted = true;
      for (let i = 0, len = partList.length; i < len; i++) {
        const part = partList[i];
        independentAttrOmitted = independentAttrOmitted && !part.independent;
        if (nextPart > -1 && targetBufferTime < part.start) {
          break;
        }
        const loaded = part.loaded;
        if (loaded) {
          nextPart = -1;
        } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {
          nextPart = i;
        }
        contiguous = loaded;
      }
      return nextPart;
    }
    loadedEndOfParts(partList, targetBufferTime) {
      const lastPart = partList[partList.length - 1];
      return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;
    }

    /*
     This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the
     "sliding" of the playlist, which is its offset from the start of playback. After sliding we can compute the real
     start and end times for each fragment in the playlist (after which this method will not need to be called).
    */
    getInitialLiveFragment(levelDetails, fragments) {
      const fragPrevious = this.fragPrevious;
      let frag = null;
      if (fragPrevious) {
        if (levelDetails.hasProgramDateTime) {
          // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding
          this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);
          frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);
        }
        if (!frag) {
          // SN does not need to be accurate between renditions, but depending on the packaging it may be so.
          const targetSN = fragPrevious.sn + 1;
          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
            const fragNext = fragments[targetSN - levelDetails.startSN];
            // Ensure that we're staying within the continuity range, since PTS resets upon a new range
            if (fragPrevious.cc === fragNext.cc) {
              frag = fragNext;
              this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);
            }
          }
          // It's important to stay within the continuity range if available; otherwise the fragments in the playlist
          // will have the wrong start times
          if (!frag) {
            frag = findFragWithCC(fragments, fragPrevious.cc);
            if (frag) {
              this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);
            }
          }
        }
      } else {
        // Find a new start fragment when fragPrevious is null
        const liveStart = this.hls.liveSyncPosition;
        if (liveStart !== null) {
          frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);
        }
      }
      return frag;
    }

    /*
    This method finds the best matching fragment given the provided position.
     */
    getFragmentAtPosition(bufferEnd, end, levelDetails) {
      const {
        config
      } = this;
      let {
        fragPrevious
      } = this;
      let {
        fragments,
        endSN
      } = levelDetails;
      const {
        fragmentHint
      } = levelDetails;
      const {
        maxFragLookUpTolerance
      } = config;
      const partList = levelDetails.partList;
      const loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);
      if (loadingParts && fragmentHint && !this.bitrateTest) {
        // Include incomplete fragment with parts at end
        fragments = fragments.concat(fragmentHint);
        endSN = fragmentHint.sn;
      }
      let frag;
      if (bufferEnd < end) {
        const lookupTolerance = bufferEnd > end - maxFragLookUpTolerance ? 0 : maxFragLookUpTolerance;
        // Remove the tolerance if it would put the bufferEnd past the actual end of stream
        // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
        frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);
      } else {
        // reach end of playlist
        frag = fragments[fragments.length - 1];
      }
      if (frag) {
        const curSNIdx = frag.sn - levelDetails.startSN;
        // Move fragPrevious forward to support forcing the next fragment to load
        // when the buffer catches up to a previously buffered range.
        const fragState = this.fragmentTracker.getState(frag);
        if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {
          fragPrevious = frag;
        }
        if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {
          // Force the next fragment to load if the previous one was already selected. This can occasionally happen with
          // non-uniform fragment durations
          const sameLevel = fragPrevious && frag.level === fragPrevious.level;
          if (sameLevel) {
            const nextFrag = fragments[curSNIdx + 1];
            if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {
              frag = nextFrag;
            } else {
              frag = null;
            }
          }
        }
      }
      return frag;
    }
    synchronizeToLiveEdge(levelDetails) {
      const {
        config,
        media
      } = this;
      if (!media) {
        return;
      }
      const liveSyncPosition = this.hls.liveSyncPosition;
      const currentTime = media.currentTime;
      const start = levelDetails.fragments[0].start;
      const end = levelDetails.edge;
      const withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;
      // Continue if we can seek forward to sync position or if current time is outside of sliding window
      if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {
        // Continue if buffer is starving or if current time is behind max latency
        const maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
        if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {
          if (!this.loadedmetadata) {
            this.nextLoadPosition = liveSyncPosition;
          }
          // Only seek if ready and there is not a significant forward buffer available for playback
          if (media.readyState) {
            this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);
            media.currentTime = liveSyncPosition;
          }
        }
      }
    }
    alignPlaylists(details, previousDetails, switchDetails) {
      // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,
      //  this could all go in level-helper mergeDetails()
      const length = details.fragments.length;
      if (!length) {
        this.warn(`No fragments in live playlist`);
        return 0;
      }
      const slidingStart = details.fragments[0].start;
      const firstLevelLoad = !previousDetails;
      const aligned = details.alignedSliding && isFiniteNumber(slidingStart);
      if (firstLevelLoad || !aligned && !slidingStart) {
        const {
          fragPrevious
        } = this;
        alignStream(fragPrevious, switchDetails, details);
        const alignedSlidingStart = details.fragments[0].start;
        this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : 'na'}->${details.startSN} prev-sn: ${fragPrevious ? fragPrevious.sn : 'na'} fragments: ${length}`);
        return alignedSlidingStart;
      }
      return slidingStart;
    }
    waitForCdnTuneIn(details) {
      // Wait for Low-Latency CDN Tune-in to get an updated playlist
      const advancePartLimit = 3;
      return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);
    }
    setStartPosition(details, sliding) {
      // compute start position if set to -1. use it straight away if value is defined
      let startPosition = this.startPosition;
      if (startPosition < sliding) {
        startPosition = -1;
      }
      if (startPosition === -1 || this.lastCurrentTime === -1) {
        // Use Playlist EXT-X-START:TIME-OFFSET when set
        // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match
        const offsetInMultivariantPlaylist = this.startTimeOffset !== null;
        const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;
        if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {
          startPosition = sliding + startTimeOffset;
          if (startTimeOffset < 0) {
            startPosition += details.totalduration;
          }
          startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);
          this.log(`Start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? 'multivariant' : 'media'} playlist, adjust startPosition to ${startPosition}`);
          this.startPosition = startPosition;
        } else if (details.live) {
          // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has
          // not been specified via the config or an as an argument to startLoad (#3736).
          startPosition = this.hls.liveSyncPosition || sliding;
        } else {
          this.startPosition = startPosition = 0;
        }
        this.lastCurrentTime = startPosition;
      }
      this.nextLoadPosition = startPosition;
    }
    getLoadPosition() {
      const {
        media
      } = this;
      // if we have not yet loaded any fragment, start loading from start position
      let pos = 0;
      if (this.loadedmetadata && media) {
        pos = media.currentTime;
      } else if (this.nextLoadPosition) {
        pos = this.nextLoadPosition;
      }
      return pos;
    }
    handleFragLoadAborted(frag, part) {
      if (this.transmuxer && frag.sn !== 'initSegment' && frag.stats.aborted) {
        this.warn(`Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${frag.level} was aborted`);
        this.resetFragmentLoading(frag);
      }
    }
    resetFragmentLoading(frag) {
      if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {
        this.state = State.IDLE;
      }
    }
    onFragmentOrKeyLoadError(filterType, data) {
      if (data.chunkMeta && !data.frag) {
        const context = this.getCurrentContext(data.chunkMeta);
        if (context) {
          data.frag = context.frag;
        }
      }
      const frag = data.frag;
      // Handle frag error related to caller's filterType
      if (!frag || frag.type !== filterType || !this.levels) {
        return;
      }
      if (this.fragContextChanged(frag)) {
        var _this$fragCurrent2;
        this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url}`);
        return;
      }
      const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;
      if (gapTagEncountered) {
        this.fragmentTracker.fragBuffered(frag, true);
      }
      // keep retrying until the limit will be reached
      const errorAction = data.errorAction;
      const {
        action,
        retryCount = 0,
        retryConfig
      } = errorAction || {};
      if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {
        this.resetStartWhenNotLoaded(this.levelLastLoaded);
        const delay = getRetryDelay(retryConfig, retryCount);
        this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);
        errorAction.resolved = true;
        this.retryDate = self.performance.now() + delay;
        this.state = State.FRAG_LOADING_WAITING_RETRY;
      } else if (retryConfig && errorAction) {
        this.resetFragmentErrors(filterType);
        if (retryCount < retryConfig.maxNumRetry) {
          // Network retry is skipped when level switch is preferred
          if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {
            errorAction.resolved = true;
          }
        } else {
          logger.warn(`${data.details} reached or exceeded max retry (${retryCount})`);
          return;
        }
      } else if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {
        this.state = State.WAITING_LEVEL;
      } else {
        this.state = State.ERROR;
      }
      // Perform next async tick sooner to speed up error action resolution
      this.tickImmediate();
    }
    reduceLengthAndFlushBuffer(data) {
      // if in appending state
      if (this.state === State.PARSING || this.state === State.PARSED) {
        const frag = data.frag;
        const playlistType = data.parent;
        const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
        // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
        // reduce max buf len if current position is buffered
        const buffered = bufferedInfo && bufferedInfo.len > 0.5;
        if (buffered) {
          this.reduceMaxBufferLength(bufferedInfo.len, (frag == null ? void 0 : frag.duration) || 10);
        }
        const flushBuffer = !buffered;
        if (flushBuffer) {
          // current position is not buffered, but browser is still complaining about buffer full error
          // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
          // in that case flush the whole audio buffer to recover
          this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);
        }
        if (frag) {
          this.fragmentTracker.removeFragment(frag);
          this.nextLoadPosition = frag.start;
        }
        this.resetLoadingState();
        return flushBuffer;
      }
      return false;
    }
    resetFragmentErrors(filterType) {
      if (filterType === PlaylistLevelType.AUDIO) {
        // Reset current fragment since audio track audio is essential and may not have a fail-over track
        this.fragCurrent = null;
      }
      // Fragment errors that result in a level switch or redundant fail-over
      // should reset the stream controller state to idle
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
      }
      if (this.state !== State.STOPPED) {
        this.state = State.IDLE;
      }
    }
    afterBufferFlushed(media, bufferType, playlistType) {
      if (!media) {
        return;
      }
      // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media
      // (so that we will check against video.buffered ranges in case of alt audio track)
      const bufferedTimeRanges = BufferHelper.getBuffered(media);
      this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);
      if (this.state === State.ENDED) {
        this.resetLoadingState();
      }
    }
    resetLoadingState() {
      this.log('Reset loading state');
      this.fragCurrent = null;
      this.fragPrevious = null;
      this.state = State.IDLE;
    }
    resetStartWhenNotLoaded(level) {
      // if loadedmetadata is not set, it means that first frag request failed
      // in that case, reset startFragRequested flag
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
        const details = level ? level.details : null;
        if (details != null && details.live) {
          // Update the start position and return to IDLE to recover live start
          this.startPosition = -1;
          this.setStartPosition(details, 0);
          this.resetLoadingState();
        } else {
          this.nextLoadPosition = this.startPosition;
        }
      }
    }
    resetWhenMissingContext(chunkMeta) {
      this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of level ${chunkMeta.level}. This chunk will not be buffered.`);
      this.removeUnbufferedFrags();
      this.resetStartWhenNotLoaded(this.levelLastLoaded);
      this.resetLoadingState();
    }
    removeUnbufferedFrags(start = 0) {
      this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);
    }
    updateLevelTiming(frag, part, level, partial) {
      var _this$transmuxer;
      const details = level.details;
      if (!details) {
        this.warn('level.details undefined');
        return;
      }
      const parsed = Object.keys(frag.elementaryStreams).reduce((result, type) => {
        const info = frag.elementaryStreams[type];
        if (info) {
          const parsedDuration = info.endPTS - info.startPTS;
          if (parsedDuration <= 0) {
            // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.
            // The new transmuxer will be configured with a time offset matching the next fragment start,
            // preventing the timeline from shifting.
            this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);
            return result || false;
          }
          const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);
          this.hls.trigger(Events$1.LEVEL_PTS_UPDATED, {
            details,
            level,
            drift,
            type,
            frag,
            start: info.startPTS,
            end: info.endPTS
          });
          return true;
        }
        return result;
      }, false);
      if (!parsed && ((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {
        const error = new Error(`Found no media in fragment ${frag.sn} of level ${frag.level} resetting transmuxer to fallback to playlist timing`);
        if (level.fragmentError === 0) {
          // Mark and track the odd empty segment as a gap to avoid reloading
          level.fragmentError++;
          frag.gap = true;
          this.fragmentTracker.removeFragment(frag);
          this.fragmentTracker.fragBuffered(frag, true);
        }
        this.warn(error.message);
        this.hls.trigger(Events$1.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.FRAG_PARSING_ERROR,
          fatal: false,
          error,
          frag,
          reason: `Found no media in msn ${frag.sn} of level "${level.url}"`
        });
        if (!this.hls) {
          return;
        }
        this.resetTransmuxer();
        // For this error fallthrough. Marking parsed will allow advancing to next fragment.
      }
      this.state = State.PARSED;
      this.hls.trigger(Events$1.FRAG_PARSED, {
        frag,
        part
      });
    }
    resetTransmuxer() {
      if (this.transmuxer) {
        this.transmuxer.destroy();
        this.transmuxer = null;
      }
    }
    recoverWorkerError(data) {
      if (data.event === 'demuxerWorker') {
        this.fragmentTracker.removeAllFragments();
        this.resetTransmuxer();
        this.resetStartWhenNotLoaded(this.levelLastLoaded);
        this.resetLoadingState();
      }
    }
    set state(nextState) {
      const previousState = this._state;
      if (previousState !== nextState) {
        this._state = nextState;
        this.log(`${previousState}->${nextState}`);
      }
    }
    get state() {
      return this._state;
    }
  }

  class ChunkCache {
    constructor() {
      this.chunks = [];
      this.dataLength = 0;
    }
    push(chunk) {
      this.chunks.push(chunk);
      this.dataLength += chunk.length;
    }
    flush() {
      const {
        chunks,
        dataLength
      } = this;
      let result;
      if (!chunks.length) {
        return new Uint8Array(0);
      } else if (chunks.length === 1) {
        result = chunks[0];
      } else {
        result = concatUint8Arrays(chunks, dataLength);
      }
      this.reset();
      return result;
    }
    reset() {
      this.chunks.length = 0;
      this.dataLength = 0;
    }
  }
  function concatUint8Arrays(chunks, dataLength) {
    const result = new Uint8Array(dataLength);
    let offset = 0;
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      result.set(chunk, offset);
      offset += chunk.length;
    }
    return result;
  }

  // ensure the worker ends up in the bundle
  // If the worker should not be included this gets aliased to empty.js
  function hasUMDWorker() {
    return typeof __HLS_WORKER_BUNDLE__ === 'function';
  }
  function injectWorker() {
    const blob = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
      type: 'text/javascript'
    });
    const objectURL = self.URL.createObjectURL(blob);
    const worker = new self.Worker(objectURL);
    return {
      worker,
      objectURL
    };
  }
  function loadWorker(path) {
    const scriptURL = new self.URL(path, self.location.href).href;
    const worker = new self.Worker(scriptURL);
    return {
      worker,
      scriptURL
    };
  }

  function dummyTrack(type = '', inputTimeScale = 90000) {
    return {
      type,
      id: -1,
      pid: -1,
      inputTimeScale,
      sequenceNumber: -1,
      samples: [],
      dropped: 0
    };
  }

  class BaseAudioDemuxer {
    constructor() {
      this._audioTrack = void 0;
      this._id3Track = void 0;
      this.frameIndex = 0;
      this.cachedData = null;
      this.basePTS = null;
      this.initPTS = null;
      this.lastPTS = null;
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      this._id3Track = {
        type: 'id3',
        id: 3,
        pid: -1,
        inputTimeScale: 90000,
        sequenceNumber: 0,
        samples: [],
        dropped: 0
      };
    }
    resetTimeStamp(deaultTimestamp) {
      this.initPTS = deaultTimestamp;
      this.resetContiguity();
    }
    resetContiguity() {
      this.basePTS = null;
      this.lastPTS = null;
      this.frameIndex = 0;
    }
    canParse(data, offset) {
      return false;
    }
    appendFrame(track, data, offset) {}

    // feed incoming data to the front of the parsing pipeline
    demux(data, timeOffset) {
      if (this.cachedData) {
        data = appendUint8Array(this.cachedData, data);
        this.cachedData = null;
      }
      let id3Data = getID3Data(data, 0);
      let offset = id3Data ? id3Data.length : 0;
      let lastDataIndex;
      const track = this._audioTrack;
      const id3Track = this._id3Track;
      const timestamp = id3Data ? getTimeStamp(id3Data) : undefined;
      const length = data.length;
      if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {
        this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);
        this.lastPTS = this.basePTS;
      }
      if (this.lastPTS === null) {
        this.lastPTS = this.basePTS;
      }

      // more expressive than alternative: id3Data?.length
      if (id3Data && id3Data.length > 0) {
        id3Track.samples.push({
          pts: this.lastPTS,
          dts: this.lastPTS,
          data: id3Data,
          type: MetadataSchema.audioId3,
          duration: Number.POSITIVE_INFINITY
        });
      }
      while (offset < length) {
        if (this.canParse(data, offset)) {
          const frame = this.appendFrame(track, data, offset);
          if (frame) {
            this.frameIndex++;
            this.lastPTS = frame.sample.pts;
            offset += frame.length;
            lastDataIndex = offset;
          } else {
            offset = length;
          }
        } else if (canParse$2(data, offset)) {
          // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data
          id3Data = getID3Data(data, offset);
          id3Track.samples.push({
            pts: this.lastPTS,
            dts: this.lastPTS,
            data: id3Data,
            type: MetadataSchema.audioId3,
            duration: Number.POSITIVE_INFINITY
          });
          offset += id3Data.length;
          lastDataIndex = offset;
        } else {
          offset++;
        }
        if (offset === length && lastDataIndex !== length) {
          const partialData = sliceUint8(data, lastDataIndex);
          if (this.cachedData) {
            this.cachedData = appendUint8Array(this.cachedData, partialData);
          } else {
            this.cachedData = partialData;
          }
        }
      }
      return {
        audioTrack: track,
        videoTrack: dummyTrack(),
        id3Track,
        textTrack: dummyTrack()
      };
    }
    demuxSampleAes(data, keyData, timeOffset) {
      return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));
    }
    flush(timeOffset) {
      // Parse cache in case of remaining frames.
      const cachedData = this.cachedData;
      if (cachedData) {
        this.cachedData = null;
        this.demux(cachedData, 0);
      }
      return {
        audioTrack: this._audioTrack,
        videoTrack: dummyTrack(),
        id3Track: this._id3Track,
        textTrack: dummyTrack()
      };
    }
    destroy() {}
  }

  /**
   * Initialize PTS
   * <p>
   *    use timestamp unless it is undefined, NaN or Infinity
   * </p>
   */
  const initPTSFn = (timestamp, timeOffset, initPTS) => {
    if (isFiniteNumber(timestamp)) {
      return timestamp * 90;
    }
    const init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;
    return timeOffset * 90000 + init90kHz;
  };

  /**
   * ADTS parser helper
   * @link https://wiki.multimedia.cx/index.php?title=ADTS
   */
  function getAudioConfig(observer, data, offset, audioCodec) {
    let adtsObjectType;
    let adtsExtensionSamplingIndex;
    let adtsChannelConfig;
    let config;
    const userAgent = navigator.userAgent.toLowerCase();
    const manifestCodec = audioCodec;
    const adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
    // byte 2
    adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;
    const adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;
    if (adtsSamplingIndex > adtsSamplingRates.length - 1) {
      const error = new Error(`invalid ADTS sampling index:${adtsSamplingIndex}`);
      observer.emit(Events$1.ERROR, Events$1.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.FRAG_PARSING_ERROR,
        fatal: true,
        error,
        reason: error.message
      });
      return;
    }
    adtsChannelConfig = (data[offset + 2] & 0x01) << 2;
    // byte 3
    adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;
    logger.log(`manifest codec:${audioCodec}, ADTS type:${adtsObjectType}, samplingIndex:${adtsSamplingIndex}`);
    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
    if (/firefox/i.test(userAgent)) {
      if (adtsSamplingIndex >= 6) {
        adtsObjectType = 5;
        config = new Array(4);
        // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
        // there is a factor 2 between frame sample rate and output sample rate
        // multiply frequency by 2 (see table below, equivalent to substract 3)
        adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
      } else {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSamplingIndex = adtsSamplingIndex;
      }
      // Android : always use AAC
    } else if (userAgent.indexOf('android') !== -1) {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSamplingIndex = adtsSamplingIndex;
    } else {
      /*  for other browsers (Chrome/Vivaldi/Opera ...)
          always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
      */
      adtsObjectType = 5;
      config = new Array(4);
      // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
      if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSamplingIndex >= 6) {
        // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
        // there is a factor 2 between frame sample rate and output sample rate
        // multiply frequency by 2 (see table below, equivalent to substract 3)
        adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
      } else {
        // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
        // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
        if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {
          adtsObjectType = 2;
          config = new Array(2);
        }
        adtsExtensionSamplingIndex = adtsSamplingIndex;
      }
    }
    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
        ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()
      Audio Profile / Audio Object Type
      0: Null
      1: AAC Main
      2: AAC LC (Low Complexity)
      3: AAC SSR (Scalable Sample Rate)
      4: AAC LTP (Long Term Prediction)
      5: SBR (Spectral Band Replication)
      6: AAC Scalable
     sampling freq
      0: 96000 Hz
      1: 88200 Hz
      2: 64000 Hz
      3: 48000 Hz
      4: 44100 Hz
      5: 32000 Hz
      6: 24000 Hz
      7: 22050 Hz
      8: 16000 Hz
      9: 12000 Hz
      10: 11025 Hz
      11: 8000 Hz
      12: 7350 Hz
      13: Reserved
      14: Reserved
      15: frequency is written explictly
      Channel Configurations
      These are the channel configurations:
      0: Defined in AOT Specifc Config
      1: 1 channel: front-center
      2: 2 channels: front-left, front-right
    */
    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
    config[0] = adtsObjectType << 3;
    // samplingFrequencyIndex
    config[0] |= (adtsSamplingIndex & 0x0e) >> 1;
    config[1] |= (adtsSamplingIndex & 0x01) << 7;
    // channelConfiguration
    config[1] |= adtsChannelConfig << 3;
    if (adtsObjectType === 5) {
      // adtsExtensionSamplingIndex
      config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;
      config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;
      // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
      //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
      config[2] |= 2 << 2;
      config[3] = 0;
    }
    return {
      config,
      samplerate: adtsSamplingRates[adtsSamplingIndex],
      channelCount: adtsChannelConfig,
      codec: 'mp4a.40.' + adtsObjectType,
      manifestCodec
    };
  }
  function isHeaderPattern$1(data, offset) {
    return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
  }
  function getHeaderLength(data, offset) {
    return data[offset + 1] & 0x01 ? 7 : 9;
  }
  function getFullFrameLength(data, offset) {
    return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;
  }
  function canGetFrameLength(data, offset) {
    return offset + 5 < data.length;
  }
  function isHeader$1(data, offset) {
    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
    // Layer bits (position 14 and 15) in header should be always 0 for ADTS
    // More info https://wiki.multimedia.cx/index.php?title=ADTS
    return offset + 1 < data.length && isHeaderPattern$1(data, offset);
  }
  function canParse$1(data, offset) {
    return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;
  }
  function probe$1(data, offset) {
    // same as isHeader but we also check that ADTS frame follows last ADTS frame
    // or end of data is reached
    if (isHeader$1(data, offset)) {
      // ADTS header Length
      const headerLength = getHeaderLength(data, offset);
      if (offset + headerLength >= data.length) {
        return false;
      }
      // ADTS frame Length
      const frameLength = getFullFrameLength(data, offset);
      if (frameLength <= headerLength) {
        return false;
      }
      const newOffset = offset + frameLength;
      return newOffset === data.length || isHeader$1(data, newOffset);
    }
    return false;
  }
  function initTrackConfig(track, observer, data, offset, audioCodec) {
    if (!track.samplerate) {
      const config = getAudioConfig(observer, data, offset, audioCodec);
      if (!config) {
        return;
      }
      track.config = config.config;
      track.samplerate = config.samplerate;
      track.channelCount = config.channelCount;
      track.codec = config.codec;
      track.manifestCodec = config.manifestCodec;
      logger.log(`parsed codec:${track.codec}, rate:${config.samplerate}, channels:${config.channelCount}`);
    }
  }
  function getFrameDuration(samplerate) {
    return 1024 * 90000 / samplerate;
  }
  function parseFrameHeader(data, offset) {
    // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
    const headerLength = getHeaderLength(data, offset);
    if (offset + headerLength <= data.length) {
      // retrieve frame size
      const frameLength = getFullFrameLength(data, offset) - headerLength;
      if (frameLength > 0) {
        // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);
        return {
          headerLength,
          frameLength
        };
      }
    }
  }
  function appendFrame$2(track, data, offset, pts, frameIndex) {
    const frameDuration = getFrameDuration(track.samplerate);
    const stamp = pts + frameIndex * frameDuration;
    const header = parseFrameHeader(data, offset);
    let unit;
    if (header) {
      const {
        frameLength,
        headerLength
      } = header;
      const _length = headerLength + frameLength;
      const missing = Math.max(0, offset + _length - data.length);
      // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);
      if (missing) {
        unit = new Uint8Array(_length - headerLength);
        unit.set(data.subarray(offset + headerLength, data.length), 0);
      } else {
        unit = data.subarray(offset + headerLength, offset + _length);
      }
      const _sample = {
        unit,
        pts: stamp
      };
      if (!missing) {
        track.samples.push(_sample);
      }
      return {
        sample: _sample,
        length: _length,
        missing
      };
    }
    // overflow incomplete header
    const length = data.length - offset;
    unit = new Uint8Array(length);
    unit.set(data.subarray(offset, data.length), 0);
    const sample = {
      unit,
      pts: stamp
    };
    return {
      sample,
      length,
      missing: -1
    };
  }

  /**
   *  MPEG parser helper
   */

  let chromeVersion$1 = null;
  const BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
  const SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];
  const SamplesCoefficients = [
  // MPEG 2.5
  [0,
  // Reserved
  72,
  // Layer3
  144,
  // Layer2
  12 // Layer1
  ],
  // Reserved
  [0,
  // Reserved
  0,
  // Layer3
  0,
  // Layer2
  0 // Layer1
  ],
  // MPEG 2
  [0,
  // Reserved
  72,
  // Layer3
  144,
  // Layer2
  12 // Layer1
  ],
  // MPEG 1
  [0,
  // Reserved
  144,
  // Layer3
  144,
  // Layer2
  12 // Layer1
  ]];
  const BytesInSlot = [0,
  // Reserved
  1,
  // Layer3
  1,
  // Layer2
  4 // Layer1
  ];
  function appendFrame$1(track, data, offset, pts, frameIndex) {
    // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
    if (offset + 24 > data.length) {
      return;
    }
    const header = parseHeader(data, offset);
    if (header && offset + header.frameLength <= data.length) {
      const frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
      const stamp = pts + frameIndex * frameDuration;
      const sample = {
        unit: data.subarray(offset, offset + header.frameLength),
        pts: stamp,
        dts: stamp
      };
      track.config = [];
      track.channelCount = header.channelCount;
      track.samplerate = header.sampleRate;
      track.samples.push(sample);
      return {
        sample,
        length: header.frameLength,
        missing: 0
      };
    }
  }
  function parseHeader(data, offset) {
    const mpegVersion = data[offset + 1] >> 3 & 3;
    const mpegLayer = data[offset + 1] >> 1 & 3;
    const bitRateIndex = data[offset + 2] >> 4 & 15;
    const sampleRateIndex = data[offset + 2] >> 2 & 3;
    if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
      const paddingBit = data[offset + 2] >> 1 & 1;
      const channelMode = data[offset + 3] >> 6;
      const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
      const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;
      const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
      const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];
      const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
      const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
      const bytesInSlot = BytesInSlot[mpegLayer];
      const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
      const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;
      if (chromeVersion$1 === null) {
        const userAgent = navigator.userAgent || '';
        const result = userAgent.match(/Chrome\/(\d+)/i);
        chromeVersion$1 = result ? parseInt(result[1]) : 0;
      }
      const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;
      if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {
        // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)
        data[offset + 3] = data[offset + 3] | 0x80;
      }
      return {
        sampleRate,
        channelCount,
        frameLength,
        samplesPerFrame
      };
    }
  }
  function isHeaderPattern(data, offset) {
    return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;
  }
  function isHeader(data, offset) {
    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
    // More info http://www.mp3-tech.org/programmer/frame_header.html
    return offset + 1 < data.length && isHeaderPattern(data, offset);
  }
  function canParse(data, offset) {
    const headerSize = 4;
    return isHeaderPattern(data, offset) && headerSize <= data.length - offset;
  }
  function probe(data, offset) {
    // same as isHeader but we also check that MPEG frame follows last MPEG frame
    // or end of data is reached
    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
      // MPEG header Length
      const headerLength = 4;
      // MPEG frame Length
      const header = parseHeader(data, offset);
      let frameLength = headerLength;
      if (header != null && header.frameLength) {
        frameLength = header.frameLength;
      }
      const newOffset = offset + frameLength;
      return newOffset === data.length || isHeader(data, newOffset);
    }
    return false;
  }

  /**
   * AAC demuxer
   */
  class AACDemuxer extends BaseAudioDemuxer {
    constructor(observer, config) {
      super();
      this.observer = void 0;
      this.config = void 0;
      this.observer = observer;
      this.config = config;
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
      this._audioTrack = {
        container: 'audio/adts',
        type: 'audio',
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: 'aac',
        samples: [],
        manifestCodec: audioCodec,
        duration: trackDuration,
        inputTimeScale: 90000,
        dropped: 0
      };
    }

    // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS
    static probe(data) {
      if (!data) {
        return false;
      }

      // Check for the ADTS sync word
      // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
      // Layer bits (position 14 and 15) in header should be always 0 for ADTS
      // More info https://wiki.multimedia.cx/index.php?title=ADTS
      const id3Data = getID3Data(data, 0);
      let offset = (id3Data == null ? void 0 : id3Data.length) || 0;
      if (probe(data, offset)) {
        return false;
      }
      for (let length = data.length; offset < length; offset++) {
        if (probe$1(data, offset)) {
          logger.log('ADTS sync word found !');
          return true;
        }
      }
      return false;
    }
    canParse(data, offset) {
      return canParse$1(data, offset);
    }
    appendFrame(track, data, offset) {
      initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
      const frame = appendFrame$2(track, data, offset, this.basePTS, this.frameIndex);
      if (frame && frame.missing === 0) {
        return frame;
      }
    }
  }

  const emsgSchemePattern = /\/emsg[-/]ID3/i;
  class MP4Demuxer {
    constructor(observer, config) {
      this.remainderData = null;
      this.timeOffset = 0;
      this.config = void 0;
      this.videoTrack = void 0;
      this.audioTrack = void 0;
      this.id3Track = void 0;
      this.txtTrack = void 0;
      this.config = config;
    }
    resetTimeStamp() {}
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      const videoTrack = this.videoTrack = dummyTrack('video', 1);
      const audioTrack = this.audioTrack = dummyTrack('audio', 1);
      const captionTrack = this.txtTrack = dummyTrack('text', 1);
      this.id3Track = dummyTrack('id3', 1);
      this.timeOffset = 0;
      if (!(initSegment != null && initSegment.byteLength)) {
        return;
      }
      const initData = parseInitSegment(initSegment);
      if (initData.video) {
        const {
          id,
          timescale,
          codec
        } = initData.video;
        videoTrack.id = id;
        videoTrack.timescale = captionTrack.timescale = timescale;
        videoTrack.codec = codec;
      }
      if (initData.audio) {
        const {
          id,
          timescale,
          codec
        } = initData.audio;
        audioTrack.id = id;
        audioTrack.timescale = timescale;
        audioTrack.codec = codec;
      }
      captionTrack.id = RemuxerTrackIdConfig.text;
      videoTrack.sampleDuration = 0;
      videoTrack.duration = audioTrack.duration = trackDuration;
    }
    resetContiguity() {
      this.remainderData = null;
    }
    static probe(data) {
      return hasMoofData(data);
    }
    demux(data, timeOffset) {
      this.timeOffset = timeOffset;
      // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter
      let videoSamples = data;
      const videoTrack = this.videoTrack;
      const textTrack = this.txtTrack;
      if (this.config.progressive) {
        // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.
        // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee
        // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.
        if (this.remainderData) {
          videoSamples = appendUint8Array(this.remainderData, data);
        }
        const segmentedData = segmentValidRange(videoSamples);
        this.remainderData = segmentedData.remainder;
        videoTrack.samples = segmentedData.valid || new Uint8Array();
      } else {
        videoTrack.samples = videoSamples;
      }
      const id3Track = this.extractID3Track(videoTrack, timeOffset);
      textTrack.samples = parseSamples(timeOffset, videoTrack);
      return {
        videoTrack,
        audioTrack: this.audioTrack,
        id3Track,
        textTrack: this.txtTrack
      };
    }
    flush() {
      const timeOffset = this.timeOffset;
      const videoTrack = this.videoTrack;
      const textTrack = this.txtTrack;
      videoTrack.samples = this.remainderData || new Uint8Array();
      this.remainderData = null;
      const id3Track = this.extractID3Track(videoTrack, this.timeOffset);
      textTrack.samples = parseSamples(timeOffset, videoTrack);
      return {
        videoTrack,
        audioTrack: dummyTrack(),
        id3Track,
        textTrack: dummyTrack()
      };
    }
    extractID3Track(videoTrack, timeOffset) {
      const id3Track = this.id3Track;
      if (videoTrack.samples.length) {
        const emsgs = findBox(videoTrack.samples, ['emsg']);
        if (emsgs) {
          emsgs.forEach(data => {
            const emsgInfo = parseEmsg(data);
            if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {
              const pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;
              let duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;
              // Safari takes anything <= 0.001 seconds and maps it to Infinity
              if (duration <= 0.001) {
                duration = Number.POSITIVE_INFINITY;
              }
              const payload = emsgInfo.payload;
              id3Track.samples.push({
                data: payload,
                len: payload.byteLength,
                dts: pts,
                pts: pts,
                type: MetadataSchema.emsg,
                duration: duration
              });
            }
          });
        }
      }
      return id3Track;
    }
    demuxSampleAes(data, keyData, timeOffset) {
      return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));
    }
    destroy() {}
  }

  const getAudioBSID = (data, offset) => {
    // check the bsid to confirm ac-3 | ec-3
    let bsid = 0;
    let numBits = 5;
    offset += numBits;
    const temp = new Uint32Array(1); // unsigned 32 bit for temporary storage
    const mask = new Uint32Array(1); // unsigned 32 bit mask value
    const byte = new Uint8Array(1); // unsigned 8 bit for temporary storage
    while (numBits > 0) {
      byte[0] = data[offset];
      // read remaining bits, upto 8 bits at a time
      const bits = Math.min(numBits, 8);
      const shift = 8 - bits;
      mask[0] = 0xff000000 >>> 24 + shift << shift;
      temp[0] = (byte[0] & mask[0]) >> shift;
      bsid = !bsid ? temp[0] : bsid << bits | temp[0];
      offset += 1;
      numBits -= bits;
    }
    return bsid;
  };

  class AC3Demuxer extends BaseAudioDemuxer {
    constructor(observer) {
      super();
      this.observer = void 0;
      this.observer = observer;
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
      this._audioTrack = {
        container: 'audio/ac-3',
        type: 'audio',
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: 'ac3',
        samples: [],
        manifestCodec: audioCodec,
        duration: trackDuration,
        inputTimeScale: 90000,
        dropped: 0
      };
    }
    canParse(data, offset) {
      return offset + 64 < data.length;
    }
    appendFrame(track, data, offset) {
      const frameLength = appendFrame(track, data, offset, this.basePTS, this.frameIndex);
      if (frameLength !== -1) {
        const sample = track.samples[track.samples.length - 1];
        return {
          sample,
          length: frameLength,
          missing: 0
        };
      }
    }
    static probe(data) {
      if (!data) {
        return false;
      }
      const id3Data = getID3Data(data, 0);
      if (!id3Data) {
        return false;
      }

      // look for the ac-3 sync bytes
      const offset = id3Data.length;
      if (data[offset] === 0x0b && data[offset + 1] === 0x77 && getTimeStamp(id3Data) !== undefined &&
      // check the bsid to confirm ac-3
      getAudioBSID(data, offset) < 16) {
        return true;
      }
      return false;
    }
  }
  function appendFrame(track, data, start, pts, frameIndex) {
    if (start + 8 > data.length) {
      return -1; // not enough bytes left
    }
    if (data[start] !== 0x0b || data[start + 1] !== 0x77) {
      return -1; // invalid magic
    }

    // get sample rate
    const samplingRateCode = data[start + 4] >> 6;
    if (samplingRateCode >= 3) {
      return -1; // invalid sampling rate
    }
    const samplingRateMap = [48000, 44100, 32000];
    const sampleRate = samplingRateMap[samplingRateCode];

    // get frame size
    const frameSizeCode = data[start + 4] & 0x3f;
    const frameSizeMap = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920];
    const frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;
    if (start + frameLength > data.length) {
      return -1;
    }

    // get channel count
    const channelMode = data[start + 6] >> 5;
    let skipCount = 0;
    if (channelMode === 2) {
      skipCount += 2;
    } else {
      if (channelMode & 1 && channelMode !== 1) {
        skipCount += 2;
      }
      if (channelMode & 4) {
        skipCount += 2;
      }
    }
    const lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;
    const channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];
    const channelCount = channelsMap[channelMode] + lfeon;

    // build dac3 box
    const bsid = data[start + 5] >> 3;
    const bsmod = data[start + 5] & 7;
    const config = new Uint8Array([samplingRateCode << 6 | bsid << 1 | bsmod >> 2, (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4, frameSizeCode << 4 & 0xe0]);
    const frameDuration = 1536 / sampleRate * 90000;
    const stamp = pts + frameIndex * frameDuration;
    const unit = data.subarray(start, start + frameLength);
    track.config = config;
    track.channelCount = channelCount;
    track.samplerate = sampleRate;
    track.samples.push({
      unit,
      pts: stamp
    });
    return frameLength;
  }

  class BaseVideoParser {
    constructor() {
      this.VideoSample = null;
    }
    createVideoSample(key, pts, dts, debug) {
      return {
        key,
        frame: false,
        pts,
        dts,
        units: [],
        debug,
        length: 0
      };
    }
    getLastNalUnit(samples) {
      var _VideoSample;
      let VideoSample = this.VideoSample;
      let lastUnit;
      // try to fallback to previous sample if current one is empty
      if (!VideoSample || VideoSample.units.length === 0) {
        VideoSample = samples[samples.length - 1];
      }
      if ((_VideoSample = VideoSample) != null && _VideoSample.units) {
        const units = VideoSample.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
    pushAccessUnit(VideoSample, videoTrack) {
      if (VideoSample.units.length && VideoSample.frame) {
        // if sample does not have PTS/DTS, patch with last sample PTS/DTS
        if (VideoSample.pts === undefined) {
          const samples = videoTrack.samples;
          const nbSamples = samples.length;
          if (nbSamples) {
            const lastSample = samples[nbSamples - 1];
            VideoSample.pts = lastSample.pts;
            VideoSample.dts = lastSample.dts;
          } else {
            // dropping samples, no timestamp found
            videoTrack.dropped++;
            return;
          }
        }
        videoTrack.samples.push(VideoSample);
      }
      if (VideoSample.debug.length) {
        logger.log(VideoSample.pts + '/' + VideoSample.dts + ':' + VideoSample.debug);
      }
    }
  }

  /**
   * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
   */

  class ExpGolomb {
    constructor(data) {
      this.data = void 0;
      this.bytesAvailable = void 0;
      this.word = void 0;
      this.bitsAvailable = void 0;
      this.data = data;
      // the number of bytes left to examine in this.data
      this.bytesAvailable = data.byteLength;
      // the current word being examined
      this.word = 0; // :uint
      // the number of bits left to examine in the current word
      this.bitsAvailable = 0; // :uint
    }

    // ():void
    loadWord() {
      const data = this.data;
      const bytesAvailable = this.bytesAvailable;
      const position = data.byteLength - bytesAvailable;
      const workingBytes = new Uint8Array(4);
      const availableBytes = Math.min(4, bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }
      workingBytes.set(data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void
    skipBits(count) {
      let skipBytes; // :int
      count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes << 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint
    readBits(size) {
      let bits = Math.min(this.bitsAvailable, size); // :uint
      const valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        logger.error('Cannot read more than 32 bits at a time');
      }
      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      } else {
        throw new Error('no bits available');
      }
      bits = size - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint
    skipLZ() {
      let leadingZeroCount; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void
    skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void
    skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint
    readUEG() {
      const clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int
    readEG() {
      const valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean
    readBoolean() {
      return this.readBits(1) === 1;
    }

    // ():int
    readUByte() {
      return this.readBits(8);
    }

    // ():int
    readUShort() {
      return this.readBits(16);
    }

    // ():int
    readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */
    skipScalingList(count) {
      let lastScale = 8;
      let nextScale = 8;
      let deltaScale;
      for (let j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @returns an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */
    readSPS() {
      let frameCropLeftOffset = 0;
      let frameCropRightOffset = 0;
      let frameCropTopOffset = 0;
      let frameCropBottomOffset = 0;
      let numRefFramesInPicOrderCntCycle;
      let scalingListCount;
      let i;
      const readUByte = this.readUByte.bind(this);
      const readBits = this.readBits.bind(this);
      const readUEG = this.readUEG.bind(this);
      const readBoolean = this.readBoolean.bind(this);
      const skipBits = this.skipBits.bind(this);
      const skipEG = this.skipEG.bind(this);
      const skipUEG = this.skipUEG.bind(this);
      const skipScalingList = this.skipScalingList.bind(this);
      readUByte();
      const profileIdc = readUByte(); // profile_idc
      readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)
      skipBits(3); // reserved_zero_3bits u(3),
      readUByte(); // level_idc u(8)
      skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        const chromaFormatIdc = readUEG();
        if (chromaFormatIdc === 3) {
          skipBits(1);
        } // separate_colour_plane_flag

        skipUEG(); // bit_depth_luma_minus8
        skipUEG(); // bit_depth_chroma_minus8
        skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                skipScalingList(16);
              } else {
                skipScalingList(64);
              }
            }
          }
        }
      }
      skipUEG(); // log2_max_frame_num_minus4
      const picOrderCntType = readUEG();
      if (picOrderCntType === 0) {
        readUEG(); // log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        skipBits(1); // delta_pic_order_always_zero_flag
        skipEG(); // offset_for_non_ref_pic
        skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          skipEG();
        } // offset_for_ref_frame[ i ]
      }
      skipUEG(); // max_num_ref_frames
      skipBits(1); // gaps_in_frame_num_value_allowed_flag
      const picWidthInMbsMinus1 = readUEG();
      const picHeightInMapUnitsMinus1 = readUEG();
      const frameMbsOnlyFlag = readBits(1);
      if (frameMbsOnlyFlag === 0) {
        skipBits(1);
      } // mb_adaptive_frame_field_flag

      skipBits(1); // direct_8x8_inference_flag
      if (readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = readUEG();
        frameCropRightOffset = readUEG();
        frameCropTopOffset = readUEG();
        frameCropBottomOffset = readUEG();
      }
      let pixelRatio = [1, 1];
      if (readBoolean()) {
        // vui_parameters_present_flag
        if (readBoolean()) {
          // aspect_ratio_info_present_flag
          const aspectRatioIdc = readUByte();
          switch (aspectRatioIdc) {
            case 1:
              pixelRatio = [1, 1];
              break;
            case 2:
              pixelRatio = [12, 11];
              break;
            case 3:
              pixelRatio = [10, 11];
              break;
            case 4:
              pixelRatio = [16, 11];
              break;
            case 5:
              pixelRatio = [40, 33];
              break;
            case 6:
              pixelRatio = [24, 11];
              break;
            case 7:
              pixelRatio = [20, 11];
              break;
            case 8:
              pixelRatio = [32, 11];
              break;
            case 9:
              pixelRatio = [80, 33];
              break;
            case 10:
              pixelRatio = [18, 11];
              break;
            case 11:
              pixelRatio = [15, 11];
              break;
            case 12:
              pixelRatio = [64, 33];
              break;
            case 13:
              pixelRatio = [160, 99];
              break;
            case 14:
              pixelRatio = [4, 3];
              break;
            case 15:
              pixelRatio = [3, 2];
              break;
            case 16:
              pixelRatio = [2, 1];
              break;
            case 255:
              {
                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                break;
              }
          }
        }
      }
      return {
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        pixelRatio: pixelRatio
      };
    }
    readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }

  class AvcVideoParser extends BaseVideoParser {
    parseAVCPES(track, textTrack, pes, last, duration) {
      const units = this.parseAVCNALu(track, pes.data);
      let VideoSample = this.VideoSample;
      let push;
      let spsfound = false;
      // free pes.data to save up some memory
      pes.data = null;

      // if new NAL units found and last sample still there, let's push ...
      // this helps parsing streams with missing AUD (only do this if AUD never found)
      if (VideoSample && units.length && !track.audFound) {
        this.pushAccessUnit(VideoSample, track);
        VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, '');
      }
      units.forEach(unit => {
        var _VideoSample2;
        switch (unit.type) {
          // NDR
          case 1:
            {
              let iskey = false;
              push = true;
              const data = unit.data;
              // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)
              if (spsfound && data.length > 4) {
                // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
                const sliceType = new ExpGolomb(data).readSliceType();
                // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
                // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
                // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
                // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
                // if (sliceType === 2 || sliceType === 7) {
                if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                  iskey = true;
                }
              }
              if (iskey) {
                var _VideoSample;
                // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push
                if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {
                  this.pushAccessUnit(VideoSample, track);
                  VideoSample = this.VideoSample = null;
                }
              }
              if (!VideoSample) {
                VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, '');
              }
              VideoSample.frame = true;
              VideoSample.key = iskey;
              break;
              // IDR
            }
          case 5:
            push = true;
            // handle PES not starting with AUD
            // if we have frame data already, that cannot belong to the same frame, so force a push
            if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {
              this.pushAccessUnit(VideoSample, track);
              VideoSample = this.VideoSample = null;
            }
            if (!VideoSample) {
              VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, '');
            }
            VideoSample.key = true;
            VideoSample.frame = true;
            break;
          // SEI
          case 6:
            {
              push = true;
              parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);
              break;
              // SPS
            }
          case 7:
            {
              var _track$pixelRatio, _track$pixelRatio2;
              push = true;
              spsfound = true;
              const sps = unit.data;
              const expGolombDecoder = new ExpGolomb(sps);
              const config = expGolombDecoder.readSPS();
              if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {
                track.width = config.width;
                track.height = config.height;
                track.pixelRatio = config.pixelRatio;
                track.sps = [sps];
                track.duration = duration;
                const codecarray = sps.subarray(1, 4);
                let codecstring = 'avc1.';
                for (let i = 0; i < 3; i++) {
                  let h = codecarray[i].toString(16);
                  if (h.length < 2) {
                    h = '0' + h;
                  }
                  codecstring += h;
                }
                track.codec = codecstring;
              }
              break;
            }
          // PPS
          case 8:
            push = true;
            track.pps = [unit.data];
            break;
          // AUD
          case 9:
            push = true;
            track.audFound = true;
            if (VideoSample) {
              this.pushAccessUnit(VideoSample, track);
            }
            VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, '');
            break;
          // Filler Data
          case 12:
            push = true;
            break;
          default:
            push = false;
            if (VideoSample) {
              VideoSample.debug += 'unknown NAL ' + unit.type + ' ';
            }
            break;
        }
        if (VideoSample && push) {
          const units = VideoSample.units;
          units.push(unit);
        }
      });
      // if last PES packet, push samples
      if (last && VideoSample) {
        this.pushAccessUnit(VideoSample, track);
        this.VideoSample = null;
      }
    }
    parseAVCNALu(track, array) {
      const len = array.byteLength;
      let state = track.naluState || 0;
      const lastState = state;
      const units = [];
      let i = 0;
      let value;
      let overflow;
      let unitType;
      let lastUnitStart = -1;
      let lastUnitType = 0;
      // logger.log('PES:' + Hex.hexDump(array));

      if (state === -1) {
        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
        lastUnitStart = 0;
        // NALu type is value read from offset 0
        lastUnitType = array[0] & 0x1f;
        state = 0;
        i = 1;
      }
      while (i < len) {
        value = array[i++];
        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
        if (!state) {
          state = value ? 0 : 1;
          continue;
        }
        if (state === 1) {
          state = value ? 0 : 2;
          continue;
        }
        // here we have state either equal to 2 or 3
        if (!value) {
          state = 3;
        } else if (value === 1) {
          overflow = i - state - 1;
          if (lastUnitStart >= 0) {
            const unit = {
              data: array.subarray(lastUnitStart, overflow),
              type: lastUnitType
            };
            // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
            units.push(unit);
          } else {
            // lastUnitStart is undefined => this is the first start code found in this PES packet
            // first check if start code delimiter is overlapping between 2 PES packets,
            // ie it started in last packet (lastState not zero)
            // and ended at the beginning of this PES packet (i <= 4 - lastState)
            const lastUnit = this.getLastNalUnit(track.samples);
            if (lastUnit) {
              if (lastState && i <= 4 - lastState) {
                // start delimiter overlapping between PES packets
                // strip start delimiter bytes from the end of last NAL unit
                // check if lastUnit had a state different from zero
                if (lastUnit.state) {
                  // strip last bytes
                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                }
              }
              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.

              if (overflow > 0) {
                // logger.log('first NALU found with overflow:' + overflow);
                lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));
                lastUnit.state = 0;
              }
            }
          }
          // check if we can read unit type
          if (i < len) {
            unitType = array[i] & 0x1f;
            // logger.log('find NALU @ offset:' + i + ',type:' + unitType);
            lastUnitStart = i;
            lastUnitType = unitType;
            state = 0;
          } else {
            // not enough byte to read unit type. let's read it on next PES parsing
            state = -1;
          }
        } else {
          state = 0;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        const unit = {
          data: array.subarray(lastUnitStart, len),
          type: lastUnitType,
          state: state
        };
        units.push(unit);
        // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
      }
      // no NALu found
      if (units.length === 0) {
        // append pes.data to previous NAL unit
        const lastUnit = this.getLastNalUnit(track.samples);
        if (lastUnit) {
          lastUnit.data = appendUint8Array(lastUnit.data, array);
        }
      }
      track.naluState = state;
      return units;
    }
  }

  /**
   * SAMPLE-AES decrypter
   */

  class SampleAesDecrypter {
    constructor(observer, config, keyData) {
      this.keyData = void 0;
      this.decrypter = void 0;
      this.keyData = keyData;
      this.decrypter = new Decrypter(config, {
        removePKCS7Padding: false
      });
    }
    decryptBuffer(encryptedData) {
      return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);
    }

    // AAC - encrypt all full 16 bytes blocks starting from offset 16
    decryptAacSample(samples, sampleIndex, callback) {
      const curUnit = samples[sampleIndex].unit;
      if (curUnit.length <= 16) {
        // No encrypted portion in this sample (first 16 bytes is not
        // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),
        return;
      }
      const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
      const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
      this.decryptBuffer(encryptedBuffer).then(decryptedBuffer => {
        const decryptedData = new Uint8Array(decryptedBuffer);
        curUnit.set(decryptedData, 16);
        if (!this.decrypter.isSync()) {
          this.decryptAacSamples(samples, sampleIndex + 1, callback);
        }
      });
    }
    decryptAacSamples(samples, sampleIndex, callback) {
      for (;; sampleIndex++) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }
        if (samples[sampleIndex].unit.length < 32) {
          continue;
        }
        this.decryptAacSample(samples, sampleIndex, callback);
        if (!this.decrypter.isSync()) {
          return;
        }
      }
    }

    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
    getAvcEncryptedData(decodedData) {
      const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
      const encryptedData = new Int8Array(encryptedDataLen);
      let outputPos = 0;
      for (let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {
        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return encryptedData;
    }
    getAvcDecryptedUnit(decodedData, decryptedData) {
      const uint8DecryptedData = new Uint8Array(decryptedData);
      let inputPos = 0;
      for (let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {
        decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return decodedData;
    }
    decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {
      const decodedData = discardEPB(curUnit.data);
      const encryptedData = this.getAvcEncryptedData(decodedData);
      this.decryptBuffer(encryptedData.buffer).then(decryptedBuffer => {
        curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);
        if (!this.decrypter.isSync()) {
          this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
        }
      });
    }
    decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
      if (samples instanceof Uint8Array) {
        throw new Error('Cannot decrypt samples of type Uint8Array');
      }
      for (;; sampleIndex++, unitIndex = 0) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }
        const curUnits = samples[sampleIndex].units;
        for (;; unitIndex++) {
          if (unitIndex >= curUnits.length) {
            break;
          }
          const curUnit = curUnits[unitIndex];
          if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
            continue;
          }
          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);
          if (!this.decrypter.isSync()) {
            return;
          }
        }
      }
    }
  }

  const PACKET_LENGTH = 188;
  class TSDemuxer {
    constructor(observer, config, typeSupported) {
      this.observer = void 0;
      this.config = void 0;
      this.typeSupported = void 0;
      this.sampleAes = null;
      this.pmtParsed = false;
      this.audioCodec = void 0;
      this.videoCodec = void 0;
      this._duration = 0;
      this._pmtId = -1;
      this._videoTrack = void 0;
      this._audioTrack = void 0;
      this._id3Track = void 0;
      this._txtTrack = void 0;
      this.aacOverFlow = null;
      this.remainderData = null;
      this.videoParser = void 0;
      this.observer = observer;
      this.config = config;
      this.typeSupported = typeSupported;
      this.videoParser = new AvcVideoParser();
    }
    static probe(data) {
      const syncOffset = TSDemuxer.syncOffset(data);
      if (syncOffset > 0) {
        logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);
      }
      return syncOffset !== -1;
    }
    static syncOffset(data) {
      const length = data.length;
      let scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;
      let i = 0;
      while (i < scanwindow) {
        // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47
        let foundPat = false;
        let packetStart = -1;
        let tsPackets = 0;
        for (let j = i; j < length; j += PACKET_LENGTH) {
          if (data[j] === 0x47 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 0x47)) {
            tsPackets++;
            if (packetStart === -1) {
              packetStart = j;
              // First sync word found at offset, increase scan length (#5251)
              if (packetStart !== 0) {
                scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;
              }
            }
            if (!foundPat) {
              foundPat = parsePID(data, j) === 0;
            }
            // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)
            if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {
              return packetStart;
            }
          } else if (tsPackets) {
            // Exit if sync word found, but does not contain contiguous packets
            return -1;
          } else {
            break;
          }
        }
        i++;
      }
      return -1;
    }

    /**
     * Creates a track model internal to demuxer used to drive remuxing input
     */
    static createTrack(type, duration) {
      return {
        container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,
        type,
        id: RemuxerTrackIdConfig[type],
        pid: -1,
        inputTimeScale: 90000,
        sequenceNumber: 0,
        samples: [],
        dropped: 0,
        duration: type === 'audio' ? duration : undefined
      };
    }

    /**
     * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
     * Resets all internal track instances of the demuxer.
     */
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      this.pmtParsed = false;
      this._pmtId = -1;
      this._videoTrack = TSDemuxer.createTrack('video');
      this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);
      this._id3Track = TSDemuxer.createTrack('id3');
      this._txtTrack = TSDemuxer.createTrack('text');
      this._audioTrack.segmentCodec = 'aac';

      // flush any partial content
      this.aacOverFlow = null;
      this.remainderData = null;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this._duration = trackDuration;
    }
    resetTimeStamp() {}
    resetContiguity() {
      const {
        _audioTrack,
        _videoTrack,
        _id3Track
      } = this;
      if (_audioTrack) {
        _audioTrack.pesData = null;
      }
      if (_videoTrack) {
        _videoTrack.pesData = null;
      }
      if (_id3Track) {
        _id3Track.pesData = null;
      }
      this.aacOverFlow = null;
      this.remainderData = null;
    }
    demux(data, timeOffset, isSampleAes = false, flush = false) {
      if (!isSampleAes) {
        this.sampleAes = null;
      }
      let pes;
      const videoTrack = this._videoTrack;
      const audioTrack = this._audioTrack;
      const id3Track = this._id3Track;
      const textTrack = this._txtTrack;
      let videoPid = videoTrack.pid;
      let videoData = videoTrack.pesData;
      let audioPid = audioTrack.pid;
      let id3Pid = id3Track.pid;
      let audioData = audioTrack.pesData;
      let id3Data = id3Track.pesData;
      let unknownPID = null;
      let pmtParsed = this.pmtParsed;
      let pmtId = this._pmtId;
      let len = data.length;
      if (this.remainderData) {
        data = appendUint8Array(this.remainderData, data);
        len = data.length;
        this.remainderData = null;
      }
      if (len < PACKET_LENGTH && !flush) {
        this.remainderData = data;
        return {
          audioTrack,
          videoTrack,
          id3Track,
          textTrack
        };
      }
      const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));
      len -= (len - syncOffset) % PACKET_LENGTH;
      if (len < data.byteLength && !flush) {
        this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);
      }

      // loop through TS packets
      let tsPacketErrors = 0;
      for (let start = syncOffset; start < len; start += PACKET_LENGTH) {
        if (data[start] === 0x47) {
          const stt = !!(data[start + 1] & 0x40);
          const pid = parsePID(data, start);
          const atf = (data[start + 3] & 0x30) >> 4;

          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          let offset;
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + PACKET_LENGTH) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case videoPid:
              if (stt) {
                if (videoData && (pes = parsePES(videoData))) {
                  this.videoParser.parseAVCPES(videoTrack, textTrack, pes, false, this._duration);
                }
                videoData = {
                  data: [],
                  size: 0
                };
              }
              if (videoData) {
                videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                videoData.size += start + PACKET_LENGTH - offset;
              }
              break;
            case audioPid:
              if (stt) {
                if (audioData && (pes = parsePES(audioData))) {
                  switch (audioTrack.segmentCodec) {
                    case 'aac':
                      this.parseAACPES(audioTrack, pes);
                      break;
                    case 'mp3':
                      this.parseMPEGPES(audioTrack, pes);
                      break;
                    case 'ac3':
                      {
                        this.parseAC3PES(audioTrack, pes);
                      }
                      break;
                  }
                }
                audioData = {
                  data: [],
                  size: 0
                };
              }
              if (audioData) {
                audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                audioData.size += start + PACKET_LENGTH - offset;
              }
              break;
            case id3Pid:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data))) {
                  this.parseID3PES(id3Track, pes);
                }
                id3Data = {
                  data: [],
                  size: 0
                };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));
                id3Data.size += start + PACKET_LENGTH - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }
              pmtId = this._pmtId = parsePAT(data, offset);
              // logger.log('PMT PID:'  + this._pmtId);
              break;
            case pmtId:
              {
                if (stt) {
                  offset += data[offset] + 1;
                }
                const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes, this.observer);

                // only update track id if track PID found while parsing PMT
                // this is to avoid resetting the PID to -1 in case
                // track PID transiently disappears from the stream
                // this could happen in case of transient missing audio samples for example
                // NOTE this is only the PID of the track as found in TS,
                // but we are not using this for MP4 track IDs.
                videoPid = parsedPIDs.videoPid;
                if (videoPid > 0) {
                  videoTrack.pid = videoPid;
                  videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;
                }
                audioPid = parsedPIDs.audioPid;
                if (audioPid > 0) {
                  audioTrack.pid = audioPid;
                  audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;
                }
                id3Pid = parsedPIDs.id3Pid;
                if (id3Pid > 0) {
                  id3Track.pid = id3Pid;
                }
                if (unknownPID !== null && !pmtParsed) {
                  logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);
                  unknownPID = null;
                  // we set it to -188, the += 188 in the for loop will reset start to 0
                  start = syncOffset - 188;
                }
                pmtParsed = this.pmtParsed = true;
                break;
              }
            case 0x11:
            case 0x1fff:
              break;
            default:
              unknownPID = pid;
              break;
          }
        } else {
          tsPacketErrors++;
        }
      }
      if (tsPacketErrors > 0) {
        emitParsingError(this.observer, new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`));
      }
      videoTrack.pesData = videoData;
      audioTrack.pesData = audioData;
      id3Track.pesData = id3Data;
      const demuxResult = {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      };
      if (flush) {
        this.extractRemainingSamples(demuxResult);
      }
      return demuxResult;
    }
    flush() {
      const {
        remainderData
      } = this;
      this.remainderData = null;
      let result;
      if (remainderData) {
        result = this.demux(remainderData, -1, false, true);
      } else {
        result = {
          videoTrack: this._videoTrack,
          audioTrack: this._audioTrack,
          id3Track: this._id3Track,
          textTrack: this._txtTrack
        };
      }
      this.extractRemainingSamples(result);
      if (this.sampleAes) {
        return this.decrypt(result, this.sampleAes);
      }
      return result;
    }
    extractRemainingSamples(demuxResult) {
      const {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      } = demuxResult;
      const videoData = videoTrack.pesData;
      const audioData = audioTrack.pesData;
      const id3Data = id3Track.pesData;
      // try to parse last PES packets
      let pes;
      if (videoData && (pes = parsePES(videoData))) {
        this.videoParser.parseAVCPES(videoTrack, textTrack, pes, true, this._duration);
        videoTrack.pesData = null;
      } else {
        // either avcData null or PES truncated, keep it for next frag parsing
        videoTrack.pesData = videoData;
      }
      if (audioData && (pes = parsePES(audioData))) {
        switch (audioTrack.segmentCodec) {
          case 'aac':
            this.parseAACPES(audioTrack, pes);
            break;
          case 'mp3':
            this.parseMPEGPES(audioTrack, pes);
            break;
          case 'ac3':
            {
              this.parseAC3PES(audioTrack, pes);
            }
            break;
        }
        audioTrack.pesData = null;
      } else {
        if (audioData != null && audioData.size) {
          logger.log('last AAC PES packet truncated,might overlap between fragments');
        }

        // either audioData null or PES truncated, keep it for next frag parsing
        audioTrack.pesData = audioData;
      }
      if (id3Data && (pes = parsePES(id3Data))) {
        this.parseID3PES(id3Track, pes);
        id3Track.pesData = null;
      } else {
        // either id3Data null or PES truncated, keep it for next frag parsing
        id3Track.pesData = id3Data;
      }
    }
    demuxSampleAes(data, keyData, timeOffset) {
      const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);
      const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);
      return this.decrypt(demuxResult, sampleAes);
    }
    decrypt(demuxResult, sampleAes) {
      return new Promise(resolve => {
        const {
          audioTrack,
          videoTrack
        } = demuxResult;
        if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {
          sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {
            if (videoTrack.samples) {
              sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {
                resolve(demuxResult);
              });
            } else {
              resolve(demuxResult);
            }
          });
        } else if (videoTrack.samples) {
          sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {
            resolve(demuxResult);
          });
        }
      });
    }
    destroy() {
      this._duration = 0;
    }
    parseAACPES(track, pes) {
      let startOffset = 0;
      const aacOverFlow = this.aacOverFlow;
      let data = pes.data;
      if (aacOverFlow) {
        this.aacOverFlow = null;
        const frameMissingBytes = aacOverFlow.missing;
        const sampleLength = aacOverFlow.sample.unit.byteLength;
        // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);
        if (frameMissingBytes === -1) {
          data = appendUint8Array(aacOverFlow.sample.unit, data);
        } else {
          const frameOverflowBytes = sampleLength - frameMissingBytes;
          aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);
          track.samples.push(aacOverFlow.sample);
          startOffset = aacOverFlow.missing;
        }
      }
      // look for ADTS header (0xFFFx)
      let offset;
      let len;
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (isHeader$1(data, offset)) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset !== startOffset) {
        let reason;
        const recoverable = offset < len - 1;
        if (recoverable) {
          reason = `AAC PES did not start with ADTS header,offset:${offset}`;
        } else {
          reason = 'No ADTS header found in AAC PES';
        }
        emitParsingError(this.observer, new Error(reason), recoverable);
        if (!recoverable) {
          return;
        }
      }
      initTrackConfig(track, this.observer, data, offset, this.audioCodec);
      let pts;
      if (pes.pts !== undefined) {
        pts = pes.pts;
      } else if (aacOverFlow) {
        // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
        // first sample PTS should be equal to last sample PTS + frameDuration
        const frameDuration = getFrameDuration(track.samplerate);
        pts = aacOverFlow.sample.pts + frameDuration;
      } else {
        logger.warn('[tsdemuxer]: AAC PES unknown PTS');
        return;
      }

      // scan for aac samples
      let frameIndex = 0;
      let frame;
      while (offset < len) {
        frame = appendFrame$2(track, data, offset, pts, frameIndex);
        offset += frame.length;
        if (!frame.missing) {
          frameIndex++;
          for (; offset < len - 1; offset++) {
            if (isHeader$1(data, offset)) {
              break;
            }
          }
        } else {
          this.aacOverFlow = frame;
          break;
        }
      }
    }
    parseMPEGPES(track, pes) {
      const data = pes.data;
      const length = data.length;
      let frameIndex = 0;
      let offset = 0;
      const pts = pes.pts;
      if (pts === undefined) {
        logger.warn('[tsdemuxer]: MPEG PES unknown PTS');
        return;
      }
      while (offset < length) {
        if (isHeader(data, offset)) {
          const frame = appendFrame$1(track, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            frameIndex++;
          } else {
            // logger.log('Unable to parse Mpeg audio frame');
            break;
          }
        } else {
          // nothing found, keep looking
          offset++;
        }
      }
    }
    parseAC3PES(track, pes) {
      {
        const data = pes.data;
        const pts = pes.pts;
        if (pts === undefined) {
          logger.warn('[tsdemuxer]: AC3 PES unknown PTS');
          return;
        }
        const length = data.length;
        let frameIndex = 0;
        let offset = 0;
        let parsed;
        while (offset < length && (parsed = appendFrame(track, data, offset, pts, frameIndex++)) > 0) {
          offset += parsed;
        }
      }
    }
    parseID3PES(id3Track, pes) {
      if (pes.pts === undefined) {
        logger.warn('[tsdemuxer]: ID3 PES unknown PTS');
        return;
      }
      const id3Sample = _extends$2({}, pes, {
        type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,
        duration: Number.POSITIVE_INFINITY
      });
      id3Track.samples.push(id3Sample);
    }
  }
  function parsePID(data, offset) {
    // pid is a 13-bit field starting at the last bit of TS[1]
    return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];
  }
  function parsePAT(data, offset) {
    // skip the PSI header and parse the first PMT entry
    return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];
  }
  function parsePMT(data, offset, typeSupported, isSampleAes, observer) {
    const result = {
      audioPid: -1,
      videoPid: -1,
      id3Pid: -1,
      segmentVideoCodec: 'avc',
      segmentAudioCodec: 'aac'
    };
    const sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
    const tableEnd = offset + 3 + sectionLength - 4;
    // to determine where the table is, we have to figure out how
    // long the program info descriptors are
    const programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
    // advance the offset to the first entry in the mapping table
    offset += 12 + programInfoLength;
    while (offset < tableEnd) {
      const pid = parsePID(data, offset);
      const esInfoLength = (data[offset + 3] & 0x0f) << 8 | data[offset + 4];
      switch (data[offset]) {
        case 0xcf:
          // SAMPLE-AES AAC
          if (!isSampleAes) {
            logEncryptedSamplesFoundInUnencryptedStream('ADTS AAC');
            break;
          }
        /* falls through */
        case 0x0f:
          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          // logger.log('AAC PID:'  + pid);
          if (result.audioPid === -1) {
            result.audioPid = pid;
          }
          break;

        // Packetized metadata (ID3)
        case 0x15:
          // logger.log('ID3 PID:'  + pid);
          if (result.id3Pid === -1) {
            result.id3Pid = pid;
          }
          break;
        case 0xdb:
          // SAMPLE-AES AVC
          if (!isSampleAes) {
            logEncryptedSamplesFoundInUnencryptedStream('H.264');
            break;
          }
        /* falls through */
        case 0x1b:
          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          // logger.log('AVC PID:'  + pid);
          if (result.videoPid === -1) {
            result.videoPid = pid;
            result.segmentVideoCodec = 'avc';
          }
          break;

        // ISO/IEC 11172-3 (MPEG-1 audio)
        // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
        case 0x03:
        case 0x04:
          // logger.log('MPEG PID:'  + pid);
          if (!typeSupported.mpeg && !typeSupported.mp3) {
            logger.log('MPEG audio found, not supported in this browser');
          } else if (result.audioPid === -1) {
            result.audioPid = pid;
            result.segmentAudioCodec = 'mp3';
          }
          break;
        case 0xc1:
          // SAMPLE-AES AC3
          if (!isSampleAes) {
            logEncryptedSamplesFoundInUnencryptedStream('AC-3');
            break;
          }
        /* falls through */
        case 0x81:
          {
            if (!typeSupported.ac3) {
              logger.log('AC-3 audio found, not supported in this browser');
            } else if (result.audioPid === -1) {
              result.audioPid = pid;
              result.segmentAudioCodec = 'ac3';
            }
          }
          break;
        case 0x06:
          // stream_type 6 can mean a lot of different things in case of DVB.
          // We need to look at the descriptors. Right now, we're only interested
          // in AC-3 audio, so we do the descriptor parsing only when we don't have
          // an audio PID yet.
          if (result.audioPid === -1 && esInfoLength > 0) {
            let parsePos = offset + 5;
            let remaining = esInfoLength;
            while (remaining > 2) {
              const descriptorId = data[parsePos];
              switch (descriptorId) {
                case 0x6a:
                  // DVB Descriptor for AC-3
                  {
                    if (typeSupported.ac3 !== true) {
                      logger.log('AC-3 audio found, not supported in this browser for now');
                    } else {
                      result.audioPid = pid;
                      result.segmentAudioCodec = 'ac3';
                    }
                  }
                  break;
              }
              const descriptorLen = data[parsePos + 1] + 2;
              parsePos += descriptorLen;
              remaining -= descriptorLen;
            }
          }
          break;
        case 0xc2: // SAMPLE-AES EC3
        /* falls through */
        case 0x87:
          emitParsingError(observer, new Error('Unsupported EC-3 in M2TS found'));
          return result;
        case 0x24:
          emitParsingError(observer, new Error('Unsupported HEVC in M2TS found'));
          return result;
      }
      // move to the next table entry
      // skip past the elementary stream descriptors, if present
      offset += esInfoLength + 5;
    }
    return result;
  }
  function emitParsingError(observer, error, levelRetry) {
    logger.warn(`parsing error: ${error.message}`);
    observer.emit(Events$1.ERROR, Events$1.ERROR, {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.FRAG_PARSING_ERROR,
      fatal: false,
      levelRetry,
      error,
      reason: error.message
    });
  }
  function logEncryptedSamplesFoundInUnencryptedStream(type) {
    logger.log(`${type} with AES-128-CBC encryption found in unencrypted stream`);
  }
  function parsePES(stream) {
    let i = 0;
    let frag;
    let pesLen;
    let pesHdrLen;
    let pesPts;
    let pesDts;
    const data = stream.data;
    // safety check
    if (!stream || stream.size === 0) {
      return null;
    }

    // we might need up to 19 bytes to read PES header
    // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
    // usually only one merge is needed (and this is rare ...)
    while (data[0].length < 19 && data.length > 1) {
      data[0] = appendUint8Array(data[0], data[1]);
      data.splice(1, 1);
    }
    // retrieve PTS/DTS from first fragment
    frag = data[0];
    const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
    if (pesPrefix === 1) {
      pesLen = (frag[4] << 8) + frag[5];
      // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
      // minus 6 : PES header size
      if (pesLen && pesLen > stream.size - 6) {
        return null;
      }
      const pesFlags = frag[7];
      if (pesFlags & 0xc0) {
        /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
            as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
            as Bitwise operators treat their operands as a sequence of 32 bits */
        pesPts = (frag[9] & 0x0e) * 536870912 +
        // 1 << 29
        (frag[10] & 0xff) * 4194304 +
        // 1 << 22
        (frag[11] & 0xfe) * 16384 +
        // 1 << 14
        (frag[12] & 0xff) * 128 +
        // 1 << 7
        (frag[13] & 0xfe) / 2;
        if (pesFlags & 0x40) {
          pesDts = (frag[14] & 0x0e) * 536870912 +
          // 1 << 29
          (frag[15] & 0xff) * 4194304 +
          // 1 << 22
          (frag[16] & 0xfe) * 16384 +
          // 1 << 14
          (frag[17] & 0xff) * 128 +
          // 1 << 7
          (frag[18] & 0xfe) / 2;
          if (pesPts - pesDts > 60 * 90000) {
            logger.warn(`${Math.round((pesPts - pesDts) / 90000)}s delta between PTS and DTS, align them`);
            pesPts = pesDts;
          }
        } else {
          pesDts = pesPts;
        }
      }
      pesHdrLen = frag[8];
      // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
      let payloadStartOffset = pesHdrLen + 9;
      if (stream.size <= payloadStartOffset) {
        return null;
      }
      stream.size -= payloadStartOffset;
      // reassemble PES packet
      const pesData = new Uint8Array(stream.size);
      for (let j = 0, dataLen = data.length; j < dataLen; j++) {
        frag = data[j];
        let len = frag.byteLength;
        if (payloadStartOffset) {
          if (payloadStartOffset > len) {
            // trim full frag if PES header bigger than frag
            payloadStartOffset -= len;
            continue;
          } else {
            // trim partial frag if PES header smaller than frag
            frag = frag.subarray(payloadStartOffset);
            len -= payloadStartOffset;
            payloadStartOffset = 0;
          }
        }
        pesData.set(frag, i);
        i += len;
      }
      if (pesLen) {
        // payload size : remove PES header + PES extension
        pesLen -= pesHdrLen + 3;
      }
      return {
        data: pesData,
        pts: pesPts,
        dts: pesDts,
        len: pesLen
      };
    }
    return null;
  }

  /**
   * MP3 demuxer
   */
  class MP3Demuxer extends BaseAudioDemuxer {
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
      this._audioTrack = {
        container: 'audio/mpeg',
        type: 'audio',
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: 'mp3',
        samples: [],
        manifestCodec: audioCodec,
        duration: trackDuration,
        inputTimeScale: 90000,
        dropped: 0
      };
    }
    static probe(data) {
      if (!data) {
        return false;
      }

      // check if data contains ID3 timestamp and MPEG sync word
      // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
      // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
      // More info http://www.mp3-tech.org/programmer/frame_header.html
      const id3Data = getID3Data(data, 0);
      let offset = (id3Data == null ? void 0 : id3Data.length) || 0;

      // Check for ac-3|ec-3 sync bytes and return false if present
      if (id3Data && data[offset] === 0x0b && data[offset + 1] === 0x77 && getTimeStamp(id3Data) !== undefined &&
      // check the bsid to confirm ac-3 or ec-3 (not mp3)
      getAudioBSID(data, offset) <= 16) {
        return false;
      }
      for (let length = data.length; offset < length; offset++) {
        if (probe(data, offset)) {
          logger.log('MPEG Audio sync word found !');
          return true;
        }
      }
      return false;
    }
    canParse(data, offset) {
      return canParse(data, offset);
    }
    appendFrame(track, data, offset) {
      if (this.basePTS === null) {
        return;
      }
      return appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);
    }
  }

  /**
   *  AAC helper
   */

  class AAC {
    static getSilentFrame(codec, channelCount) {
      switch (codec) {
        case 'mp4a.40.2':
          if (channelCount === 1) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
          } else if (channelCount === 2) {
            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
          } else if (channelCount === 3) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
          } else if (channelCount === 4) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
          } else if (channelCount === 5) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
          } else if (channelCount === 6) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
          }
          break;
        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
        default:
          if (channelCount === 1) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 2) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 3) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          }
          break;
      }
      return undefined;
    }
  }

  /**
   * Generate MP4 Box
   */

  const UINT32_MAX = Math.pow(2, 32) - 1;
  class MP4 {
    static init() {
      MP4.types = {
        avc1: [],
        // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        '.mp3': [],
        dac3: [],
        'ac-3': [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };
      let i;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }
      const videoHdlr = new Uint8Array([0x00,
      // version 0
      0x00, 0x00, 0x00,
      // flags
      0x00, 0x00, 0x00, 0x00,
      // pre_defined
      0x76, 0x69, 0x64, 0x65,
      // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00,
      // reserved
      0x00, 0x00, 0x00, 0x00,
      // reserved
      0x00, 0x00, 0x00, 0x00,
      // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);
      const audioHdlr = new Uint8Array([0x00,
      // version 0
      0x00, 0x00, 0x00,
      // flags
      0x00, 0x00, 0x00, 0x00,
      // pre_defined
      0x73, 0x6f, 0x75, 0x6e,
      // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00,
      // reserved
      0x00, 0x00, 0x00, 0x00,
      // reserved
      0x00, 0x00, 0x00, 0x00,
      // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);
      MP4.HDLR_TYPES = {
        video: videoHdlr,
        audio: audioHdlr
      };
      const dref = new Uint8Array([0x00,
      // version 0
      0x00, 0x00, 0x00,
      // flags
      0x00, 0x00, 0x00, 0x01,
      // entry_count
      0x00, 0x00, 0x00, 0x0c,
      // entry_size
      0x75, 0x72, 0x6c, 0x20,
      // 'url' type
      0x00,
      // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);
      const stco = new Uint8Array([0x00,
      // version
      0x00, 0x00, 0x00,
      // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);
      MP4.STTS = MP4.STSC = MP4.STCO = stco;
      MP4.STSZ = new Uint8Array([0x00,
      // version
      0x00, 0x00, 0x00,
      // flags
      0x00, 0x00, 0x00, 0x00,
      // sample_size
      0x00, 0x00, 0x00, 0x00 // sample_count
      ]);
      MP4.VMHD = new Uint8Array([0x00,
      // version
      0x00, 0x00, 0x01,
      // flags
      0x00, 0x00,
      // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00,
      // version
      0x00, 0x00, 0x00,
      // flags
      0x00, 0x00,
      // balance
      0x00, 0x00 // reserved
      ]);
      MP4.STSD = new Uint8Array([0x00,
      // version 0
      0x00, 0x00, 0x00,
      // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      const minorVersion = new Uint8Array([0, 0, 0, 1]);
      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
    static box(type, ...payload) {
      let size = 8;
      let i = payload.length;
      const len = i;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }
      const result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
    static hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
    static mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
    static mdhd(timescale, duration) {
      duration *= timescale;
      const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,
      // version 1
      0x00, 0x00, 0x00,
      // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
      // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
      // modification_time
      timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,
      // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,
      // 'und' language (undetermined)
      0x00, 0x00]));
    }
    static mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
    static mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,
      // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number
      ]));
    }
    static minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
    static moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    static moov(tracks) {
      let i = tracks.length;
      const boxes = [];
      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }
      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
    static mvex(tracks) {
      let i = tracks.length;
      const boxes = [];
      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }
      return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);
    }
    static mvhd(timescale, duration) {
      duration *= timescale;
      const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      const bytes = new Uint8Array([0x01,
      // version 1
      0x00, 0x00, 0x00,
      // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
      // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
      // modification_time
      timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,
      // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,
      // 1.0 rate
      0x01, 0x00,
      // 1.0 volume
      0x00, 0x00,
      // reserved
      0x00, 0x00, 0x00, 0x00,
      // reserved
      0x00, 0x00, 0x00, 0x00,
      // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
      // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
    static sdtp(track) {
      const samples = track.samples || [];
      const bytes = new Uint8Array(4 + samples.length);
      let i;
      let flags;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }
      return MP4.box(MP4.types.sdtp, bytes);
    }
    static stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
    static avc1(track) {
      let sps = [];
      let pps = [];
      let i;
      let data;
      let len;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xff);
        sps.push(len & 0xff);

        // SPS
        sps = sps.concat(Array.prototype.slice.call(data));
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xff);
        pps.push(len & 0xff);
        pps = pps.concat(Array.prototype.slice.call(data));
      }
      const avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,
      // version
      sps[3],
      // profile
      sps[4],
      // profile compat
      sps[5],
      // level
      0xfc | 3,
      // lengthSizeMinusOne, hard-coded to 4 bytes
      0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))); // "PPS"
      const width = track.width;
      const height = track.height;
      const hSpacing = track.pixelRatio[0];
      const vSpacing = track.pixelRatio[1];
      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,
      // reserved
      0x00, 0x00, 0x00,
      // reserved
      0x00, 0x01,
      // data_reference_index
      0x00, 0x00,
      // pre_defined
      0x00, 0x00,
      // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // pre_defined
      width >> 8 & 0xff, width & 0xff,
      // width
      height >> 8 & 0xff, height & 0xff,
      // height
      0x00, 0x48, 0x00, 0x00,
      // horizresolution
      0x00, 0x48, 0x00, 0x00,
      // vertresolution
      0x00, 0x00, 0x00, 0x00,
      // reserved
      0x00, 0x01,
      // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6c,
      // dailymotion/hls.js
      0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // compressorname
      0x00, 0x18,
      // depth = 24
      0x11, 0x11]),
      // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,
      // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0,
      // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])),
      // avgBitrate
      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,
      // hSpacing
      hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,
      // vSpacing
      vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));
    }
    static esds(track) {
      const configlen = track.config.length;
      return new Uint8Array([0x00,
      // version 0
      0x00, 0x00, 0x00,
      // flags

      0x03,
      // descriptor_type
      0x17 + configlen,
      // length
      0x00, 0x01,
      // es_id
      0x00,
      // stream_priority

      0x04,
      // descriptor_type
      0x0f + configlen,
      // length
      0x40,
      // codec : mpeg4_audio
      0x15,
      // stream_type
      0x00, 0x00, 0x00,
      // buffer_size
      0x00, 0x00, 0x00, 0x00,
      // maxBitrate
      0x00, 0x00, 0x00, 0x00,
      // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
    static audioStsd(track) {
      const samplerate = track.samplerate;
      return new Uint8Array([0x00, 0x00, 0x00,
      // reserved
      0x00, 0x00, 0x00,
      // reserved
      0x00, 0x01,
      // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // reserved
      0x00, track.channelCount,
      // channelcount
      0x00, 0x10,
      // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00,
      // reserved2
      samplerate >> 8 & 0xff, samplerate & 0xff,
      //
      0x00, 0x00]);
    }
    static mp4a(track) {
      return MP4.box(MP4.types.mp4a, MP4.audioStsd(track), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
    static mp3(track) {
      return MP4.box(MP4.types['.mp3'], MP4.audioStsd(track));
    }
    static ac3(track) {
      return MP4.box(MP4.types['ac-3'], MP4.audioStsd(track), MP4.box(MP4.types.dac3, track.config));
    }
    static stsd(track) {
      if (track.type === 'audio') {
        if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {
          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
        }
        if (track.segmentCodec === 'ac3') {
          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));
        }
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
    static tkhd(track) {
      const id = track.id;
      const duration = track.duration * track.timescale;
      const width = track.width;
      const height = track.height;
      const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,
      // version 1
      0x00, 0x00, 0x07,
      // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
      // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
      // modification_time
      id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,
      // track_ID
      0x00, 0x00, 0x00, 0x00,
      // reserved
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // reserved
      0x00, 0x00,
      // layer
      0x00, 0x00,
      // alternate_group
      0x00, 0x00,
      // non-audio track volume
      0x00, 0x00,
      // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
      // transformation: unity matrix
      width >> 8 & 0xff, width & 0xff, 0x00, 0x00,
      // width
      height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height
      ]));
    }
    static traf(track, baseMediaDecodeTime) {
      const sampleDependencyTable = MP4.sdtp(track);
      const id = track.id;
      const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
      const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,
      // version 0
      0x00, 0x00, 0x00,
      // flags
      id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID
      ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,
      // version 1
      0x00, 0x00, 0x00,
      // flags
      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +
      // tfhd
      20 +
      // tfdt
      8 +
      // traf header
      16 +
      // mfhd
      8 +
      // moof header
      8),
      // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track a track definition
     */
    static trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
    static trex(track) {
      const id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00,
      // version 0
      0x00, 0x00, 0x00,
      // flags
      id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,
      // track_ID
      0x00, 0x00, 0x00, 0x01,
      // default_sample_description_index
      0x00, 0x00, 0x00, 0x00,
      // default_sample_duration
      0x00, 0x00, 0x00, 0x00,
      // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
    static trun(track, offset) {
      const samples = track.samples || [];
      const len = samples.length;
      const arraylen = 12 + 16 * len;
      const array = new Uint8Array(arraylen);
      let i;
      let sample;
      let duration;
      let size;
      let flags;
      let cts;
      offset += 8 + arraylen;
      array.set([track.type === 'video' ? 0x01 : 0x00,
      // version 1 for video with signed-int sample_composition_time_offset
      0x00, 0x0f, 0x01,
      // flags
      len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,
      // sample_count
      offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,
        // sample_duration
        size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,
        // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,
        // sample_flags
        cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
    static initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }
      const movie = MP4.moov(tracks);
      const result = appendUint8Array(MP4.FTYP, movie);
      return result;
    }
  }
  MP4.types = void 0;
  MP4.HDLR_TYPES = void 0;
  MP4.STTS = void 0;
  MP4.STSC = void 0;
  MP4.STCO = void 0;
  MP4.STSZ = void 0;
  MP4.VMHD = void 0;
  MP4.SMHD = void 0;
  MP4.STSD = void 0;
  MP4.FTYP = void 0;
  MP4.DINF = void 0;

  const MPEG_TS_CLOCK_FREQ_HZ = 90000;
  function toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {
    const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`
    return round ? Math.round(result) : result;
  }
  function toTimescaleFromScale(baseTime, destScale, srcScale = 1, round = false) {
    return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);
  }
  function toMsFromMpegTsClock(baseTime, round = false) {
    return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);
  }
  function toMpegTsClockFromTimescale(baseTime, srcScale = 1) {
    return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);
  }

  const MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds
  const AAC_SAMPLES_PER_FRAME = 1024;
  const MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;
  const AC3_SAMPLES_PER_FRAME = 1536;
  let chromeVersion = null;
  let safariWebkitVersion = null;
  class MP4Remuxer {
    constructor(observer, config, typeSupported, vendor = '') {
      this.observer = void 0;
      this.config = void 0;
      this.typeSupported = void 0;
      this.ISGenerated = false;
      this._initPTS = null;
      this._initDTS = null;
      this.nextAvcDts = null;
      this.nextAudioPts = null;
      this.videoSampleDuration = null;
      this.isAudioContiguous = false;
      this.isVideoContiguous = false;
      this.videoTrackConfig = void 0;
      this.observer = observer;
      this.config = config;
      this.typeSupported = typeSupported;
      this.ISGenerated = false;
      if (chromeVersion === null) {
        const userAgent = navigator.userAgent || '';
        const result = userAgent.match(/Chrome\/(\d+)/i);
        chromeVersion = result ? parseInt(result[1]) : 0;
      }
      if (safariWebkitVersion === null) {
        const result = navigator.userAgent.match(/Safari\/(\d+)/i);
        safariWebkitVersion = result ? parseInt(result[1]) : 0;
      }
    }
    destroy() {
      // @ts-ignore
      this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
    }
    resetTimeStamp(defaultTimeStamp) {
      logger.log('[mp4-remuxer]: initPTS & initDTS reset');
      this._initPTS = this._initDTS = defaultTimeStamp;
    }
    resetNextTimestamp() {
      logger.log('[mp4-remuxer]: reset next timestamp');
      this.isVideoContiguous = false;
      this.isAudioContiguous = false;
    }
    resetInitSegment() {
      logger.log('[mp4-remuxer]: ISGenerated flag reset');
      this.ISGenerated = false;
      this.videoTrackConfig = undefined;
    }
    getVideoStartPts(videoSamples) {
      let rolloverDetected = false;
      const startPTS = videoSamples.reduce((minPTS, sample) => {
        const delta = sample.pts - minPTS;
        if (delta < -4294967296) {
          // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation
          rolloverDetected = true;
          return normalizePts(minPTS, sample.pts);
        } else if (delta > 0) {
          return minPTS;
        } else {
          return sample.pts;
        }
      }, videoSamples[0].pts);
      if (rolloverDetected) {
        logger.debug('PTS rollover detected');
      }
      return startPTS;
    }
    remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {
      let video;
      let audio;
      let initSegment;
      let text;
      let id3;
      let independent;
      let audioTimeOffset = timeOffset;
      let videoTimeOffset = timeOffset;

      // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.
      // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the "pid"
      // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.
      // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),
      // then we can remux one track without waiting for the other.
      const hasAudio = audioTrack.pid > -1;
      const hasVideo = videoTrack.pid > -1;
      const length = videoTrack.samples.length;
      const enoughAudioSamples = audioTrack.samples.length > 0;
      const enoughVideoSamples = flush && length > 0 || length > 1;
      const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;
      if (canRemuxAvc) {
        if (this.ISGenerated) {
          var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;
          const config = this.videoTrackConfig;
          if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? void 0 : _config$pixelRatio2[1]))) {
            this.resetInitSegment();
          }
        } else {
          initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
        }
        const isVideoContiguous = this.isVideoContiguous;
        let firstKeyFrameIndex = -1;
        let firstKeyFramePTS;
        if (enoughVideoSamples) {
          firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);
          if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {
            independent = true;
            if (firstKeyFrameIndex > 0) {
              logger.warn(`[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);
              const startPTS = this.getVideoStartPts(videoTrack.samples);
              videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);
              videoTrack.dropped += firstKeyFrameIndex;
              videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;
              firstKeyFramePTS = videoTimeOffset;
            } else if (firstKeyFrameIndex === -1) {
              logger.warn(`[mp4-remuxer]: No keyframe found out of ${length} video samples`);
              independent = false;
            }
          }
        }
        if (this.ISGenerated) {
          if (enoughAudioSamples && enoughVideoSamples) {
            // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)
            // if first audio DTS is not aligned with first video DTS then we need to take that into account
            // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small
            // drift between audio and video streams
            const startPTS = this.getVideoStartPts(videoTrack.samples);
            const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;
            const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
            audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
            videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
          }

          // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.
          if (enoughAudioSamples) {
            // if initSegment was generated without audio samples, regenerate it again
            if (!audioTrack.samplerate) {
              logger.warn('[mp4-remuxer]: regenerate InitSegment as audio detected');
              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
            }
            audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);
            if (enoughVideoSamples) {
              const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;
              // if initSegment was generated without video samples, regenerate it again
              if (!videoTrack.inputTimeScale) {
                logger.warn('[mp4-remuxer]: regenerate InitSegment as video detected');
                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
              }
              video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);
            }
          } else if (enoughVideoSamples) {
            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);
          }
          if (video) {
            video.firstKeyFrame = firstKeyFrameIndex;
            video.independent = firstKeyFrameIndex !== -1;
            video.firstKeyFramePTS = firstKeyFramePTS;
          }
        }
      }

      // Allow ID3 and text to remux, even if more audio/video samples are required
      if (this.ISGenerated && this._initPTS && this._initDTS) {
        if (id3Track.samples.length) {
          id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);
        }
        if (textTrack.samples.length) {
          text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);
        }
      }
      return {
        audio,
        video,
        initSegment,
        independent,
        text,
        id3
      };
    }
    generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {
      const audioSamples = audioTrack.samples;
      const videoSamples = videoTrack.samples;
      const typeSupported = this.typeSupported;
      const tracks = {};
      const _initPTS = this._initPTS;
      let computePTSDTS = !_initPTS || accurateTimeOffset;
      let container = 'audio/mp4';
      let initPTS;
      let initDTS;
      let timescale;
      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }
      if (audioTrack.config && audioSamples.length) {
        // let's use audio sampling rate as MP4 time scale.
        // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
        // using audio sampling rate here helps having an integer MP4 frame duration
        // this avoids potential rounding issue and AV sync issue
        audioTrack.timescale = audioTrack.samplerate;
        switch (audioTrack.segmentCodec) {
          case 'mp3':
            if (typeSupported.mpeg) {
              // Chrome and Safari
              container = 'audio/mpeg';
              audioTrack.codec = '';
            } else if (typeSupported.mp3) {
              // Firefox
              audioTrack.codec = 'mp3';
            }
            break;
          case 'ac3':
            audioTrack.codec = 'ac-3';
            break;
        }
        tracks.audio = {
          id: 'audio',
          container: container,
          codec: audioTrack.codec,
          initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          timescale = audioTrack.inputTimeScale;
          if (!_initPTS || timescale !== _initPTS.timescale) {
            // remember first PTS of this demuxing context. for audio, PTS = DTS
            initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);
          } else {
            computePTSDTS = false;
          }
        }
      }
      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        // let's use input time scale as MP4 video timescale
        // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
        videoTrack.timescale = videoTrack.inputTimeScale;
        tracks.video = {
          id: 'main',
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: MP4.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          timescale = videoTrack.inputTimeScale;
          if (!_initPTS || timescale !== _initPTS.timescale) {
            const startPTS = this.getVideoStartPts(videoSamples);
            const startOffset = Math.round(timescale * timeOffset);
            initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);
            initPTS = Math.min(initPTS, startPTS - startOffset);
          } else {
            computePTSDTS = false;
          }
        }
        this.videoTrackConfig = {
          width: videoTrack.width,
          height: videoTrack.height,
          pixelRatio: videoTrack.pixelRatio
        };
      }
      if (Object.keys(tracks).length) {
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = {
            baseTime: initPTS,
            timescale: timescale
          };
          this._initDTS = {
            baseTime: initDTS,
            timescale: timescale
          };
        } else {
          initPTS = timescale = undefined;
        }
        return {
          tracks,
          initPTS,
          timescale
        };
      }
    }
    remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
      const timeScale = track.inputTimeScale;
      const inputSamples = track.samples;
      const outputSamples = [];
      const nbSamples = inputSamples.length;
      const initPTS = this._initPTS;
      let nextAvcDts = this.nextAvcDts;
      let offset = 8;
      let mp4SampleDuration = this.videoSampleDuration;
      let firstDTS;
      let lastDTS;
      let minPTS = Number.POSITIVE_INFINITY;
      let maxPTS = Number.NEGATIVE_INFINITY;
      let sortSamples = false;

      // if parsed fragment is contiguous with last one, let's use last DTS value as reference
      if (!contiguous || nextAvcDts === null) {
        const pts = timeOffset * timeScale;
        const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);
        if (chromeVersion && nextAvcDts !== null && Math.abs(pts - cts - nextAvcDts) < 15000) {
          // treat as contigous to adjust samples that would otherwise produce video buffer gaps in Chrome
          contiguous = true;
        } else {
          // if not contiguous, let's use target timeOffset
          nextAvcDts = pts - cts;
        }
      }

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      const initTime = initPTS.baseTime * timeScale / initPTS.timescale;
      for (let i = 0; i < nbSamples; i++) {
        const sample = inputSamples[i];
        sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);
        sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);
        if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
          sortSamples = true;
        }
      }

      // sort video samples by DTS then PTS then demux id order
      if (sortSamples) {
        inputSamples.sort(function (a, b) {
          const deltadts = a.dts - b.dts;
          const deltapts = a.pts - b.pts;
          return deltadts || deltapts;
        });
      }

      // Get first/last DTS
      firstDTS = inputSamples[0].dts;
      lastDTS = inputSamples[inputSamples.length - 1].dts;

      // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      const inputDuration = lastDTS - firstDTS;
      const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;

      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)
        const delta = firstDTS - nextAvcDts;
        const foundHole = delta > averageSampleDuration;
        const foundOverlap = delta < -1;
        if (foundHole || foundOverlap) {
          if (foundHole) {
            logger.warn(`AVC: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected at ${timeOffset.toFixed(3)}`);
          } else {
            logger.warn(`AVC: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected at ${timeOffset.toFixed(3)}`);
          }
          if (!foundOverlap || nextAvcDts >= inputSamples[0].pts || chromeVersion) {
            firstDTS = nextAvcDts;
            const firstPTS = inputSamples[0].pts - delta;
            if (foundHole) {
              inputSamples[0].dts = firstDTS;
              inputSamples[0].pts = firstPTS;
            } else {
              for (let i = 0; i < inputSamples.length; i++) {
                if (inputSamples[i].dts > firstPTS) {
                  break;
                }
                inputSamples[i].dts -= delta;
                inputSamples[i].pts -= delta;
              }
            }
            logger.log(`Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);
          }
        }
      }
      firstDTS = Math.max(0, firstDTS);
      let nbNalu = 0;
      let naluLen = 0;
      let dtsStep = firstDTS;
      for (let i = 0; i < nbSamples; i++) {
        // compute total/avc sample length and nb of NAL units
        const sample = inputSamples[i];
        const units = sample.units;
        const nbUnits = units.length;
        let sampleLen = 0;
        for (let j = 0; j < nbUnits; j++) {
          sampleLen += units[j].data.length;
        }
        naluLen += sampleLen;
        nbNalu += nbUnits;
        sample.length = sampleLen;

        // ensure sample monotonic DTS
        if (sample.dts < dtsStep) {
          sample.dts = dtsStep;
          dtsStep += averageSampleDuration / 4 | 0 || 1;
        } else {
          dtsStep = sample.dts;
        }
        minPTS = Math.min(sample.pts, minPTS);
        maxPTS = Math.max(sample.pts, maxPTS);
      }
      lastDTS = inputSamples[nbSamples - 1].dts;

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      const mdatSize = naluLen + 4 * nbNalu + 8;
      let mdat;
      try {
        mdat = new Uint8Array(mdatSize);
      } catch (err) {
        this.observer.emit(Events$1.ERROR, Events$1.ERROR, {
          type: ErrorTypes.MUX_ERROR,
          details: ErrorDetails.REMUX_ALLOC_ERROR,
          fatal: false,
          error: err,
          bytes: mdatSize,
          reason: `fail allocating video mdat ${mdatSize}`
        });
        return;
      }
      const view = new DataView(mdat.buffer);
      view.setUint32(0, mdatSize);
      mdat.set(MP4.types.mdat, 4);
      let stretchedLastFrame = false;
      let minDtsDelta = Number.POSITIVE_INFINITY;
      let minPtsDelta = Number.POSITIVE_INFINITY;
      let maxDtsDelta = Number.NEGATIVE_INFINITY;
      let maxPtsDelta = Number.NEGATIVE_INFINITY;
      for (let i = 0; i < nbSamples; i++) {
        const VideoSample = inputSamples[i];
        const VideoSampleUnits = VideoSample.units;
        let mp4SampleLength = 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        for (let j = 0, nbUnits = VideoSampleUnits.length; j < nbUnits; j++) {
          const unit = VideoSampleUnits[j];
          const unitData = unit.data;
          const unitDataLen = unit.data.byteLength;
          view.setUint32(offset, unitDataLen);
          offset += 4;
          mdat.set(unitData, offset);
          offset += unitDataLen;
          mp4SampleLength += 4 + unitDataLen;
        }

        // expected sample duration is the Decoding Timestamp diff of consecutive samples
        let ptsDelta;
        if (i < nbSamples - 1) {
          mp4SampleDuration = inputSamples[i + 1].dts - VideoSample.dts;
          ptsDelta = inputSamples[i + 1].pts - VideoSample.pts;
        } else {
          const config = this.config;
          const lastFrameDuration = i > 0 ? VideoSample.dts - inputSamples[i - 1].dts : averageSampleDuration;
          ptsDelta = i > 0 ? VideoSample.pts - inputSamples[i - 1].pts : averageSampleDuration;
          if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {
            // In some cases, a segment's audio track duration may exceed the video track duration.
            // Since we've already remuxed audio, and we know how long the audio track is, we look to
            // see if the delta to the next segment is longer than maxBufferHole.
            // If so, playback would potentially get stuck, so we artificially inflate
            // the duration of the last frame to minimize any potential gap between segments.
            const gapTolerance = Math.floor(config.maxBufferHole * timeScale);
            const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - VideoSample.pts;
            if (deltaToFrameEnd > gapTolerance) {
              // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
              // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.
              mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
              if (mp4SampleDuration < 0) {
                mp4SampleDuration = lastFrameDuration;
              } else {
                stretchedLastFrame = true;
              }
              logger.log(`[mp4-remuxer]: It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          } else {
            mp4SampleDuration = lastFrameDuration;
          }
        }
        const compositionTimeOffset = Math.round(VideoSample.pts - VideoSample.dts);
        minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);
        maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);
        minPtsDelta = Math.min(minPtsDelta, ptsDelta);
        maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);
        outputSamples.push(new Mp4Sample(VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));
      }
      if (outputSamples.length) {
        if (chromeVersion) {
          if (chromeVersion < 70) {
            // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue
            // https://code.google.com/p/chromium/issues/detail?id=229412
            const flags = outputSamples[0].flags;
            flags.dependsOn = 2;
            flags.isNonSync = 0;
          }
        } else if (safariWebkitVersion) {
          // Fix for "CNN special report, with CC" in test-streams (Safari browser only)
          // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.
          if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {
            logger.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');
            let dts = firstDTS;
            for (let i = 0, len = outputSamples.length; i < len; i++) {
              const nextDts = dts + outputSamples[i].duration;
              const pts = dts + outputSamples[i].cts;
              if (i < len - 1) {
                const nextPts = nextDts + outputSamples[i + 1].cts;
                outputSamples[i].duration = nextPts - pts;
              } else {
                outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;
              }
              outputSamples[i].cts = 0;
              dts = nextDts;
            }
          }
        }
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;
      this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;
      this.videoSampleDuration = mp4SampleDuration;
      this.isVideoContiguous = true;
      const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends$2({}, track, {
        samples: outputSamples
      }));
      const type = 'video';
      const data = {
        data1: moof,
        data2: mdat,
        startPTS: minPTS / timeScale,
        endPTS: (maxPTS + mp4SampleDuration) / timeScale,
        startDTS: firstDTS / timeScale,
        endDTS: nextAvcDts / timeScale,
        type,
        hasAudio: false,
        hasVideo: true,
        nb: outputSamples.length,
        dropped: track.dropped
      };
      track.samples = [];
      track.dropped = 0;
      return data;
    }
    getSamplesPerFrame(track) {
      switch (track.segmentCodec) {
        case 'mp3':
          return MPEG_AUDIO_SAMPLE_PER_FRAME;
        case 'ac3':
          return AC3_SAMPLES_PER_FRAME;
        default:
          return AAC_SAMPLES_PER_FRAME;
      }
    }
    remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {
      const inputTimeScale = track.inputTimeScale;
      const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
      const scaleFactor = inputTimeScale / mp4timeScale;
      const mp4SampleDuration = this.getSamplesPerFrame(track);
      const inputSampleDuration = mp4SampleDuration * scaleFactor;
      const initPTS = this._initPTS;
      const rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;
      const outputSamples = [];
      const alignedWithVideo = videoTimeOffset !== undefined;
      let inputSamples = track.samples;
      let offset = rawMPEG ? 0 : 8;
      let nextAudioPts = this.nextAudioPts || -1;

      // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);

      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with
      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
      //  - less than 20 audio frames distance
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      // this helps ensuring audio continuity
      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
      const timeOffsetMpegTS = timeOffset * inputTimeScale;
      const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;
      this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);

      // compute normalized PTS
      inputSamples.forEach(function (sample) {
        sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);
      });
      if (!contiguous || nextAudioPts < 0) {
        // filter out sample with negative PTS that are not playable anyway
        // if we don't remove these negative samples, they will shift all audio samples forward.
        // leading to audio overlap between current / next fragment
        inputSamples = inputSamples.filter(sample => sample.pts >= 0);

        // in case all samples have negative PTS, and have been filtered out, return now
        if (!inputSamples.length) {
          return;
        }
        if (videoTimeOffset === 0) {
          // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence
          nextAudioPts = 0;
        } else if (accurateTimeOffset && !alignedWithVideo) {
          // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS
          nextAudioPts = Math.max(0, timeOffsetMpegTS);
        } else {
          // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS
          nextAudioPts = inputSamples[0].pts;
        }
      }

      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.

      if (track.segmentCodec === 'aac') {
        const maxAudioFramesDrift = this.config.maxAudioFramesDrift;
        for (let i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {
          // First, let's see how far off this frame is from where we expect it to be
          const sample = inputSamples[i];
          const pts = sample.pts;
          const delta = pts - nextPts;
          const duration = Math.abs(1000 * delta / inputTimeScale);

          // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync
          if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {
            if (i === 0) {
              logger.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1000 * delta / inputTimeScale)} ms.`);
              this.nextAudioPts = nextAudioPts = nextPts = pts;
            }
          } // eslint-disable-line brace-style

          // Insert missing frames if:
          // 1: We're more than maxAudioFramesDrift frame away
          // 2: Not more than MAX_SILENT_FRAME_DURATION away
          // 3: currentTime (aka nextPtsNorm) is not 0
          // 4: remuxing with video (videoTimeOffset !== undefined)
          else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {
            let missing = Math.round(delta / inputSampleDuration);
            // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from
            // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.
            nextPts = pts - missing * inputSampleDuration;
            if (nextPts < 0) {
              missing--;
              nextPts += inputSampleDuration;
            }
            if (i === 0) {
              this.nextAudioPts = nextAudioPts = nextPts;
            }
            logger.warn(`[mp4-remuxer]: Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(1000 * delta / inputTimeScale)} ms gap.`);
            for (let j = 0; j < missing; j++) {
              const newStamp = Math.max(nextPts, 0);
              let fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
              if (!fillFrame) {
                logger.log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');
                fillFrame = sample.unit.subarray();
              }
              inputSamples.splice(i, 0, {
                unit: fillFrame,
                pts: newStamp
              });
              nextPts += inputSampleDuration;
              i++;
            }
          }
          sample.pts = nextPts;
          nextPts += inputSampleDuration;
        }
      }
      let firstPTS = null;
      let lastPTS = null;
      let mdat;
      let mdatSize = 0;
      let sampleLength = inputSamples.length;
      while (sampleLength--) {
        mdatSize += inputSamples[sampleLength].unit.byteLength;
      }
      for (let j = 0, _nbSamples = inputSamples.length; j < _nbSamples; j++) {
        const audioSample = inputSamples[j];
        const unit = audioSample.unit;
        let pts = audioSample.pts;
        if (lastPTS !== null) {
          // If we have more than one sample, set the duration of the sample to the "real" duration; the PTS diff with
          // the previous sample
          const prevSample = outputSamples[j - 1];
          prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);
        } else {
          if (contiguous && track.segmentCodec === 'aac') {
            // set PTS/DTS to expected PTS/DTS
            pts = nextAudioPts;
          }
          // remember first PTS of our audioSamples
          firstPTS = pts;
          if (mdatSize > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */
            mdatSize += offset;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.emit(Events$1.ERROR, Events$1.ERROR, {
                type: ErrorTypes.MUX_ERROR,
                details: ErrorDetails.REMUX_ALLOC_ERROR,
                fatal: false,
                error: err,
                bytes: mdatSize,
                reason: `fail allocating audio mdat ${mdatSize}`
              });
              return;
            }
            if (!rawMPEG) {
              const view = new DataView(mdat.buffer);
              view.setUint32(0, mdatSize);
              mdat.set(MP4.types.mdat, 4);
            }
          } else {
            // no audio samples
            return;
          }
        }
        mdat.set(unit, offset);
        const unitLen = unit.byteLength;
        offset += unitLen;
        // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG
        // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration
        // becomes the PTS diff with the previous sample
        outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));
        lastPTS = pts;
      }

      // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones
      const nbSamples = outputSamples.length;
      if (!nbSamples) {
        return;
      }

      // The next audio sample PTS should be equal to last sample PTS + duration
      const lastSample = outputSamples[outputSamples.length - 1];
      this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;

      // Set the track samples from inputSamples to outputSamples before remuxing
      const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends$2({}, track, {
        samples: outputSamples
      }));

      // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared
      track.samples = [];
      const start = firstPTS / inputTimeScale;
      const end = nextAudioPts / inputTimeScale;
      const type = 'audio';
      const audioData = {
        data1: moof,
        data2: mdat,
        startPTS: start,
        endPTS: end,
        startDTS: start,
        endDTS: end,
        type,
        hasAudio: true,
        hasVideo: false,
        nb: nbSamples
      };
      this.isAudioContiguous = true;
      return audioData;
    }
    remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      const inputTimeScale = track.inputTimeScale;
      const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
      const scaleFactor = inputTimeScale / mp4timeScale;
      const nextAudioPts = this.nextAudioPts;
      // sync with video's timestamp
      const initDTS = this._initDTS;
      const init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;
      const startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;
      const endDTS = videoData.endDTS * inputTimeScale + init90kHz;
      // one sample's duration value
      const frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;
      // samples count of this segment's duration
      const nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);
      // silent frame
      const silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
      logger.warn('[mp4-remuxer]: remux empty Audio');
      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        logger.trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');
        return;
      }
      const samples = [];
      for (let i = 0; i < nbSamples; i++) {
        const stamp = startDTS + i * frameDuration;
        samples.push({
          unit: silentFrame,
          pts: stamp,
          dts: stamp
        });
      }
      track.samples = samples;
      return this.remuxAudio(track, timeOffset, contiguous, false);
    }
  }
  function normalizePts(value, reference) {
    let offset;
    if (reference === null) {
      return value;
    }
    if (reference < value) {
      // - 2^33
      offset = -8589934592;
    } else {
      // + 2^33
      offset = 8589934592;
    }
    /* PTS is 33bit (from 0 to 2^33 -1)
      if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
      PTS looping occured. fill the gap */
    while (Math.abs(value - reference) > 4294967296) {
      value += offset;
    }
    return value;
  }
  function findKeyframeIndex(samples) {
    for (let i = 0; i < samples.length; i++) {
      if (samples[i].key) {
        return i;
      }
    }
    return -1;
  }
  function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {
    const length = track.samples.length;
    if (!length) {
      return;
    }
    const inputTimeScale = track.inputTimeScale;
    for (let index = 0; index < length; index++) {
      const sample = track.samples[index];
      // setting id3 pts, dts to relative time
      // using this._initPTS and this._initDTS to calculate relative time
      sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
      sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
    }
    const samples = track.samples;
    track.samples = [];
    return {
      samples
    };
  }
  function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {
    const length = track.samples.length;
    if (!length) {
      return;
    }
    const inputTimeScale = track.inputTimeScale;
    for (let index = 0; index < length; index++) {
      const sample = track.samples[index];
      // setting text pts, dts to relative time
      // using this._initPTS and this._initDTS to calculate relative time
      sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
    }
    track.samples.sort((a, b) => a.pts - b.pts);
    const samples = track.samples;
    track.samples = [];
    return {
      samples
    };
  }
  class Mp4Sample {
    constructor(isKeyframe, duration, size, cts) {
      this.size = void 0;
      this.duration = void 0;
      this.cts = void 0;
      this.flags = void 0;
      this.duration = duration;
      this.size = size;
      this.cts = cts;
      this.flags = {
        isLeading: 0,
        isDependedOn: 0,
        hasRedundancy: 0,
        degradPrio: 0,
        dependsOn: isKeyframe ? 2 : 1,
        isNonSync: isKeyframe ? 0 : 1
      };
    }
  }

  class PassThroughRemuxer {
    constructor() {
      this.emitInitSegment = false;
      this.audioCodec = void 0;
      this.videoCodec = void 0;
      this.initData = void 0;
      this.initPTS = null;
      this.initTracks = void 0;
      this.lastEndTime = null;
    }
    destroy() {}
    resetTimeStamp(defaultInitPTS) {
      this.initPTS = defaultInitPTS;
      this.lastEndTime = null;
    }
    resetNextTimestamp() {
      this.lastEndTime = null;
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));
      this.emitInitSegment = true;
    }
    generateInitSegment(initSegment) {
      let {
        audioCodec,
        videoCodec
      } = this;
      if (!(initSegment != null && initSegment.byteLength)) {
        this.initTracks = undefined;
        this.initData = undefined;
        return;
      }
      const initData = this.initData = parseInitSegment(initSegment);

      // Get codec from initSegment or fallback to default
      if (initData.audio) {
        audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);
      }
      if (initData.video) {
        videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);
      }
      const tracks = {};
      if (initData.audio && initData.video) {
        tracks.audiovideo = {
          container: 'video/mp4',
          codec: audioCodec + ',' + videoCodec,
          initSegment,
          id: 'main'
        };
      } else if (initData.audio) {
        tracks.audio = {
          container: 'audio/mp4',
          codec: audioCodec,
          initSegment,
          id: 'audio'
        };
      } else if (initData.video) {
        tracks.video = {
          container: 'video/mp4',
          codec: videoCodec,
          initSegment,
          id: 'main'
        };
      } else {
        logger.warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');
      }
      this.initTracks = tracks;
    }
    remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {
      var _initData, _initData2;
      let {
        initPTS,
        lastEndTime
      } = this;
      const result = {
        audio: undefined,
        video: undefined,
        text: textTrack,
        id3: id3Track,
        initSegment: undefined
      };

      // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the
      // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update
      // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.
      if (!isFiniteNumber(lastEndTime)) {
        lastEndTime = this.lastEndTime = timeOffset || 0;
      }

      // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only
      // audio or video (or both); adding it to video was an arbitrary choice.
      const data = videoTrack.samples;
      if (!(data != null && data.length)) {
        return result;
      }
      const initSegment = {
        initPTS: undefined,
        timescale: 1
      };
      let initData = this.initData;
      if (!((_initData = initData) != null && _initData.length)) {
        this.generateInitSegment(data);
        initData = this.initData;
      }
      if (!((_initData2 = initData) != null && _initData2.length)) {
        // We can't remux if the initSegment could not be generated
        logger.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');
        return result;
      }
      if (this.emitInitSegment) {
        initSegment.tracks = this.initTracks;
        this.emitInitSegment = false;
      }
      const duration = getDuration(data, initData);
      const startDTS = getStartDTS(initData, data);
      const decodeTime = startDTS === null ? timeOffset : startDTS;
      if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {
        initSegment.initPTS = decodeTime - timeOffset;
        if (initPTS && initPTS.timescale === 1) {
          logger.warn(`Adjusting initPTS by ${initSegment.initPTS - initPTS.baseTime}`);
        }
        this.initPTS = initPTS = {
          baseTime: initSegment.initPTS,
          timescale: 1
        };
      }
      const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;
      const endTime = startTime + duration;
      offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);
      if (duration > 0) {
        this.lastEndTime = endTime;
      } else {
        logger.warn('Duration parsed from mp4 should be greater than zero');
        this.resetNextTimestamp();
      }
      const hasAudio = !!initData.audio;
      const hasVideo = !!initData.video;
      let type = '';
      if (hasAudio) {
        type += 'audio';
      }
      if (hasVideo) {
        type += 'video';
      }
      const track = {
        data1: data,
        startPTS: startTime,
        startDTS: startTime,
        endPTS: endTime,
        endDTS: endTime,
        type,
        hasAudio,
        hasVideo,
        nb: 1,
        dropped: 0
      };
      result.audio = track.type === 'audio' ? track : undefined;
      result.video = track.type !== 'audio' ? track : undefined;
      result.initSegment = initSegment;
      result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);
      if (textTrack.samples.length) {
        result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);
      }
      return result;
    }
  }
  function isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {
    if (initPTS === null) {
      return true;
    }
    // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second
    const minDuration = Math.max(duration, 1);
    const startTime = startDTS - initPTS.baseTime / initPTS.timescale;
    return Math.abs(startTime - timeOffset) > minDuration;
  }
  function getParsedTrackCodec(track, type) {
    const parsedCodec = track == null ? void 0 : track.codec;
    if (parsedCodec && parsedCodec.length > 4) {
      return parsedCodec;
    }
    if (type === ElementaryStreamTypes.AUDIO) {
      if (parsedCodec === 'ec-3' || parsedCodec === 'ac-3' || parsedCodec === 'alac') {
        return parsedCodec;
      }
      if (parsedCodec === 'fLaC' || parsedCodec === 'Opus') {
        // Opting not to get `preferManagedMediaSource` from player config for isSupported() check for simplicity
        const preferManagedMediaSource = false;
        return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);
      }
      const result = 'mp4a.40.5';
      logger.info(`Parsed audio codec "${parsedCodec}" or audio object type not handled. Using "${result}"`);
      return result;
    }
    // Provide defaults based on codec type
    // This allows for some playback of some fmp4 playlists without CODECS defined in manifest
    logger.warn(`Unhandled video codec "${parsedCodec}"`);
    if (parsedCodec === 'hvc1' || parsedCodec === 'hev1') {
      return 'hvc1.1.6.L120.90';
    }
    if (parsedCodec === 'av01') {
      return 'av01.0.04M.08';
    }
    return 'avc1.42e01e';
  }

  let now$1;
  // performance.now() not available on WebWorker, at least on Safari Desktop
  try {
    now$1 = self.performance.now.bind(self.performance);
  } catch (err) {
    logger.debug('Unable to use Performance API on this environment');
    now$1 = optionalSelf == null ? void 0 : optionalSelf.Date.now;
  }
  const muxConfig = [{
    demux: MP4Demuxer,
    remux: PassThroughRemuxer
  }, {
    demux: TSDemuxer,
    remux: MP4Remuxer
  }, {
    demux: AACDemuxer,
    remux: MP4Remuxer
  }, {
    demux: MP3Demuxer,
    remux: MP4Remuxer
  }];
  {
    muxConfig.splice(2, 0, {
      demux: AC3Demuxer,
      remux: MP4Remuxer
    });
  }
  class Transmuxer {
    constructor(observer, typeSupported, config, vendor, id) {
      this.async = false;
      this.observer = void 0;
      this.typeSupported = void 0;
      this.config = void 0;
      this.vendor = void 0;
      this.id = void 0;
      this.demuxer = void 0;
      this.remuxer = void 0;
      this.decrypter = void 0;
      this.probe = void 0;
      this.decryptionPromise = null;
      this.transmuxConfig = void 0;
      this.currentTransmuxState = void 0;
      this.observer = observer;
      this.typeSupported = typeSupported;
      this.config = config;
      this.vendor = vendor;
      this.id = id;
    }
    configure(transmuxConfig) {
      this.transmuxConfig = transmuxConfig;
      if (this.decrypter) {
        this.decrypter.reset();
      }
    }
    push(data, decryptdata, chunkMeta, state) {
      const stats = chunkMeta.transmuxing;
      stats.executeStart = now$1();
      let uintData = new Uint8Array(data);
      const {
        currentTransmuxState,
        transmuxConfig
      } = this;
      if (state) {
        this.currentTransmuxState = state;
      }
      const {
        contiguous,
        discontinuity,
        trackSwitch,
        accurateTimeOffset,
        timeOffset,
        initSegmentChange
      } = state || currentTransmuxState;
      const {
        audioCodec,
        videoCodec,
        defaultInitPts,
        duration,
        initSegmentData
      } = transmuxConfig;
      const keyData = getEncryptionType(uintData, decryptdata);
      if (keyData && keyData.method === 'AES-128') {
        const decrypter = this.getDecrypter();
        // Software decryption is synchronous; webCrypto is not
        if (decrypter.isSync()) {
          // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
          // data is handled in the flush() call
          let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);
          // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress
          const loadingParts = chunkMeta.part > -1;
          if (loadingParts) {
            decryptedData = decrypter.flush();
          }
          if (!decryptedData) {
            stats.executeEnd = now$1();
            return emptyResult(chunkMeta);
          }
          uintData = new Uint8Array(decryptedData);
        } else {
          this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(decryptedData => {
            // Calling push here is important; if flush() is called while this is still resolving, this ensures that
            // the decrypted data has been transmuxed
            const result = this.push(decryptedData, null, chunkMeta);
            this.decryptionPromise = null;
            return result;
          });
          return this.decryptionPromise;
        }
      }
      const resetMuxers = this.needsProbing(discontinuity, trackSwitch);
      if (resetMuxers) {
        const error = this.configureTransmuxer(uintData);
        if (error) {
          logger.warn(`[transmuxer] ${error.message}`);
          this.observer.emit(Events$1.ERROR, Events$1.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_PARSING_ERROR,
            fatal: false,
            error,
            reason: error.message
          });
          stats.executeEnd = now$1();
          return emptyResult(chunkMeta);
        }
      }
      if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {
        this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);
      }
      if (discontinuity || initSegmentChange || resetMuxers) {
        this.resetInitialTimestamp(defaultInitPts);
      }
      if (!contiguous) {
        this.resetContiguity();
      }
      const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);
      const currentState = this.currentTransmuxState;
      currentState.contiguous = true;
      currentState.discontinuity = false;
      currentState.trackSwitch = false;
      stats.executeEnd = now$1();
      return result;
    }

    // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)
    flush(chunkMeta) {
      const stats = chunkMeta.transmuxing;
      stats.executeStart = now$1();
      const {
        decrypter,
        currentTransmuxState,
        decryptionPromise
      } = this;
      if (decryptionPromise) {
        // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore
        // only flushing is required for async decryption
        return decryptionPromise.then(() => {
          return this.flush(chunkMeta);
        });
      }
      const transmuxResults = [];
      const {
        timeOffset
      } = currentTransmuxState;
      if (decrypter) {
        // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults
        // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,
        // or for progressive downloads with small segments)
        const decryptedData = decrypter.flush();
        if (decryptedData) {
          // Push always returns a TransmuxerResult if decryptdata is null
          transmuxResults.push(this.push(decryptedData, null, chunkMeta));
        }
      }
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        // If probing failed, then Hls.js has been given content its not able to handle
        stats.executeEnd = now$1();
        return [emptyResult(chunkMeta)];
      }
      const demuxResultOrPromise = demuxer.flush(timeOffset);
      if (isPromise$1(demuxResultOrPromise)) {
        // Decrypt final SAMPLE-AES samples
        return demuxResultOrPromise.then(demuxResult => {
          this.flushRemux(transmuxResults, demuxResult, chunkMeta);
          return transmuxResults;
        });
      }
      this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);
      return transmuxResults;
    }
    flushRemux(transmuxResults, demuxResult, chunkMeta) {
      const {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      } = demuxResult;
      const {
        accurateTimeOffset,
        timeOffset
      } = this.currentTransmuxState;
      logger.log(`[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : ''} of level ${chunkMeta.level}`);
      const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);
      transmuxResults.push({
        remuxResult,
        chunkMeta
      });
      chunkMeta.transmuxing.executeEnd = now$1();
    }
    resetInitialTimestamp(defaultInitPts) {
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        return;
      }
      demuxer.resetTimeStamp(defaultInitPts);
      remuxer.resetTimeStamp(defaultInitPts);
    }
    resetContiguity() {
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        return;
      }
      demuxer.resetContiguity();
      remuxer.resetNextTimestamp();
    }
    resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        return;
      }
      demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);
      remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);
    }
    destroy() {
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = undefined;
      }
      if (this.remuxer) {
        this.remuxer.destroy();
        this.remuxer = undefined;
      }
    }
    transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {
      let result;
      if (keyData && keyData.method === 'SAMPLE-AES') {
        result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);
      } else {
        result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);
      }
      return result;
    }
    transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {
      const {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);
      const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);
      return {
        remuxResult,
        chunkMeta
      };
    }
    transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {
      return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(demuxResult => {
        const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);
        return {
          remuxResult,
          chunkMeta
        };
      });
    }
    configureTransmuxer(data) {
      const {
        config,
        observer,
        typeSupported,
        vendor
      } = this;
      // probe for content type
      let mux;
      for (let i = 0, len = muxConfig.length; i < len; i++) {
        var _muxConfig$i$demux;
        if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data)) {
          mux = muxConfig[i];
          break;
        }
      }
      if (!mux) {
        return new Error('Failed to find demuxer by probing fragment data');
      }
      // so let's check that current remuxer and demuxer are still valid
      const demuxer = this.demuxer;
      const remuxer = this.remuxer;
      const Remuxer = mux.remux;
      const Demuxer = mux.demux;
      if (!remuxer || !(remuxer instanceof Remuxer)) {
        this.remuxer = new Remuxer(observer, config, typeSupported, vendor);
      }
      if (!demuxer || !(demuxer instanceof Demuxer)) {
        this.demuxer = new Demuxer(observer, config, typeSupported);
        this.probe = Demuxer.probe;
      }
    }
    needsProbing(discontinuity, trackSwitch) {
      // in case of continuity change, or track switch
      // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)
      return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;
    }
    getDecrypter() {
      let decrypter = this.decrypter;
      if (!decrypter) {
        decrypter = this.decrypter = new Decrypter(this.config);
      }
      return decrypter;
    }
  }
  function getEncryptionType(data, decryptData) {
    let encryptionType = null;
    if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {
      encryptionType = decryptData;
    }
    return encryptionType;
  }
  const emptyResult = chunkMeta => ({
    remuxResult: {},
    chunkMeta
  });
  function isPromise$1(p) {
    return 'then' in p && p.then instanceof Function;
  }
  class TransmuxConfig {
    constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {
      this.audioCodec = void 0;
      this.videoCodec = void 0;
      this.initSegmentData = void 0;
      this.duration = void 0;
      this.defaultInitPts = void 0;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this.initSegmentData = initSegmentData;
      this.duration = duration;
      this.defaultInitPts = defaultInitPts || null;
    }
  }
  class TransmuxState {
    constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {
      this.discontinuity = void 0;
      this.contiguous = void 0;
      this.accurateTimeOffset = void 0;
      this.trackSwitch = void 0;
      this.timeOffset = void 0;
      this.initSegmentChange = void 0;
      this.discontinuity = discontinuity;
      this.contiguous = contiguous;
      this.accurateTimeOffset = accurateTimeOffset;
      this.trackSwitch = trackSwitch;
      this.timeOffset = timeOffset;
      this.initSegmentChange = initSegmentChange;
    }
  }

  var eventemitter3 = {exports: {}};

  (function (module) {

  	var has = Object.prototype.hasOwnProperty
  	  , prefix = '~';

  	/**
  	 * Constructor to create a storage for our `EE` objects.
  	 * An `Events` instance is a plain object whose properties are event names.
  	 *
  	 * @constructor
  	 * @private
  	 */
  	function Events() {}

  	//
  	// We try to not inherit from `Object.prototype`. In some engines creating an
  	// instance in this way is faster than calling `Object.create(null)` directly.
  	// If `Object.create(null)` is not supported we prefix the event names with a
  	// character to make sure that the built-in object properties are not
  	// overridden or used as an attack vector.
  	//
  	if (Object.create) {
  	  Events.prototype = Object.create(null);

  	  //
  	  // This hack is needed because the `__proto__` property is still inherited in
  	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  	  //
  	  if (!new Events().__proto__) prefix = false;
  	}

  	/**
  	 * Representation of a single event listener.
  	 *
  	 * @param {Function} fn The listener function.
  	 * @param {*} context The context to invoke the listener with.
  	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
  	 * @constructor
  	 * @private
  	 */
  	function EE(fn, context, once) {
  	  this.fn = fn;
  	  this.context = context;
  	  this.once = once || false;
  	}

  	/**
  	 * Add a listener for a given event.
  	 *
  	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
  	 * @param {(String|Symbol)} event The event name.
  	 * @param {Function} fn The listener function.
  	 * @param {*} context The context to invoke the listener with.
  	 * @param {Boolean} once Specify if the listener is a one-time listener.
  	 * @returns {EventEmitter}
  	 * @private
  	 */
  	function addListener(emitter, event, fn, context, once) {
  	  if (typeof fn !== 'function') {
  	    throw new TypeError('The listener must be a function');
  	  }

  	  var listener = new EE(fn, context || emitter, once)
  	    , evt = prefix ? prefix + event : event;

  	  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  	  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  	  else emitter._events[evt] = [emitter._events[evt], listener];

  	  return emitter;
  	}

  	/**
  	 * Clear event by name.
  	 *
  	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
  	 * @param {(String|Symbol)} evt The Event name.
  	 * @private
  	 */
  	function clearEvent(emitter, evt) {
  	  if (--emitter._eventsCount === 0) emitter._events = new Events();
  	  else delete emitter._events[evt];
  	}

  	/**
  	 * Minimal `EventEmitter` interface that is molded against the Node.js
  	 * `EventEmitter` interface.
  	 *
  	 * @constructor
  	 * @public
  	 */
  	function EventEmitter() {
  	  this._events = new Events();
  	  this._eventsCount = 0;
  	}

  	/**
  	 * Return an array listing the events for which the emitter has registered
  	 * listeners.
  	 *
  	 * @returns {Array}
  	 * @public
  	 */
  	EventEmitter.prototype.eventNames = function eventNames() {
  	  var names = []
  	    , events
  	    , name;

  	  if (this._eventsCount === 0) return names;

  	  for (name in (events = this._events)) {
  	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  	  }

  	  if (Object.getOwnPropertySymbols) {
  	    return names.concat(Object.getOwnPropertySymbols(events));
  	  }

  	  return names;
  	};

  	/**
  	 * Return the listeners registered for a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @returns {Array} The registered listeners.
  	 * @public
  	 */
  	EventEmitter.prototype.listeners = function listeners(event) {
  	  var evt = prefix ? prefix + event : event
  	    , handlers = this._events[evt];

  	  if (!handlers) return [];
  	  if (handlers.fn) return [handlers.fn];

  	  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
  	    ee[i] = handlers[i].fn;
  	  }

  	  return ee;
  	};

  	/**
  	 * Return the number of listeners listening to a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @returns {Number} The number of listeners.
  	 * @public
  	 */
  	EventEmitter.prototype.listenerCount = function listenerCount(event) {
  	  var evt = prefix ? prefix + event : event
  	    , listeners = this._events[evt];

  	  if (!listeners) return 0;
  	  if (listeners.fn) return 1;
  	  return listeners.length;
  	};

  	/**
  	 * Calls each of the listeners registered for a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @returns {Boolean} `true` if the event had listeners, else `false`.
  	 * @public
  	 */
  	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  	  var evt = prefix ? prefix + event : event;

  	  if (!this._events[evt]) return false;

  	  var listeners = this._events[evt]
  	    , len = arguments.length
  	    , args
  	    , i;

  	  if (listeners.fn) {
  	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

  	    switch (len) {
  	      case 1: return listeners.fn.call(listeners.context), true;
  	      case 2: return listeners.fn.call(listeners.context, a1), true;
  	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
  	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
  	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
  	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
  	    }

  	    for (i = 1, args = new Array(len -1); i < len; i++) {
  	      args[i - 1] = arguments[i];
  	    }

  	    listeners.fn.apply(listeners.context, args);
  	  } else {
  	    var length = listeners.length
  	      , j;

  	    for (i = 0; i < length; i++) {
  	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

  	      switch (len) {
  	        case 1: listeners[i].fn.call(listeners[i].context); break;
  	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
  	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
  	        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
  	        default:
  	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
  	            args[j - 1] = arguments[j];
  	          }

  	          listeners[i].fn.apply(listeners[i].context, args);
  	      }
  	    }
  	  }

  	  return true;
  	};

  	/**
  	 * Add a listener for a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @param {Function} fn The listener function.
  	 * @param {*} [context=this] The context to invoke the listener with.
  	 * @returns {EventEmitter} `this`.
  	 * @public
  	 */
  	EventEmitter.prototype.on = function on(event, fn, context) {
  	  return addListener(this, event, fn, context, false);
  	};

  	/**
  	 * Add a one-time listener for a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @param {Function} fn The listener function.
  	 * @param {*} [context=this] The context to invoke the listener with.
  	 * @returns {EventEmitter} `this`.
  	 * @public
  	 */
  	EventEmitter.prototype.once = function once(event, fn, context) {
  	  return addListener(this, event, fn, context, true);
  	};

  	/**
  	 * Remove the listeners of a given event.
  	 *
  	 * @param {(String|Symbol)} event The event name.
  	 * @param {Function} fn Only remove the listeners that match this function.
  	 * @param {*} context Only remove the listeners that have this context.
  	 * @param {Boolean} once Only remove one-time listeners.
  	 * @returns {EventEmitter} `this`.
  	 * @public
  	 */
  	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  	  var evt = prefix ? prefix + event : event;

  	  if (!this._events[evt]) return this;
  	  if (!fn) {
  	    clearEvent(this, evt);
  	    return this;
  	  }

  	  var listeners = this._events[evt];

  	  if (listeners.fn) {
  	    if (
  	      listeners.fn === fn &&
  	      (!once || listeners.once) &&
  	      (!context || listeners.context === context)
  	    ) {
  	      clearEvent(this, evt);
  	    }
  	  } else {
  	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
  	      if (
  	        listeners[i].fn !== fn ||
  	        (once && !listeners[i].once) ||
  	        (context && listeners[i].context !== context)
  	      ) {
  	        events.push(listeners[i]);
  	      }
  	    }

  	    //
  	    // Reset the array, or remove it completely if we have no more listeners.
  	    //
  	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
  	    else clearEvent(this, evt);
  	  }

  	  return this;
  	};

  	/**
  	 * Remove all listeners, or those of the specified event.
  	 *
  	 * @param {(String|Symbol)} [event] The event name.
  	 * @returns {EventEmitter} `this`.
  	 * @public
  	 */
  	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  	  var evt;

  	  if (event) {
  	    evt = prefix ? prefix + event : event;
  	    if (this._events[evt]) clearEvent(this, evt);
  	  } else {
  	    this._events = new Events();
  	    this._eventsCount = 0;
  	  }

  	  return this;
  	};

  	//
  	// Alias methods names because people roll like that.
  	//
  	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  	//
  	// Expose the prefix.
  	//
  	EventEmitter.prefixed = prefix;

  	//
  	// Allow `EventEmitter` to be imported as module namespace.
  	//
  	EventEmitter.EventEmitter = EventEmitter;

  	//
  	// Expose the module.
  	//
  	{
  	  module.exports = EventEmitter;
  	} 
  } (eventemitter3));

  var eventemitter3Exports = eventemitter3.exports;
  var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

  class TransmuxerInterface {
    constructor(hls, id, onTransmuxComplete, onFlush) {
      this.error = null;
      this.hls = void 0;
      this.id = void 0;
      this.observer = void 0;
      this.frag = null;
      this.part = null;
      this.useWorker = void 0;
      this.workerContext = null;
      this.onwmsg = void 0;
      this.transmuxer = null;
      this.onTransmuxComplete = void 0;
      this.onFlush = void 0;
      const config = hls.config;
      this.hls = hls;
      this.id = id;
      this.useWorker = !!config.enableWorker;
      this.onTransmuxComplete = onTransmuxComplete;
      this.onFlush = onFlush;
      const forwardMessage = (ev, data) => {
        data = data || {};
        data.frag = this.frag;
        data.id = this.id;
        if (ev === Events$1.ERROR) {
          this.error = data.error;
        }
        this.hls.trigger(ev, data);
      };

      // forward events to main thread
      this.observer = new EventEmitter();
      this.observer.on(Events$1.FRAG_DECRYPTED, forwardMessage);
      this.observer.on(Events$1.ERROR, forwardMessage);
      const MediaSource = getMediaSource(config.preferManagedMediaSource) || {
        isTypeSupported: () => false
      };
      const m2tsTypeSupported = {
        mpeg: MediaSource.isTypeSupported('audio/mpeg'),
        mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"'),
        ac3: MediaSource.isTypeSupported('audio/mp4; codecs="ac-3"') 
      };
      if (this.useWorker && typeof Worker !== 'undefined') {
        const canCreateWorker = config.workerPath || hasUMDWorker();
        if (canCreateWorker) {
          try {
            if (config.workerPath) {
              logger.log(`loading Web Worker ${config.workerPath} for "${id}"`);
              this.workerContext = loadWorker(config.workerPath);
            } else {
              logger.log(`injecting Web Worker for "${id}"`);
              this.workerContext = injectWorker();
            }
            this.onwmsg = event => this.onWorkerMessage(event);
            const {
              worker
            } = this.workerContext;
            worker.addEventListener('message', this.onwmsg);
            worker.onerror = event => {
              const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);
              config.enableWorker = false;
              logger.warn(`Error in "${id}" Web Worker, fallback to inline`);
              this.hls.trigger(Events$1.ERROR, {
                type: ErrorTypes.OTHER_ERROR,
                details: ErrorDetails.INTERNAL_EXCEPTION,
                fatal: false,
                event: 'demuxerWorker',
                error
              });
            };
            worker.postMessage({
              cmd: 'init',
              typeSupported: m2tsTypeSupported,
              vendor: '',
              id: id,
              config: JSON.stringify(config)
            });
          } catch (err) {
            logger.warn(`Error setting up "${id}" Web Worker, fallback to inline`, err);
            this.resetWorker();
            this.error = null;
            this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id);
          }
          return;
        }
      }
      this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id);
    }
    resetWorker() {
      if (this.workerContext) {
        const {
          worker,
          objectURL
        } = this.workerContext;
        if (objectURL) {
          // revoke the Object URL that was used to create transmuxer worker, so as not to leak it
          self.URL.revokeObjectURL(objectURL);
        }
        worker.removeEventListener('message', this.onwmsg);
        worker.onerror = null;
        worker.terminate();
        this.workerContext = null;
      }
    }
    destroy() {
      if (this.workerContext) {
        this.resetWorker();
        this.onwmsg = undefined;
      } else {
        const transmuxer = this.transmuxer;
        if (transmuxer) {
          transmuxer.destroy();
          this.transmuxer = null;
        }
      }
      const observer = this.observer;
      if (observer) {
        observer.removeAllListeners();
      }
      this.frag = null;
      // @ts-ignore
      this.observer = null;
      // @ts-ignore
      this.hls = null;
    }
    push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {
      var _frag$initSegment, _lastFrag$initSegment;
      chunkMeta.transmuxing.start = self.performance.now();
      const {
        transmuxer
      } = this;
      const timeOffset = part ? part.start : frag.start;
      // TODO: push "clear-lead" decrypt data for unencrypted fragments in streams with encrypted ones
      const decryptdata = frag.decryptdata;
      const lastFrag = this.frag;
      const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
      const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);
      const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;
      const partDiff = this.part ? chunkMeta.part - this.part.index : -1;
      const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);
      const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));
      const now = self.performance.now();
      if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {
        frag.stats.parsing.start = now;
      }
      if (part && (partDiff || !contiguous)) {
        part.stats.parsing.start = now;
      }
      const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));
      const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);
      if (!contiguous || discontinuity || initSegmentChange) {
        logger.log(`[transmuxer-interface, ${frag.type}]: Starting new transmux session for sn: ${chunkMeta.sn} p: ${chunkMeta.part} level: ${chunkMeta.level} id: ${chunkMeta.id}
        discontinuity: ${discontinuity}
        trackSwitch: ${trackSwitch}
        contiguous: ${contiguous}
        accurateTimeOffset: ${accurateTimeOffset}
        timeOffset: ${timeOffset}
        initSegmentChange: ${initSegmentChange}`);
        const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);
        this.configureTransmuxer(config);
      }
      this.frag = frag;
      this.part = part;

      // Frags with sn of 'initSegment' are not transmuxed
      if (this.workerContext) {
        // post fragment payload as transferable objects for ArrayBuffer (no copy)
        this.workerContext.worker.postMessage({
          cmd: 'demux',
          data,
          decryptdata,
          chunkMeta,
          state
        }, data instanceof ArrayBuffer ? [data] : []);
      } else if (transmuxer) {
        const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);
        if (isPromise$1(transmuxResult)) {
          transmuxer.async = true;
          transmuxResult.then(data => {
            this.handleTransmuxComplete(data);
          }).catch(error => {
            this.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');
          });
        } else {
          transmuxer.async = false;
          this.handleTransmuxComplete(transmuxResult);
        }
      }
    }
    flush(chunkMeta) {
      chunkMeta.transmuxing.start = self.performance.now();
      const {
        transmuxer
      } = this;
      if (this.workerContext) {
        this.workerContext.worker.postMessage({
          cmd: 'flush',
          chunkMeta
        });
      } else if (transmuxer) {
        let transmuxResult = transmuxer.flush(chunkMeta);
        const asyncFlush = isPromise$1(transmuxResult);
        if (asyncFlush || transmuxer.async) {
          if (!isPromise$1(transmuxResult)) {
            transmuxResult = Promise.resolve(transmuxResult);
          }
          transmuxResult.then(data => {
            this.handleFlushResult(data, chunkMeta);
          }).catch(error => {
            this.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');
          });
        } else {
          this.handleFlushResult(transmuxResult, chunkMeta);
        }
      }
    }
    transmuxerError(error, chunkMeta, reason) {
      if (!this.hls) {
        return;
      }
      this.error = error;
      this.hls.trigger(Events$1.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.FRAG_PARSING_ERROR,
        chunkMeta,
        frag: this.frag || undefined,
        fatal: false,
        error,
        err: error,
        reason
      });
    }
    handleFlushResult(results, chunkMeta) {
      results.forEach(result => {
        this.handleTransmuxComplete(result);
      });
      this.onFlush(chunkMeta);
    }
    onWorkerMessage(event) {
      const data = event.data;
      if (!(data != null && data.event)) {
        logger.warn(`worker message received with no ${data ? 'event name' : 'data'}`);
        return;
      }
      const hls = this.hls;
      if (!this.hls) {
        return;
      }
      switch (data.event) {
        case 'init':
          {
            var _this$workerContext;
            const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;
            if (objectURL) {
              // revoke the Object URL that was used to create transmuxer worker, so as not to leak it
              self.URL.revokeObjectURL(objectURL);
            }
            break;
          }
        case 'transmuxComplete':
          {
            this.handleTransmuxComplete(data.data);
            break;
          }
        case 'flush':
          {
            this.onFlush(data.data);
            break;
          }

        // pass logs from the worker thread to the main logger
        case 'workerLog':
          if (logger[data.data.logType]) {
            logger[data.data.logType](data.data.message);
          }
          break;
        default:
          {
            data.data = data.data || {};
            data.data.frag = this.frag;
            data.data.id = this.id;
            hls.trigger(data.event, data.data);
            break;
          }
      }
    }
    configureTransmuxer(config) {
      const {
        transmuxer
      } = this;
      if (this.workerContext) {
        this.workerContext.worker.postMessage({
          cmd: 'configure',
          config
        });
      } else if (transmuxer) {
        transmuxer.configure(config);
      }
    }
    handleTransmuxComplete(result) {
      result.chunkMeta.transmuxing.end = self.performance.now();
      this.onTransmuxComplete(result);
    }
  }

  function subtitleOptionsIdentical(trackList1, trackList2) {
    if (trackList1.length !== trackList2.length) {
      return false;
    }
    for (let i = 0; i < trackList1.length; i++) {
      if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {
        return false;
      }
    }
    return true;
  }
  function mediaAttributesIdentical(attrs1, attrs2, customAttributes) {
    // Media options with the same rendition ID must be bit identical
    const stableRenditionId = attrs1['STABLE-RENDITION-ID'];
    if (stableRenditionId && !customAttributes) {
      return stableRenditionId === attrs2['STABLE-RENDITION-ID'];
    }
    // When rendition ID is not present, compare attributes
    return !(customAttributes || ['LANGUAGE', 'NAME', 'CHARACTERISTICS', 'AUTOSELECT', 'DEFAULT', 'FORCED', 'ASSOC-LANGUAGE']).some(subtitleAttribute => attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);
  }
  function subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {
    return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || '').toLowerCase());
  }

  const TICK_INTERVAL$2 = 100; // how often to tick in ms

  class AudioStreamController extends BaseStreamController {
    constructor(hls, fragmentTracker, keyLoader) {
      super(hls, fragmentTracker, keyLoader, '[audio-stream-controller]', PlaylistLevelType.AUDIO);
      this.videoBuffer = null;
      this.videoTrackCC = -1;
      this.waitingVideoCC = -1;
      this.bufferedTrack = null;
      this.switchingTrack = null;
      this.trackId = -1;
      this.waitingData = null;
      this.mainDetails = null;
      this.flushing = false;
      this.bufferFlushed = false;
      this.cachedTrackLoadedData = null;
      this._registerListeners();
    }
    onHandlerDestroying() {
      this._unregisterListeners();
      super.onHandlerDestroying();
      this.mainDetails = null;
      this.bufferedTrack = null;
      this.switchingTrack = null;
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events$1.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
      hls.on(Events$1.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.on(Events$1.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.on(Events$1.ERROR, this.onError, this);
      hls.on(Events$1.BUFFER_RESET, this.onBufferReset, this);
      hls.on(Events$1.BUFFER_CREATED, this.onBufferCreated, this);
      hls.on(Events$1.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.on(Events$1.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.on(Events$1.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.on(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events$1.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
      hls.off(Events$1.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.off(Events$1.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.off(Events$1.ERROR, this.onError, this);
      hls.off(Events$1.BUFFER_RESET, this.onBufferReset, this);
      hls.off(Events$1.BUFFER_CREATED, this.onBufferCreated, this);
      hls.off(Events$1.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.off(Events$1.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.off(Events$1.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.off(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
    }

    // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value
    onInitPtsFound(event, {
      frag,
      id,
      initPTS,
      timescale
    }) {
      // Always update the new INIT PTS
      // Can change due level switch
      if (id === 'main') {
        const cc = frag.cc;
        this.initPTS[frag.cc] = {
          baseTime: initPTS,
          timescale
        };
        this.log(`InitPTS for cc: ${cc} found from main: ${initPTS}`);
        this.videoTrackCC = cc;
        // If we are waiting, tick immediately to unblock audio fragment transmuxing
        if (this.state === State.WAITING_INIT_PTS) {
          this.tick();
        }
      }
    }
    startLoad(startPosition) {
      if (!this.levels) {
        this.startPosition = startPosition;
        this.state = State.STOPPED;
        return;
      }
      const lastCurrentTime = this.lastCurrentTime;
      this.stopLoad();
      this.setInterval(TICK_INTERVAL$2);
      if (lastCurrentTime > 0 && startPosition === -1) {
        this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);
        startPosition = lastCurrentTime;
        this.state = State.IDLE;
      } else {
        this.loadedmetadata = false;
        this.state = State.WAITING_TRACK;
      }
      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
      this.tick();
    }
    doTick() {
      switch (this.state) {
        case State.IDLE:
          this.doTickIdle();
          break;
        case State.WAITING_TRACK:
          {
            var _levels$trackId;
            const {
              levels,
              trackId
            } = this;
            const details = levels == null ? void 0 : (_levels$trackId = levels[trackId]) == null ? void 0 : _levels$trackId.details;
            if (details) {
              if (this.waitForCdnTuneIn(details)) {
                break;
              }
              this.state = State.WAITING_INIT_PTS;
            }
            break;
          }
        case State.FRAG_LOADING_WAITING_RETRY:
          {
            var _this$media;
            const now = performance.now();
            const retryDate = this.retryDate;
            // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
            if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
              const {
                levels,
                trackId
              } = this;
              this.log('RetryDate reached, switch back to IDLE state');
              this.resetStartWhenNotLoaded((levels == null ? void 0 : levels[trackId]) || null);
              this.state = State.IDLE;
            }
            break;
          }
        case State.WAITING_INIT_PTS:
          {
            // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
            const waitingData = this.waitingData;
            if (waitingData) {
              const {
                frag,
                part,
                cache,
                complete
              } = waitingData;
              if (this.initPTS[frag.cc] !== undefined) {
                this.waitingData = null;
                this.waitingVideoCC = -1;
                this.state = State.FRAG_LOADING;
                const payload = cache.flush();
                const data = {
                  frag,
                  part,
                  payload,
                  networkDetails: null
                };
                this._handleFragmentLoadProgress(data);
                if (complete) {
                  super._handleFragmentLoadComplete(data);
                }
              } else if (this.videoTrackCC !== this.waitingVideoCC) {
                // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found
                this.log(`Waiting fragment cc (${frag.cc}) cancelled because video is at cc ${this.videoTrackCC}`);
                this.clearWaitingFragment();
              } else {
                // Drop waiting fragment if an earlier fragment is needed
                const pos = this.getLoadPosition();
                const bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);
                const waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);
                if (waitingFragmentAtPosition < 0) {
                  this.log(`Waiting fragment cc (${frag.cc}) @ ${frag.start} cancelled because another fragment at ${bufferInfo.end} is needed`);
                  this.clearWaitingFragment();
                }
              }
            } else {
              this.state = State.IDLE;
            }
          }
      }
      this.onTickEnd();
    }
    clearWaitingFragment() {
      const waitingData = this.waitingData;
      if (waitingData) {
        this.fragmentTracker.removeFragment(waitingData.frag);
        this.waitingData = null;
        this.waitingVideoCC = -1;
        this.state = State.IDLE;
      }
    }
    resetLoadingState() {
      this.clearWaitingFragment();
      super.resetLoadingState();
    }
    onTickEnd() {
      const {
        media
      } = this;
      if (!(media != null && media.readyState)) {
        // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)
        return;
      }
      this.lastCurrentTime = media.currentTime;
    }
    doTickIdle() {
      const {
        hls,
        levels,
        media,
        trackId
      } = this;
      const config = hls.config;

      // 1. if video not attached AND
      //    start fragment already requested OR start frag prefetch not enabled
      // 2. if tracks or track not loaded and selected
      // then exit loop
      // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
      if (!media && (this.startFragRequested || !config.startFragPrefetch) || !(levels != null && levels[trackId])) {
        return;
      }
      const levelInfo = levels[trackId];
      const trackDetails = levelInfo.details;
      if (!trackDetails || trackDetails.live && this.levelLastLoaded !== levelInfo || this.waitForCdnTuneIn(trackDetails)) {
        this.state = State.WAITING_TRACK;
        return;
      }
      const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;
      if (this.bufferFlushed && bufferable) {
        this.bufferFlushed = false;
        this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);
      }
      const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);
      if (bufferInfo === null) {
        return;
      }
      const {
        bufferedTrack,
        switchingTrack
      } = this;
      if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {
        hls.trigger(Events$1.BUFFER_EOS, {
          type: 'audio'
        });
        this.state = State.ENDED;
        return;
      }
      const mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);
      const bufferLen = bufferInfo.len;
      const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len);
      const fragments = trackDetails.fragments;
      const start = fragments[0].start;
      let targetBufferTime = this.flushing ? this.getLoadPosition() : bufferInfo.end;
      if (switchingTrack && media) {
        const pos = this.getLoadPosition();
        // STABLE
        if (bufferedTrack && !mediaAttributesIdentical(switchingTrack.attrs, bufferedTrack.attrs)) {
          targetBufferTime = pos;
        }
        // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
        if (trackDetails.PTSKnown && pos < start) {
          // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
          if (bufferInfo.end > start || bufferInfo.nextStart) {
            this.log('Alt audio track ahead of main track, seek to start of alt audio track');
            media.currentTime = start + 0.05;
          }
        }
      }

      // if buffer length is less than maxBufLen, or near the end, find a fragment to load
      if (bufferLen >= maxBufLen && !switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {
        return;
      }
      let frag = this.getNextFragment(targetBufferTime, trackDetails);
      let atGap = false;
      // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags
      if (frag && this.isLoopLoading(frag, targetBufferTime)) {
        atGap = !!frag.gap;
        frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
      }
      if (!frag) {
        this.bufferFlushed = true;
        return;
      }

      // Buffer audio up to one target duration ahead of main buffer
      const atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;
      if (atBufferSyncLimit ||
      // Or wait for main buffer after buffing some audio
      !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {
        // Check fragment-tracker for main fragments since GAP segments do not show up in bufferInfo
        const mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);
        if (mainFrag === null) {
          return;
        }
        // Bridge gaps in main buffer
        atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);
        if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {
          return;
        }
      }
      this.loadFragment(frag, levelInfo, targetBufferTime);
    }
    getMaxBufferLength(mainBufferLength) {
      const maxConfigBuffer = super.getMaxBufferLength();
      if (!mainBufferLength) {
        return maxConfigBuffer;
      }
      return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);
    }
    onMediaDetaching() {
      this.videoBuffer = null;
      this.bufferFlushed = this.flushing = false;
      super.onMediaDetaching();
    }
    onAudioTracksUpdated(event, {
      audioTracks
    }) {
      // Reset tranxmuxer is essential for large context switches (Content Steering)
      this.resetTransmuxer();
      this.levels = audioTracks.map(mediaPlaylist => new Level(mediaPlaylist));
    }
    onAudioTrackSwitching(event, data) {
      // if any URL found on new audio track, it is an alternate audio track
      const altAudio = !!data.url;
      this.trackId = data.id;
      const {
        fragCurrent
      } = this;
      if (fragCurrent) {
        fragCurrent.abortRequests();
        this.removeUnbufferedFrags(fragCurrent.start);
      }
      this.resetLoadingState();
      // destroy useless transmuxer when switching audio to main
      if (!altAudio) {
        this.resetTransmuxer();
      } else {
        // switching to audio track, start timer if not already started
        this.setInterval(TICK_INTERVAL$2);
      }

      // should we switch tracks ?
      if (altAudio) {
        this.switchingTrack = data;
        // main audio track are handled by stream-controller, just do something if switching to alt audio track
        this.state = State.IDLE;
        this.flushAudioIfNeeded(data);
      } else {
        this.switchingTrack = null;
        this.bufferedTrack = data;
        this.state = State.STOPPED;
      }
      this.tick();
    }
    onManifestLoading() {
      this.fragmentTracker.removeAllFragments();
      this.startPosition = this.lastCurrentTime = 0;
      this.bufferFlushed = this.flushing = false;
      this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;
      this.startFragRequested = false;
      this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;
    }
    onLevelLoaded(event, data) {
      this.mainDetails = data.details;
      if (this.cachedTrackLoadedData !== null) {
        this.hls.trigger(Events$1.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);
        this.cachedTrackLoadedData = null;
      }
    }
    onAudioTrackLoaded(event, data) {
      var _track$details;
      if (this.mainDetails == null) {
        this.cachedTrackLoadedData = data;
        return;
      }
      const {
        levels
      } = this;
      const {
        details: newDetails,
        id: trackId
      } = data;
      if (!levels) {
        this.warn(`Audio tracks were reset while loading level ${trackId}`);
        return;
      }
      this.log(`Audio track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''},duration:${newDetails.totalduration}`);
      const track = levels[trackId];
      let sliding = 0;
      if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
        this.checkLiveUpdate(newDetails);
        const mainDetails = this.mainDetails;
        if (newDetails.deltaUpdateFailed || !mainDetails) {
          return;
        }
        if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
          // Make sure our audio rendition is aligned with the "main" rendition, using
          // pdt as our reference times.
          alignMediaPlaylistByPDT(newDetails, mainDetails);
          sliding = newDetails.fragments[0].start;
        } else {
          var _this$levelLastLoaded;
          sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);
        }
      }
      track.details = newDetails;
      this.levelLastLoaded = track;

      // compute start position if we are aligned with the main playlist
      if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
        this.setStartPosition(this.mainDetails || newDetails, sliding);
      }
      // only switch back to IDLE state if we were waiting for track to start downloading a new fragment
      if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {
        this.state = State.IDLE;
      }

      // trigger handler right now
      this.tick();
    }
    _handleFragmentLoadProgress(data) {
      var _frag$initSegment;
      const {
        frag,
        part,
        payload
      } = data;
      const {
        config,
        trackId,
        levels
      } = this;
      if (!levels) {
        this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);
        return;
      }
      const track = levels[trackId];
      if (!track) {
        this.warn('Audio track is undefined on fragment load progress');
        return;
      }
      const details = track.details;
      if (!details) {
        this.warn('Audio track details undefined on fragment load progress');
        this.removeUnbufferedFrags(frag.start);
        return;
      }
      const audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';
      let transmuxer = this.transmuxer;
      if (!transmuxer) {
        transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
      }

      // Check if we have video initPTS
      // If not we need to wait for it
      const initPTS = this.initPTS[frag.cc];
      const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;
      if (initPTS !== undefined) {
        // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);
        // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
        const accurateTimeOffset = false; // details.PTSKnown || !details.live;
        const partIndex = part ? part.index : -1;
        const partial = partIndex !== -1;
        const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
        transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
      } else {
        this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);
        const {
          cache
        } = this.waitingData = this.waitingData || {
          frag,
          part,
          cache: new ChunkCache(),
          complete: false
        };
        cache.push(new Uint8Array(payload));
        this.waitingVideoCC = this.videoTrackCC;
        this.state = State.WAITING_INIT_PTS;
      }
    }
    _handleFragmentLoadComplete(fragLoadedData) {
      if (this.waitingData) {
        this.waitingData.complete = true;
        return;
      }
      super._handleFragmentLoadComplete(fragLoadedData);
    }
    onBufferReset( /* event: Events.BUFFER_RESET */
    ) {
      // reset reference to sourcebuffers
      this.mediaBuffer = this.videoBuffer = null;
      this.loadedmetadata = false;
    }
    onBufferCreated(event, data) {
      const audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer || null;
      }
      if (data.tracks.video) {
        this.videoBuffer = data.tracks.video.buffer || null;
      }
    }
    onFragBuffered(event, data) {
      const {
        frag,
        part
      } = data;
      if (frag.type !== PlaylistLevelType.AUDIO) {
        if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {
          const bufferable = this.videoBuffer || this.media;
          if (bufferable) {
            const bufferedTimeRanges = BufferHelper.getBuffered(bufferable);
            if (bufferedTimeRanges.length) {
              this.loadedmetadata = true;
            }
          }
        }
        return;
      }
      if (this.fragContextChanged(frag)) {
        // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion
        // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer
        this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : 'false'}`);
        return;
      }
      if (frag.sn !== 'initSegment') {
        this.fragPrevious = frag;
        const track = this.switchingTrack;
        if (track) {
          this.bufferedTrack = track;
          this.switchingTrack = null;
          this.hls.trigger(Events$1.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));
        }
      }
      this.fragBufferedComplete(frag, part);
    }
    onError(event, data) {
      var _data$context;
      if (data.fatal) {
        this.state = State.ERROR;
        return;
      }
      switch (data.details) {
        case ErrorDetails.FRAG_GAP:
        case ErrorDetails.FRAG_PARSING_ERROR:
        case ErrorDetails.FRAG_DECRYPT_ERROR:
        case ErrorDetails.FRAG_LOAD_ERROR:
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
        case ErrorDetails.KEY_LOAD_ERROR:
        case ErrorDetails.KEY_LOAD_TIMEOUT:
          this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);
          break;
        case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case ErrorDetails.LEVEL_PARSING_ERROR:
          // in case of non fatal error while loading track, if not retrying to load track, switch back to IDLE
          if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {
            this.state = State.IDLE;
          }
          break;
        case ErrorDetails.BUFFER_APPEND_ERROR:
        case ErrorDetails.BUFFER_FULL_ERROR:
          if (!data.parent || data.parent !== 'audio') {
            return;
          }
          if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {
            this.resetLoadingState();
            return;
          }
          if (this.reduceLengthAndFlushBuffer(data)) {
            this.bufferedTrack = null;
            super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');
          }
          break;
        case ErrorDetails.INTERNAL_EXCEPTION:
          this.recoverWorkerError(data);
          break;
      }
    }
    onBufferFlushing(event, {
      type
    }) {
      if (type !== ElementaryStreamTypes.VIDEO) {
        this.flushing = true;
      }
    }
    onBufferFlushed(event, {
      type
    }) {
      if (type !== ElementaryStreamTypes.VIDEO) {
        this.flushing = false;
        this.bufferFlushed = true;
        if (this.state === State.ENDED) {
          this.state = State.IDLE;
        }
        const mediaBuffer = this.mediaBuffer || this.media;
        if (mediaBuffer) {
          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);
          this.tick();
        }
      }
    }
    _handleTransmuxComplete(transmuxResult) {
      var _id3$samples;
      const id = 'audio';
      const {
        hls
      } = this;
      const {
        remuxResult,
        chunkMeta
      } = transmuxResult;
      const context = this.getCurrentContext(chunkMeta);
      if (!context) {
        this.resetWhenMissingContext(chunkMeta);
        return;
      }
      const {
        frag,
        part,
        level
      } = context;
      const {
        details
      } = level;
      const {
        audio,
        text,
        id3,
        initSegment
      } = remuxResult;

      // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.
      // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.
      if (this.fragContextChanged(frag) || !details) {
        this.fragmentTracker.removeFragment(frag);
        return;
      }
      this.state = State.PARSING;
      if (this.switchingTrack && audio) {
        this.completeAudioSwitch(this.switchingTrack);
      }
      if (initSegment != null && initSegment.tracks) {
        const mapFragment = frag.initSegment || frag;
        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
        hls.trigger(Events$1.FRAG_PARSING_INIT_SEGMENT, {
          frag: mapFragment,
          id,
          tracks: initSegment.tracks
        });
        // Only flush audio from old audio tracks when PTS is known on new audio track
      }
      if (audio) {
        const {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        } = audio;
        if (part) {
          part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
            startPTS,
            endPTS,
            startDTS,
            endDTS
          };
        }
        frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
        this.bufferFragmentData(audio, frag, part, chunkMeta);
      }
      if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
        const emittedID3 = _extends$2({
          id,
          frag,
          details
        }, id3);
        hls.trigger(Events$1.FRAG_PARSING_METADATA, emittedID3);
      }
      if (text) {
        const emittedText = _extends$2({
          id,
          frag,
          details
        }, text);
        hls.trigger(Events$1.FRAG_PARSING_USERDATA, emittedText);
      }
    }
    _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
      if (this.state !== State.PARSING) {
        return;
      }
      // delete any video track found on audio transmuxer
      if (tracks.video) {
        delete tracks.video;
      }

      // include levelCodec in audio and video tracks
      const track = tracks.audio;
      if (!track) {
        return;
      }
      track.id = 'audio';
      const variantAudioCodecs = currentLevel.audioCodec;
      this.log(`Init audio buffer, container:${track.container}, codecs[level/parsed]=[${variantAudioCodecs}/${track.codec}]`);
      // SourceBuffer will use track.levelCodec if defined
      if (variantAudioCodecs && variantAudioCodecs.split(',').length === 1) {
        track.levelCodec = variantAudioCodecs;
      }
      this.hls.trigger(Events$1.BUFFER_CODECS, tracks);
      const initSegment = track.initSegment;
      if (initSegment != null && initSegment.byteLength) {
        const segment = {
          type: 'audio',
          frag,
          part: null,
          chunkMeta,
          parent: frag.type,
          data: initSegment
        };
        this.hls.trigger(Events$1.BUFFER_APPENDING, segment);
      }
      // trigger handler right now
      this.tickImmediate();
    }
    loadFragment(frag, track, targetBufferTime) {
      // only load if fragment is not loaded or if in audio switch
      const fragState = this.fragmentTracker.getState(frag);
      this.fragCurrent = frag;

      // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch
      if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
        var _track$details2;
        if (frag.sn === 'initSegment') {
          this._loadInitSegment(frag, track);
        } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {
          this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);
          this.state = State.WAITING_INIT_PTS;
          const mainDetails = this.mainDetails;
          if (mainDetails && mainDetails.fragments[0].start !== track.details.fragments[0].start) {
            alignMediaPlaylistByPDT(track.details, mainDetails);
          }
        } else {
          this.startFragRequested = true;
          super.loadFragment(frag, track, targetBufferTime);
        }
      } else {
        this.clearTrackerIfNeeded(frag);
      }
    }
    flushAudioIfNeeded(switchingTrack) {
      const {
        media,
        bufferedTrack
      } = this;
      const bufferedAttributes = bufferedTrack == null ? void 0 : bufferedTrack.attrs;
      const switchAttributes = switchingTrack.attrs;
      if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedTrack.name !== switchingTrack.name || bufferedTrack.lang !== switchingTrack.lang)) {
        this.log('Switching audio track : flushing all audio');
        super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');
        this.bufferedTrack = null;
      }
    }
    completeAudioSwitch(switchingTrack) {
      const {
        hls
      } = this;
      this.flushAudioIfNeeded(switchingTrack);
      this.bufferedTrack = switchingTrack;
      this.switchingTrack = null;
      hls.trigger(Events$1.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));
    }
  }

  class AudioTrackController extends BasePlaylistController {
    constructor(hls) {
      super(hls, '[audio-track-controller]');
      this.tracks = [];
      this.groupIds = null;
      this.tracksInGroup = [];
      this.trackId = -1;
      this.currentTrack = null;
      this.selectDefaultTrack = true;
      this.registerListeners();
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events$1.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events$1.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.on(Events$1.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.on(Events$1.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events$1.LEVEL_LOADING, this.onLevelLoading, this);
      hls.off(Events$1.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.off(Events$1.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.off(Events$1.ERROR, this.onError, this);
    }
    destroy() {
      this.unregisterListeners();
      this.tracks.length = 0;
      this.tracksInGroup.length = 0;
      this.currentTrack = null;
      super.destroy();
    }
    onManifestLoading() {
      this.tracks = [];
      this.tracksInGroup = [];
      this.groupIds = null;
      this.currentTrack = null;
      this.trackId = -1;
      this.selectDefaultTrack = true;
    }
    onManifestParsed(event, data) {
      this.tracks = data.audioTracks || [];
    }
    onAudioTrackLoaded(event, data) {
      const {
        id,
        groupId,
        details
      } = data;
      const trackInActiveGroup = this.tracksInGroup[id];
      if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
        this.warn(`Audio track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);
        return;
      }
      const curDetails = trackInActiveGroup.details;
      trackInActiveGroup.details = data.details;
      this.log(`Audio track ${id} "${trackInActiveGroup.name}" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);
      if (id === this.trackId) {
        this.playlistLoaded(id, data, curDetails);
      }
    }
    onLevelLoading(event, data) {
      this.switchLevel(data.level);
    }
    onLevelSwitching(event, data) {
      this.switchLevel(data.level);
    }
    switchLevel(levelIndex) {
      const levelInfo = this.hls.levels[levelIndex];
      if (!levelInfo) {
        return;
      }
      const audioGroups = levelInfo.audioGroups || null;
      const currentGroups = this.groupIds;
      let currentTrack = this.currentTrack;
      if (!audioGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (audioGroups == null ? void 0 : audioGroups.length) || audioGroups != null && audioGroups.some(groupId => (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {
        this.groupIds = audioGroups;
        this.trackId = -1;
        this.currentTrack = null;
        const audioTracks = this.tracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);
        if (audioTracks.length) {
          // Disable selectDefaultTrack if there are no default tracks
          if (this.selectDefaultTrack && !audioTracks.some(track => track.default)) {
            this.selectDefaultTrack = false;
          }
          // track.id should match hls.audioTracks index
          audioTracks.forEach((track, i) => {
            track.id = i;
          });
        } else if (!currentTrack && !this.tracksInGroup.length) {
          // Do not dispatch AUDIO_TRACKS_UPDATED when there were and are no tracks
          return;
        }
        this.tracksInGroup = audioTracks;

        // Find preferred track
        const audioPreference = this.hls.config.audioPreference;
        if (!currentTrack && audioPreference) {
          const groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);
          if (groupIndex > -1) {
            currentTrack = audioTracks[groupIndex];
          } else {
            const allIndex = findMatchingOption(audioPreference, this.tracks);
            currentTrack = this.tracks[allIndex];
          }
        }

        // Select initial track
        let trackId = this.findTrackId(currentTrack);
        if (trackId === -1 && currentTrack) {
          trackId = this.findTrackId(null);
        }

        // Dispatch events and load track if needed
        const audioTracksUpdated = {
          audioTracks
        };
        this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group(s): ${audioGroups == null ? void 0 : audioGroups.join(',')}`);
        this.hls.trigger(Events$1.AUDIO_TRACKS_UPDATED, audioTracksUpdated);
        const selectedTrackId = this.trackId;
        if (trackId !== -1 && selectedTrackId === -1) {
          this.setAudioTrack(trackId);
        } else if (audioTracks.length && selectedTrackId === -1) {
          var _this$groupIds;
          const error = new Error(`No audio track selected for current audio group-ID(s): ${(_this$groupIds = this.groupIds) == null ? void 0 : _this$groupIds.join(',')} track count: ${audioTracks.length}`);
          this.warn(error.message);
          this.hls.trigger(Events$1.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
            fatal: true,
            error
          });
        }
      } else if (this.shouldReloadPlaylist(currentTrack)) {
        // Retry playlist loading if no playlist is or has been loaded yet
        this.setAudioTrack(this.trackId);
      }
    }
    onError(event, data) {
      if (data.fatal || !data.context) {
        return;
      }
      if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {
        this.requestScheduled = -1;
        this.checkRetry(data);
      }
    }
    get allAudioTracks() {
      return this.tracks;
    }
    get audioTracks() {
      return this.tracksInGroup;
    }
    get audioTrack() {
      return this.trackId;
    }
    set audioTrack(newId) {
      // If audio track is selected from API then don't choose from the manifest default track
      this.selectDefaultTrack = false;
      this.setAudioTrack(newId);
    }
    setAudioOption(audioOption) {
      const hls = this.hls;
      hls.config.audioPreference = audioOption;
      if (audioOption) {
        const allAudioTracks = this.allAudioTracks;
        this.selectDefaultTrack = false;
        if (allAudioTracks.length) {
          // First see if current option matches (no switch op)
          const currentTrack = this.currentTrack;
          if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {
            return currentTrack;
          }
          // Find option in available tracks (tracksInGroup)
          const groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);
          if (groupIndex > -1) {
            const track = this.tracksInGroup[groupIndex];
            this.setAudioTrack(groupIndex);
            return track;
          } else if (currentTrack) {
            // Find option in nearest level audio group
            let searchIndex = hls.loadLevel;
            if (searchIndex === -1) {
              searchIndex = hls.firstAutoLevel;
            }
            const switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);
            if (switchIndex === -1) {
              // could not find matching variant
              return null;
            }
            // and switch level to acheive the audio group switch
            hls.nextLoadLevel = switchIndex;
          }
          if (audioOption.channels || audioOption.audioCodec) {
            // Could not find a match with codec / channels predicate
            // Find a match without channels or codec
            const withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);
            if (withoutCodecAndChannelsMatch > -1) {
              return allAudioTracks[withoutCodecAndChannelsMatch];
            }
          }
        }
      }
      return null;
    }
    setAudioTrack(newId) {
      const tracks = this.tracksInGroup;

      // check if level idx is valid
      if (newId < 0 || newId >= tracks.length) {
        this.warn(`Invalid audio track id: ${newId}`);
        return;
      }

      // stopping live reloading timer if any
      this.clearTimer();
      this.selectDefaultTrack = false;
      const lastTrack = this.currentTrack;
      const track = tracks[newId];
      const trackLoaded = track.details && !track.details.live;
      if (newId === this.trackId && track === lastTrack && trackLoaded) {
        return;
      }
      this.log(`Switching to audio-track ${newId} "${track.name}" lang:${track.lang} group:${track.groupId} channels:${track.channels}`);
      this.trackId = newId;
      this.currentTrack = track;
      this.hls.trigger(Events$1.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));
      // Do not reload track unless live
      if (trackLoaded) {
        return;
      }
      const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);
      this.loadPlaylist(hlsUrlParameters);
    }
    findTrackId(currentTrack) {
      const audioTracks = this.tracksInGroup;
      for (let i = 0; i < audioTracks.length; i++) {
        const track = audioTracks[i];
        if (this.selectDefaultTrack && !track.default) {
          continue;
        }
        if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {
          return i;
        }
      }
      if (currentTrack) {
        const {
          name,
          lang,
          assocLang,
          characteristics,
          audioCodec,
          channels
        } = currentTrack;
        for (let i = 0; i < audioTracks.length; i++) {
          const track = audioTracks[i];
          if (matchesOption({
            name,
            lang,
            assocLang,
            characteristics,
            audioCodec,
            channels
          }, track, audioMatchPredicate)) {
            return i;
          }
        }
        for (let i = 0; i < audioTracks.length; i++) {
          const track = audioTracks[i];
          if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {
            return i;
          }
        }
        for (let i = 0; i < audioTracks.length; i++) {
          const track = audioTracks[i];
          if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE'])) {
            return i;
          }
        }
      }
      return -1;
    }
    loadPlaylist(hlsUrlParameters) {
      const audioTrack = this.currentTrack;
      if (this.shouldLoadPlaylist(audioTrack) && audioTrack) {
        super.loadPlaylist();
        const id = audioTrack.id;
        const groupId = audioTrack.groupId;
        let url = audioTrack.url;
        if (hlsUrlParameters) {
          try {
            url = hlsUrlParameters.addDirectives(url);
          } catch (error) {
            this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
          }
        }
        // track not retrieved yet, or live playlist we need to (re)load it
        this.log(`loading audio-track playlist ${id} "${audioTrack.name}" lang:${audioTrack.lang} group:${groupId}`);
        this.clearTimer();
        this.hls.trigger(Events$1.AUDIO_TRACK_LOADING, {
          url,
          id,
          groupId,
          deliveryDirectives: hlsUrlParameters || null
        });
      }
    }
  }

  const TICK_INTERVAL$1 = 500; // how often to tick in ms

  class SubtitleStreamController extends BaseStreamController {
    constructor(hls, fragmentTracker, keyLoader) {
      super(hls, fragmentTracker, keyLoader, '[subtitle-stream-controller]', PlaylistLevelType.SUBTITLE);
      this.currentTrackId = -1;
      this.tracksBuffered = [];
      this.mainDetails = null;
      this._registerListeners();
    }
    onHandlerDestroying() {
      this._unregisterListeners();
      super.onHandlerDestroying();
      this.mainDetails = null;
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events$1.ERROR, this.onError, this);
      hls.on(Events$1.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.on(Events$1.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
      hls.on(Events$1.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.on(Events$1.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
      hls.on(Events$1.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.on(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events$1.ERROR, this.onError, this);
      hls.off(Events$1.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.off(Events$1.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
      hls.off(Events$1.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.off(Events$1.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
      hls.off(Events$1.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.off(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    startLoad(startPosition) {
      this.stopLoad();
      this.state = State.IDLE;
      this.setInterval(TICK_INTERVAL$1);
      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
      this.tick();
    }
    onManifestLoading() {
      this.mainDetails = null;
      this.fragmentTracker.removeAllFragments();
    }
    onMediaDetaching() {
      this.tracksBuffered = [];
      super.onMediaDetaching();
    }
    onLevelLoaded(event, data) {
      this.mainDetails = data.details;
    }
    onSubtitleFragProcessed(event, data) {
      const {
        frag,
        success
      } = data;
      this.fragPrevious = frag;
      this.state = State.IDLE;
      if (!success) {
        return;
      }
      const buffered = this.tracksBuffered[this.currentTrackId];
      if (!buffered) {
        return;
      }

      // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo
      // so we can re-use the logic used to detect how much has been buffered
      let timeRange;
      const fragStart = frag.start;
      for (let i = 0; i < buffered.length; i++) {
        if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
          timeRange = buffered[i];
          break;
        }
      }
      const fragEnd = frag.start + frag.duration;
      if (timeRange) {
        timeRange.end = fragEnd;
      } else {
        timeRange = {
          start: fragStart,
          end: fragEnd
        };
        buffered.push(timeRange);
      }
      this.fragmentTracker.fragBuffered(frag);
      this.fragBufferedComplete(frag, null);
    }
    onBufferFlushing(event, data) {
      const {
        startOffset,
        endOffset
      } = data;
      if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {
        const endOffsetSubtitles = endOffset - 1;
        if (endOffsetSubtitles <= 0) {
          return;
        }
        data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);
        this.tracksBuffered.forEach(buffered => {
          for (let i = 0; i < buffered.length;) {
            if (buffered[i].end <= endOffsetSubtitles) {
              buffered.shift();
              continue;
            } else if (buffered[i].start < endOffsetSubtitles) {
              buffered[i].start = endOffsetSubtitles;
            } else {
              break;
            }
            i++;
          }
        });
        this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);
      }
    }
    onFragBuffered(event, data) {
      if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {
        var _this$media;
        if ((_this$media = this.media) != null && _this$media.buffered.length) {
          this.loadedmetadata = true;
        }
      }
    }

    // If something goes wrong, proceed to next frag, if we were processing one.
    onError(event, data) {
      const frag = data.frag;
      if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {
        if (data.details === ErrorDetails.FRAG_GAP) {
          this.fragmentTracker.fragBuffered(frag, true);
        }
        if (this.fragCurrent) {
          this.fragCurrent.abortRequests();
        }
        if (this.state !== State.STOPPED) {
          this.state = State.IDLE;
        }
      }
    }

    // Got all new subtitle levels.
    onSubtitleTracksUpdated(event, {
      subtitleTracks
    }) {
      if (this.levels && subtitleOptionsIdentical(this.levels, subtitleTracks)) {
        this.levels = subtitleTracks.map(mediaPlaylist => new Level(mediaPlaylist));
        return;
      }
      this.tracksBuffered = [];
      this.levels = subtitleTracks.map(mediaPlaylist => {
        const level = new Level(mediaPlaylist);
        this.tracksBuffered[level.id] = [];
        return level;
      });
      this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);
      this.fragPrevious = null;
      this.mediaBuffer = null;
    }
    onSubtitleTrackSwitch(event, data) {
      var _this$levels;
      this.currentTrackId = data.id;
      if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {
        this.clearInterval();
        return;
      }

      // Check if track has the necessary details to load fragments
      const currentTrack = this.levels[this.currentTrackId];
      if (currentTrack != null && currentTrack.details) {
        this.mediaBuffer = this.mediaBufferTimeRanges;
      } else {
        this.mediaBuffer = null;
      }
      if (currentTrack) {
        this.setInterval(TICK_INTERVAL$1);
      }
    }

    // Got a new set of subtitle fragments.
    onSubtitleTrackLoaded(event, data) {
      var _track$details;
      const {
        currentTrackId,
        levels
      } = this;
      const {
        details: newDetails,
        id: trackId
      } = data;
      if (!levels) {
        this.warn(`Subtitle tracks were reset while loading level ${trackId}`);
        return;
      }
      const track = levels[trackId];
      if (trackId >= levels.length || !track) {
        return;
      }
      this.log(`Subtitle track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''},duration:${newDetails.totalduration}`);
      this.mediaBuffer = this.mediaBufferTimeRanges;
      let sliding = 0;
      if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
        const mainDetails = this.mainDetails;
        if (newDetails.deltaUpdateFailed || !mainDetails) {
          return;
        }
        const mainSlidingStartFragment = mainDetails.fragments[0];
        if (!track.details) {
          if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
            alignMediaPlaylistByPDT(newDetails, mainDetails);
            sliding = newDetails.fragments[0].start;
          } else if (mainSlidingStartFragment) {
            // line up live playlist with main so that fragments in range are loaded
            sliding = mainSlidingStartFragment.start;
            addSliding(newDetails, sliding);
          }
        } else {
          var _this$levelLastLoaded;
          sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);
          if (sliding === 0 && mainSlidingStartFragment) {
            // realign with main when there is no overlap with last refresh
            sliding = mainSlidingStartFragment.start;
            addSliding(newDetails, sliding);
          }
        }
      }
      track.details = newDetails;
      this.levelLastLoaded = track;
      if (trackId !== currentTrackId) {
        return;
      }
      if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
        this.setStartPosition(this.mainDetails || newDetails, sliding);
      }

      // trigger handler right now
      this.tick();

      // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload
      if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {
        const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);
        if (!foundFrag) {
          this.warn('Subtitle playlist not aligned with playback');
          track.details = undefined;
        }
      }
    }
    _handleFragmentLoadComplete(fragLoadedData) {
      const {
        frag,
        payload
      } = fragLoadedData;
      const decryptData = frag.decryptdata;
      const hls = this.hls;
      if (this.fragContextChanged(frag)) {
        return;
      }
      // check to see if the payload needs to be decrypted
      if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {
        const startTime = performance.now();
        // decrypt the subtitles
        this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(err => {
          hls.trigger(Events$1.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_DECRYPT_ERROR,
            fatal: false,
            error: err,
            reason: err.message,
            frag
          });
          throw err;
        }).then(decryptedData => {
          const endTime = performance.now();
          hls.trigger(Events$1.FRAG_DECRYPTED, {
            frag,
            payload: decryptedData,
            stats: {
              tstart: startTime,
              tdecrypt: endTime
            }
          });
        }).catch(err => {
          this.warn(`${err.name}: ${err.message}`);
          this.state = State.IDLE;
        });
      }
    }
    doTick() {
      if (!this.media) {
        this.state = State.IDLE;
        return;
      }
      if (this.state === State.IDLE) {
        const {
          currentTrackId,
          levels
        } = this;
        const track = levels == null ? void 0 : levels[currentTrackId];
        if (!track || !levels.length || !track.details) {
          return;
        }
        const {
          config
        } = this;
        const currentTime = this.getLoadPosition();
        const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);
        const {
          end: targetBufferTime,
          len: bufferLen
        } = bufferedInfo;
        const mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);
        const trackDetails = track.details;
        const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len) + trackDetails.levelTargetDuration;
        if (bufferLen > maxBufLen) {
          return;
        }
        const fragments = trackDetails.fragments;
        const fragLen = fragments.length;
        const end = trackDetails.edge;
        let foundFrag = null;
        const fragPrevious = this.fragPrevious;
        if (targetBufferTime < end) {
          const tolerance = config.maxFragLookUpTolerance;
          const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;
          foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);
          if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {
            foundFrag = fragments[0];
          }
        } else {
          foundFrag = fragments[fragLen - 1];
        }
        if (!foundFrag) {
          return;
        }
        foundFrag = this.mapToInitFragWhenRequired(foundFrag);
        if (foundFrag.sn !== 'initSegment') {
          // Load earlier fragment in same discontinuity to make up for misaligned playlists and cues that extend beyond end of segment
          const curSNIdx = foundFrag.sn - trackDetails.startSN;
          const prevFrag = fragments[curSNIdx - 1];
          if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {
            foundFrag = prevFrag;
          }
        }
        if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {
          // only load if fragment is not loaded
          this.loadFragment(foundFrag, track, targetBufferTime);
        }
      }
    }
    getMaxBufferLength(mainBufferLength) {
      const maxConfigBuffer = super.getMaxBufferLength();
      if (!mainBufferLength) {
        return maxConfigBuffer;
      }
      return Math.max(maxConfigBuffer, mainBufferLength);
    }
    loadFragment(frag, level, targetBufferTime) {
      this.fragCurrent = frag;
      if (frag.sn === 'initSegment') {
        this._loadInitSegment(frag, level);
      } else {
        this.startFragRequested = true;
        super.loadFragment(frag, level, targetBufferTime);
      }
    }
    get mediaBufferTimeRanges() {
      return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);
    }
  }
  class BufferableInstance {
    constructor(timeranges) {
      this.buffered = void 0;
      const getRange = (name, index, length) => {
        index = index >>> 0;
        if (index > length - 1) {
          throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index}) is greater than the maximum bound (${length})`);
        }
        return timeranges[index][name];
      };
      this.buffered = {
        get length() {
          return timeranges.length;
        },
        end(index) {
          return getRange('end', index, timeranges.length);
        },
        start(index) {
          return getRange('start', index, timeranges.length);
        }
      };
    }
  }

  class SubtitleTrackController extends BasePlaylistController {
    constructor(hls) {
      super(hls, '[subtitle-track-controller]');
      this.media = null;
      this.tracks = [];
      this.groupIds = null;
      this.tracksInGroup = [];
      this.trackId = -1;
      this.currentTrack = null;
      this.selectDefaultTrack = true;
      this.queuedDefaultTrack = -1;
      this.asyncPollTrackChange = () => this.pollTrackChange(0);
      this.useTextTrackPolling = false;
      this.subtitlePollingInterval = -1;
      this._subtitleDisplay = true;
      this.onTextTracksChanged = () => {
        if (!this.useTextTrackPolling) {
          self.clearInterval(this.subtitlePollingInterval);
        }
        // Media is undefined when switching streams via loadSource()
        if (!this.media || !this.hls.config.renderTextTracksNatively) {
          return;
        }
        let textTrack = null;
        const tracks = filterSubtitleTracks(this.media.textTracks);
        for (let i = 0; i < tracks.length; i++) {
          if (tracks[i].mode === 'hidden') {
            // Do not break in case there is a following track with showing.
            textTrack = tracks[i];
          } else if (tracks[i].mode === 'showing') {
            textTrack = tracks[i];
            break;
          }
        }

        // Find internal track index for TextTrack
        const trackId = this.findTrackForTextTrack(textTrack);
        if (this.subtitleTrack !== trackId) {
          this.setSubtitleTrack(trackId);
        }
      };
      this.registerListeners();
    }
    destroy() {
      this.unregisterListeners();
      this.tracks.length = 0;
      this.tracksInGroup.length = 0;
      this.currentTrack = null;
      this.onTextTracksChanged = this.asyncPollTrackChange = null;
      super.destroy();
    }
    get subtitleDisplay() {
      return this._subtitleDisplay;
    }
    set subtitleDisplay(value) {
      this._subtitleDisplay = value;
      if (this.trackId > -1) {
        this.toggleTrackModes();
      }
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events$1.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events$1.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.on(Events$1.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.on(Events$1.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events$1.LEVEL_LOADING, this.onLevelLoading, this);
      hls.off(Events$1.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.off(Events$1.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.off(Events$1.ERROR, this.onError, this);
    }

    // Listen for subtitle track change, then extract the current track ID.
    onMediaAttached(event, data) {
      this.media = data.media;
      if (!this.media) {
        return;
      }
      if (this.queuedDefaultTrack > -1) {
        this.subtitleTrack = this.queuedDefaultTrack;
        this.queuedDefaultTrack = -1;
      }
      this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);
      if (this.useTextTrackPolling) {
        this.pollTrackChange(500);
      } else {
        this.media.textTracks.addEventListener('change', this.asyncPollTrackChange);
      }
    }
    pollTrackChange(timeout) {
      self.clearInterval(this.subtitlePollingInterval);
      this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);
    }
    onMediaDetaching() {
      if (!this.media) {
        return;
      }
      self.clearInterval(this.subtitlePollingInterval);
      if (!this.useTextTrackPolling) {
        this.media.textTracks.removeEventListener('change', this.asyncPollTrackChange);
      }
      if (this.trackId > -1) {
        this.queuedDefaultTrack = this.trackId;
      }
      const textTracks = filterSubtitleTracks(this.media.textTracks);
      // Clear loaded cues on media detachment from tracks
      textTracks.forEach(track => {
        clearCurrentCues(track);
      });
      // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.
      this.subtitleTrack = -1;
      this.media = null;
    }
    onManifestLoading() {
      this.tracks = [];
      this.groupIds = null;
      this.tracksInGroup = [];
      this.trackId = -1;
      this.currentTrack = null;
      this.selectDefaultTrack = true;
    }

    // Fired whenever a new manifest is loaded.
    onManifestParsed(event, data) {
      this.tracks = data.subtitleTracks;
    }
    onSubtitleTrackLoaded(event, data) {
      const {
        id,
        groupId,
        details
      } = data;
      const trackInActiveGroup = this.tracksInGroup[id];
      if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
        this.warn(`Subtitle track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);
        return;
      }
      const curDetails = trackInActiveGroup.details;
      trackInActiveGroup.details = data.details;
      this.log(`Subtitle track ${id} "${trackInActiveGroup.name}" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);
      if (id === this.trackId) {
        this.playlistLoaded(id, data, curDetails);
      }
    }
    onLevelLoading(event, data) {
      this.switchLevel(data.level);
    }
    onLevelSwitching(event, data) {
      this.switchLevel(data.level);
    }
    switchLevel(levelIndex) {
      const levelInfo = this.hls.levels[levelIndex];
      if (!levelInfo) {
        return;
      }
      const subtitleGroups = levelInfo.subtitleGroups || null;
      const currentGroups = this.groupIds;
      let currentTrack = this.currentTrack;
      if (!subtitleGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (subtitleGroups == null ? void 0 : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some(groupId => (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {
        this.groupIds = subtitleGroups;
        this.trackId = -1;
        this.currentTrack = null;
        const subtitleTracks = this.tracks.filter(track => !subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1);
        if (subtitleTracks.length) {
          // Disable selectDefaultTrack if there are no default tracks
          if (this.selectDefaultTrack && !subtitleTracks.some(track => track.default)) {
            this.selectDefaultTrack = false;
          }
          // track.id should match hls.audioTracks index
          subtitleTracks.forEach((track, i) => {
            track.id = i;
          });
        } else if (!currentTrack && !this.tracksInGroup.length) {
          // Do not dispatch SUBTITLE_TRACKS_UPDATED when there were and are no tracks
          return;
        }
        this.tracksInGroup = subtitleTracks;

        // Find preferred track
        const subtitlePreference = this.hls.config.subtitlePreference;
        if (!currentTrack && subtitlePreference) {
          this.selectDefaultTrack = false;
          const groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);
          if (groupIndex > -1) {
            currentTrack = subtitleTracks[groupIndex];
          } else {
            const allIndex = findMatchingOption(subtitlePreference, this.tracks);
            currentTrack = this.tracks[allIndex];
          }
        }

        // Select initial track
        let trackId = this.findTrackId(currentTrack);
        if (trackId === -1 && currentTrack) {
          trackId = this.findTrackId(null);
        }

        // Dispatch events and load track if needed
        const subtitleTracksUpdated = {
          subtitleTracks
        };
        this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in "${subtitleGroups == null ? void 0 : subtitleGroups.join(',')}" group-id`);
        this.hls.trigger(Events$1.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);
        if (trackId !== -1 && this.trackId === -1) {
          this.setSubtitleTrack(trackId);
        }
      } else if (this.shouldReloadPlaylist(currentTrack)) {
        // Retry playlist loading if no playlist is or has been loaded yet
        this.setSubtitleTrack(this.trackId);
      }
    }
    findTrackId(currentTrack) {
      const tracks = this.tracksInGroup;
      const selectDefault = this.selectDefaultTrack;
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];
        if (selectDefault && !track.default || !selectDefault && !currentTrack) {
          continue;
        }
        if (!currentTrack || matchesOption(track, currentTrack)) {
          return i;
        }
      }
      if (currentTrack) {
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {
            return i;
          }
        }
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE'])) {
            return i;
          }
        }
      }
      return -1;
    }
    findTrackForTextTrack(textTrack) {
      if (textTrack) {
        const tracks = this.tracksInGroup;
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          if (subtitleTrackMatchesTextTrack(track, textTrack)) {
            return i;
          }
        }
      }
      return -1;
    }
    onError(event, data) {
      if (data.fatal || !data.context) {
        return;
      }
      if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {
        this.checkRetry(data);
      }
    }
    get allSubtitleTracks() {
      return this.tracks;
    }

    /** get alternate subtitle tracks list from playlist **/
    get subtitleTracks() {
      return this.tracksInGroup;
    }

    /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/
    get subtitleTrack() {
      return this.trackId;
    }
    set subtitleTrack(newId) {
      this.selectDefaultTrack = false;
      this.setSubtitleTrack(newId);
    }
    setSubtitleOption(subtitleOption) {
      this.hls.config.subtitlePreference = subtitleOption;
      if (subtitleOption) {
        const allSubtitleTracks = this.allSubtitleTracks;
        this.selectDefaultTrack = false;
        if (allSubtitleTracks.length) {
          // First see if current option matches (no switch op)
          const currentTrack = this.currentTrack;
          if (currentTrack && matchesOption(subtitleOption, currentTrack)) {
            return currentTrack;
          }
          // Find option in current group
          const groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);
          if (groupIndex > -1) {
            const track = this.tracksInGroup[groupIndex];
            this.setSubtitleTrack(groupIndex);
            return track;
          } else if (currentTrack) {
            // If this is not the initial selection return null
            // option should have matched one in active group
            return null;
          } else {
            // Find the option in all tracks for initial selection
            const allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);
            if (allIndex > -1) {
              return allSubtitleTracks[allIndex];
            }
          }
        }
      }
      return null;
    }
    loadPlaylist(hlsUrlParameters) {
      super.loadPlaylist();
      const currentTrack = this.currentTrack;
      if (this.shouldLoadPlaylist(currentTrack) && currentTrack) {
        const id = currentTrack.id;
        const groupId = currentTrack.groupId;
        let url = currentTrack.url;
        if (hlsUrlParameters) {
          try {
            url = hlsUrlParameters.addDirectives(url);
          } catch (error) {
            this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
          }
        }
        this.log(`Loading subtitle playlist for id ${id}`);
        this.hls.trigger(Events$1.SUBTITLE_TRACK_LOADING, {
          url,
          id,
          groupId,
          deliveryDirectives: hlsUrlParameters || null
        });
      }
    }

    /**
     * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
     * This operates on the DOM textTracks.
     * A value of -1 will disable all subtitle tracks.
     */
    toggleTrackModes() {
      const {
        media
      } = this;
      if (!media) {
        return;
      }
      const textTracks = filterSubtitleTracks(media.textTracks);
      const currentTrack = this.currentTrack;
      let nextTrack;
      if (currentTrack) {
        nextTrack = textTracks.filter(textTrack => subtitleTrackMatchesTextTrack(currentTrack, textTrack))[0];
        if (!nextTrack) {
          this.warn(`Unable to find subtitle TextTrack with name "${currentTrack.name}" and language "${currentTrack.lang}"`);
        }
      }
      [].slice.call(textTracks).forEach(track => {
        if (track.mode !== 'disabled' && track !== nextTrack) {
          track.mode = 'disabled';
        }
      });
      if (nextTrack) {
        const mode = this.subtitleDisplay ? 'showing' : 'hidden';
        if (nextTrack.mode !== mode) {
          nextTrack.mode = mode;
        }
      }
    }

    /**
     * This method is responsible for validating the subtitle index and periodically reloading if live.
     * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
     */
    setSubtitleTrack(newId) {
      const tracks = this.tracksInGroup;

      // setting this.subtitleTrack will trigger internal logic
      // if media has not been attached yet, it will fail
      // we keep a reference to the default track id
      // and we'll set subtitleTrack when onMediaAttached is triggered
      if (!this.media) {
        this.queuedDefaultTrack = newId;
        return;
      }

      // exit if track id as already set or invalid
      if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {
        this.warn(`Invalid subtitle track id: ${newId}`);
        return;
      }

      // stopping live reloading timer if any
      this.clearTimer();
      this.selectDefaultTrack = false;
      const lastTrack = this.currentTrack;
      const track = tracks[newId] || null;
      this.trackId = newId;
      this.currentTrack = track;
      this.toggleTrackModes();
      if (!track) {
        // switch to -1
        this.hls.trigger(Events$1.SUBTITLE_TRACK_SWITCH, {
          id: newId
        });
        return;
      }
      const trackLoaded = !!track.details && !track.details.live;
      if (newId === this.trackId && track === lastTrack && trackLoaded) {
        return;
      }
      this.log(`Switching to subtitle-track ${newId}` + (track ? ` "${track.name}" lang:${track.lang} group:${track.groupId}` : ''));
      const {
        id,
        groupId = '',
        name,
        type,
        url
      } = track;
      this.hls.trigger(Events$1.SUBTITLE_TRACK_SWITCH, {
        id,
        groupId,
        name,
        type,
        url
      });
      const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);
      this.loadPlaylist(hlsUrlParameters);
    }
  }

  class BufferOperationQueue {
    constructor(sourceBufferReference) {
      this.buffers = void 0;
      this.queues = {
        video: [],
        audio: [],
        audiovideo: []
      };
      this.buffers = sourceBufferReference;
    }
    append(operation, type, pending) {
      const queue = this.queues[type];
      queue.push(operation);
      if (queue.length === 1 && !pending) {
        this.executeNext(type);
      }
    }
    insertAbort(operation, type) {
      const queue = this.queues[type];
      queue.unshift(operation);
      this.executeNext(type);
    }
    appendBlocker(type) {
      let execute;
      const promise = new Promise(resolve => {
        execute = resolve;
      });
      const operation = {
        execute,
        onStart: () => {},
        onComplete: () => {},
        onError: () => {}
      };
      this.append(operation, type);
      return promise;
    }
    executeNext(type) {
      const queue = this.queues[type];
      if (queue.length) {
        const operation = queue[0];
        try {
          // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations
          // which do not end with this event must call _onSBUpdateEnd manually
          operation.execute();
        } catch (error) {
          logger.warn(`[buffer-operation-queue]: Exception executing "${type}" SourceBuffer operation: ${error}`);
          operation.onError(error);

          // Only shift the current operation off, otherwise the updateend handler will do this for us
          const sb = this.buffers[type];
          if (!(sb != null && sb.updating)) {
            this.shiftAndExecuteNext(type);
          }
        }
      }
    }
    shiftAndExecuteNext(type) {
      this.queues[type].shift();
      this.executeNext(type);
    }
    current(type) {
      return this.queues[type][0];
    }
  }

  const VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/;
  class BufferController {
    constructor(hls) {
      // The level details used to determine duration, target-duration and live
      this.details = null;
      // cache the self generated object url to detect hijack of video tag
      this._objectUrl = null;
      // A queue of buffer operations which require the SourceBuffer to not be updating upon execution
      this.operationQueue = void 0;
      // References to event listeners for each SourceBuffer, so that they can be referenced for event removal
      this.listeners = void 0;
      this.hls = void 0;
      // The number of BUFFER_CODEC events received before any sourceBuffers are created
      this.bufferCodecEventsExpected = 0;
      // The total number of BUFFER_CODEC events received
      this._bufferCodecEventsTotal = 0;
      // A reference to the attached media element
      this.media = null;
      // A reference to the active media source
      this.mediaSource = null;
      // Last MP3 audio chunk appended
      this.lastMpegAudioChunk = null;
      this.appendSource = void 0;
      // counters
      this.appendErrors = {
        audio: 0,
        video: 0,
        audiovideo: 0
      };
      this.tracks = {};
      this.pendingTracks = {};
      this.sourceBuffer = void 0;
      this.log = void 0;
      this.warn = void 0;
      this.error = void 0;
      this._onEndStreaming = event => {
        if (!this.hls) {
          return;
        }
        this.hls.pauseBuffering();
      };
      this._onStartStreaming = event => {
        if (!this.hls) {
          return;
        }
        this.hls.resumeBuffering();
      };
      // Keep as arrow functions so that we can directly reference these functions directly as event listeners
      this._onMediaSourceOpen = () => {
        const {
          media,
          mediaSource
        } = this;
        this.log('Media source opened');
        if (media) {
          media.removeEventListener('emptied', this._onMediaEmptied);
          this.updateMediaElementDuration();
          this.hls.trigger(Events$1.MEDIA_ATTACHED, {
            media,
            mediaSource: mediaSource
          });
        }
        if (mediaSource) {
          // once received, don't listen anymore to sourceopen event
          mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);
        }
        this.checkPendingTracks();
      };
      this._onMediaSourceClose = () => {
        this.log('Media source closed');
      };
      this._onMediaSourceEnded = () => {
        this.log('Media source ended');
      };
      this._onMediaEmptied = () => {
        const {
          mediaSrc,
          _objectUrl
        } = this;
        if (mediaSrc !== _objectUrl) {
          logger.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${mediaSrc})`);
        }
      };
      this.hls = hls;
      const logPrefix = '[buffer-controller]';
      this.appendSource = isManagedMediaSource(getMediaSource(hls.config.preferManagedMediaSource));
      this.log = logger.log.bind(logger, logPrefix);
      this.warn = logger.warn.bind(logger, logPrefix);
      this.error = logger.error.bind(logger, logPrefix);
      this._initSourceBuffer();
      this.registerListeners();
    }
    hasSourceTypes() {
      return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;
    }
    destroy() {
      this.unregisterListeners();
      this.details = null;
      this.lastMpegAudioChunk = null;
      // @ts-ignore
      this.hls = null;
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.on(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events$1.BUFFER_RESET, this.onBufferReset, this);
      hls.on(Events$1.BUFFER_APPENDING, this.onBufferAppending, this);
      hls.on(Events$1.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.on(Events$1.BUFFER_EOS, this.onBufferEos, this);
      hls.on(Events$1.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.on(Events$1.LEVEL_UPDATED, this.onLevelUpdated, this);
      hls.on(Events$1.FRAG_PARSED, this.onFragParsed, this);
      hls.on(Events$1.FRAG_CHANGED, this.onFragChanged, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events$1.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.off(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events$1.BUFFER_RESET, this.onBufferReset, this);
      hls.off(Events$1.BUFFER_APPENDING, this.onBufferAppending, this);
      hls.off(Events$1.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.off(Events$1.BUFFER_EOS, this.onBufferEos, this);
      hls.off(Events$1.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.off(Events$1.LEVEL_UPDATED, this.onLevelUpdated, this);
      hls.off(Events$1.FRAG_PARSED, this.onFragParsed, this);
      hls.off(Events$1.FRAG_CHANGED, this.onFragChanged, this);
    }
    _initSourceBuffer() {
      this.sourceBuffer = {};
      this.operationQueue = new BufferOperationQueue(this.sourceBuffer);
      this.listeners = {
        audio: [],
        video: [],
        audiovideo: []
      };
      this.appendErrors = {
        audio: 0,
        video: 0,
        audiovideo: 0
      };
      this.lastMpegAudioChunk = null;
    }
    onManifestLoading() {
      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;
      this.details = null;
    }
    onManifestParsed(event, data) {
      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
      // sourcebuffers will be created all at once when the expected nb of tracks will be reached
      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
      // it will contain the expected nb of source buffers, no need to compute it
      let codecEvents = 2;
      if (data.audio && !data.video || !data.altAudio || !true) {
        codecEvents = 1;
      }
      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;
      this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`);
    }
    onMediaAttaching(event, data) {
      const media = this.media = data.media;
      const MediaSource = getMediaSource(this.appendSource);
      if (media && MediaSource) {
        var _ms$constructor;
        const ms = this.mediaSource = new MediaSource();
        this.log(`created media source: ${(_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name}`);
        // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound
        ms.addEventListener('sourceopen', this._onMediaSourceOpen);
        ms.addEventListener('sourceended', this._onMediaSourceEnded);
        ms.addEventListener('sourceclose', this._onMediaSourceClose);
        if (this.appendSource) {
          ms.addEventListener('startstreaming', this._onStartStreaming);
          ms.addEventListener('endstreaming', this._onEndStreaming);
        }

        // cache the locally generated object url
        const objectUrl = this._objectUrl = self.URL.createObjectURL(ms);
        // link video and media Source
        if (this.appendSource) {
          try {
            media.removeAttribute('src');
            // ManagedMediaSource will not open without disableRemotePlayback set to false or source alternatives
            const MMS = self.ManagedMediaSource;
            media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;
            removeSourceChildren(media);
            addSource(media, objectUrl);
            media.load();
          } catch (error) {
            media.src = objectUrl;
          }
        } else {
          media.src = objectUrl;
        }
        media.addEventListener('emptied', this._onMediaEmptied);
      }
    }
    onMediaDetaching() {
      const {
        media,
        mediaSource,
        _objectUrl
      } = this;
      if (mediaSource) {
        this.log('media source detaching');
        if (mediaSource.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            mediaSource.endOfStream();
          } catch (err) {
            this.warn(`onMediaDetaching: ${err.message} while calling endOfStream`);
          }
        }
        // Clean up the SourceBuffers by invoking onBufferReset
        this.onBufferReset();
        mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);
        mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);
        mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);
        if (this.appendSource) {
          mediaSource.removeEventListener('startstreaming', this._onStartStreaming);
          mediaSource.removeEventListener('endstreaming', this._onEndStreaming);
        }

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (media) {
          media.removeEventListener('emptied', this._onMediaEmptied);
          if (_objectUrl) {
            self.URL.revokeObjectURL(_objectUrl);
          }

          // clean up video tag src only if it's our own url. some external libraries might
          // hijack the video tag and change its 'src' without destroying the Hls instance first
          if (this.mediaSrc === _objectUrl) {
            media.removeAttribute('src');
            if (this.appendSource) {
              removeSourceChildren(media);
            }
            media.load();
          } else {
            this.warn('media|source.src was changed by a third party - skip cleanup');
          }
        }
        this.mediaSource = null;
        this.media = null;
        this._objectUrl = null;
        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;
        this.pendingTracks = {};
        this.tracks = {};
      }
      this.hls.trigger(Events$1.MEDIA_DETACHED, undefined);
    }
    onBufferReset() {
      this.getSourceBufferTypes().forEach(type => {
        this.resetBuffer(type);
      });
      this._initSourceBuffer();
    }
    resetBuffer(type) {
      const sb = this.sourceBuffer[type];
      try {
        if (sb) {
          var _this$mediaSource;
          this.removeBufferListeners(type);
          // Synchronously remove the SB from the map before the next call in order to prevent an async function from
          // accessing it
          this.sourceBuffer[type] = undefined;
          if ((_this$mediaSource = this.mediaSource) != null && _this$mediaSource.sourceBuffers.length) {
            this.mediaSource.removeSourceBuffer(sb);
          }
        }
      } catch (err) {
        this.warn(`onBufferReset ${type}`, err);
      }
    }
    onBufferCodecs(event, data) {
      const sourceBufferCount = this.getSourceBufferTypes().length;
      const trackNames = Object.keys(data);
      trackNames.forEach(trackName => {
        if (sourceBufferCount) {
          // check if SourceBuffer codec needs to change
          const track = this.tracks[trackName];
          if (track && typeof track.buffer.changeType === 'function') {
            var _trackCodec;
            const {
              id,
              codec,
              levelCodec,
              container,
              metadata
            } = data[trackName];
            const currentCodecFull = pickMostCompleteCodecName(track.codec, track.levelCodec);
            const currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');
            let trackCodec = pickMostCompleteCodecName(codec, levelCodec);
            const nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');
            if (trackCodec && currentCodec !== nextCodec) {
              if (trackName.slice(0, 5) === 'audio') {
                trackCodec = getCodecCompatibleName(trackCodec, this.appendSource);
              }
              const mimeType = `${container};codecs=${trackCodec}`;
              this.appendChangeType(trackName, mimeType);
              this.log(`switching codec ${currentCodecFull} to ${trackCodec}`);
              this.tracks[trackName] = {
                buffer: track.buffer,
                codec,
                container,
                levelCodec,
                metadata,
                id
              };
            }
          }
        } else {
          // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
          this.pendingTracks[trackName] = data[trackName];
        }
      });

      // if sourcebuffers already created, do nothing ...
      if (sourceBufferCount) {
        return;
      }
      const bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
      if (this.bufferCodecEventsExpected !== bufferCodecEventsExpected) {
        this.log(`${bufferCodecEventsExpected} bufferCodec event(s) expected ${trackNames.join(',')}`);
        this.bufferCodecEventsExpected = bufferCodecEventsExpected;
      }
      if (this.mediaSource && this.mediaSource.readyState === 'open') {
        this.checkPendingTracks();
      }
    }
    appendChangeType(type, mimeType) {
      const {
        operationQueue
      } = this;
      const operation = {
        execute: () => {
          const sb = this.sourceBuffer[type];
          if (sb) {
            this.log(`changing ${type} sourceBuffer type to ${mimeType}`);
            sb.changeType(mimeType);
          }
          operationQueue.shiftAndExecuteNext(type);
        },
        onStart: () => {},
        onComplete: () => {},
        onError: error => {
          this.warn(`Failed to change ${type} SourceBuffer type`, error);
        }
      };
      operationQueue.append(operation, type, !!this.pendingTracks[type]);
    }
    onBufferAppending(event, eventData) {
      const {
        hls,
        operationQueue,
        tracks
      } = this;
      const {
        data,
        type,
        frag,
        part,
        chunkMeta
      } = eventData;
      const chunkStats = chunkMeta.buffering[type];
      const bufferAppendingStart = self.performance.now();
      chunkStats.start = bufferAppendingStart;
      const fragBuffering = frag.stats.buffering;
      const partBuffering = part ? part.stats.buffering : null;
      if (fragBuffering.start === 0) {
        fragBuffering.start = bufferAppendingStart;
      }
      if (partBuffering && partBuffering.start === 0) {
        partBuffering.start = bufferAppendingStart;
      }

      // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended
      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).
      // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486
      const audioTrack = tracks.audio;
      let checkTimestampOffset = false;
      if (type === 'audio' && (audioTrack == null ? void 0 : audioTrack.container) === 'audio/mpeg') {
        checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;
        this.lastMpegAudioChunk = chunkMeta;
      }
      const fragStart = frag.start;
      const operation = {
        execute: () => {
          chunkStats.executeStart = self.performance.now();
          if (checkTimestampOffset) {
            const sb = this.sourceBuffer[type];
            if (sb) {
              const delta = fragStart - sb.timestampOffset;
              if (Math.abs(delta) >= 0.1) {
                this.log(`Updating audio SourceBuffer timestampOffset to ${fragStart} (delta: ${delta}) sn: ${frag.sn})`);
                sb.timestampOffset = fragStart;
              }
            }
          }
          this.appendExecutor(data, type);
        },
        onStart: () => {
          // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);
        },
        onComplete: () => {
          // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);
          const end = self.performance.now();
          chunkStats.executeEnd = chunkStats.end = end;
          if (fragBuffering.first === 0) {
            fragBuffering.first = end;
          }
          if (partBuffering && partBuffering.first === 0) {
            partBuffering.first = end;
          }
          const {
            sourceBuffer
          } = this;
          const timeRanges = {};
          for (const type in sourceBuffer) {
            timeRanges[type] = BufferHelper.getBuffered(sourceBuffer[type]);
          }
          this.appendErrors[type] = 0;
          if (type === 'audio' || type === 'video') {
            this.appendErrors.audiovideo = 0;
          } else {
            this.appendErrors.audio = 0;
            this.appendErrors.video = 0;
          }
          this.hls.trigger(Events$1.BUFFER_APPENDED, {
            type,
            frag,
            part,
            chunkMeta,
            parent: frag.type,
            timeRanges
          });
        },
        onError: error => {
          // in case any error occured while appending, put back segment in segments table
          const event = {
            type: ErrorTypes.MEDIA_ERROR,
            parent: frag.type,
            details: ErrorDetails.BUFFER_APPEND_ERROR,
            sourceBufferName: type,
            frag,
            part,
            chunkMeta,
            error,
            err: error,
            fatal: false
          };
          if (error.code === DOMException.QUOTA_EXCEEDED_ERR) {
            // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
            // let's stop appending any segments, and report BUFFER_FULL_ERROR error
            event.details = ErrorDetails.BUFFER_FULL_ERROR;
          } else {
            const appendErrorCount = ++this.appendErrors[type];
            event.details = ErrorDetails.BUFFER_APPEND_ERROR;
            /* with UHD content, we could get loop of quota exceeded error until
              browser is able to evict some data from sourcebuffer. Retrying can help recover.
            */
            this.warn(`Failed ${appendErrorCount}/${hls.config.appendErrorMaxRetry} times to append segment in "${type}" sourceBuffer`);
            if (appendErrorCount >= hls.config.appendErrorMaxRetry) {
              event.fatal = true;
            }
          }
          hls.trigger(Events$1.ERROR, event);
        }
      };
      operationQueue.append(operation, type, !!this.pendingTracks[type]);
    }
    onBufferFlushing(event, data) {
      const {
        operationQueue
      } = this;
      const flushOperation = type => ({
        execute: this.removeExecutor.bind(this, type, data.startOffset, data.endOffset),
        onStart: () => {
          // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);
        },
        onComplete: () => {
          // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);
          this.hls.trigger(Events$1.BUFFER_FLUSHED, {
            type
          });
        },
        onError: error => {
          this.warn(`Failed to remove from ${type} SourceBuffer`, error);
        }
      });
      if (data.type) {
        operationQueue.append(flushOperation(data.type), data.type);
      } else {
        this.getSourceBufferTypes().forEach(type => {
          operationQueue.append(flushOperation(type), type);
        });
      }
    }
    onFragParsed(event, data) {
      const {
        frag,
        part
      } = data;
      const buffersAppendedTo = [];
      const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;
      if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {
        buffersAppendedTo.push('audiovideo');
      } else {
        if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {
          buffersAppendedTo.push('audio');
        }
        if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {
          buffersAppendedTo.push('video');
        }
      }
      const onUnblocked = () => {
        const now = self.performance.now();
        frag.stats.buffering.end = now;
        if (part) {
          part.stats.buffering.end = now;
        }
        const stats = part ? part.stats : frag.stats;
        this.hls.trigger(Events$1.FRAG_BUFFERED, {
          frag,
          part,
          stats,
          id: frag.type
        });
      };
      if (buffersAppendedTo.length === 0) {
        this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);
      }
      this.blockBuffers(onUnblocked, buffersAppendedTo);
    }
    onFragChanged(event, data) {
      this.trimBuffers();
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()
    // an undefined data.type will mark all buffers as EOS.
    onBufferEos(event, data) {
      const ended = this.getSourceBufferTypes().reduce((acc, type) => {
        const sb = this.sourceBuffer[type];
        if (sb && (!data.type || data.type === type)) {
          sb.ending = true;
          if (!sb.ended) {
            sb.ended = true;
            this.log(`${type} sourceBuffer now EOS`);
          }
        }
        return acc && !!(!sb || sb.ended);
      }, true);
      if (ended) {
        this.log(`Queueing mediaSource.endOfStream()`);
        this.blockBuffers(() => {
          this.getSourceBufferTypes().forEach(type => {
            const sb = this.sourceBuffer[type];
            if (sb) {
              sb.ending = false;
            }
          });
          const {
            mediaSource
          } = this;
          if (!mediaSource || mediaSource.readyState !== 'open') {
            if (mediaSource) {
              this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);
            }
            return;
          }
          this.log(`Calling mediaSource.endOfStream()`);
          // Allow this to throw and be caught by the enqueueing function
          mediaSource.endOfStream();
        });
      }
    }
    onLevelUpdated(event, {
      details
    }) {
      if (!details.fragments.length) {
        return;
      }
      this.details = details;
      if (this.getSourceBufferTypes().length) {
        this.blockBuffers(this.updateMediaElementDuration.bind(this));
      } else {
        this.updateMediaElementDuration();
      }
    }
    trimBuffers() {
      const {
        hls,
        details,
        media
      } = this;
      if (!media || details === null) {
        return;
      }
      const sourceBufferTypes = this.getSourceBufferTypes();
      if (!sourceBufferTypes.length) {
        return;
      }
      const config = hls.config;
      const currentTime = media.currentTime;
      const targetDuration = details.levelTargetDuration;

      // Support for deprecated liveBackBufferLength
      const backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;
      if (isFiniteNumber(backBufferLength) && backBufferLength > 0) {
        const maxBackBufferLength = Math.max(backBufferLength, targetDuration);
        const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;
        this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);
      }
      if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {
        const frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);
        const maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);
        const targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;
        this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);
      }
    }
    flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {
      const {
        details,
        sourceBuffer
      } = this;
      const sourceBufferTypes = this.getSourceBufferTypes();
      sourceBufferTypes.forEach(type => {
        const sb = sourceBuffer[type];
        if (sb) {
          const buffered = BufferHelper.getBuffered(sb);
          // when target buffer start exceeds actual buffer start
          if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
            this.hls.trigger(Events$1.BACK_BUFFER_REACHED, {
              bufferEnd: targetBackBufferPosition
            });

            // Support for deprecated event:
            if (details != null && details.live) {
              this.hls.trigger(Events$1.LIVE_BACK_BUFFER_REACHED, {
                bufferEnd: targetBackBufferPosition
              });
            } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {
              this.log(`Cannot flush ${type} back buffer while SourceBuffer is in ended state`);
              return;
            }
            this.hls.trigger(Events$1.BUFFER_FLUSHING, {
              startOffset: 0,
              endOffset: targetBackBufferPosition,
              type
            });
          }
        }
      });
    }
    flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {
      const {
        sourceBuffer
      } = this;
      const sourceBufferTypes = this.getSourceBufferTypes();
      sourceBufferTypes.forEach(type => {
        const sb = sourceBuffer[type];
        if (sb) {
          const buffered = BufferHelper.getBuffered(sb);
          const numBufferedRanges = buffered.length;
          // The buffer is either empty or contiguous
          if (numBufferedRanges < 2) {
            return;
          }
          const bufferStart = buffered.start(numBufferedRanges - 1);
          const bufferEnd = buffered.end(numBufferedRanges - 1);
          // No flush if we can tolerate the current buffer length or the current buffer range we would flush is contiguous with current position
          if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {
            return;
          } else if (sb.ended && currentTime - bufferEnd < 2 * targetDuration) {
            this.log(`Cannot flush ${type} front buffer while SourceBuffer is in ended state`);
            return;
          }
          this.hls.trigger(Events$1.BUFFER_FLUSHING, {
            startOffset: bufferStart,
            endOffset: Infinity,
            type
          });
        }
      });
    }

    /**
     * Update Media Source duration to current level duration or override to Infinity if configuration parameter
     * 'liveDurationInfinity` is set to `true`
     * More details: https://github.com/video-dev/hls.js/issues/355
     */
    updateMediaElementDuration() {
      if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {
        return;
      }
      const {
        details,
        hls,
        media,
        mediaSource
      } = this;
      const levelDuration = details.fragments[0].start + details.totalduration;
      const mediaDuration = media.duration;
      const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;
      if (details.live && hls.config.liveDurationInfinity) {
        // Override duration to Infinity
        mediaSource.duration = Infinity;
        this.updateSeekableRange(details);
      } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {
        // levelDuration was the last value we set.
        // not using mediaSource.duration as the browser may tweak this value
        // only update Media Source duration if its value increase, this is to avoid
        // flushing already buffered portion when switching between quality level
        this.log(`Updating Media Source duration to ${levelDuration.toFixed(3)}`);
        mediaSource.duration = levelDuration;
      }
    }
    updateSeekableRange(levelDetails) {
      const mediaSource = this.mediaSource;
      const fragments = levelDetails.fragments;
      const len = fragments.length;
      if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {
        const start = Math.max(0, fragments[0].start);
        const end = Math.max(start, start + levelDetails.totalduration);
        this.log(`Media Source duration is set to ${mediaSource.duration}. Setting seekable range to ${start}-${end}.`);
        mediaSource.setLiveSeekableRange(start, end);
      }
    }
    checkPendingTracks() {
      const {
        bufferCodecEventsExpected,
        operationQueue,
        pendingTracks
      } = this;

      // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.
      // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after
      // data has been appended to existing ones.
      // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.
      const pendingTracksCount = Object.keys(pendingTracks).length;
      if (pendingTracksCount && (!bufferCodecEventsExpected || pendingTracksCount === 2 || 'audiovideo' in pendingTracks)) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        const buffers = this.getSourceBufferTypes();
        if (buffers.length) {
          this.hls.trigger(Events$1.BUFFER_CREATED, {
            tracks: this.tracks
          });
          buffers.forEach(type => {
            operationQueue.executeNext(type);
          });
        } else {
          const error = new Error('could not create source buffer for media codec(s)');
          this.hls.trigger(Events$1.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
            fatal: true,
            error,
            reason: error.message
          });
        }
      }
    }
    createSourceBuffers(tracks) {
      const {
        sourceBuffer,
        mediaSource
      } = this;
      if (!mediaSource) {
        throw Error('createSourceBuffers called when mediaSource was null');
      }
      for (const trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var _track$levelCodec;
          const track = tracks[trackName];
          if (!track) {
            throw Error(`source buffer exists for track ${trackName}, however track does not`);
          }
          // use levelCodec as first priority unless it contains multiple comma-separated codec values
          let codec = ((_track$levelCodec = track.levelCodec) == null ? void 0 : _track$levelCodec.indexOf(',')) === -1 ? track.levelCodec : track.codec;
          if (codec) {
            if (trackName.slice(0, 5) === 'audio') {
              codec = getCodecCompatibleName(codec, this.appendSource);
            }
          }
          const mimeType = `${track.container};codecs=${codec}`;
          this.log(`creating sourceBuffer(${mimeType})`);
          try {
            const sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            const sbName = trackName;
            this.addBufferListener(sbName, 'updatestart', this._onSBUpdateStart);
            this.addBufferListener(sbName, 'updateend', this._onSBUpdateEnd);
            this.addBufferListener(sbName, 'error', this._onSBUpdateError);
            // ManagedSourceBuffer bufferedchange event
            if (this.appendSource) {
              this.addBufferListener(sbName, 'bufferedchange', (type, event) => {
                // If media was ejected check for a change. Added ranges are redundant with changes on 'updateend' event.
                const removedRanges = event.removedRanges;
                if (removedRanges != null && removedRanges.length) {
                  this.hls.trigger(Events$1.BUFFER_FLUSHED, {
                    type: trackName
                  });
                }
              });
            }
            this.tracks[trackName] = {
              buffer: sb,
              codec: codec,
              container: track.container,
              levelCodec: track.levelCodec,
              metadata: track.metadata,
              id: track.id
            };
          } catch (err) {
            this.error(`error while trying to add sourceBuffer: ${err.message}`);
            this.hls.trigger(Events$1.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,
              fatal: false,
              error: err,
              sourceBufferName: trackName,
              mimeType: mimeType
            });
          }
        }
      }
    }
    get mediaSrc() {
      var _this$media, _this$media$querySele;
      const media = ((_this$media = this.media) == null ? void 0 : (_this$media$querySele = _this$media.querySelector) == null ? void 0 : _this$media$querySele.call(_this$media, 'source')) || this.media;
      return media == null ? void 0 : media.src;
    }
    _onSBUpdateStart(type) {
      const {
        operationQueue
      } = this;
      const operation = operationQueue.current(type);
      operation.onStart();
    }
    _onSBUpdateEnd(type) {
      var _this$mediaSource2;
      if (((_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState) === 'closed') {
        this.resetBuffer(type);
        return;
      }
      const {
        operationQueue
      } = this;
      const operation = operationQueue.current(type);
      operation.onComplete();
      operationQueue.shiftAndExecuteNext(type);
    }
    _onSBUpdateError(type, event) {
      var _this$mediaSource3;
      const error = new Error(`${type} SourceBuffer error. MediaSource readyState: ${(_this$mediaSource3 = this.mediaSource) == null ? void 0 : _this$mediaSource3.readyState}`);
      this.error(`${error}`, event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event
      this.hls.trigger(Events$1.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.BUFFER_APPENDING_ERROR,
        sourceBufferName: type,
        error,
        fatal: false
      });
      // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue
      const operation = this.operationQueue.current(type);
      if (operation) {
        operation.onError(error);
      }
    }

    // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually
    removeExecutor(type, startOffset, endOffset) {
      const {
        media,
        mediaSource,
        operationQueue,
        sourceBuffer
      } = this;
      const sb = sourceBuffer[type];
      if (!media || !mediaSource || !sb) {
        this.warn(`Attempting to remove from the ${type} SourceBuffer, but it does not exist`);
        operationQueue.shiftAndExecuteNext(type);
        return;
      }
      const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;
      const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;
      const removeStart = Math.max(0, startOffset);
      const removeEnd = Math.min(endOffset, mediaDuration, msDuration);
      if (removeEnd > removeStart && (!sb.ending || sb.ended)) {
        sb.ended = false;
        this.log(`Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);
        sb.remove(removeStart, removeEnd);
      } else {
        // Cycle the queue
        operationQueue.shiftAndExecuteNext(type);
      }
    }

    // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually
    appendExecutor(data, type) {
      const sb = this.sourceBuffer[type];
      if (!sb) {
        if (!this.pendingTracks[type]) {
          throw new Error(`Attempting to append to the ${type} SourceBuffer, but it does not exist`);
        }
        return;
      }
      sb.ended = false;
      sb.appendBuffer(data);
    }

    // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises
    // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue
    // upon completion, since we already do it here
    blockBuffers(onUnblocked, buffers = this.getSourceBufferTypes()) {
      if (!buffers.length) {
        this.log('Blocking operation requested, but no SourceBuffers exist');
        Promise.resolve().then(onUnblocked);
        return;
      }
      const {
        operationQueue
      } = this;

      // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);
      const blockingOperations = buffers.map(type => operationQueue.appendBlocker(type));
      Promise.all(blockingOperations).then(() => {
        // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);
        onUnblocked();
        buffers.forEach(type => {
          const sb = this.sourceBuffer[type];
          // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to
          // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)
          // While this is a workaround, it's probably useful to have around
          if (!(sb != null && sb.updating)) {
            operationQueue.shiftAndExecuteNext(type);
          }
        });
      });
    }
    getSourceBufferTypes() {
      return Object.keys(this.sourceBuffer);
    }
    addBufferListener(type, event, fn) {
      const buffer = this.sourceBuffer[type];
      if (!buffer) {
        return;
      }
      const listener = fn.bind(this, type);
      this.listeners[type].push({
        event,
        listener
      });
      buffer.addEventListener(event, listener);
    }
    removeBufferListeners(type) {
      const buffer = this.sourceBuffer[type];
      if (!buffer) {
        return;
      }
      this.listeners[type].forEach(l => {
        buffer.removeEventListener(l.event, l.listener);
      });
    }
  }
  function removeSourceChildren(node) {
    const sourceChildren = node.querySelectorAll('source');
    [].slice.call(sourceChildren).forEach(source => {
      node.removeChild(source);
    });
  }
  function addSource(media, url) {
    const source = self.document.createElement('source');
    source.type = 'video/mp4';
    source.src = url;
    media.appendChild(source);
  }

  /**
   *
   * This code was ported from the dash.js project at:
   *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
   *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
   *
   * The original copyright appears below:
   *
   * The copyright in this software is being made available under the BSD License,
   * included below. This software may be subject to other third party and contributor
   * rights, including patent rights, and no such rights are granted under this license.
   *
   * Copyright (c) 2015-2016, DASH Industry Forum.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   *  1. Redistributions of source code must retain the above copyright notice, this
   *  list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above copyright notice,
   *  this list of conditions and the following disclaimer in the documentation and/or
   *  other materials provided with the distribution.
   *  2. Neither the name of Dash Industry Forum nor the names of its
   *  contributors may be used to endorse or promote products derived from this software
   *  without specific prior written permission.
   *
   *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
   *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   *  POSSIBILITY OF SUCH DAMAGE.
   */
  /**
   *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
   */

  const specialCea608CharsCodes = {
    0x2a: 0xe1,
    // lowercase a, acute accent
    0x5c: 0xe9,
    // lowercase e, acute accent
    0x5e: 0xed,
    // lowercase i, acute accent
    0x5f: 0xf3,
    // lowercase o, acute accent
    0x60: 0xfa,
    // lowercase u, acute accent
    0x7b: 0xe7,
    // lowercase c with cedilla
    0x7c: 0xf7,
    // division symbol
    0x7d: 0xd1,
    // uppercase N tilde
    0x7e: 0xf1,
    // lowercase n tilde
    0x7f: 0x2588,
    // Full block
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    0x80: 0xae,
    // Registered symbol (R)
    0x81: 0xb0,
    // degree sign
    0x82: 0xbd,
    // 1/2 symbol
    0x83: 0xbf,
    // Inverted (open) question mark
    0x84: 0x2122,
    // Trademark symbol (TM)
    0x85: 0xa2,
    // Cents symbol
    0x86: 0xa3,
    // Pounds sterling
    0x87: 0x266a,
    // Music 8'th note
    0x88: 0xe0,
    // lowercase a, grave accent
    0x89: 0x20,
    // transparent space (regular)
    0x8a: 0xe8,
    // lowercase e, grave accent
    0x8b: 0xe2,
    // lowercase a, circumflex accent
    0x8c: 0xea,
    // lowercase e, circumflex accent
    0x8d: 0xee,
    // lowercase i, circumflex accent
    0x8e: 0xf4,
    // lowercase o, circumflex accent
    0x8f: 0xfb,
    // lowercase u, circumflex accent
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    0x90: 0xc1,
    // capital letter A with acute
    0x91: 0xc9,
    // capital letter E with acute
    0x92: 0xd3,
    // capital letter O with acute
    0x93: 0xda,
    // capital letter U with acute
    0x94: 0xdc,
    // capital letter U with diaresis
    0x95: 0xfc,
    // lowercase letter U with diaeresis
    0x96: 0x2018,
    // opening single quote
    0x97: 0xa1,
    // inverted exclamation mark
    0x98: 0x2a,
    // asterisk
    0x99: 0x2019,
    // closing single quote
    0x9a: 0x2501,
    // box drawings heavy horizontal
    0x9b: 0xa9,
    // copyright sign
    0x9c: 0x2120,
    // Service mark
    0x9d: 0x2022,
    // (round) bullet
    0x9e: 0x201c,
    // Left double quotation mark
    0x9f: 0x201d,
    // Right double quotation mark
    0xa0: 0xc0,
    // uppercase A, grave accent
    0xa1: 0xc2,
    // uppercase A, circumflex
    0xa2: 0xc7,
    // uppercase C with cedilla
    0xa3: 0xc8,
    // uppercase E, grave accent
    0xa4: 0xca,
    // uppercase E, circumflex
    0xa5: 0xcb,
    // capital letter E with diaresis
    0xa6: 0xeb,
    // lowercase letter e with diaresis
    0xa7: 0xce,
    // uppercase I, circumflex
    0xa8: 0xcf,
    // uppercase I, with diaresis
    0xa9: 0xef,
    // lowercase i, with diaresis
    0xaa: 0xd4,
    // uppercase O, circumflex
    0xab: 0xd9,
    // uppercase U, grave accent
    0xac: 0xf9,
    // lowercase u, grave accent
    0xad: 0xdb,
    // uppercase U, circumflex
    0xae: 0xab,
    // left-pointing double angle quotation mark
    0xaf: 0xbb,
    // right-pointing double angle quotation mark
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    0xb0: 0xc3,
    // Uppercase A, tilde
    0xb1: 0xe3,
    // Lowercase a, tilde
    0xb2: 0xcd,
    // Uppercase I, acute accent
    0xb3: 0xcc,
    // Uppercase I, grave accent
    0xb4: 0xec,
    // Lowercase i, grave accent
    0xb5: 0xd2,
    // Uppercase O, grave accent
    0xb6: 0xf2,
    // Lowercase o, grave accent
    0xb7: 0xd5,
    // Uppercase O, tilde
    0xb8: 0xf5,
    // Lowercase o, tilde
    0xb9: 0x7b,
    // Open curly brace
    0xba: 0x7d,
    // Closing curly brace
    0xbb: 0x5c,
    // Backslash
    0xbc: 0x5e,
    // Caret
    0xbd: 0x5f,
    // Underscore
    0xbe: 0x7c,
    // Pipe (vertical line)
    0xbf: 0x223c,
    // Tilde operator
    0xc0: 0xc4,
    // Uppercase A, umlaut
    0xc1: 0xe4,
    // Lowercase A, umlaut
    0xc2: 0xd6,
    // Uppercase O, umlaut
    0xc3: 0xf6,
    // Lowercase o, umlaut
    0xc4: 0xdf,
    // Esszett (sharp S)
    0xc5: 0xa5,
    // Yen symbol
    0xc6: 0xa4,
    // Generic currency sign
    0xc7: 0x2503,
    // Box drawings heavy vertical
    0xc8: 0xc5,
    // Uppercase A, ring
    0xc9: 0xe5,
    // Lowercase A, ring
    0xca: 0xd8,
    // Uppercase O, stroke
    0xcb: 0xf8,
    // Lowercase o, strok
    0xcc: 0x250f,
    // Box drawings heavy down and right
    0xcd: 0x2513,
    // Box drawings heavy down and left
    0xce: 0x2517,
    // Box drawings heavy up and right
    0xcf: 0x251b // Box drawings heavy up and left
  };

  /**
   * Utils
   */
  const getCharForByte = byte => String.fromCharCode(specialCea608CharsCodes[byte] || byte);
  const NR_ROWS = 15;
  const NR_COLS = 100;
  // Tables to look up row from PAC data
  const rowsLowCh1 = {
    0x11: 1,
    0x12: 3,
    0x15: 5,
    0x16: 7,
    0x17: 9,
    0x10: 11,
    0x13: 12,
    0x14: 14
  };
  const rowsHighCh1 = {
    0x11: 2,
    0x12: 4,
    0x15: 6,
    0x16: 8,
    0x17: 10,
    0x13: 13,
    0x14: 15
  };
  const rowsLowCh2 = {
    0x19: 1,
    0x1a: 3,
    0x1d: 5,
    0x1e: 7,
    0x1f: 9,
    0x18: 11,
    0x1b: 12,
    0x1c: 14
  };
  const rowsHighCh2 = {
    0x19: 2,
    0x1a: 4,
    0x1d: 6,
    0x1e: 8,
    0x1f: 10,
    0x1b: 13,
    0x1c: 15
  };
  const backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];
  class CaptionsLogger {
    constructor() {
      this.time = null;
      this.verboseLevel = 0;
    }
    log(severity, msg) {
      if (this.verboseLevel >= severity) {
        const m = typeof msg === 'function' ? msg() : msg;
        logger.log(`${this.time} [${severity}] ${m}`);
      }
    }
  }
  const numArrayToHexArray = function numArrayToHexArray(numArray) {
    const hexArray = [];
    for (let j = 0; j < numArray.length; j++) {
      hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
  };
  class PenState {
    constructor() {
      this.foreground = 'white';
      this.underline = false;
      this.italics = false;
      this.background = 'black';
      this.flash = false;
    }
    reset() {
      this.foreground = 'white';
      this.underline = false;
      this.italics = false;
      this.background = 'black';
      this.flash = false;
    }
    setStyles(styles) {
      const attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
      for (let i = 0; i < attribs.length; i++) {
        const style = attribs[i];
        if (styles.hasOwnProperty(style)) {
          this[style] = styles[style];
        }
      }
    }
    isDefault() {
      return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
    }
    equals(other) {
      return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
    }
    copy(newPenState) {
      this.foreground = newPenState.foreground;
      this.underline = newPenState.underline;
      this.italics = newPenState.italics;
      this.background = newPenState.background;
      this.flash = newPenState.flash;
    }
    toString() {
      return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
    }
  }

  /**
   * Unicode character with styling and background.
   * @constructor
   */
  class StyledUnicodeChar {
    constructor() {
      this.uchar = ' ';
      this.penState = new PenState();
    }
    reset() {
      this.uchar = ' ';
      this.penState.reset();
    }
    setChar(uchar, newPenState) {
      this.uchar = uchar;
      this.penState.copy(newPenState);
    }
    setPenState(newPenState) {
      this.penState.copy(newPenState);
    }
    equals(other) {
      return this.uchar === other.uchar && this.penState.equals(other.penState);
    }
    copy(newChar) {
      this.uchar = newChar.uchar;
      this.penState.copy(newChar.penState);
    }
    isEmpty() {
      return this.uchar === ' ' && this.penState.isDefault();
    }
  }

  /**
   * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
   * @constructor
   */
  class Row {
    constructor(logger) {
      this.chars = [];
      this.pos = 0;
      this.currPenState = new PenState();
      this.cueStartTime = null;
      this.logger = void 0;
      for (let i = 0; i < NR_COLS; i++) {
        this.chars.push(new StyledUnicodeChar());
      }
      this.logger = logger;
    }
    equals(other) {
      for (let i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].equals(other.chars[i])) {
          return false;
        }
      }
      return true;
    }
    copy(other) {
      for (let i = 0; i < NR_COLS; i++) {
        this.chars[i].copy(other.chars[i]);
      }
    }
    isEmpty() {
      let empty = true;
      for (let i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }

    /**
     *  Set the cursor to a valid column.
     */
    setCursor(absPos) {
      if (this.pos !== absPos) {
        this.pos = absPos;
      }
      if (this.pos < 0) {
        this.logger.log(3, 'Negative cursor position ' + this.pos);
        this.pos = 0;
      } else if (this.pos > NR_COLS) {
        this.logger.log(3, 'Too large cursor position ' + this.pos);
        this.pos = NR_COLS;
      }
    }

    /**
     * Move the cursor relative to current position.
     */
    moveCursor(relPos) {
      const newPos = this.pos + relPos;
      if (relPos > 1) {
        for (let i = this.pos + 1; i < newPos + 1; i++) {
          this.chars[i].setPenState(this.currPenState);
        }
      }
      this.setCursor(newPos);
    }

    /**
     * Backspace, move one step back and clear character.
     */
    backSpace() {
      this.moveCursor(-1);
      this.chars[this.pos].setChar(' ', this.currPenState);
    }
    insertChar(byte) {
      if (byte >= 0x90) {
        // Extended char
        this.backSpace();
      }
      const char = getCharForByte(byte);
      if (this.pos >= NR_COLS) {
        this.logger.log(0, () => 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
        return;
      }
      this.chars[this.pos].setChar(char, this.currPenState);
      this.moveCursor(1);
    }
    clearFromPos(startPos) {
      let i;
      for (i = startPos; i < NR_COLS; i++) {
        this.chars[i].reset();
      }
    }
    clear() {
      this.clearFromPos(0);
      this.pos = 0;
      this.currPenState.reset();
    }
    clearToEndOfRow() {
      this.clearFromPos(this.pos);
    }
    getTextString() {
      const chars = [];
      let empty = true;
      for (let i = 0; i < NR_COLS; i++) {
        const char = this.chars[i].uchar;
        if (char !== ' ') {
          empty = false;
        }
        chars.push(char);
      }
      if (empty) {
        return '';
      } else {
        return chars.join('');
      }
    }
    setPenStyles(styles) {
      this.currPenState.setStyles(styles);
      const currChar = this.chars[this.pos];
      currChar.setPenState(this.currPenState);
    }
  }

  /**
   * Keep a CEA-608 screen of 32x15 styled characters
   * @constructor
   */
  class CaptionScreen {
    constructor(logger) {
      this.rows = [];
      this.currRow = NR_ROWS - 1;
      this.nrRollUpRows = null;
      this.lastOutputScreen = null;
      this.logger = void 0;
      for (let i = 0; i < NR_ROWS; i++) {
        this.rows.push(new Row(logger));
      }
      this.logger = logger;
    }
    reset() {
      for (let i = 0; i < NR_ROWS; i++) {
        this.rows[i].clear();
      }
      this.currRow = NR_ROWS - 1;
    }
    equals(other) {
      let equal = true;
      for (let i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].equals(other.rows[i])) {
          equal = false;
          break;
        }
      }
      return equal;
    }
    copy(other) {
      for (let i = 0; i < NR_ROWS; i++) {
        this.rows[i].copy(other.rows[i]);
      }
    }
    isEmpty() {
      let empty = true;
      for (let i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }
    backSpace() {
      const row = this.rows[this.currRow];
      row.backSpace();
    }
    clearToEndOfRow() {
      const row = this.rows[this.currRow];
      row.clearToEndOfRow();
    }

    /**
     * Insert a character (without styling) in the current row.
     */
    insertChar(char) {
      const row = this.rows[this.currRow];
      row.insertChar(char);
    }
    setPen(styles) {
      const row = this.rows[this.currRow];
      row.setPenStyles(styles);
    }
    moveCursor(relPos) {
      const row = this.rows[this.currRow];
      row.moveCursor(relPos);
    }
    setCursor(absPos) {
      this.logger.log(2, 'setCursor: ' + absPos);
      const row = this.rows[this.currRow];
      row.setCursor(absPos);
    }
    setPAC(pacData) {
      this.logger.log(2, () => 'pacData = ' + JSON.stringify(pacData));
      let newRow = pacData.row - 1;
      if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
        newRow = this.nrRollUpRows - 1;
      }

      // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
      if (this.nrRollUpRows && this.currRow !== newRow) {
        // clear all rows first
        for (let i = 0; i < NR_ROWS; i++) {
          this.rows[i].clear();
        }

        // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
        // topRowIndex - the start of rows to copy (inclusive index)
        const topRowIndex = this.currRow + 1 - this.nrRollUpRows;
        // We only copy if the last position was already shown.
        // We use the cueStartTime value to check this.
        const lastOutputScreen = this.lastOutputScreen;
        if (lastOutputScreen) {
          const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
          const time = this.logger.time;
          if (prevLineTime !== null && time !== null && prevLineTime < time) {
            for (let i = 0; i < this.nrRollUpRows; i++) {
              this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);
            }
          }
        }
      }
      this.currRow = newRow;
      const row = this.rows[this.currRow];
      if (pacData.indent !== null) {
        const indent = pacData.indent;
        const prevPos = Math.max(indent - 1, 0);
        row.setCursor(pacData.indent);
        pacData.color = row.chars[prevPos].penState.foreground;
      }
      const styles = {
        foreground: pacData.color,
        underline: pacData.underline,
        italics: pacData.italics,
        background: 'black',
        flash: false
      };
      this.setPen(styles);
    }

    /**
     * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
     */
    setBkgData(bkgData) {
      this.logger.log(2, () => 'bkgData = ' + JSON.stringify(bkgData));
      this.backSpace();
      this.setPen(bkgData);
      this.insertChar(0x20); // Space
    }
    setRollUpRows(nrRows) {
      this.nrRollUpRows = nrRows;
    }
    rollUp() {
      if (this.nrRollUpRows === null) {
        this.logger.log(3, 'roll_up but nrRollUpRows not set yet');
        return; // Not properly setup
      }
      this.logger.log(1, () => this.getDisplayText());
      const topRowIndex = this.currRow + 1 - this.nrRollUpRows;
      const topRow = this.rows.splice(topRowIndex, 1)[0];
      topRow.clear();
      this.rows.splice(this.currRow, 0, topRow);
      this.logger.log(2, 'Rolling up');
      // this.logger.log(VerboseLevel.TEXT, this.get_display_text())
    }

    /**
     * Get all non-empty rows with as unicode text.
     */
    getDisplayText(asOneRow) {
      asOneRow = asOneRow || false;
      const displayText = [];
      let text = '';
      let rowNr = -1;
      for (let i = 0; i < NR_ROWS; i++) {
        const rowText = this.rows[i].getTextString();
        if (rowText) {
          rowNr = i + 1;
          if (asOneRow) {
            displayText.push('Row ' + rowNr + ": '" + rowText + "'");
          } else {
            displayText.push(rowText.trim());
          }
        }
      }
      if (displayText.length > 0) {
        if (asOneRow) {
          text = '[' + displayText.join(' | ') + ']';
        } else {
          text = displayText.join('\n');
        }
      }
      return text;
    }
    getTextAndFormat() {
      return this.rows;
    }
  }

  // var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

  class Cea608Channel {
    constructor(channelNumber, outputFilter, logger) {
      this.chNr = void 0;
      this.outputFilter = void 0;
      this.mode = void 0;
      this.verbose = void 0;
      this.displayedMemory = void 0;
      this.nonDisplayedMemory = void 0;
      this.lastOutputScreen = void 0;
      this.currRollUpRow = void 0;
      this.writeScreen = void 0;
      this.cueStartTime = void 0;
      this.logger = void 0;
      this.chNr = channelNumber;
      this.outputFilter = outputFilter;
      this.mode = null;
      this.verbose = 0;
      this.displayedMemory = new CaptionScreen(logger);
      this.nonDisplayedMemory = new CaptionScreen(logger);
      this.lastOutputScreen = new CaptionScreen(logger);
      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
      this.writeScreen = this.displayedMemory;
      this.mode = null;
      this.cueStartTime = null; // Keeps track of where a cue started.
      this.logger = logger;
    }
    reset() {
      this.mode = null;
      this.displayedMemory.reset();
      this.nonDisplayedMemory.reset();
      this.lastOutputScreen.reset();
      this.outputFilter.reset();
      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
      this.writeScreen = this.displayedMemory;
      this.mode = null;
      this.cueStartTime = null;
    }
    getHandler() {
      return this.outputFilter;
    }
    setHandler(newHandler) {
      this.outputFilter = newHandler;
    }
    setPAC(pacData) {
      this.writeScreen.setPAC(pacData);
    }
    setBkgData(bkgData) {
      this.writeScreen.setBkgData(bkgData);
    }
    setMode(newMode) {
      if (newMode === this.mode) {
        return;
      }
      this.mode = newMode;
      this.logger.log(2, () => 'MODE=' + newMode);
      if (this.mode === 'MODE_POP-ON') {
        this.writeScreen = this.nonDisplayedMemory;
      } else {
        this.writeScreen = this.displayedMemory;
        this.writeScreen.reset();
      }
      if (this.mode !== 'MODE_ROLL-UP') {
        this.displayedMemory.nrRollUpRows = null;
        this.nonDisplayedMemory.nrRollUpRows = null;
      }
      this.mode = newMode;
    }
    insertChars(chars) {
      for (let i = 0; i < chars.length; i++) {
        this.writeScreen.insertChar(chars[i]);
      }
      const screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
      this.logger.log(2, () => screen + ': ' + this.writeScreen.getDisplayText(true));
      if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
        this.logger.log(1, () => 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
        this.outputDataUpdate();
      }
    }
    ccRCL() {
      // Resume Caption Loading (switch mode to Pop On)
      this.logger.log(2, 'RCL - Resume Caption Loading');
      this.setMode('MODE_POP-ON');
    }
    ccBS() {
      // BackSpace
      this.logger.log(2, 'BS - BackSpace');
      if (this.mode === 'MODE_TEXT') {
        return;
      }
      this.writeScreen.backSpace();
      if (this.writeScreen === this.displayedMemory) {
        this.outputDataUpdate();
      }
    }
    ccAOF() {
      // Reserved (formerly Alarm Off)
    }
    ccAON() {
      // Reserved (formerly Alarm On)
    }
    ccDER() {
      // Delete to End of Row
      this.logger.log(2, 'DER- Delete to End of Row');
      this.writeScreen.clearToEndOfRow();
      this.outputDataUpdate();
    }
    ccRU(nrRows) {
      // Roll-Up Captions-2,3,or 4 Rows
      this.logger.log(2, 'RU(' + nrRows + ') - Roll Up');
      this.writeScreen = this.displayedMemory;
      this.setMode('MODE_ROLL-UP');
      this.writeScreen.setRollUpRows(nrRows);
    }
    ccFON() {
      // Flash On
      this.logger.log(2, 'FON - Flash On');
      this.writeScreen.setPen({
        flash: true
      });
    }
    ccRDC() {
      // Resume Direct Captioning (switch mode to PaintOn)
      this.logger.log(2, 'RDC - Resume Direct Captioning');
      this.setMode('MODE_PAINT-ON');
    }
    ccTR() {
      // Text Restart in text mode (not supported, however)
      this.logger.log(2, 'TR');
      this.setMode('MODE_TEXT');
    }
    ccRTD() {
      // Resume Text Display in Text mode (not supported, however)
      this.logger.log(2, 'RTD');
      this.setMode('MODE_TEXT');
    }
    ccEDM() {
      // Erase Displayed Memory
      this.logger.log(2, 'EDM - Erase Displayed Memory');
      this.displayedMemory.reset();
      this.outputDataUpdate(true);
    }
    ccCR() {
      // Carriage Return
      this.logger.log(2, 'CR - Carriage Return');
      this.writeScreen.rollUp();
      this.outputDataUpdate(true);
    }
    ccENM() {
      // Erase Non-Displayed Memory
      this.logger.log(2, 'ENM - Erase Non-displayed Memory');
      this.nonDisplayedMemory.reset();
    }
    ccEOC() {
      // End of Caption (Flip Memories)
      this.logger.log(2, 'EOC - End Of Caption');
      if (this.mode === 'MODE_POP-ON') {
        const tmp = this.displayedMemory;
        this.displayedMemory = this.nonDisplayedMemory;
        this.nonDisplayedMemory = tmp;
        this.writeScreen = this.nonDisplayedMemory;
        this.logger.log(1, () => 'DISP: ' + this.displayedMemory.getDisplayText());
      }
      this.outputDataUpdate(true);
    }
    ccTO(nrCols) {
      // Tab Offset 1,2, or 3 columns
      this.logger.log(2, 'TO(' + nrCols + ') - Tab Offset');
      this.writeScreen.moveCursor(nrCols);
    }
    ccMIDROW(secondByte) {
      // Parse MIDROW command
      const styles = {
        flash: false
      };
      styles.underline = secondByte % 2 === 1;
      styles.italics = secondByte >= 0x2e;
      if (!styles.italics) {
        const colorIndex = Math.floor(secondByte / 2) - 0x10;
        const colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
        styles.foreground = colors[colorIndex];
      } else {
        styles.foreground = 'white';
      }
      this.logger.log(2, 'MIDROW: ' + JSON.stringify(styles));
      this.writeScreen.setPen(styles);
    }
    outputDataUpdate(dispatch = false) {
      const time = this.logger.time;
      if (time === null) {
        return;
      }
      if (this.outputFilter) {
        if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
          // Start of a new cue
          this.cueStartTime = time;
        } else {
          if (!this.displayedMemory.equals(this.lastOutputScreen)) {
            this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);
            if (dispatch && this.outputFilter.dispatchCue) {
              this.outputFilter.dispatchCue();
            }
            this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;
          }
        }
        this.lastOutputScreen.copy(this.displayedMemory);
      }
    }
    cueSplitAtTime(t) {
      if (this.outputFilter) {
        if (!this.displayedMemory.isEmpty()) {
          if (this.outputFilter.newCue) {
            this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
          }
          this.cueStartTime = t;
        }
      }
    }
  }

  // Will be 1 or 2 when parsing captions

  class Cea608Parser {
    constructor(field, out1, out2) {
      this.channels = void 0;
      this.currentChannel = 0;
      this.cmdHistory = createCmdHistory();
      this.logger = void 0;
      const logger = this.logger = new CaptionsLogger();
      this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];
    }
    getHandler(channel) {
      return this.channels[channel].getHandler();
    }
    setHandler(channel, newHandler) {
      this.channels[channel].setHandler(newHandler);
    }

    /**
     * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
     */
    addData(time, byteList) {
      this.logger.time = time;
      for (let i = 0; i < byteList.length; i += 2) {
        const a = byteList[i] & 0x7f;
        const b = byteList[i + 1] & 0x7f;
        let cmdFound = false;
        let charsFound = null;
        if (a === 0 && b === 0) {
          continue;
        } else {
          this.logger.log(3, () => '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
        }
        const cmdHistory = this.cmdHistory;
        const isControlCode = a >= 0x10 && a <= 0x1f;
        if (isControlCode) {
          // Skip redundant control codes
          if (hasCmdRepeated(a, b, cmdHistory)) {
            setLastCmd(null, null, cmdHistory);
            this.logger.log(3, () => 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
            continue;
          }
          setLastCmd(a, b, this.cmdHistory);
          cmdFound = this.parseCmd(a, b);
          if (!cmdFound) {
            cmdFound = this.parseMidrow(a, b);
          }
          if (!cmdFound) {
            cmdFound = this.parsePAC(a, b);
          }
          if (!cmdFound) {
            cmdFound = this.parseBackgroundAttributes(a, b);
          }
        } else {
          setLastCmd(null, null, cmdHistory);
        }
        if (!cmdFound) {
          charsFound = this.parseChars(a, b);
          if (charsFound) {
            const currChNr = this.currentChannel;
            if (currChNr && currChNr > 0) {
              const channel = this.channels[currChNr];
              channel.insertChars(charsFound);
            } else {
              this.logger.log(2, 'No channel found yet. TEXT-MODE?');
            }
          }
        }
        if (!cmdFound && !charsFound) {
          this.logger.log(2, () => "Couldn't parse cleaned data " + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
        }
      }
    }

    /**
     * Parse Command.
     * @returns True if a command was found
     */
    parseCmd(a, b) {
      const cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;
      const cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;
      if (!(cond1 || cond2)) {
        return false;
      }
      const chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;
      const channel = this.channels[chNr];
      if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {
        if (b === 0x20) {
          channel.ccRCL();
        } else if (b === 0x21) {
          channel.ccBS();
        } else if (b === 0x22) {
          channel.ccAOF();
        } else if (b === 0x23) {
          channel.ccAON();
        } else if (b === 0x24) {
          channel.ccDER();
        } else if (b === 0x25) {
          channel.ccRU(2);
        } else if (b === 0x26) {
          channel.ccRU(3);
        } else if (b === 0x27) {
          channel.ccRU(4);
        } else if (b === 0x28) {
          channel.ccFON();
        } else if (b === 0x29) {
          channel.ccRDC();
        } else if (b === 0x2a) {
          channel.ccTR();
        } else if (b === 0x2b) {
          channel.ccRTD();
        } else if (b === 0x2c) {
          channel.ccEDM();
        } else if (b === 0x2d) {
          channel.ccCR();
        } else if (b === 0x2e) {
          channel.ccENM();
        } else if (b === 0x2f) {
          channel.ccEOC();
        }
      } else {
        // a == 0x17 || a == 0x1F
        channel.ccTO(b - 0x20);
      }
      this.currentChannel = chNr;
      return true;
    }

    /**
     * Parse midrow styling command
     */
    parseMidrow(a, b) {
      let chNr = 0;
      if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {
        if (a === 0x11) {
          chNr = 1;
        } else {
          chNr = 2;
        }
        if (chNr !== this.currentChannel) {
          this.logger.log(0, 'Mismatch channel in midrow parsing');
          return false;
        }
        const channel = this.channels[chNr];
        if (!channel) {
          return false;
        }
        channel.ccMIDROW(b);
        this.logger.log(3, () => 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
        return true;
      }
      return false;
    }

    /**
     * Parse Preable Access Codes (Table 53).
     * @returns {Boolean} Tells if PAC found
     */
    parsePAC(a, b) {
      let row;
      const case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;
      const case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;
      if (!(case1 || case2)) {
        return false;
      }
      const chNr = a <= 0x17 ? 1 : 2;
      if (b >= 0x40 && b <= 0x5f) {
        row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
      } else {
        // 0x60 <= b <= 0x7F
        row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
      }
      const channel = this.channels[chNr];
      if (!channel) {
        return false;
      }
      channel.setPAC(this.interpretPAC(row, b));
      this.currentChannel = chNr;
      return true;
    }

    /**
     * Interpret the second byte of the pac, and return the information.
     * @returns pacData with style parameters
     */
    interpretPAC(row, byte) {
      let pacIndex;
      const pacData = {
        color: null,
        italics: false,
        indent: null,
        underline: false,
        row: row
      };
      if (byte > 0x5f) {
        pacIndex = byte - 0x60;
      } else {
        pacIndex = byte - 0x40;
      }
      pacData.underline = (pacIndex & 1) === 1;
      if (pacIndex <= 0xd) {
        pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
      } else if (pacIndex <= 0xf) {
        pacData.italics = true;
        pacData.color = 'white';
      } else {
        pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
      }
      return pacData; // Note that row has zero offset. The spec uses 1.
    }

    /**
     * Parse characters.
     * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
     */
    parseChars(a, b) {
      let channelNr;
      let charCodes = null;
      let charCode1 = null;
      if (a >= 0x19) {
        channelNr = 2;
        charCode1 = a - 8;
      } else {
        channelNr = 1;
        charCode1 = a;
      }
      if (charCode1 >= 0x11 && charCode1 <= 0x13) {
        // Special character
        let oneCode;
        if (charCode1 === 0x11) {
          oneCode = b + 0x50;
        } else if (charCode1 === 0x12) {
          oneCode = b + 0x70;
        } else {
          oneCode = b + 0x90;
        }
        this.logger.log(2, () => "Special char '" + getCharForByte(oneCode) + "' in channel " + channelNr);
        charCodes = [oneCode];
      } else if (a >= 0x20 && a <= 0x7f) {
        charCodes = b === 0 ? [a] : [a, b];
      }
      if (charCodes) {
        this.logger.log(3, () => 'Char codes =  ' + numArrayToHexArray(charCodes).join(','));
      }
      return charCodes;
    }

    /**
     * Parse extended background attributes as well as new foreground color black.
     * @returns True if background attributes are found
     */
    parseBackgroundAttributes(a, b) {
      const case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;
      const case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;
      if (!(case1 || case2)) {
        return false;
      }
      let index;
      const bkgData = {};
      if (a === 0x10 || a === 0x18) {
        index = Math.floor((b - 0x20) / 2);
        bkgData.background = backgroundColors[index];
        if (b % 2 === 1) {
          bkgData.background = bkgData.background + '_semi';
        }
      } else if (b === 0x2d) {
        bkgData.background = 'transparent';
      } else {
        bkgData.foreground = 'black';
        if (b === 0x2f) {
          bkgData.underline = true;
        }
      }
      const chNr = a <= 0x17 ? 1 : 2;
      const channel = this.channels[chNr];
      channel.setBkgData(bkgData);
      return true;
    }

    /**
     * Reset state of parser and its channels.
     */
    reset() {
      for (let i = 0; i < Object.keys(this.channels).length; i++) {
        const channel = this.channels[i];
        if (channel) {
          channel.reset();
        }
      }
      setLastCmd(null, null, this.cmdHistory);
    }

    /**
     * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
     */
    cueSplitAtTime(t) {
      for (let i = 0; i < this.channels.length; i++) {
        const channel = this.channels[i];
        if (channel) {
          channel.cueSplitAtTime(t);
        }
      }
    }
  }
  function setLastCmd(a, b, cmdHistory) {
    cmdHistory.a = a;
    cmdHistory.b = b;
  }
  function hasCmdRepeated(a, b, cmdHistory) {
    return cmdHistory.a === a && cmdHistory.b === b;
  }
  function createCmdHistory() {
    return {
      a: null,
      b: null
    };
  }

  class OutputFilter {
    constructor(timelineController, trackName) {
      this.timelineController = void 0;
      this.cueRanges = [];
      this.trackName = void 0;
      this.startTime = null;
      this.endTime = null;
      this.screen = null;
      this.timelineController = timelineController;
      this.trackName = trackName;
    }
    dispatchCue() {
      if (this.startTime === null) {
        return;
      }
      this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);
      this.startTime = null;
    }
    newCue(startTime, endTime, screen) {
      if (this.startTime === null || this.startTime > startTime) {
        this.startTime = startTime;
      }
      this.endTime = endTime;
      this.screen = screen;
      this.timelineController.createCaptionsTrack(this.trackName);
    }
    reset() {
      this.cueRanges = [];
      this.startTime = null;
    }
  }

  /**
   * Copyright 2013 vtt.js Contributors
   *
   * Licensed under the Apache License, Version 2.0 (the 'License');
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an 'AS IS' BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var VTTCue$1 = (function () {
    if (optionalSelf != null && optionalSelf.VTTCue) {
      return self.VTTCue;
    }
    const AllowedDirections = ['', 'lr', 'rl'];
    const AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];
    function isAllowedValue(allowed, value) {
      if (typeof value !== 'string') {
        return false;
      }
      // necessary for assuring the generic conforms to the Array interface
      if (!Array.isArray(allowed)) {
        return false;
      }
      // reset the type so that the next narrowing works well
      const lcValue = value.toLowerCase();
      // use the allow list to narrow the type to a specific subset of strings
      if (~allowed.indexOf(lcValue)) {
        return lcValue;
      }
      return false;
    }
    function findDirectionSetting(value) {
      return isAllowedValue(AllowedDirections, value);
    }
    function findAlignSetting(value) {
      return isAllowedValue(AllowedAlignments, value);
    }
    function extend(obj, ...rest) {
      let i = 1;
      for (; i < arguments.length; i++) {
        const cobj = arguments[i];
        for (const p in cobj) {
          obj[p] = cobj[p];
        }
      }
      return obj;
    }
    function VTTCue(startTime, endTime, text) {
      const cue = this;
      const baseObj = {
        enumerable: true
      };
      /**
       * Shim implementation specific properties. These properties are not in
       * the spec.
       */

      // Lets us know when the VTTCue's data has changed in such a way that we need
      // to recompute its display state. This lets us compute its display state
      // lazily.
      cue.hasBeenReset = false;

      /**
       * VTTCue and TextTrackCue properties
       * http://dev.w3.org/html5/webvtt/#vttcue-interface
       */

      let _id = '';
      let _pauseOnExit = false;
      let _startTime = startTime;
      let _endTime = endTime;
      let _text = text;
      let _region = null;
      let _vertical = '';
      let _snapToLines = true;
      let _line = 'auto';
      let _lineAlign = 'start';
      let _position = 50;
      let _positionAlign = 'middle';
      let _size = 50;
      let _align = 'middle';
      Object.defineProperty(cue, 'id', extend({}, baseObj, {
        get: function () {
          return _id;
        },
        set: function (value) {
          _id = '' + value;
        }
      }));
      Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
        get: function () {
          return _pauseOnExit;
        },
        set: function (value) {
          _pauseOnExit = !!value;
        }
      }));
      Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
        get: function () {
          return _startTime;
        },
        set: function (value) {
          if (typeof value !== 'number') {
            throw new TypeError('Start time must be set to a number.');
          }
          _startTime = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
        get: function () {
          return _endTime;
        },
        set: function (value) {
          if (typeof value !== 'number') {
            throw new TypeError('End time must be set to a number.');
          }
          _endTime = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, 'text', extend({}, baseObj, {
        get: function () {
          return _text;
        },
        set: function (value) {
          _text = '' + value;
          this.hasBeenReset = true;
        }
      }));

      // todo: implement VTTRegion polyfill?
      Object.defineProperty(cue, 'region', extend({}, baseObj, {
        get: function () {
          return _region;
        },
        set: function (value) {
          _region = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
        get: function () {
          return _vertical;
        },
        set: function (value) {
          const setting = findDirectionSetting(value);
          // Have to check for false because the setting an be an empty string.
          if (setting === false) {
            throw new SyntaxError('An invalid or illegal string was specified.');
          }
          _vertical = setting;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
        get: function () {
          return _snapToLines;
        },
        set: function (value) {
          _snapToLines = !!value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, 'line', extend({}, baseObj, {
        get: function () {
          return _line;
        },
        set: function (value) {
          if (typeof value !== 'number' && value !== 'auto') {
            throw new SyntaxError('An invalid number or illegal string was specified.');
          }
          _line = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
        get: function () {
          return _lineAlign;
        },
        set: function (value) {
          const setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError('An invalid or illegal string was specified.');
          }
          _lineAlign = setting;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, 'position', extend({}, baseObj, {
        get: function () {
          return _position;
        },
        set: function (value) {
          if (value < 0 || value > 100) {
            throw new Error('Position must be between 0 and 100.');
          }
          _position = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
        get: function () {
          return _positionAlign;
        },
        set: function (value) {
          const setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError('An invalid or illegal string was specified.');
          }
          _positionAlign = setting;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, 'size', extend({}, baseObj, {
        get: function () {
          return _size;
        },
        set: function (value) {
          if (value < 0 || value > 100) {
            throw new Error('Size must be between 0 and 100.');
          }
          _size = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, 'align', extend({}, baseObj, {
        get: function () {
          return _align;
        },
        set: function (value) {
          const setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError('An invalid or illegal string was specified.');
          }
          _align = setting;
          this.hasBeenReset = true;
        }
      }));

      /**
       * Other <track> spec defined properties
       */

      // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
      cue.displayState = undefined;
    }

    /**
     * VTTCue methods
     */

    VTTCue.prototype.getCueAsHTML = function () {
      // Assume WebVTT.convertCueToDOMTree is on the global.
      const WebVTT = self.WebVTT;
      return WebVTT.convertCueToDOMTree(self, this.text);
    };
    // this is a polyfill hack
    return VTTCue;
  })();

  /*
   * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js
   */

  class StringDecoder {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    decode(data, options) {
      if (!data) {
        return '';
      }
      if (typeof data !== 'string') {
        throw new Error('Error - expected string data.');
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  }

  // Try to parse input as a time stamp.
  function parseTimeStamp$1(input) {
    function computeSeconds(h, m, s, f) {
      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);
    }
    const m = input.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
    if (!m) {
      return null;
    }
    if (parseFloat(m[2]) > 59) {
      // Timestamp takes the form of [hours]:[minutes].[milliseconds]
      // First position is hours as it's over 59.
      return computeSeconds(m[2], m[3], 0, m[4]);
    }
    // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3], m[4]);
  }

  // A settings object holds key/value pairs and will ignore anything but the first
  // assignment to a specific key.
  let Settings$1 = class Settings {
    constructor() {
      this.values = Object.create(null);
    }
    // Only accept the first assignment to any key.
    set(k, v) {
      if (!this.get(k) && v !== '') {
        this.values[k] = v;
      }
    }
    // Return the value for a key, or a default value.
    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
    // a number of possible default values as properties where 'defaultKey' is
    // the key of the property that will be chosen; otherwise it's assumed to be
    // a single value.
    get(k, dflt, defaultKey) {
      if (defaultKey) {
        return this.has(k) ? this.values[k] : dflt[defaultKey];
      }
      return this.has(k) ? this.values[k] : dflt;
    }
    // Check whether we have a value for a key.
    has(k) {
      return k in this.values;
    }
    // Accept a setting if its one of the given alternatives.
    alt(k, v, a) {
      for (let n = 0; n < a.length; ++n) {
        if (v === a[n]) {
          this.set(k, v);
          break;
        }
      }
    }
    // Accept a setting if its a valid (signed) integer.
    integer(k, v) {
      if (/^-?\d+$/.test(v)) {
        // integer
        this.set(k, parseInt(v, 10));
      }
    }
    // Accept a setting if its a valid percentage.
    percent(k, v) {
      if (/^([\d]{1,3})(\.[\d]*)?%$/.test(v)) {
        const percent = parseFloat(v);
        if (percent >= 0 && percent <= 100) {
          this.set(k, percent);
          return true;
        }
      }
      return false;
    }
  };

  // Helper function to parse input into groups separated by 'groupDelim', and
  // interpret each group as a key/value pair separated by 'keyValueDelim'.
  function parseOptions$1(input, callback, keyValueDelim, groupDelim) {
    const groups = groupDelim ? input.split(groupDelim) : [input];
    for (const i in groups) {
      if (typeof groups[i] !== 'string') {
        continue;
      }
      const kv = groups[i].split(keyValueDelim);
      if (kv.length !== 2) {
        continue;
      }
      const k = kv[0];
      const v = kv[1];
      callback(k, v);
    }
  }
  const defaults$2 = new VTTCue$1(0, 0, '');
  // 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
  //  Safari doesn't yet support this change, but FF and Chrome do.
  const center = defaults$2.align === 'middle' ? 'middle' : 'center';
  function parseCue$1(input, cue, regionList) {
    // Remember the original input if we need to throw an error.
    const oInput = input;
    // 4.1 WebVTT timestamp
    function consumeTimeStamp() {
      const ts = parseTimeStamp$1(input);
      if (ts === null) {
        throw new Error('Malformed timestamp: ' + oInput);
      }

      // Remove time stamp from input.
      input = input.replace(/^[^\sa-zA-Z-]+/, '');
      return ts;
    }

    // 4.4.2 WebVTT cue settings
    function consumeCueSettings(input, cue) {
      const settings = new Settings$1();
      parseOptions$1(input, function (k, v) {
        let vals;
        switch (k) {
          case 'region':
            // Find the last region we parsed with the same region id.
            for (let i = regionList.length - 1; i >= 0; i--) {
              if (regionList[i].id === v) {
                settings.set(k, regionList[i].region);
                break;
              }
            }
            break;
          case 'vertical':
            settings.alt(k, v, ['rl', 'lr']);
            break;
          case 'line':
            vals = v.split(',');
            settings.integer(k, vals[0]);
            if (settings.percent(k, vals[0])) {
              settings.set('snapToLines', false);
            }
            settings.alt(k, vals[0], ['auto']);
            if (vals.length === 2) {
              settings.alt('lineAlign', vals[1], ['start', center, 'end']);
            }
            break;
          case 'position':
            vals = v.split(',');
            settings.percent(k, vals[0]);
            if (vals.length === 2) {
              settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
            }
            break;
          case 'size':
            settings.percent(k, v);
            break;
          case 'align':
            settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
            break;
        }
      }, /:/, /\s/);

      // Apply default values for any missing fields.
      cue.region = settings.get('region', null);
      cue.vertical = settings.get('vertical', '');
      let line = settings.get('line', 'auto');
      if (line === 'auto' && defaults$2.line === -1) {
        // set numeric line number for Safari
        line = -1;
      }
      cue.line = line;
      cue.lineAlign = settings.get('lineAlign', 'start');
      cue.snapToLines = settings.get('snapToLines', true);
      cue.size = settings.get('size', 100);
      cue.align = settings.get('align', center);
      let position = settings.get('position', 'auto');
      if (position === 'auto' && defaults$2.position === 50) {
        // set numeric position for Safari
        position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
      }
      cue.position = position;
    }
    function skipWhitespace() {
      input = input.replace(/^\s+/, '');
    }

    // 4.1 WebVTT cue timings.
    skipWhitespace();
    cue.startTime = consumeTimeStamp(); // (1) collect cue start time
    skipWhitespace();
    if (input.slice(0, 3) !== '-->') {
      // (3) next characters must match '-->'
      throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
    }
    input = input.slice(3);
    skipWhitespace();
    cue.endTime = consumeTimeStamp(); // (5) collect cue end time

    // 4.1 WebVTT cue settings list.
    skipWhitespace();
    consumeCueSettings(input, cue);
  }
  function fixLineBreaks(input) {
    return input.replace(/<br(?: \/)?>/gi, '\n');
  }
  class VTTParser {
    constructor() {
      this.state = 'INITIAL';
      this.buffer = '';
      this.decoder = new StringDecoder();
      this.regionList = [];
      this.cue = null;
      this.oncue = void 0;
      this.onparsingerror = void 0;
      this.onflush = void 0;
    }
    parse(data) {
      const _this = this;

      // If there is no data then we won't decode it, but will just try to parse
      // whatever is in buffer already. This may occur in circumstances, for
      // example when flush() is called.
      if (data) {
        // Try to decode the data that we received.
        _this.buffer += _this.decoder.decode(data, {
          stream: true
        });
      }
      function collectNextLine() {
        let buffer = _this.buffer;
        let pos = 0;
        buffer = fixLineBreaks(buffer);
        while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
          ++pos;
        }
        const line = buffer.slice(0, pos);
        // Advance the buffer early in case we fail below.
        if (buffer[pos] === '\r') {
          ++pos;
        }
        if (buffer[pos] === '\n') {
          ++pos;
        }
        _this.buffer = buffer.slice(pos);
        return line;
      }

      // 3.2 WebVTT metadata header syntax
      function parseHeader(input) {
        parseOptions$1(input, function (k, v) {
          // switch (k) {
          // case 'region':
          // 3.3 WebVTT region metadata header syntax
          // console.log('parse region', v);
          // parseRegion(v);
          // break;
          // }
        }, /:/);
      }

      // 5.1 WebVTT file parsing.
      try {
        let line = '';
        if (_this.state === 'INITIAL') {
          // We can't start parsing until we have the first line.
          if (!/\r\n|\n/.test(_this.buffer)) {
            return this;
          }
          line = collectNextLine();
          // strip of UTF-8 BOM if any
          // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8
          const m = line.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
          if (!(m != null && m[0])) {
            throw new Error('Malformed WebVTT signature.');
          }
          _this.state = 'HEADER';
        }
        let alreadyCollectedLine = false;
        while (_this.buffer) {
          // We can't parse a line until we have the full line.
          if (!/\r\n|\n/.test(_this.buffer)) {
            return this;
          }
          if (!alreadyCollectedLine) {
            line = collectNextLine();
          } else {
            alreadyCollectedLine = false;
          }
          switch (_this.state) {
            case 'HEADER':
              // 13-18 - Allow a header (metadata) under the WEBVTT line.
              if (/:/.test(line)) {
                parseHeader(line);
              } else if (!line) {
                // An empty line terminates the header and starts the body (cues).
                _this.state = 'ID';
              }
              continue;
            case 'NOTE':
              // Ignore NOTE blocks.
              if (!line) {
                _this.state = 'ID';
              }
              continue;
            case 'ID':
              // Check for the start of NOTE blocks.
              if (/^NOTE($|[ \t])/.test(line)) {
                _this.state = 'NOTE';
                break;
              }
              // 19-29 - Allow any number of line terminators, then initialize new cue values.
              if (!line) {
                continue;
              }
              _this.cue = new VTTCue$1(0, 0, '');
              _this.state = 'CUE';
              // 30-39 - Check if self line contains an optional identifier or timing data.
              if (line.indexOf('-->') === -1) {
                _this.cue.id = line;
                continue;
              }
            // Process line as start of a cue.
            /* falls through */
            case 'CUE':
              // 40 - Collect cue timings and settings.
              if (!_this.cue) {
                _this.state = 'BADCUE';
                continue;
              }
              try {
                parseCue$1(line, _this.cue, _this.regionList);
              } catch (e) {
                // In case of an error ignore rest of the cue.
                _this.cue = null;
                _this.state = 'BADCUE';
                continue;
              }
              _this.state = 'CUETEXT';
              continue;
            case 'CUETEXT':
              {
                const hasSubstring = line.indexOf('-->') !== -1;
                // 34 - If we have an empty line then report the cue.
                // 35 - If we have the special substring '-->' then report the cue,
                // but do not collect the line as we need to process the current
                // one as a new cue.
                if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                  // We are done parsing self cue.
                  if (_this.oncue && _this.cue) {
                    _this.oncue(_this.cue);
                  }
                  _this.cue = null;
                  _this.state = 'ID';
                  continue;
                }
                if (_this.cue === null) {
                  continue;
                }
                if (_this.cue.text) {
                  _this.cue.text += '\n';
                }
                _this.cue.text += line;
              }
              continue;
            case 'BADCUE':
              // 54-62 - Collect and discard the remaining cue.
              if (!line) {
                _this.state = 'ID';
              }
          }
        }
      } catch (e) {
        // If we are currently parsing a cue, report what we have.
        if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {
          _this.oncue(_this.cue);
        }
        _this.cue = null;
        // Enter BADWEBVTT state if header was not parsed correctly otherwise
        // another exception occurred so enter BADCUE state.
        _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
      }
      return this;
    }
    flush() {
      const _this = this;
      try {
        // Finish decoding the stream.
        // _this.buffer += _this.decoder.decode();
        // Synthesize the end of the current cue or region.
        if (_this.cue || _this.state === 'HEADER') {
          _this.buffer += '\n\n';
          _this.parse();
        }
        // If we've flushed, parsed, and we're still on the INITIAL state then
        // that means we don't have enough of the stream to parse the first
        // line.
        if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {
          throw new Error('Malformed WebVTT signature.');
        }
      } catch (e) {
        if (_this.onparsingerror) {
          _this.onparsingerror(e);
        }
      }
      if (_this.onflush) {
        _this.onflush();
      }
      return this;
    }
  }

  const LINEBREAKS = /\r\n|\n\r|\n|\r/g;

  // String.prototype.startsWith is not supported in IE11
  const startsWith = function startsWith(inputString, searchString, position = 0) {
    return inputString.slice(position, position + searchString.length) === searchString;
  };
  const cueString2millis = function cueString2millis(timeString) {
    let ts = parseInt(timeString.slice(-3));
    const secs = parseInt(timeString.slice(-6, -4));
    const mins = parseInt(timeString.slice(-9, -7));
    const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(':'))) : 0;
    if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {
      throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);
    }
    ts += 1000 * secs;
    ts += 60 * 1000 * mins;
    ts += 60 * 60 * 1000 * hours;
    return ts;
  };

  // From https://github.com/darkskyapp/string-hash
  const hash = function hash(text) {
    let _hash = 5381;
    let i = text.length;
    while (i) {
      _hash = _hash * 33 ^ text.charCodeAt(--i);
    }
    return (_hash >>> 0).toString();
  };

  // Create a unique hash id for a cue based on start/end times and text.
  // This helps timeline-controller to avoid showing repeated captions.
  function generateCueId(startTime, endTime, text) {
    return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);
  }
  const calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
    let currCC = vttCCs[cc];
    let prevCC = vttCCs[currCC.prevCC];

    // This is the first discontinuity or cues have been processed since the last discontinuity
    // Offset = current discontinuity time
    if (!prevCC || !prevCC.new && currCC.new) {
      vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
      currCC.new = false;
      return;
    }

    // There have been discontinuities since cues were last parsed.
    // Offset = time elapsed
    while ((_prevCC = prevCC) != null && _prevCC.new) {
      var _prevCC;
      vttCCs.ccOffset += currCC.start - prevCC.start;
      currCC.new = false;
      currCC = prevCC;
      prevCC = vttCCs[currCC.prevCC];
    }
    vttCCs.presentationOffset = presentationTime;
  };
  function parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {
    const parser = new VTTParser();
    // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
    // Uint8Array.prototype.reduce is not implemented in IE11
    const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\n').split('\n');
    const cues = [];
    const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;
    let cueTime = '00:00.000';
    let timestampMapMPEGTS = 0;
    let timestampMapLOCAL = 0;
    let parsingError;
    let inHeader = true;
    parser.oncue = function (cue) {
      // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
      const currCC = vttCCs[cc];
      let cueOffset = vttCCs.ccOffset;

      // Calculate subtitle PTS offset
      const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;

      // Update offsets for new discontinuities
      if (currCC != null && currCC.new) {
        if (timestampMapLOCAL !== undefined) {
          // When local time is provided, offset = discontinuity start time - local time
          cueOffset = vttCCs.ccOffset = currCC.start;
        } else {
          calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);
        }
      }
      if (webVttMpegTsMapOffset) {
        if (!initPTS) {
          parsingError = new Error('Missing initPTS for VTT MPEGTS');
          return;
        }
        // If we have MPEGTS, offset = presentation time + discontinuity offset
        cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;
      }
      const duration = cue.endTime - cue.startTime;
      const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;
      cue.startTime = Math.max(startTime, 0);
      cue.endTime = Math.max(startTime + duration, 0);

      //trim trailing webvtt block whitespaces
      const text = cue.text.trim();

      // Fix encoding of special characters
      cue.text = decodeURIComponent(encodeURIComponent(text));

      // If the cue was not assigned an id from the VTT file (line above the content), create one.
      if (!cue.id) {
        cue.id = generateCueId(cue.startTime, cue.endTime, text);
      }
      if (cue.endTime > 0) {
        cues.push(cue);
      }
    };
    parser.onparsingerror = function (error) {
      parsingError = error;
    };
    parser.onflush = function () {
      if (parsingError) {
        errorCallBack(parsingError);
        return;
      }
      callBack(cues);
    };

    // Go through contents line by line.
    vttLines.forEach(line => {
      if (inHeader) {
        // Look for X-TIMESTAMP-MAP in header.
        if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
          // Once found, no more are allowed anyway, so stop searching.
          inHeader = false;
          // Extract LOCAL and MPEGTS.
          line.slice(16).split(',').forEach(timestamp => {
            if (startsWith(timestamp, 'LOCAL:')) {
              cueTime = timestamp.slice(6);
            } else if (startsWith(timestamp, 'MPEGTS:')) {
              timestampMapMPEGTS = parseInt(timestamp.slice(7));
            }
          });
          try {
            // Convert cue time to seconds
            timestampMapLOCAL = cueString2millis(cueTime) / 1000;
          } catch (error) {
            parsingError = error;
          }
          // Return without parsing X-TIMESTAMP-MAP line.
          return;
        } else if (line === '') {
          inHeader = false;
        }
      }
      // Parse line by default.
      parser.parse(line + '\n');
    });
    parser.flush();
  }

  const IMSC1_CODEC = 'stpp.ttml.im1t';

  // Time format: h:m:s:frames(.subframes)
  const HMSF_REGEX = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;

  // Time format: hours, minutes, seconds, milliseconds, frames, ticks
  const TIME_UNIT_REGEX = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/;
  const textAlignToLineAlign = {
    left: 'start',
    center: 'center',
    right: 'end',
    start: 'start',
    end: 'end'
  };
  function parseIMSC1(payload, initPTS, callBack, errorCallBack) {
    const results = findBox(new Uint8Array(payload), ['mdat']);
    if (results.length === 0) {
      errorCallBack(new Error('Could not parse IMSC1 mdat'));
      return;
    }
    const ttmlList = results.map(mdat => utf8ArrayToStr(mdat));
    const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);
    try {
      ttmlList.forEach(ttml => callBack(parseTTML(ttml, syncTime)));
    } catch (error) {
      errorCallBack(error);
    }
  }
  function parseTTML(ttml, syncTime) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(ttml, 'text/xml');
    const tt = xmlDoc.getElementsByTagName('tt')[0];
    if (!tt) {
      throw new Error('Invalid ttml');
    }
    const defaultRateInfo = {
      frameRate: 30,
      subFrameRate: 1,
      frameRateMultiplier: 0,
      tickRate: 0
    };
    const rateInfo = Object.keys(defaultRateInfo).reduce((result, key) => {
      result[key] = tt.getAttribute(`ttp:${key}`) || defaultRateInfo[key];
      return result;
    }, {});
    const trim = tt.getAttribute('xml:space') !== 'preserve';
    const styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));
    const regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));
    const cueElements = getElementCollection(tt, 'body', '[begin]');
    return [].map.call(cueElements, cueElement => {
      const cueText = getTextContent(cueElement, trim);
      if (!cueText || !cueElement.hasAttribute('begin')) {
        return null;
      }
      const startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);
      const duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);
      let endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);
      if (startTime === null) {
        throw timestampParsingError(cueElement);
      }
      if (endTime === null) {
        if (duration === null) {
          throw timestampParsingError(cueElement);
        }
        endTime = startTime + duration;
      }
      const cue = new VTTCue$1(startTime - syncTime, endTime - syncTime, cueText);
      cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);
      const region = regionElements[cueElement.getAttribute('region')];
      const style = styleElements[cueElement.getAttribute('style')];

      // Apply styles to cue
      const styles = getTtmlStyles(region, style, styleElements);
      const {
        textAlign
      } = styles;
      if (textAlign) {
        // cue.positionAlign not settable in FF~2016
        const lineAlign = textAlignToLineAlign[textAlign];
        if (lineAlign) {
          cue.lineAlign = lineAlign;
        }
        cue.align = textAlign;
      }
      _extends$2(cue, styles);
      return cue;
    }).filter(cue => cue !== null);
  }
  function getElementCollection(fromElement, parentName, childName) {
    const parent = fromElement.getElementsByTagName(parentName)[0];
    if (parent) {
      return [].slice.call(parent.querySelectorAll(childName));
    }
    return [];
  }
  function collectionToDictionary(elementsWithId) {
    return elementsWithId.reduce((dict, element) => {
      const id = element.getAttribute('xml:id');
      if (id) {
        dict[id] = element;
      }
      return dict;
    }, {});
  }
  function getTextContent(element, trim) {
    return [].slice.call(element.childNodes).reduce((str, node, i) => {
      var _node$childNodes;
      if (node.nodeName === 'br' && i) {
        return str + '\n';
      }
      if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {
        return getTextContent(node, trim);
      } else if (trim) {
        return str + node.textContent.trim().replace(/\s+/g, ' ');
      }
      return str + node.textContent;
    }, '');
  }
  function getTtmlStyles(region, style, styleElements) {
    const ttsNs = 'http://www.w3.org/ns/ttml#styling';
    let regionStyle = null;
    const styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily'
    // 'fontWeight',
    // 'lineHeight',
    // 'wrapOption',
    // 'fontStyle',
    // 'direction',
    // 'writingMode'
    ];
    const regionStyleName = region != null && region.hasAttribute('style') ? region.getAttribute('style') : null;
    if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {
      regionStyle = styleElements[regionStyleName];
    }
    return styleAttributes.reduce((styles, name) => {
      const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);
      if (value) {
        styles[name] = value;
      }
      return styles;
    }, {});
  }
  function getAttributeNS(element, ns, name) {
    if (!element) {
      return null;
    }
    return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;
  }
  function timestampParsingError(node) {
    return new Error(`Could not parse ttml timestamp ${node}`);
  }
  function parseTtmlTime(timeAttributeValue, rateInfo) {
    if (!timeAttributeValue) {
      return null;
    }
    let seconds = parseTimeStamp$1(timeAttributeValue);
    if (seconds === null) {
      if (HMSF_REGEX.test(timeAttributeValue)) {
        seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);
      } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {
        seconds = parseTimeUnits(timeAttributeValue, rateInfo);
      }
    }
    return seconds;
  }
  function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {
    const m = HMSF_REGEX.exec(timeAttributeValue);
    const frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;
    return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;
  }
  function parseTimeUnits(timeAttributeValue, rateInfo) {
    const m = TIME_UNIT_REGEX.exec(timeAttributeValue);
    const value = Number(m[1]);
    const unit = m[2];
    switch (unit) {
      case 'h':
        return value * 3600;
      case 'm':
        return value * 60;
      case 'ms':
        return value * 1000;
      case 'f':
        return value / rateInfo.frameRate;
      case 't':
        return value / rateInfo.tickRate;
    }
    return value;
  }

  class TimelineController {
    constructor(hls) {
      this.hls = void 0;
      this.media = null;
      this.config = void 0;
      this.enabled = true;
      this.Cues = void 0;
      this.textTracks = [];
      this.tracks = [];
      this.initPTS = [];
      this.unparsedVttFrags = [];
      this.captionsTracks = {};
      this.nonNativeCaptionsTracks = {};
      this.cea608Parser1 = void 0;
      this.cea608Parser2 = void 0;
      this.lastCc = -1;
      // Last video (CEA-608) fragment CC
      this.lastSn = -1;
      // Last video (CEA-608) fragment MSN
      this.lastPartIndex = -1;
      // Last video (CEA-608) fragment Part Index
      this.prevCC = -1;
      // Last subtitle fragment CC
      this.vttCCs = newVTTCCs();
      this.captionsProperties = void 0;
      this.hls = hls;
      this.config = hls.config;
      this.Cues = hls.config.cueHandler;
      this.captionsProperties = {
        textTrack1: {
          label: this.config.captionsTextTrack1Label,
          languageCode: this.config.captionsTextTrack1LanguageCode
        },
        textTrack2: {
          label: this.config.captionsTextTrack2Label,
          languageCode: this.config.captionsTextTrack2LanguageCode
        },
        textTrack3: {
          label: this.config.captionsTextTrack3Label,
          languageCode: this.config.captionsTextTrack3LanguageCode
        },
        textTrack4: {
          label: this.config.captionsTextTrack4Label,
          languageCode: this.config.captionsTextTrack4LanguageCode
        }
      };
      hls.on(Events$1.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.on(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.on(Events$1.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.on(Events$1.FRAG_LOADING, this.onFragLoading, this);
      hls.on(Events$1.FRAG_LOADED, this.onFragLoaded, this);
      hls.on(Events$1.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
      hls.on(Events$1.FRAG_DECRYPTED, this.onFragDecrypted, this);
      hls.on(Events$1.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.on(Events$1.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
      hls.on(Events$1.BUFFER_FLUSHING, this.onBufferFlushing, this);
    }
    destroy() {
      const {
        hls
      } = this;
      hls.off(Events$1.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.off(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.off(Events$1.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.off(Events$1.FRAG_LOADING, this.onFragLoading, this);
      hls.off(Events$1.FRAG_LOADED, this.onFragLoaded, this);
      hls.off(Events$1.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
      hls.off(Events$1.FRAG_DECRYPTED, this.onFragDecrypted, this);
      hls.off(Events$1.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.off(Events$1.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
      hls.off(Events$1.BUFFER_FLUSHING, this.onBufferFlushing, this);
      // @ts-ignore
      this.hls = this.config = null;
      this.cea608Parser1 = this.cea608Parser2 = undefined;
    }
    initCea608Parsers() {
      if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) {
        const channel1 = new OutputFilter(this, 'textTrack1');
        const channel2 = new OutputFilter(this, 'textTrack2');
        const channel3 = new OutputFilter(this, 'textTrack3');
        const channel4 = new OutputFilter(this, 'textTrack4');
        this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);
        this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);
      }
    }
    addCues(trackName, startTime, endTime, screen, cueRanges) {
      // skip cues which overlap more than 50% with previously parsed time ranges
      let merged = false;
      for (let i = cueRanges.length; i--;) {
        const cueRange = cueRanges[i];
        const overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
        if (overlap >= 0) {
          cueRange[0] = Math.min(cueRange[0], startTime);
          cueRange[1] = Math.max(cueRange[1], endTime);
          merged = true;
          if (overlap / (endTime - startTime) > 0.5) {
            return;
          }
        }
      }
      if (!merged) {
        cueRanges.push([startTime, endTime]);
      }
      if (this.config.renderTextTracksNatively) {
        const track = this.captionsTracks[trackName];
        this.Cues.newCue(track, startTime, endTime, screen);
      } else {
        const cues = this.Cues.newCue(null, startTime, endTime, screen);
        this.hls.trigger(Events$1.CUES_PARSED, {
          type: 'captions',
          cues,
          track: trackName
        });
      }
    }

    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
    onInitPtsFound(event, {
      frag,
      id,
      initPTS,
      timescale
    }) {
      const {
        unparsedVttFrags
      } = this;
      if (id === 'main') {
        this.initPTS[frag.cc] = {
          baseTime: initPTS,
          timescale
        };
      }

      // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.
      // Parse any unparsed fragments upon receiving the initial PTS.
      if (unparsedVttFrags.length) {
        this.unparsedVttFrags = [];
        unparsedVttFrags.forEach(frag => {
          this.onFragLoaded(Events$1.FRAG_LOADED, frag);
        });
      }
    }
    getExistingTrack(label, language) {
      const {
        media
      } = this;
      if (media) {
        for (let i = 0; i < media.textTracks.length; i++) {
          const textTrack = media.textTracks[i];
          if (canReuseVttTextTrack(textTrack, {
            name: label,
            lang: language,
            attrs: {}
          })) {
            return textTrack;
          }
        }
      }
      return null;
    }
    createCaptionsTrack(trackName) {
      if (this.config.renderTextTracksNatively) {
        this.createNativeTrack(trackName);
      } else {
        this.createNonNativeTrack(trackName);
      }
    }
    createNativeTrack(trackName) {
      if (this.captionsTracks[trackName]) {
        return;
      }
      const {
        captionsProperties,
        captionsTracks,
        media
      } = this;
      const {
        label,
        languageCode
      } = captionsProperties[trackName];
      // Enable reuse of existing text track.
      const existingTrack = this.getExistingTrack(label, languageCode);
      if (!existingTrack) {
        const textTrack = this.createTextTrack('captions', label, languageCode);
        if (textTrack) {
          // Set a special property on the track so we know it's managed by Hls.js
          textTrack[trackName] = true;
          captionsTracks[trackName] = textTrack;
        }
      } else {
        captionsTracks[trackName] = existingTrack;
        clearCurrentCues(captionsTracks[trackName]);
        sendAddTrackEvent(captionsTracks[trackName], media);
      }
    }
    createNonNativeTrack(trackName) {
      if (this.nonNativeCaptionsTracks[trackName]) {
        return;
      }
      // Create a list of a single track for the provider to consume
      const trackProperties = this.captionsProperties[trackName];
      if (!trackProperties) {
        return;
      }
      const label = trackProperties.label;
      const track = {
        _id: trackName,
        label,
        kind: 'captions',
        default: trackProperties.media ? !!trackProperties.media.default : false,
        closedCaptions: trackProperties.media
      };
      this.nonNativeCaptionsTracks[trackName] = track;
      this.hls.trigger(Events$1.NON_NATIVE_TEXT_TRACKS_FOUND, {
        tracks: [track]
      });
    }
    createTextTrack(kind, label, lang) {
      const media = this.media;
      if (!media) {
        return;
      }
      return media.addTextTrack(kind, label, lang);
    }
    onMediaAttaching(event, data) {
      this.media = data.media;
      this._cleanTracks();
    }
    onMediaDetaching() {
      const {
        captionsTracks
      } = this;
      Object.keys(captionsTracks).forEach(trackName => {
        clearCurrentCues(captionsTracks[trackName]);
        delete captionsTracks[trackName];
      });
      this.nonNativeCaptionsTracks = {};
    }
    onManifestLoading() {
      // Detect discontinuity in video fragment (CEA-608) parsing
      this.lastCc = -1;
      this.lastSn = -1;
      this.lastPartIndex = -1;
      // Detect discontinuity in subtitle manifests
      this.prevCC = -1;
      this.vttCCs = newVTTCCs();
      // Reset tracks
      this._cleanTracks();
      this.tracks = [];
      this.captionsTracks = {};
      this.nonNativeCaptionsTracks = {};
      this.textTracks = [];
      this.unparsedVttFrags = [];
      this.initPTS = [];
      if (this.cea608Parser1 && this.cea608Parser2) {
        this.cea608Parser1.reset();
        this.cea608Parser2.reset();
      }
    }
    _cleanTracks() {
      // clear outdated subtitles
      const {
        media
      } = this;
      if (!media) {
        return;
      }
      const textTracks = media.textTracks;
      if (textTracks) {
        for (let i = 0; i < textTracks.length; i++) {
          clearCurrentCues(textTracks[i]);
        }
      }
    }
    onSubtitleTracksUpdated(event, data) {
      const tracks = data.subtitleTracks || [];
      const hasIMSC1 = tracks.some(track => track.textCodec === IMSC1_CODEC);
      if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {
        const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);
        if (listIsIdentical) {
          this.tracks = tracks;
          return;
        }
        this.textTracks = [];
        this.tracks = tracks;
        if (this.config.renderTextTracksNatively) {
          const media = this.media;
          const inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;
          this.tracks.forEach((track, index) => {
            // Reuse tracks with the same label and lang, but do not reuse 608/708 tracks
            let textTrack;
            if (inUseTracks) {
              let inUseTrack = null;
              for (let i = 0; i < inUseTracks.length; i++) {
                if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {
                  inUseTrack = inUseTracks[i];
                  inUseTracks[i] = null;
                  break;
                }
              }
              if (inUseTrack) {
                textTrack = inUseTrack;
              }
            }
            if (textTrack) {
              clearCurrentCues(textTrack);
            } else {
              const textTrackKind = captionsOrSubtitlesFromCharacteristics(track);
              textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);
              if (textTrack) {
                textTrack.mode = 'disabled';
              }
            }
            if (textTrack) {
              this.textTracks.push(textTrack);
            }
          });
          // Warn when video element has captions or subtitle TextTracks carried over from another source
          if (inUseTracks != null && inUseTracks.length) {
            const unusedTextTracks = inUseTracks.filter(t => t !== null).map(t => t.label);
            if (unusedTextTracks.length) {
              logger.warn(`Media element contains unused subtitle tracks: ${unusedTextTracks.join(', ')}. Replace media element for each source to clear TextTracks and captions menu.`);
            }
          }
        } else if (this.tracks.length) {
          // Create a list of tracks for the provider to consume
          const tracksList = this.tracks.map(track => {
            return {
              label: track.name,
              kind: track.type.toLowerCase(),
              default: track.default,
              subtitleTrack: track
            };
          });
          this.hls.trigger(Events$1.NON_NATIVE_TEXT_TRACKS_FOUND, {
            tracks: tracksList
          });
        }
      }
    }
    onManifestLoaded(event, data) {
      if (this.config.enableCEA708Captions && data.captions) {
        data.captions.forEach(captionsTrack => {
          const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);
          if (!instreamIdMatch) {
            return;
          }
          const trackName = `textTrack${instreamIdMatch[1]}`;
          const trackProperties = this.captionsProperties[trackName];
          if (!trackProperties) {
            return;
          }
          trackProperties.label = captionsTrack.name;
          if (captionsTrack.lang) {
            // optional attribute
            trackProperties.languageCode = captionsTrack.lang;
          }
          trackProperties.media = captionsTrack;
        });
      }
    }
    closedCaptionsForLevel(frag) {
      const level = this.hls.levels[frag.level];
      return level == null ? void 0 : level.attrs['CLOSED-CAPTIONS'];
    }
    onFragLoading(event, data) {
      // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
      if (this.enabled && data.frag.type === PlaylistLevelType.MAIN) {
        var _data$part$index, _data$part;
        const {
          cea608Parser1,
          cea608Parser2,
          lastSn
        } = this;
        const {
          cc,
          sn
        } = data.frag;
        const partIndex = (_data$part$index = (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;
        if (cea608Parser1 && cea608Parser2) {
          if (sn !== lastSn + 1 || sn === lastSn && partIndex !== this.lastPartIndex + 1 || cc !== this.lastCc) {
            cea608Parser1.reset();
            cea608Parser2.reset();
          }
        }
        this.lastCc = cc;
        this.lastSn = sn;
        this.lastPartIndex = partIndex;
      }
    }
    onFragLoaded(event, data) {
      const {
        frag,
        payload
      } = data;
      if (frag.type === PlaylistLevelType.SUBTITLE) {
        // If fragment is subtitle type, parse as WebVTT.
        if (payload.byteLength) {
          const decryptData = frag.decryptdata;
          // fragment after decryption has a stats object
          const decrypted = ('stats' in data);
          // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.
          if (decryptData == null || !decryptData.encrypted || decrypted) {
            const trackPlaylistMedia = this.tracks[frag.level];
            const vttCCs = this.vttCCs;
            if (!vttCCs[frag.cc]) {
              vttCCs[frag.cc] = {
                start: frag.start,
                prevCC: this.prevCC,
                new: true
              };
              this.prevCC = frag.cc;
            }
            if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {
              this._parseIMSC1(frag, payload);
            } else {
              this._parseVTTs(data);
            }
          }
        } else {
          // In case there is no payload, finish unsuccessfully.
          this.hls.trigger(Events$1.SUBTITLE_FRAG_PROCESSED, {
            success: false,
            frag,
            error: new Error('Empty subtitle payload')
          });
        }
      }
    }
    _parseIMSC1(frag, payload) {
      const hls = this.hls;
      parseIMSC1(payload, this.initPTS[frag.cc], cues => {
        this._appendCues(cues, frag.level);
        hls.trigger(Events$1.SUBTITLE_FRAG_PROCESSED, {
          success: true,
          frag: frag
        });
      }, error => {
        logger.log(`Failed to parse IMSC1: ${error}`);
        hls.trigger(Events$1.SUBTITLE_FRAG_PROCESSED, {
          success: false,
          frag: frag,
          error
        });
      });
    }
    _parseVTTs(data) {
      var _frag$initSegment;
      const {
        frag,
        payload
      } = data;
      // We need an initial synchronisation PTS. Store fragments as long as none has arrived
      const {
        initPTS,
        unparsedVttFrags
      } = this;
      const maxAvCC = initPTS.length - 1;
      if (!initPTS[frag.cc] && maxAvCC === -1) {
        unparsedVttFrags.push(data);
        return;
      }
      const hls = this.hls;
      // Parse the WebVTT file contents.
      const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;
      parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, cues => {
        this._appendCues(cues, frag.level);
        hls.trigger(Events$1.SUBTITLE_FRAG_PROCESSED, {
          success: true,
          frag: frag
        });
      }, error => {
        const missingInitPTS = error.message === 'Missing initPTS for VTT MPEGTS';
        if (missingInitPTS) {
          unparsedVttFrags.push(data);
        } else {
          this._fallbackToIMSC1(frag, payload);
        }
        // Something went wrong while parsing. Trigger event with success false.
        logger.log(`Failed to parse VTT cue: ${error}`);
        if (missingInitPTS && maxAvCC > frag.cc) {
          return;
        }
        hls.trigger(Events$1.SUBTITLE_FRAG_PROCESSED, {
          success: false,
          frag: frag,
          error
        });
      });
    }
    _fallbackToIMSC1(frag, payload) {
      // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result
      const trackPlaylistMedia = this.tracks[frag.level];
      if (!trackPlaylistMedia.textCodec) {
        parseIMSC1(payload, this.initPTS[frag.cc], () => {
          trackPlaylistMedia.textCodec = IMSC1_CODEC;
          this._parseIMSC1(frag, payload);
        }, () => {
          trackPlaylistMedia.textCodec = 'wvtt';
        });
      }
    }
    _appendCues(cues, fragLevel) {
      const hls = this.hls;
      if (this.config.renderTextTracksNatively) {
        const textTrack = this.textTracks[fragLevel];
        // WebVTTParser.parse is an async method and if the currently selected text track mode is set to "disabled"
        // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null
        // and trying to access getCueById method of cues will throw an exception
        // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.
        if (!textTrack || textTrack.mode === 'disabled') {
          return;
        }
        cues.forEach(cue => addCueToTrack(textTrack, cue));
      } else {
        const currentTrack = this.tracks[fragLevel];
        if (!currentTrack) {
          return;
        }
        const track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;
        hls.trigger(Events$1.CUES_PARSED, {
          type: 'subtitles',
          cues,
          track
        });
      }
    }
    onFragDecrypted(event, data) {
      const {
        frag
      } = data;
      if (frag.type === PlaylistLevelType.SUBTITLE) {
        this.onFragLoaded(Events$1.FRAG_LOADED, data);
      }
    }
    onSubtitleTracksCleared() {
      this.tracks = [];
      this.captionsTracks = {};
    }
    onFragParsingUserdata(event, data) {
      this.initCea608Parsers();
      const {
        cea608Parser1,
        cea608Parser2
      } = this;
      if (!this.enabled || !cea608Parser1 || !cea608Parser2) {
        return;
      }
      const {
        frag,
        samples
      } = data;
      if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === 'NONE') {
        return;
      }
      // If the event contains captions (found in the bytes property), push all bytes into the parser immediately
      // It will create the proper timestamps based on the PTS value
      for (let i = 0; i < samples.length; i++) {
        const ccBytes = samples[i].bytes;
        if (ccBytes) {
          const ccdatas = this.extractCea608Data(ccBytes);
          cea608Parser1.addData(samples[i].pts, ccdatas[0]);
          cea608Parser2.addData(samples[i].pts, ccdatas[1]);
        }
      }
    }
    onBufferFlushing(event, {
      startOffset,
      endOffset,
      endOffsetSubtitles,
      type
    }) {
      const {
        media
      } = this;
      if (!media || media.currentTime < endOffset) {
        return;
      }
      // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed
      // Forward cues are never removed because we can loose streamed 608 content from recent fragments
      if (!type || type === 'video') {
        const {
          captionsTracks
        } = this;
        Object.keys(captionsTracks).forEach(trackName => removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));
      }
      if (this.config.renderTextTracksNatively) {
        // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed
        if (startOffset === 0 && endOffsetSubtitles !== undefined) {
          const {
            textTracks
          } = this;
          Object.keys(textTracks).forEach(trackName => removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));
        }
      }
    }
    extractCea608Data(byteArray) {
      const actualCCBytes = [[], []];
      const count = byteArray[0] & 0x1f;
      let position = 2;
      for (let j = 0; j < count; j++) {
        const tmpByte = byteArray[position++];
        const ccbyte1 = 0x7f & byteArray[position++];
        const ccbyte2 = 0x7f & byteArray[position++];
        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }
        const ccValid = (0x04 & tmpByte) !== 0; // Support all four channels
        if (ccValid) {
          const ccType = 0x03 & tmpByte;
          if (0x00 /* CEA608 field1*/ === ccType || 0x01 /* CEA608 field2*/ === ccType) {
            // Exclude CEA708 CC data.
            actualCCBytes[ccType].push(ccbyte1);
            actualCCBytes[ccType].push(ccbyte2);
          }
        }
      }
      return actualCCBytes;
    }
  }
  function captionsOrSubtitlesFromCharacteristics(track) {
    if (track.characteristics) {
      if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {
        return 'captions';
      }
    }
    return 'subtitles';
  }
  function canReuseVttTextTrack(inUseTrack, manifestTrack) {
    return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);
  }
  function intersection(x1, x2, y1, y2) {
    return Math.min(x2, y2) - Math.max(x1, y1);
  }
  function newVTTCCs() {
    return {
      ccOffset: 0,
      presentationOffset: 0,
      0: {
        start: 0,
        prevCC: -1,
        new: true
      }
    };
  }

  class CapLevelController {
    constructor(hls) {
      this.hls = void 0;
      this.autoLevelCapping = void 0;
      this.firstLevel = void 0;
      this.media = void 0;
      this.restrictedLevels = void 0;
      this.timer = void 0;
      this.clientRect = void 0;
      this.streamController = void 0;
      this.hls = hls;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      this.firstLevel = -1;
      this.media = null;
      this.restrictedLevels = [];
      this.timer = undefined;
      this.clientRect = null;
      this.registerListeners();
    }
    setStreamController(streamController) {
      this.streamController = streamController;
    }
    destroy() {
      if (this.hls) {
        this.unregisterListener();
      }
      if (this.timer) {
        this.stopCapping();
      }
      this.media = null;
      this.clientRect = null;
      // @ts-ignore
      this.hls = this.streamController = null;
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
      hls.on(Events$1.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.on(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events$1.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.on(Events$1.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.on(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    unregisterListener() {
      const {
        hls
      } = this;
      hls.off(Events$1.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
      hls.off(Events$1.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.off(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events$1.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.off(Events$1.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.off(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    onFpsDropLevelCapping(event, data) {
      // Don't add a restricted level more than once
      const level = this.hls.levels[data.droppedLevel];
      if (this.isLevelAllowed(level)) {
        this.restrictedLevels.push({
          bitrate: level.bitrate,
          height: level.height,
          width: level.width
        });
      }
    }
    onMediaAttaching(event, data) {
      this.media = data.media instanceof HTMLVideoElement ? data.media : null;
      this.clientRect = null;
      if (this.timer && this.hls.levels.length) {
        this.detectPlayerSize();
      }
    }
    onManifestParsed(event, data) {
      const hls = this.hls;
      this.restrictedLevels = [];
      this.firstLevel = data.firstLevel;
      if (hls.config.capLevelToPlayerSize && data.video) {
        // Start capping immediately if the manifest has signaled video codecs
        this.startCapping();
      }
    }
    onLevelsUpdated(event, data) {
      if (this.timer && isFiniteNumber(this.autoLevelCapping)) {
        this.detectPlayerSize();
      }
    }

    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
    // to the first level
    onBufferCodecs(event, data) {
      const hls = this.hls;
      if (hls.config.capLevelToPlayerSize && data.video) {
        // If the manifest did not signal a video codec capping has been deferred until we're certain video is present
        this.startCapping();
      }
    }
    onMediaDetaching() {
      this.stopCapping();
    }
    detectPlayerSize() {
      if (this.media) {
        if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
          this.clientRect = null;
          return;
        }
        const levels = this.hls.levels;
        if (levels.length) {
          const hls = this.hls;
          const maxLevel = this.getMaxLevel(levels.length - 1);
          if (maxLevel !== this.autoLevelCapping) {
            logger.log(`Setting autoLevelCapping to ${maxLevel}: ${levels[maxLevel].height}p@${levels[maxLevel].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`);
          }
          hls.autoLevelCapping = maxLevel;
          if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            this.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = hls.autoLevelCapping;
        }
      }
    }

    /*
     * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
     */
    getMaxLevel(capLevelIndex) {
      const levels = this.hls.levels;
      if (!levels.length) {
        return -1;
      }
      const validLevels = levels.filter((level, index) => this.isLevelAllowed(level) && index <= capLevelIndex);
      this.clientRect = null;
      return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
    }
    startCapping() {
      if (this.timer) {
        // Don't reset capping if started twice; this can happen if the manifest signals a video codec
        return;
      }
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      self.clearInterval(this.timer);
      this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);
      this.detectPlayerSize();
    }
    stopCapping() {
      this.restrictedLevels = [];
      this.firstLevel = -1;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      if (this.timer) {
        self.clearInterval(this.timer);
        this.timer = undefined;
      }
    }
    getDimensions() {
      if (this.clientRect) {
        return this.clientRect;
      }
      const media = this.media;
      const boundsRect = {
        width: 0,
        height: 0
      };
      if (media) {
        const clientRect = media.getBoundingClientRect();
        boundsRect.width = clientRect.width;
        boundsRect.height = clientRect.height;
        if (!boundsRect.width && !boundsRect.height) {
          // When the media element has no width or height (equivalent to not being in the DOM),
          // then use its width and height attributes (media.width, media.height)
          boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
          boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
        }
      }
      this.clientRect = boundsRect;
      return boundsRect;
    }
    get mediaWidth() {
      return this.getDimensions().width * this.contentScaleFactor;
    }
    get mediaHeight() {
      return this.getDimensions().height * this.contentScaleFactor;
    }
    get contentScaleFactor() {
      let pixelRatio = 1;
      if (!this.hls.config.ignoreDevicePixelRatio) {
        try {
          pixelRatio = self.devicePixelRatio;
        } catch (e) {
          /* no-op */
        }
      }
      return pixelRatio;
    }
    isLevelAllowed(level) {
      const restrictedLevels = this.restrictedLevels;
      return !restrictedLevels.some(restrictedLevel => {
        return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;
      });
    }
    static getMaxLevelByMediaSize(levels, width, height) {
      if (!(levels != null && levels.length)) {
        return -1;
      }

      // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
      // to determine whether we've chosen the greatest bandwidth for the media's dimensions
      const atGreatestBandwidth = (curLevel, nextLevel) => {
        if (!nextLevel) {
          return true;
        }
        return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
      };

      // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
      // the max level
      let maxLevelIndex = levels.length - 1;
      // Prevent changes in aspect-ratio from causing capping to toggle back and forth
      const squareSize = Math.max(width, height);
      for (let i = 0; i < levels.length; i += 1) {
        const level = levels[i];
        if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {
          maxLevelIndex = i;
          break;
        }
      }
      return maxLevelIndex;
    }
  }

  class FPSController {
    constructor(hls) {
      this.hls = void 0;
      this.isVideoPlaybackQualityAvailable = false;
      this.timer = void 0;
      this.media = null;
      this.lastTime = void 0;
      this.lastDroppedFrames = 0;
      this.lastDecodedFrames = 0;
      // stream controller must be provided as a dependency!
      this.streamController = void 0;
      this.hls = hls;
      this.registerListeners();
    }
    setStreamController(streamController) {
      this.streamController = streamController;
    }
    registerListeners() {
      this.hls.on(Events$1.MEDIA_ATTACHING, this.onMediaAttaching, this);
    }
    unregisterListeners() {
      this.hls.off(Events$1.MEDIA_ATTACHING, this.onMediaAttaching, this);
    }
    destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.unregisterListeners();
      this.isVideoPlaybackQualityAvailable = false;
      this.media = null;
    }
    onMediaAttaching(event, data) {
      const config = this.hls.config;
      if (config.capLevelOnFPSDrop) {
        const media = data.media instanceof self.HTMLVideoElement ? data.media : null;
        this.media = media;
        if (media && typeof media.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }
        self.clearInterval(this.timer);
        this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
      }
    }
    checkFPS(video, decodedFrames, droppedFrames) {
      const currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          const currentPeriod = currentTime - this.lastTime;
          const currentDropped = droppedFrames - this.lastDroppedFrames;
          const currentDecoded = decodedFrames - this.lastDecodedFrames;
          const droppedFPS = 1000 * currentDropped / currentPeriod;
          const hls = this.hls;
          hls.trigger(Events$1.FPS_DROP, {
            currentDropped: currentDropped,
            currentDecoded: currentDecoded,
            totalDroppedFrames: droppedFrames
          });
          if (droppedFPS > 0) {
            // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              let currentLevel = hls.currentLevel;
              logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                hls.trigger(Events$1.FPS_DROP_LEVEL_CAPPING, {
                  level: currentLevel,
                  droppedLevel: hls.currentLevel
                });
                hls.autoLevelCapping = currentLevel;
                this.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
    checkFPSInterval() {
      const video = this.media;
      if (video) {
        if (this.isVideoPlaybackQualityAvailable) {
          const videoPlaybackQuality = video.getVideoPlaybackQuality();
          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          // HTMLVideoElement doesn't include the webkit types
          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
        }
      }
    }
  }

  const LOGGER_PREFIX = '[eme]';
  /**
   * Controller to deal with encrypted media extensions (EME)
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API
   *
   * @class
   * @constructor
   */
  class EMEController {
    constructor(hls) {
      this.hls = void 0;
      this.config = void 0;
      this.media = null;
      this.keyFormatPromise = null;
      this.keySystemAccessPromises = {};
      this._requestLicenseFailureCount = 0;
      this.mediaKeySessions = [];
      this.keyIdToKeySessionPromise = {};
      this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [];
      this.onMediaEncrypted = this._onMediaEncrypted.bind(this);
      this.onWaitingForKey = this._onWaitingForKey.bind(this);
      this.debug = logger.debug.bind(logger, LOGGER_PREFIX);
      this.log = logger.log.bind(logger, LOGGER_PREFIX);
      this.warn = logger.warn.bind(logger, LOGGER_PREFIX);
      this.error = logger.error.bind(logger, LOGGER_PREFIX);
      this.hls = hls;
      this.config = hls.config;
      this.registerListeners();
    }
    destroy() {
      this.unregisterListeners();
      this.onMediaDetached();
      // Remove any references that could be held in config options or callbacks
      const config = this.config;
      config.requestMediaKeySystemAccessFunc = null;
      config.licenseXhrSetup = config.licenseResponseCallback = undefined;
      config.drmSystems = config.drmSystemOptions = {};
      // @ts-ignore
      this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;
      // @ts-ignore
      this.config = null;
    }
    registerListeners() {
      this.hls.on(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.on(Events$1.MEDIA_DETACHED, this.onMediaDetached, this);
      this.hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.on(Events$1.MANIFEST_LOADED, this.onManifestLoaded, this);
    }
    unregisterListeners() {
      this.hls.off(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.off(Events$1.MEDIA_DETACHED, this.onMediaDetached, this);
      this.hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.off(Events$1.MANIFEST_LOADED, this.onManifestLoaded, this);
    }
    getLicenseServerUrl(keySystem) {
      const {
        drmSystems,
        widevineLicenseUrl
      } = this.config;
      const keySystemConfiguration = drmSystems[keySystem];
      if (keySystemConfiguration) {
        return keySystemConfiguration.licenseUrl;
      }

      // For backward compatibility
      if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {
        return widevineLicenseUrl;
      }
      throw new Error(`no license server URL configured for key-system "${keySystem}"`);
    }
    getServerCertificateUrl(keySystem) {
      const {
        drmSystems
      } = this.config;
      const keySystemConfiguration = drmSystems[keySystem];
      if (keySystemConfiguration) {
        return keySystemConfiguration.serverCertificateUrl;
      } else {
        this.log(`No Server Certificate in config.drmSystems["${keySystem}"]`);
      }
    }
    attemptKeySystemAccess(keySystemsToAttempt) {
      const levels = this.hls.levels;
      const uniqueCodec = (value, i, a) => !!value && a.indexOf(value) === i;
      const audioCodecs = levels.map(level => level.audioCodec).filter(uniqueCodec);
      const videoCodecs = levels.map(level => level.videoCodec).filter(uniqueCodec);
      if (audioCodecs.length + videoCodecs.length === 0) {
        videoCodecs.push('avc1.42e01e');
      }
      return new Promise((resolve, reject) => {
        const attempt = keySystems => {
          const keySystem = keySystems.shift();
          this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(mediaKeys => resolve({
            keySystem,
            mediaKeys
          })).catch(error => {
            if (keySystems.length) {
              attempt(keySystems);
            } else if (error instanceof EMEKeyError) {
              reject(error);
            } else {
              reject(new EMEKeyError({
                type: ErrorTypes.KEY_SYSTEM_ERROR,
                details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                error,
                fatal: true
              }, error.message));
            }
          });
        };
        attempt(keySystemsToAttempt);
      });
    }
    requestMediaKeySystemAccess(keySystem, supportedConfigurations) {
      const {
        requestMediaKeySystemAccessFunc
      } = this.config;
      if (!(typeof requestMediaKeySystemAccessFunc === 'function')) {
        let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;
        if (requestMediaKeySystemAccess === null && self.location.protocol === 'http:') {
          errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;
        }
        return Promise.reject(new Error(errMessage));
      }
      return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);
    }
    getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {
      // This can throw, but is caught in event handler callpath
      const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);
      const keySystemAccessPromises = this.keySystemAccessPromises[keySystem];
      let keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;
      if (!keySystemAccess) {
        this.log(`Requesting encrypted media "${keySystem}" key-system access with config: ${JSON.stringify(mediaKeySystemConfigs)}`);
        keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);
        const _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {
          keySystemAccess
        };
        keySystemAccess.catch(error => {
          this.log(`Failed to obtain access to key-system "${keySystem}": ${error}`);
        });
        return keySystemAccess.then(mediaKeySystemAccess => {
          this.log(`Access for key-system "${mediaKeySystemAccess.keySystem}" obtained`);
          const certificateRequest = this.fetchServerCertificate(keySystem);
          this.log(`Create media-keys for "${keySystem}"`);
          _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(mediaKeys => {
            this.log(`Media-keys created for "${keySystem}"`);
            return certificateRequest.then(certificate => {
              if (certificate) {
                return this.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);
              }
              return mediaKeys;
            });
          });
          _keySystemAccessPromises.mediaKeys.catch(error => {
            this.error(`Failed to create media-keys for "${keySystem}"}: ${error}`);
          });
          return _keySystemAccessPromises.mediaKeys;
        });
      }
      return keySystemAccess.then(() => keySystemAccessPromises.mediaKeys);
    }
    createMediaKeySessionContext({
      decryptdata,
      keySystem,
      mediaKeys
    }) {
      this.log(`Creating key-system session "${keySystem}" keyId: ${Hex.hexDump(decryptdata.keyId || [])}`);
      const mediaKeysSession = mediaKeys.createSession();
      const mediaKeySessionContext = {
        decryptdata,
        keySystem,
        mediaKeys,
        mediaKeysSession,
        keyStatus: 'status-pending'
      };
      this.mediaKeySessions.push(mediaKeySessionContext);
      return mediaKeySessionContext;
    }
    renewKeySession(mediaKeySessionContext) {
      const decryptdata = mediaKeySessionContext.decryptdata;
      if (decryptdata.pssh) {
        const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);
        const keyId = this.getKeyIdString(decryptdata);
        const scheme = 'cenc';
        this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'expired');
      } else {
        this.warn(`Could not renew expired session. Missing pssh initData.`);
      }
      this.removeSession(mediaKeySessionContext);
    }
    getKeyIdString(decryptdata) {
      if (!decryptdata) {
        throw new Error('Could not read keyId of undefined decryptdata');
      }
      if (decryptdata.keyId === null) {
        throw new Error('keyId is null');
      }
      return Hex.hexDump(decryptdata.keyId);
    }
    updateKeySession(mediaKeySessionContext, data) {
      var _mediaKeySessionConte;
      const keySession = mediaKeySessionContext.mediaKeysSession;
      this.log(`Updating key-session "${keySession.sessionId}" for keyID ${Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || [])}
      } (data length: ${data ? data.byteLength : data})`);
      return keySession.update(data);
    }
    selectKeySystemFormat(frag) {
      const keyFormats = Object.keys(frag.levelkeys || {});
      if (!this.keyFormatPromise) {
        this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(', ')}`);
        this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
      }
      return this.keyFormatPromise;
    }
    getKeyFormatPromise(keyFormats) {
      return new Promise((resolve, reject) => {
        const keySystemsInConfig = getKeySystemsForConfig(this.config);
        const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter(value => !!value && keySystemsInConfig.indexOf(value) !== -1);
        return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({
          keySystem
        }) => {
          const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);
          if (keySystemFormat) {
            resolve(keySystemFormat);
          } else {
            reject(new Error(`Unable to find format for key-system "${keySystem}"`));
          }
        }).catch(reject);
      });
    }
    loadKey(data) {
      const decryptdata = data.keyInfo.decryptdata;
      const keyId = this.getKeyIdString(decryptdata);
      const keyDetails = `(keyId: ${keyId} format: "${decryptdata.keyFormat}" method: ${decryptdata.method} uri: ${decryptdata.uri})`;
      this.log(`Starting session for key ${keyDetails}`);
      let keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];
      if (!keySessionContextPromise) {
        keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(({
          keySystem,
          mediaKeys
        }) => {
          this.throwIfDestroyed();
          this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);
          return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {
            this.throwIfDestroyed();
            const keySessionContext = this.createMediaKeySessionContext({
              keySystem,
              mediaKeys,
              decryptdata
            });
            const scheme = 'cenc';
            return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'playlist-key');
          });
        });
        keySessionContextPromise.catch(error => this.handleError(error));
      }
      return keySessionContextPromise;
    }
    throwIfDestroyed(message = 'Invalid state') {
      if (!this.hls) {
        throw new Error('invalid state');
      }
    }
    handleError(error) {
      if (!this.hls) {
        return;
      }
      this.error(error.message);
      if (error instanceof EMEKeyError) {
        this.hls.trigger(Events$1.ERROR, error.data);
      } else {
        this.hls.trigger(Events$1.ERROR, {
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_NO_KEYS,
          error,
          fatal: true
        });
      }
    }
    getKeySystemForKeyPromise(decryptdata) {
      const keyId = this.getKeyIdString(decryptdata);
      const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];
      if (!mediaKeySessionContext) {
        const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);
        const keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);
        return this.attemptKeySystemAccess(keySystemsToAttempt);
      }
      return mediaKeySessionContext;
    }
    getKeySystemSelectionPromise(keySystemsToAttempt) {
      if (!keySystemsToAttempt.length) {
        keySystemsToAttempt = getKeySystemsForConfig(this.config);
      }
      if (keySystemsToAttempt.length === 0) {
        throw new EMEKeyError({
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
          fatal: true
        }, `Missing key-system license configuration options ${JSON.stringify({
        drmSystems: this.config.drmSystems
      })}`);
      }
      return this.attemptKeySystemAccess(keySystemsToAttempt);
    }
    _onMediaEncrypted(event) {
      const {
        initDataType,
        initData
      } = event;
      const logMessage = `"${event.type}" event: init data type: "${initDataType}"`;
      this.debug(logMessage);

      // Ignore event when initData is null
      if (initData === null) {
        return;
      }
      let keyId;
      let keySystemDomain;
      if (initDataType === 'sinf' && this.config.drmSystems[KeySystems.FAIRPLAY]) {
        // Match sinf keyId to playlist skd://keyId=
        const json = bin2str(new Uint8Array(initData));
        try {
          const sinf = base64Decode(JSON.parse(json).sinf);
          const tenc = parseSinf(new Uint8Array(sinf));
          if (!tenc) {
            throw new Error(`'schm' box missing or not cbcs/cenc with schi > tenc`);
          }
          keyId = tenc.subarray(8, 24);
          keySystemDomain = KeySystems.FAIRPLAY;
        } catch (error) {
          this.warn(`${logMessage} Failed to parse sinf: ${error}`);
          return;
        }
      } else {
        // Support Widevine clear-lead key-session creation (otherwise depend on playlist keys)
        const psshResults = parseMultiPssh(initData);
        const psshInfo = psshResults.filter(pssh => pssh.systemId === KeySystemIds.WIDEVINE)[0];
        if (!psshInfo) {
          if (psshResults.length === 0 || psshResults.some(pssh => !pssh.systemId)) {
            this.warn(`${logMessage} contains incomplete or invalid pssh data`);
          } else {
            this.log(`ignoring ${logMessage} for ${psshResults.map(pssh => keySystemIdToKeySystemDomain(pssh.systemId)).join(',')} pssh data in favor of playlist keys`);
          }
          return;
        }
        keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);
        if (psshInfo.version === 0 && psshInfo.data) {
          const offset = psshInfo.data.length - 22;
          keyId = psshInfo.data.subarray(offset, offset + 16);
        }
      }
      if (!keySystemDomain || !keyId) {
        return;
      }
      const keyIdHex = Hex.hexDump(keyId);
      const {
        keyIdToKeySessionPromise,
        mediaKeySessions
      } = this;
      let keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];
      for (let i = 0; i < mediaKeySessions.length; i++) {
        // Match playlist key
        const keyContext = mediaKeySessions[i];
        const decryptdata = keyContext.decryptdata;
        if (!decryptdata.keyId) {
          continue;
        }
        const oldKeyIdHex = Hex.hexDump(decryptdata.keyId);
        if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, '').indexOf(keyIdHex) !== -1) {
          keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];
          if (decryptdata.pssh) {
            break;
          }
          delete keyIdToKeySessionPromise[oldKeyIdHex];
          decryptdata.pssh = new Uint8Array(initData);
          decryptdata.keyId = keyId;
          keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(() => {
            return this.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, 'encrypted-event-key-match');
          });
          break;
        }
      }
      if (!keySessionContextPromise) {
        // Clear-lead key (not encountered in playlist)
        keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(({
          keySystem,
          mediaKeys
        }) => {
          var _keySystemToKeySystem;
          this.throwIfDestroyed();
          const decryptdata = new LevelKey('ISO-23001-7', keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : '');
          decryptdata.pssh = new Uint8Array(initData);
          decryptdata.keyId = keyId;
          return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {
            this.throwIfDestroyed();
            const keySessionContext = this.createMediaKeySessionContext({
              decryptdata,
              keySystem,
              mediaKeys
            });
            return this.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, 'encrypted-event-no-match');
          });
        });
      }
      keySessionContextPromise.catch(error => this.handleError(error));
    }
    _onWaitingForKey(event) {
      this.log(`"${event.type}" event`);
    }
    attemptSetMediaKeys(keySystem, mediaKeys) {
      const queue = this.setMediaKeysQueue.slice();
      this.log(`Setting media-keys for "${keySystem}"`);
      // Only one setMediaKeys() can run at one time, and multiple setMediaKeys() operations
      // can be queued for execution for multiple key sessions.
      const setMediaKeysPromise = Promise.all(queue).then(() => {
        if (!this.media) {
          throw new Error('Attempted to set mediaKeys without media element attached');
        }
        return this.media.setMediaKeys(mediaKeys);
      });
      this.setMediaKeysQueue.push(setMediaKeysPromise);
      return setMediaKeysPromise.then(() => {
        this.log(`Media-keys set for "${keySystem}"`);
        queue.push(setMediaKeysPromise);
        this.setMediaKeysQueue = this.setMediaKeysQueue.filter(p => queue.indexOf(p) === -1);
      });
    }
    generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {
      var _this$config$drmSyste, _this$config$drmSyste2;
      const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;
      if (generateRequestFilter) {
        try {
          const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);
          if (!mappedInitData) {
            throw new Error('Invalid response from configured generateRequest filter');
          }
          initDataType = mappedInitData.initDataType;
          initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;
        } catch (error) {
          var _this$hls;
          this.warn(error.message);
          if ((_this$hls = this.hls) != null && _this$hls.config.debug) {
            throw error;
          }
        }
      }
      if (initData === null) {
        this.log(`Skipping key-session request for "${reason}" (no initData)`);
        return Promise.resolve(context);
      }
      const keyId = this.getKeyIdString(context.decryptdata);
      this.log(`Generating key-session request for "${reason}": ${keyId} (init data type: ${initDataType} length: ${initData ? initData.byteLength : null})`);
      const licenseStatus = new EventEmitter();
      const onmessage = context._onmessage = event => {
        const keySession = context.mediaKeysSession;
        if (!keySession) {
          licenseStatus.emit('error', new Error('invalid state'));
          return;
        }
        const {
          messageType,
          message
        } = event;
        this.log(`"${messageType}" message event for session "${keySession.sessionId}" message size: ${message.byteLength}`);
        if (messageType === 'license-request' || messageType === 'license-renewal') {
          this.renewLicense(context, message).catch(error => {
            this.handleError(error);
            licenseStatus.emit('error', error);
          });
        } else if (messageType === 'license-release') {
          if (context.keySystem === KeySystems.FAIRPLAY) {
            this.updateKeySession(context, strToUtf8array('acknowledged'));
            this.removeSession(context);
          }
        } else {
          this.warn(`unhandled media key message type "${messageType}"`);
        }
      };
      const onkeystatuseschange = context._onkeystatuseschange = event => {
        const keySession = context.mediaKeysSession;
        if (!keySession) {
          licenseStatus.emit('error', new Error('invalid state'));
          return;
        }
        this.onKeyStatusChange(context);
        const keyStatus = context.keyStatus;
        licenseStatus.emit('keyStatus', keyStatus);
        if (keyStatus === 'expired') {
          this.warn(`${context.keySystem} expired for key ${keyId}`);
          this.renewKeySession(context);
        }
      };
      context.mediaKeysSession.addEventListener('message', onmessage);
      context.mediaKeysSession.addEventListener('keystatuseschange', onkeystatuseschange);
      const keyUsablePromise = new Promise((resolve, reject) => {
        licenseStatus.on('error', reject);
        licenseStatus.on('keyStatus', keyStatus => {
          if (keyStatus.startsWith('usable')) {
            resolve();
          } else if (keyStatus === 'output-restricted') {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
              fatal: false
            }, 'HDCP level output restricted'));
          } else if (keyStatus === 'internal-error') {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
              fatal: true
            }, `key status changed to "${keyStatus}"`));
          } else if (keyStatus === 'expired') {
            reject(new Error('key expired while generating request'));
          } else {
            this.warn(`unhandled key status change "${keyStatus}"`);
          }
        });
      });
      return context.mediaKeysSession.generateRequest(initDataType, initData).then(() => {
        var _context$mediaKeysSes;
        this.log(`Request generated for key-session "${(_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId}" keyId: ${keyId}`);
      }).catch(error => {
        throw new EMEKeyError({
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_NO_SESSION,
          error,
          fatal: false
        }, `Error generating key-session request: ${error}`);
      }).then(() => keyUsablePromise).catch(error => {
        licenseStatus.removeAllListeners();
        this.removeSession(context);
        throw error;
      }).then(() => {
        licenseStatus.removeAllListeners();
        return context;
      });
    }
    onKeyStatusChange(mediaKeySessionContext) {
      mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status, keyId) => {
        this.log(`key status change "${status}" for keyStatuses keyId: ${Hex.hexDump('buffer' in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId))} session keyId: ${Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || []))} uri: ${mediaKeySessionContext.decryptdata.uri}`);
        mediaKeySessionContext.keyStatus = status;
      });
    }
    fetchServerCertificate(keySystem) {
      const config = this.config;
      const Loader = config.loader;
      const certLoader = new Loader(config);
      const url = this.getServerCertificateUrl(keySystem);
      if (!url) {
        return Promise.resolve();
      }
      this.log(`Fetching server certificate for "${keySystem}"`);
      return new Promise((resolve, reject) => {
        const loaderContext = {
          responseType: 'arraybuffer',
          url
        };
        const loadPolicy = config.certLoadPolicy.default;
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0
        };
        const loaderCallbacks = {
          onSuccess: (response, stats, context, networkDetails) => {
            resolve(response.data);
          },
          onError: (response, contex, networkDetails, stats) => {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
              fatal: true,
              networkDetails,
              response: _objectSpread2({
                url: loaderContext.url,
                data: undefined
              }, response)
            }, `"${keySystem}" certificate request failed (${url}). Status: ${response.code} (${response.text})`));
          },
          onTimeout: (stats, context, networkDetails) => {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
              fatal: true,
              networkDetails,
              response: {
                url: loaderContext.url,
                data: undefined
              }
            }, `"${keySystem}" certificate request timed out (${url})`));
          },
          onAbort: (stats, context, networkDetails) => {
            reject(new Error('aborted'));
          }
        };
        certLoader.load(loaderContext, loaderConfig, loaderCallbacks);
      });
    }
    setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {
      return new Promise((resolve, reject) => {
        mediaKeys.setServerCertificate(cert).then(success => {
          this.log(`setServerCertificate ${success ? 'success' : 'not supported by CDM'} (${cert == null ? void 0 : cert.byteLength}) on "${keySystem}"`);
          resolve(mediaKeys);
        }).catch(error => {
          reject(new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
            error,
            fatal: true
          }, error.message));
        });
      });
    }
    renewLicense(context, keyMessage) {
      return this.requestLicense(context, new Uint8Array(keyMessage)).then(data => {
        return this.updateKeySession(context, new Uint8Array(data)).catch(error => {
          throw new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,
            error,
            fatal: true
          }, error.message);
        });
      });
    }
    unpackPlayReadyKeyMessage(xhr, licenseChallenge) {
      // On Edge, the raw license message is UTF-16-encoded XML.  We need
      // to unpack the Challenge element (base64-encoded string containing the
      // actual license request) and any HttpHeader elements (sent as request
      // headers).
      // For PlayReady CDMs, we need to dig the Challenge out of the XML.
      const xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));
      if (!xmlString.includes('PlayReadyKeyMessage')) {
        // This does not appear to be a wrapped message as on Edge.  Some
        // clients do not need this unwrapping, so we will assume this is one of
        // them.  Note that "xml" at this point probably looks like random
        // garbage, since we interpreted UTF-8 as UTF-16.
        xhr.setRequestHeader('Content-Type', 'text/xml; charset=utf-8');
        return licenseChallenge;
      }
      const keyMessageXml = new DOMParser().parseFromString(xmlString, 'application/xml');
      // Set request headers.
      const headers = keyMessageXml.querySelectorAll('HttpHeader');
      if (headers.length > 0) {
        let header;
        for (let i = 0, len = headers.length; i < len; i++) {
          var _header$querySelector, _header$querySelector2;
          header = headers[i];
          const name = (_header$querySelector = header.querySelector('name')) == null ? void 0 : _header$querySelector.textContent;
          const value = (_header$querySelector2 = header.querySelector('value')) == null ? void 0 : _header$querySelector2.textContent;
          if (name && value) {
            xhr.setRequestHeader(name, value);
          }
        }
      }
      const challengeElement = keyMessageXml.querySelector('Challenge');
      const challengeText = challengeElement == null ? void 0 : challengeElement.textContent;
      if (!challengeText) {
        throw new Error(`Cannot find <Challenge> in key message`);
      }
      return strToUtf8array(atob(challengeText));
    }
    setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {
      const licenseXhrSetup = this.config.licenseXhrSetup;
      if (!licenseXhrSetup) {
        xhr.open('POST', url, true);
        return Promise.resolve({
          xhr,
          licenseChallenge
        });
      }
      return Promise.resolve().then(() => {
        if (!keysListItem.decryptdata) {
          throw new Error('Key removed');
        }
        return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);
      }).catch(error => {
        if (!keysListItem.decryptdata) {
          // Key session removed. Cancel license request.
          throw error;
        }
        // let's try to open before running setup
        xhr.open('POST', url, true);
        return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);
      }).then(licenseXhrSetupResult => {
        // if licenseXhrSetup did not yet call open, let's do it now
        if (!xhr.readyState) {
          xhr.open('POST', url, true);
        }
        const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;
        return {
          xhr,
          licenseChallenge: finalLicenseChallenge
        };
      });
    }
    requestLicense(keySessionContext, licenseChallenge) {
      const keyLoadPolicy = this.config.keyLoadPolicy.default;
      return new Promise((resolve, reject) => {
        const url = this.getLicenseServerUrl(keySessionContext.keySystem);
        this.log(`Sending license request to URL: ${url}`);
        const xhr = new XMLHttpRequest();
        xhr.responseType = 'arraybuffer';
        xhr.onreadystatechange = () => {
          if (!this.hls || !keySessionContext.mediaKeysSession) {
            return reject(new Error('invalid state'));
          }
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              this._requestLicenseFailureCount = 0;
              let data = xhr.response;
              this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);
              const licenseResponseCallback = this.config.licenseResponseCallback;
              if (licenseResponseCallback) {
                try {
                  data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);
                } catch (error) {
                  this.error(error);
                }
              }
              resolve(data);
            } else {
              const retryConfig = keyLoadPolicy.errorRetry;
              const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;
              this._requestLicenseFailureCount++;
              if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {
                reject(new EMEKeyError({
                  type: ErrorTypes.KEY_SYSTEM_ERROR,
                  details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                  fatal: true,
                  networkDetails: xhr,
                  response: {
                    url,
                    data: undefined,
                    code: xhr.status,
                    text: xhr.statusText
                  }
                }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));
              } else {
                const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;
                this.warn(`Retrying license request, ${attemptsLeft} attempts left`);
                this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);
              }
            }
          }
        };
        if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {
          keySessionContext.licenseXhr.abort();
        }
        keySessionContext.licenseXhr = xhr;
        this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({
          xhr,
          licenseChallenge
        }) => {
          if (keySessionContext.keySystem == KeySystems.PLAYREADY) {
            licenseChallenge = this.unpackPlayReadyKeyMessage(xhr, licenseChallenge);
          }
          xhr.send(licenseChallenge);
        });
      });
    }
    onMediaAttached(event, data) {
      if (!this.config.emeEnabled) {
        return;
      }
      const media = data.media;

      // keep reference of media
      this.media = media;
      media.addEventListener('encrypted', this.onMediaEncrypted);
      media.addEventListener('waitingforkey', this.onWaitingForKey);
    }
    onMediaDetached() {
      const media = this.media;
      const mediaKeysList = this.mediaKeySessions;
      if (media) {
        media.removeEventListener('encrypted', this.onMediaEncrypted);
        media.removeEventListener('waitingforkey', this.onWaitingForKey);
        this.media = null;
      }
      this._requestLicenseFailureCount = 0;
      this.setMediaKeysQueue = [];
      this.mediaKeySessions = [];
      this.keyIdToKeySessionPromise = {};
      LevelKey.clearKeyUriToKeyIdMap();

      // Close all sessions and remove media keys from the video element.
      const keySessionCount = mediaKeysList.length;
      EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map(mediaKeySessionContext => this.removeSession(mediaKeySessionContext)).concat(media == null ? void 0 : media.setMediaKeys(null).catch(error => {
        this.log(`Could not clear media keys: ${error}`);
      }))).then(() => {
        if (keySessionCount) {
          this.log('finished closing key sessions and clearing media keys');
          mediaKeysList.length = 0;
        }
      }).catch(error => {
        this.log(`Could not close sessions and clear media keys: ${error}`);
      });
    }
    onManifestLoading() {
      this.keyFormatPromise = null;
    }
    onManifestLoaded(event, {
      sessionKeys
    }) {
      if (!sessionKeys || !this.config.emeEnabled) {
        return;
      }
      if (!this.keyFormatPromise) {
        const keyFormats = sessionKeys.reduce((formats, sessionKey) => {
          if (formats.indexOf(sessionKey.keyFormat) === -1) {
            formats.push(sessionKey.keyFormat);
          }
          return formats;
        }, []);
        this.log(`Selecting key-system from session-keys ${keyFormats.join(', ')}`);
        this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
      }
    }
    removeSession(mediaKeySessionContext) {
      const {
        mediaKeysSession,
        licenseXhr
      } = mediaKeySessionContext;
      if (mediaKeysSession) {
        this.log(`Remove licenses and keys and close session ${mediaKeysSession.sessionId}`);
        if (mediaKeySessionContext._onmessage) {
          mediaKeysSession.removeEventListener('message', mediaKeySessionContext._onmessage);
          mediaKeySessionContext._onmessage = undefined;
        }
        if (mediaKeySessionContext._onkeystatuseschange) {
          mediaKeysSession.removeEventListener('keystatuseschange', mediaKeySessionContext._onkeystatuseschange);
          mediaKeySessionContext._onkeystatuseschange = undefined;
        }
        if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {
          licenseXhr.abort();
        }
        mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;
        const index = this.mediaKeySessions.indexOf(mediaKeySessionContext);
        if (index > -1) {
          this.mediaKeySessions.splice(index, 1);
        }
        return mediaKeysSession.remove().catch(error => {
          this.log(`Could not remove session: ${error}`);
        }).then(() => {
          return mediaKeysSession.close();
        }).catch(error => {
          this.log(`Could not close session: ${error}`);
        });
      }
    }
  }
  EMEController.CDMCleanupPromise = void 0;
  class EMEKeyError extends Error {
    constructor(data, message) {
      super(message);
      this.data = void 0;
      data.error || (data.error = new Error(message));
      this.data = data;
      data.err = data.error;
    }
  }

  /**
   * Common Media Object Type
   *
   * @group CMCD
   * @group CMSD
   *
   * @beta
   */
  var CmObjectType;
  (function (CmObjectType) {
    /**
     * text file, such as a manifest or playlist
     */
    CmObjectType["MANIFEST"] = "m";
    /**
     * audio only
     */
    CmObjectType["AUDIO"] = "a";
    /**
     * video only
     */
    CmObjectType["VIDEO"] = "v";
    /**
     * muxed audio and video
     */
    CmObjectType["MUXED"] = "av";
    /**
     * init segment
     */
    CmObjectType["INIT"] = "i";
    /**
     * caption or subtitle
     */
    CmObjectType["CAPTION"] = "c";
    /**
     * ISOBMFF timed text track
     */
    CmObjectType["TIMED_TEXT"] = "tt";
    /**
     * cryptographic key, license or certificate.
     */
    CmObjectType["KEY"] = "k";
    /**
     * other
     */
    CmObjectType["OTHER"] = "o";
  })(CmObjectType || (CmObjectType = {}));

  /**
   * Common Media Streaming Format
   *
   * @group CMCD
   * @group CMSD
   *
   * @beta
   */
  var CmStreamingFormat;
  (function (CmStreamingFormat) {
    /**
     * MPEG DASH
     */
    CmStreamingFormat["DASH"] = "d";
    /**
     * HTTP Live Streaming (HLS)
     */
    CmStreamingFormat["HLS"] = "h";
    /**
     * Smooth Streaming
     */
    CmStreamingFormat["SMOOTH"] = "s";
    /**
     * Other
     */
    CmStreamingFormat["OTHER"] = "o";
  })(CmStreamingFormat || (CmStreamingFormat = {}));

  /**
   * CMCD header fields.
   *
   * @group CMCD
   *
   * @beta
   */
  var CmcdHeaderField;
  (function (CmcdHeaderField) {
    /**
     * keys whose values vary with the object being requested.
     */
    CmcdHeaderField["OBJECT"] = "CMCD-Object";
    /**
     * keys whose values vary with each request.
     */
    CmcdHeaderField["REQUEST"] = "CMCD-Request";
    /**
     * keys whose values are expected to be invariant over the life of the session.
     */
    CmcdHeaderField["SESSION"] = "CMCD-Session";
    /**
     * keys whose values do not vary with every request or object.
     */
    CmcdHeaderField["STATUS"] = "CMCD-Status";
  })(CmcdHeaderField || (CmcdHeaderField = {}));

  /**
   * The map of CMCD header fields to official CMCD keys.
   *
   * @internal
   *
   * @group CMCD
   */
  const CmcdHeaderMap = {
    [CmcdHeaderField.OBJECT]: ['br', 'd', 'ot', 'tb'],
    [CmcdHeaderField.REQUEST]: ['bl', 'dl', 'mtp', 'nor', 'nrr', 'su'],
    [CmcdHeaderField.SESSION]: ['cid', 'pr', 'sf', 'sid', 'st', 'v'],
    [CmcdHeaderField.STATUS]: ['bs', 'rtp']
  };

  /**
   * Structured Field Item
   *
   * @group Structured Field
   *
   * @beta
   */
  class SfItem {
    constructor(value, params) {
      this.value = void 0;
      this.params = void 0;
      if (Array.isArray(value)) {
        value = value.map(v => v instanceof SfItem ? v : new SfItem(v));
      }
      this.value = value;
      this.params = params;
    }
  }

  /**
   * A class to represent structured field tokens when `Symbol` is not available.
   *
   * @group Structured Field
   *
   * @beta
   */
  class SfToken {
    constructor(description) {
      this.description = void 0;
      this.description = description;
    }
  }

  const DICT = 'Dict';

  function format(value) {
    if (Array.isArray(value)) {
      return JSON.stringify(value);
    }
    if (value instanceof Map) {
      return 'Map{}';
    }
    if (value instanceof Set) {
      return 'Set{}';
    }
    if (typeof value === 'object') {
      return JSON.stringify(value);
    }
    return String(value);
  }
  function throwError(action, src, type, cause) {
    return new Error(`failed to ${action} "${format(src)}" as ${type}`, {
      cause
    });
  }

  const BARE_ITEM = 'Bare Item';

  const BOOLEAN = 'Boolean';

  const BYTES = 'Byte Sequence';

  const DECIMAL = 'Decimal';

  const INTEGER = 'Integer';

  function isInvalidInt(value) {
    return value < -999999999999999 || 999999999999999 < value;
  }

  const STRING_REGEX = /[\x00-\x1f\x7f]+/; // eslint-disable-line no-control-regex

  const TOKEN = 'Token';

  const KEY = 'Key';

  function serializeError(src, type, cause) {
    return throwError('serialize', src, type, cause);
  }

  // 4.1.9.  Serializing a Boolean
  //
  // Given a Boolean as input_boolean, return an ASCII string suitable for
  // use in a HTTP field value.
  //
  // 1.  If input_boolean is not a boolean, fail serialization.
  //
  // 2.  Let output be an empty string.
  //
  // 3.  Append "?" to output.
  //
  // 4.  If input_boolean is true, append "1" to output.
  //
  // 5.  If input_boolean is false, append "0" to output.
  //
  // 6.  Return output.
  function serializeBoolean(value) {
    if (typeof value !== 'boolean') {
      throw serializeError(value, BOOLEAN);
    }
    return value ? '?1' : '?0';
  }

  /**
   * Encodes binary data to base64
   *
   * @param binary - The binary data to encode
   * @returns The base64 encoded string
   *
   * @group Utils
   *
   * @beta
   */
  function base64encode(binary) {
    return btoa(String.fromCharCode(...binary));
  }

  // 4.1.8.  Serializing a Byte Sequence
  //
  // Given a Byte Sequence as input_bytes, return an ASCII string suitable
  // for use in a HTTP field value.
  //
  // 1.  If input_bytes is not a sequence of bytes, fail serialization.
  //
  // 2.  Let output be an empty string.
  //
  // 3.  Append ":" to output.
  //
  // 4.  Append the result of base64-encoding input_bytes as per
  //     [RFC4648], Section 4, taking account of the requirements below.
  //
  // 5.  Append ":" to output.
  //
  // 6.  Return output.
  //
  // The encoded data is required to be padded with "=", as per [RFC4648],
  // Section 3.2.
  //
  // Likewise, encoded data SHOULD have pad bits set to zero, as per
  // [RFC4648], Section 3.5, unless it is not possible to do so due to
  // implementation constraints.
  function serializeByteSequence(value) {
    if (ArrayBuffer.isView(value) === false) {
      throw serializeError(value, BYTES);
    }
    return `:${base64encode(value)}:`;
  }

  // 4.1.4.  Serializing an Integer
  //
  // Given an Integer as input_integer, return an ASCII string suitable
  // for use in a HTTP field value.
  //
  // 1.  If input_integer is not an integer in the range of
  //     -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail
  //     serialization.
  //
  // 2.  Let output be an empty string.
  //
  // 3.  If input_integer is less than (but not equal to) 0, append "-" to
  //     output.
  //
  // 4.  Append input_integer's numeric value represented in base 10 using
  //     only decimal digits to output.
  //
  // 5.  Return output.
  function serializeInteger(value) {
    if (isInvalidInt(value)) {
      throw serializeError(value, INTEGER);
    }
    return value.toString();
  }

  // 4.1.10.  Serializing a Date
  //
  // Given a Date as input_integer, return an ASCII string suitable for
  // use in an HTTP field value.
  // 1.  Let output be "@".
  // 2.  Append to output the result of running Serializing an Integer
  //     with input_date (Section 4.1.4).
  // 3.  Return output.
  function serializeDate(value) {
    return `@${serializeInteger(value.getTime() / 1000)}`;
  }

  /**
   * This implements the rounding procedure described in step 2 of the "Serializing a Decimal" specification.
   * This rounding style is known as "even rounding", "banker's rounding", or "commercial rounding".
   *
   * @param value - The value to round
   * @param precision - The number of decimal places to round to
   * @returns The rounded value
   *
   * @group Utils
   *
   * @beta
   */
  function roundToEven(value, precision) {
    if (value < 0) {
      return -roundToEven(-value, precision);
    }
    const decimalShift = Math.pow(10, precision);
    const isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;
    if (isEquidistant) {
      // If the tail of the decimal place is 'equidistant' we round to the nearest even value
      const flooredValue = Math.floor(value * decimalShift);
      return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;
    } else {
      // Otherwise, proceed as normal
      return Math.round(value * decimalShift) / decimalShift;
    }
  }

  // 4.1.5.  Serializing a Decimal
  //
  // Given a decimal number as input_decimal, return an ASCII string
  // suitable for use in a HTTP field value.
  //
  // 1.   If input_decimal is not a decimal number, fail serialization.
  //
  // 2.   If input_decimal has more than three significant digits to the
  //      right of the decimal point, round it to three decimal places,
  //      rounding the final digit to the nearest value, or to the even
  //      value if it is equidistant.
  //
  // 3.   If input_decimal has more than 12 significant digits to the left
  //      of the decimal point after rounding, fail serialization.
  //
  // 4.   Let output be an empty string.
  //
  // 5.   If input_decimal is less than (but not equal to) 0, append "-"
  //      to output.
  //
  // 6.   Append input_decimal's integer component represented in base 10
  //      (using only decimal digits) to output; if it is zero, append
  //      "0".
  //
  // 7.   Append "." to output.
  //
  // 8.   If input_decimal's fractional component is zero, append "0" to
  //      output.
  //
  // 9.   Otherwise, append the significant digits of input_decimal's
  //      fractional component represented in base 10 (using only decimal
  //      digits) to output.
  //
  // 10.  Return output.
  function serializeDecimal(value) {
    const roundedValue = roundToEven(value, 3); // round to 3 decimal places
    if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {
      throw serializeError(value, DECIMAL);
    }
    const stringValue = roundedValue.toString();
    return stringValue.includes('.') ? stringValue : `${stringValue}.0`;
  }

  const STRING = 'String';

  // 4.1.6.  Serializing a String
  //
  // Given a String as input_string, return an ASCII string suitable for
  // use in a HTTP field value.
  //
  // 1.  Convert input_string into a sequence of ASCII characters; if
  //     conversion fails, fail serialization.
  //
  // 2.  If input_string contains characters in the range %x00-1f or %x7f
  //     (i.e., not in VCHAR or SP), fail serialization.
  //
  // 3.  Let output be the string DQUOTE.
  //
  // 4.  For each character char in input_string:
  //
  //     1.  If char is "\" or DQUOTE:
  //
  //         1.  Append "\" to output.
  //
  //     2.  Append char to output.
  //
  // 5.  Append DQUOTE to output.
  //
  // 6.  Return output.
  function serializeString(value) {
    if (STRING_REGEX.test(value)) {
      throw serializeError(value, STRING);
    }
    return `"${value.replace(/\\/g, `\\\\`).replace(/"/g, `\\"`)}"`;
  }

  function symbolToStr(symbol) {
    return symbol.description || symbol.toString().slice(7, -1);
  }

  function serializeToken(token) {
    const value = symbolToStr(token);
    if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(value) === false) {
      throw serializeError(value, TOKEN);
    }
    return value;
  }

  // 4.1.3.1.  Serializing a Bare Item
  //
  // Given an Item as input_item, return an ASCII string suitable for use
  // in a HTTP field value.
  //
  // 1.  If input_item is an Integer, return the result of running
  //     Serializing an Integer (Section 4.1.4) with input_item.
  //
  // 2.  If input_item is a Decimal, return the result of running
  //     Serializing a Decimal (Section 4.1.5) with input_item.
  //
  // 3.  If input_item is a String, return the result of running
  //     Serializing a String (Section 4.1.6) with input_item.
  //
  // 4.  If input_item is a Token, return the result of running
  //     Serializing a Token (Section 4.1.7) with input_item.
  //
  // 5.  If input_item is a Boolean, return the result of running
  //     Serializing a Boolean (Section 4.1.9) with input_item.
  //
  // 6.  If input_item is a Byte Sequence, return the result of running
  //     Serializing a Byte Sequence (Section 4.1.8) with input_item.
  //
  // 7.  If input_item is a Date, return the result of running Serializing
  //     a Date (Section 4.1.10) with input_item.
  //
  // 8.  Otherwise, fail serialization.
  function serializeBareItem(value) {
    switch (typeof value) {
      case 'number':
        if (!isFiniteNumber(value)) {
          throw serializeError(value, BARE_ITEM);
        }
        if (Number.isInteger(value)) {
          return serializeInteger(value);
        }
        return serializeDecimal(value);
      case 'string':
        return serializeString(value);
      case 'symbol':
        return serializeToken(value);
      case 'boolean':
        return serializeBoolean(value);
      case 'object':
        if (value instanceof Date) {
          return serializeDate(value);
        }
        if (value instanceof Uint8Array) {
          return serializeByteSequence(value);
        }
        if (value instanceof SfToken) {
          return serializeToken(value);
        }
      default:
        // fail
        throw serializeError(value, BARE_ITEM);
    }
  }

  // 4.1.1.3.  Serializing a Key
  //
  // Given a key as input_key, return an ASCII string suitable for use in
  // a HTTP field value.
  //
  // 1.  Convert input_key into a sequence of ASCII characters; if
  //     conversion fails, fail serialization.
  //
  // 2.  If input_key contains characters not in lcalpha, DIGIT, "_", "-",
  //     ".", or "*" fail serialization.
  //
  // 3.  If the first character of input_key is not lcalpha or "*", fail
  //     serialization.
  //
  // 4.  Let output be an empty string.
  //
  // 5.  Append input_key to output.
  //
  // 6.  Return output.
  function serializeKey(value) {
    if (/^[a-z*][a-z0-9\-_.*]*$/.test(value) === false) {
      throw serializeError(value, KEY);
    }
    return value;
  }

  // 4.1.1.2.  Serializing Parameters
  //
  // Given an ordered Dictionary as input_parameters (each member having a
  // param_name and a param_value), return an ASCII string suitable for
  // use in a HTTP field value.
  //
  // 1.  Let output be an empty string.
  //
  // 2.  For each param_name with a value of param_value in
  //     input_parameters:
  //
  //     1.  Append ";" to output.
  //
  //     2.  Append the result of running Serializing a Key
  //         (Section 4.1.1.3) with param_name to output.
  //
  //     3.  If param_value is not Boolean true:
  //
  //         1.  Append "=" to output.
  //
  //         2.  Append the result of running Serializing a bare Item
  //             (Section 4.1.3.1) with param_value to output.
  //
  // 3.  Return output.
  function serializeParams(params) {
    if (params == null) {
      return '';
    }
    return Object.entries(params).map(([key, value]) => {
      if (value === true) {
        return `;${serializeKey(key)}`; // omit true
      }
      return `;${serializeKey(key)}=${serializeBareItem(value)}`;
    }).join('');
  }

  // 4.1.3.  Serializing an Item
  //
  // Given an Item as bare_item and Parameters as item_parameters, return
  // an ASCII string suitable for use in a HTTP field value.
  //
  // 1.  Let output be an empty string.
  //
  // 2.  Append the result of running Serializing a Bare Item
  //     Section 4.1.3.1 with bare_item to output.
  //
  // 3.  Append the result of running Serializing Parameters
  //     Section 4.1.1.2 with item_parameters to output.
  //
  // 4.  Return output.
  function serializeItem(value) {
    if (value instanceof SfItem) {
      return `${serializeBareItem(value.value)}${serializeParams(value.params)}`;
    } else {
      return serializeBareItem(value);
    }
  }

  // 4.1.1.1.  Serializing an Inner List
  //
  // Given an array of (member_value, parameters) tuples as inner_list,
  // and parameters as list_parameters, return an ASCII string suitable
  // for use in a HTTP field value.
  //
  // 1.  Let output be the string "(".
  //
  // 2.  For each (member_value, parameters) of inner_list:
  //
  //     1.  Append the result of running Serializing an Item
  //         (Section 4.1.3) with (member_value, parameters) to output.
  //
  //     2.  If more values remain in inner_list, append a single SP to
  //         output.
  //
  // 3.  Append ")" to output.
  //
  // 4.  Append the result of running Serializing Parameters
  //     (Section 4.1.1.2) with list_parameters to output.
  //
  // 5.  Return output.
  function serializeInnerList(value) {
    return `(${value.value.map(serializeItem).join(' ')})${serializeParams(value.params)}`;
  }

  // 4.1.2.  Serializing a Dictionary
  //
  // Given an ordered Dictionary as input_dictionary (each member having a
  // member_name and a tuple value of (member_value, parameters)), return
  // an ASCII string suitable for use in a HTTP field value.
  //
  // 1.  Let output be an empty string.
  //
  // 2.  For each member_name with a value of (member_value, parameters)
  //     in input_dictionary:
  //
  //     1.  Append the result of running Serializing a Key
  //         (Section 4.1.1.3) with member's member_name to output.
  //
  //     2.  If member_value is Boolean true:
  //
  //         1.  Append the result of running Serializing Parameters
  //             (Section 4.1.1.2) with parameters to output.
  //
  //     3.  Otherwise:
  //
  //         1.  Append "=" to output.
  //
  //         2.  If member_value is an array, append the result of running
  //             Serializing an Inner List (Section 4.1.1.1) with
  //             (member_value, parameters) to output.
  //
  //         3.  Otherwise, append the result of running Serializing an
  //             Item (Section 4.1.3) with (member_value, parameters) to
  //             output.
  //
  //     4.  If more members remain in input_dictionary:
  //
  //         1.  Append "," to output.
  //
  //         2.  Append a single SP to output.
  //
  // 3.  Return output.
  function serializeDict(dict, options = {
    whitespace: true
  }) {
    if (typeof dict !== 'object') {
      throw serializeError(dict, DICT);
    }
    const entries = dict instanceof Map ? dict.entries() : Object.entries(dict);
    const optionalWhiteSpace = options != null && options.whitespace ? ' ' : '';
    return Array.from(entries).map(([key, item]) => {
      if (item instanceof SfItem === false) {
        item = new SfItem(item);
      }
      let output = serializeKey(key);
      if (item.value === true) {
        output += serializeParams(item.params);
      } else {
        output += '=';
        if (Array.isArray(item.value)) {
          output += serializeInnerList(item);
        } else {
          output += serializeItem(item);
        }
      }
      return output;
    }).join(`,${optionalWhiteSpace}`);
  }

  /**
   * Encode an object into a structured field dictionary
   *
   * @param input - The structured field dictionary to encode
   * @returns The structured field string
   *
   * @group Structured Field
   *
   * @beta
   */
  function encodeSfDict(value, options) {
    return serializeDict(value, options);
  }

  /**
   * Checks if the given key is a token field.
   *
   * @param key - The key to check.
   *
   * @returns `true` if the key is a token field.
   *
   * @internal
   *
   * @group CMCD
   */
  const isTokenField = key => key === 'ot' || key === 'sf' || key === 'st';

  const isValid = value => {
    if (typeof value === 'number') {
      return isFiniteNumber(value);
    }
    return value != null && value !== '' && value !== false;
  };

  /**
   * Constructs a relative path from a URL.
   *
   * @param url - The destination URL
   * @param base - The base URL
   * @returns The relative path
   *
   * @group Utils
   *
   * @beta
   */
  function urlToRelativePath(url, base) {
    const to = new URL(url);
    const from = new URL(base);
    if (to.origin !== from.origin) {
      return url;
    }
    const toPath = to.pathname.split('/').slice(1);
    const fromPath = from.pathname.split('/').slice(1, -1);
    // remove common parents
    while (toPath[0] === fromPath[0]) {
      toPath.shift();
      fromPath.shift();
    }
    // add back paths
    while (fromPath.length) {
      fromPath.shift();
      toPath.unshift('..');
    }
    return toPath.join('/');
  }

  /**
   * Generate a random v4 UUID
   *
   * @returns A random v4 UUID
   *
   * @group Utils
   *
   * @beta
   */
  function uuid() {
    try {
      return crypto.randomUUID();
    } catch (error) {
      try {
        const url = URL.createObjectURL(new Blob());
        const uuid = url.toString();
        URL.revokeObjectURL(url);
        return uuid.slice(uuid.lastIndexOf('/') + 1);
      } catch (error) {
        let dt = new Date().getTime();
        const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
          const r = (dt + Math.random() * 16) % 16 | 0;
          dt = Math.floor(dt / 16);
          return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
        });
        return uuid;
      }
    }
  }

  const toRounded = value => Math.round(value);
  const toUrlSafe = (value, options) => {
    if (options != null && options.baseUrl) {
      value = urlToRelativePath(value, options.baseUrl);
    }
    return encodeURIComponent(value);
  };
  const toHundred = value => toRounded(value / 100) * 100;
  /**
   * The default formatters for CMCD values.
   *
   * @group CMCD
   *
   * @beta
   */
  const CmcdFormatters = {
    /**
     * Bitrate (kbps) rounded integer
     */
    br: toRounded,
    /**
     * Duration (milliseconds) rounded integer
     */
    d: toRounded,
    /**
     * Buffer Length (milliseconds) rounded nearest 100ms
     */
    bl: toHundred,
    /**
     * Deadline (milliseconds) rounded nearest 100ms
     */
    dl: toHundred,
    /**
     * Measured Throughput (kbps) rounded nearest 100kbps
     */
    mtp: toHundred,
    /**
     * Next Object Request URL encoded
     */
    nor: toUrlSafe,
    /**
     * Requested maximum throughput (kbps) rounded nearest 100kbps
     */
    rtp: toHundred,
    /**
     * Top Bitrate (kbps) rounded integer
     */
    tb: toRounded
  };

  /**
   * Internal CMCD processing function.
   *
   * @param obj - The CMCD object to process.
   * @param map - The mapping function to use.
   * @param options - Options for encoding.
   *
   * @internal
   *
   * @group CMCD
   */
  function processCmcd(obj, options) {
    const results = {};
    if (obj == null || typeof obj !== 'object') {
      return results;
    }
    const keys = Object.keys(obj).sort();
    const formatters = _extends$2({}, CmcdFormatters, options == null ? void 0 : options.formatters);
    const filter = options == null ? void 0 : options.filter;
    keys.forEach(key => {
      if (filter != null && filter(key)) {
        return;
      }
      let value = obj[key];
      const formatter = formatters[key];
      if (formatter) {
        value = formatter(value, options);
      }
      // Version should only be reported if not equal to 1.
      if (key === 'v' && value === 1) {
        return;
      }
      // Playback rate should only be sent if not equal to 1.
      if (key == 'pr' && value === 1) {
        return;
      }
      // ignore invalid values
      if (!isValid(value)) {
        return;
      }
      if (isTokenField(key) && typeof value === 'string') {
        value = new SfToken(value);
      }
      results[key] = value;
    });
    return results;
  }

  /**
   * Encode a CMCD object to a string.
   *
   * @param cmcd - The CMCD object to encode.
   * @param options - Options for encoding.
   *
   * @returns The encoded CMCD string.
   *
   * @group CMCD
   *
   * @beta
   */
  function encodeCmcd(cmcd, options = {}) {
    if (!cmcd) {
      return '';
    }
    return encodeSfDict(processCmcd(cmcd, options), _extends$2({
      whitespace: false
    }, options));
  }

  /**
   * Convert a CMCD data object to request headers
   *
   * @param cmcd - The CMCD data object to convert.
   * @param options - Options for encoding the CMCD object.
   *
   * @returns The CMCD header shards.
   *
   * @group CMCD
   *
   * @beta
   */
  function toCmcdHeaders(cmcd, options = {}) {
    if (!cmcd) {
      return {};
    }
    const entries = Object.entries(cmcd);
    const headerMap = Object.entries(CmcdHeaderMap).concat(Object.entries((options == null ? void 0 : options.customHeaderMap) || {}));
    const shards = entries.reduce((acc, entry) => {
      var _headerMap$find, _acc$field;
      const [key, value] = entry;
      const field = ((_headerMap$find = headerMap.find(entry => entry[1].includes(key))) == null ? void 0 : _headerMap$find[0]) || CmcdHeaderField.REQUEST;
      (_acc$field = acc[field]) != null ? _acc$field : acc[field] = {};
      acc[field][key] = value;
      return acc;
    }, {});
    return Object.entries(shards).reduce((acc, [field, value]) => {
      acc[field] = encodeCmcd(value, options);
      return acc;
    }, {});
  }

  /**
   * Append CMCD query args to a header object.
   *
   * @param headers - The headers to append to.
   * @param cmcd - The CMCD object to append.
   * @param customHeaderMap - A map of custom CMCD keys to header fields.
   *
   * @returns The headers with the CMCD header shards appended.
   *
   * @group CMCD
   *
   * @beta
   */
  function appendCmcdHeaders(headers, cmcd, options) {
    return _extends$2(headers, toCmcdHeaders(cmcd, options));
  }

  /**
   * CMCD parameter name.
   *
   * @group CMCD
   *
   * @beta
   */
  const CMCD_PARAM = 'CMCD';

  /**
   * Convert a CMCD data object to a query arg.
   *
   * @param cmcd - The CMCD object to convert.
   * @param options - Options for encoding the CMCD object.
   *
   * @returns The CMCD query arg.
   *
   * @group CMCD
   *
   * @beta
   */
  function toCmcdQuery(cmcd, options = {}) {
    if (!cmcd) {
      return '';
    }
    const params = encodeCmcd(cmcd, options);
    return `${CMCD_PARAM}=${encodeURIComponent(params)}`;
  }

  const REGEX = /CMCD=[^&#]+/;
  /**
   * Append CMCD query args to a URL.
   *
   * @param url - The URL to append to.
   * @param cmcd - The CMCD object to append.
   * @param options - Options for encoding the CMCD object.
   *
   * @returns The URL with the CMCD query args appended.
   *
   * @group CMCD
   *
   * @beta
   */
  function appendCmcdQuery(url, cmcd, options) {
    // TODO: Replace with URLSearchParams once we drop Safari < 10.1 & Chrome < 49 support.
    // https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
    const query = toCmcdQuery(cmcd, options);
    if (!query) {
      return url;
    }
    if (REGEX.test(url)) {
      return url.replace(REGEX, query);
    }
    const separator = url.includes('?') ? '&' : '?';
    return `${url}${separator}${query}`;
  }

  /**
   * Controller to deal with Common Media Client Data (CMCD)
   * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf
   */
  class CMCDController {
    // eslint-disable-line no-restricted-globals

    constructor(hls) {
      this.hls = void 0;
      this.config = void 0;
      this.media = void 0;
      this.sid = void 0;
      this.cid = void 0;
      this.useHeaders = false;
      this.includeKeys = void 0;
      this.initialized = false;
      this.starved = false;
      this.buffering = true;
      this.audioBuffer = void 0;
      // eslint-disable-line no-restricted-globals
      this.videoBuffer = void 0;
      this.onWaiting = () => {
        if (this.initialized) {
          this.starved = true;
        }
        this.buffering = true;
      };
      this.onPlaying = () => {
        if (!this.initialized) {
          this.initialized = true;
        }
        this.buffering = false;
      };
      /**
       * Apply CMCD data to a manifest request.
       */
      this.applyPlaylistData = context => {
        try {
          this.apply(context, {
            ot: CmObjectType.MANIFEST,
            su: !this.initialized
          });
        } catch (error) {
          logger.warn('Could not generate manifest CMCD data.', error);
        }
      };
      /**
       * Apply CMCD data to a segment request
       */
      this.applyFragmentData = context => {
        try {
          const fragment = context.frag;
          const level = this.hls.levels[fragment.level];
          const ot = this.getObjectType(fragment);
          const data = {
            d: fragment.duration * 1000,
            ot
          };
          if (ot === CmObjectType.VIDEO || ot === CmObjectType.AUDIO || ot == CmObjectType.MUXED) {
            data.br = level.bitrate / 1000;
            data.tb = this.getTopBandwidth(ot) / 1000;
            data.bl = this.getBufferLength(ot);
          }
          this.apply(context, data);
        } catch (error) {
          logger.warn('Could not generate segment CMCD data.', error);
        }
      };
      this.hls = hls;
      const config = this.config = hls.config;
      const {
        cmcd
      } = config;
      if (cmcd != null) {
        config.pLoader = this.createPlaylistLoader();
        config.fLoader = this.createFragmentLoader();
        this.sid = cmcd.sessionId || uuid();
        this.cid = cmcd.contentId;
        this.useHeaders = cmcd.useHeaders === true;
        this.includeKeys = cmcd.includeKeys;
        this.registerListeners();
      }
    }
    registerListeners() {
      const hls = this.hls;
      hls.on(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events$1.MEDIA_DETACHED, this.onMediaDetached, this);
      hls.on(Events$1.BUFFER_CREATED, this.onBufferCreated, this);
    }
    unregisterListeners() {
      const hls = this.hls;
      hls.off(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events$1.MEDIA_DETACHED, this.onMediaDetached, this);
      hls.off(Events$1.BUFFER_CREATED, this.onBufferCreated, this);
    }
    destroy() {
      this.unregisterListeners();
      this.onMediaDetached();

      // @ts-ignore
      this.hls = this.config = this.audioBuffer = this.videoBuffer = null;
      // @ts-ignore
      this.onWaiting = this.onPlaying = null;
    }
    onMediaAttached(event, data) {
      this.media = data.media;
      this.media.addEventListener('waiting', this.onWaiting);
      this.media.addEventListener('playing', this.onPlaying);
    }
    onMediaDetached() {
      if (!this.media) {
        return;
      }
      this.media.removeEventListener('waiting', this.onWaiting);
      this.media.removeEventListener('playing', this.onPlaying);

      // @ts-ignore
      this.media = null;
    }
    onBufferCreated(event, data) {
      var _data$tracks$audio, _data$tracks$video;
      this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;
      this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;
    }
    /**
     * Create baseline CMCD data
     */
    createData() {
      var _this$media;
      return {
        v: 1,
        sf: CmStreamingFormat.HLS,
        sid: this.sid,
        cid: this.cid,
        pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,
        mtp: this.hls.bandwidthEstimate / 1000
      };
    }

    /**
     * Apply CMCD data to a request.
     */
    apply(context, data = {}) {
      // apply baseline data
      _extends$2(data, this.createData());
      const isVideo = data.ot === CmObjectType.INIT || data.ot === CmObjectType.VIDEO || data.ot === CmObjectType.MUXED;
      if (this.starved && isVideo) {
        data.bs = true;
        data.su = true;
        this.starved = false;
      }
      if (data.su == null) {
        data.su = this.buffering;
      }

      // TODO: Implement rtp, nrr, nor, dl

      const {
        includeKeys
      } = this;
      if (includeKeys) {
        data = Object.keys(data).reduce((acc, key) => {
          includeKeys.includes(key) && (acc[key] = data[key]);
          return acc;
        }, {});
      }
      if (this.useHeaders) {
        if (!context.headers) {
          context.headers = {};
        }
        appendCmcdHeaders(context.headers, data);
      } else {
        context.url = appendCmcdQuery(context.url, data);
      }
    }
    /**
     * The CMCD object type.
     */
    getObjectType(fragment) {
      const {
        type
      } = fragment;
      if (type === 'subtitle') {
        return CmObjectType.TIMED_TEXT;
      }
      if (fragment.sn === 'initSegment') {
        return CmObjectType.INIT;
      }
      if (type === 'audio') {
        return CmObjectType.AUDIO;
      }
      if (type === 'main') {
        if (!this.hls.audioTracks.length) {
          return CmObjectType.MUXED;
        }
        return CmObjectType.VIDEO;
      }
      return undefined;
    }

    /**
     * Get the highest bitrate.
     */
    getTopBandwidth(type) {
      let bitrate = 0;
      let levels;
      const hls = this.hls;
      if (type === CmObjectType.AUDIO) {
        levels = hls.audioTracks;
      } else {
        const max = hls.maxAutoLevel;
        const len = max > -1 ? max + 1 : hls.levels.length;
        levels = hls.levels.slice(0, len);
      }
      for (const level of levels) {
        if (level.bitrate > bitrate) {
          bitrate = level.bitrate;
        }
      }
      return bitrate > 0 ? bitrate : NaN;
    }

    /**
     * Get the buffer length for a media type in milliseconds
     */
    getBufferLength(type) {
      const media = this.hls.media;
      const buffer = type === CmObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
      if (!buffer || !media) {
        return NaN;
      }
      const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);
      return info.len * 1000;
    }

    /**
     * Create a playlist loader
     */
    createPlaylistLoader() {
      const {
        pLoader
      } = this.config;
      const apply = this.applyPlaylistData;
      const Ctor = pLoader || this.config.loader;
      return class CmcdPlaylistLoader {
        constructor(config) {
          this.loader = void 0;
          this.loader = new Ctor(config);
        }
        get stats() {
          return this.loader.stats;
        }
        get context() {
          return this.loader.context;
        }
        destroy() {
          this.loader.destroy();
        }
        abort() {
          this.loader.abort();
        }
        load(context, config, callbacks) {
          apply(context);
          this.loader.load(context, config, callbacks);
        }
      };
    }

    /**
     * Create a playlist loader
     */
    createFragmentLoader() {
      const {
        fLoader
      } = this.config;
      const apply = this.applyFragmentData;
      const Ctor = fLoader || this.config.loader;
      return class CmcdFragmentLoader {
        constructor(config) {
          this.loader = void 0;
          this.loader = new Ctor(config);
        }
        get stats() {
          return this.loader.stats;
        }
        get context() {
          return this.loader.context;
        }
        destroy() {
          this.loader.destroy();
        }
        abort() {
          this.loader.abort();
        }
        load(context, config, callbacks) {
          apply(context);
          this.loader.load(context, config, callbacks);
        }
      };
    }
  }

  const PATHWAY_PENALTY_DURATION_MS = 300000;
  class ContentSteeringController {
    constructor(hls) {
      this.hls = void 0;
      this.log = void 0;
      this.loader = null;
      this.uri = null;
      this.pathwayId = '.';
      this.pathwayPriority = null;
      this.timeToLoad = 300;
      this.reloadTimer = -1;
      this.updated = 0;
      this.started = false;
      this.enabled = true;
      this.levels = null;
      this.audioTracks = null;
      this.subtitleTracks = null;
      this.penalizedPathways = {};
      this.hls = hls;
      this.log = logger.log.bind(logger, `[content-steering]:`);
      this.registerListeners();
    }
    registerListeners() {
      const hls = this.hls;
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.on(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events$1.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const hls = this.hls;
      if (!hls) {
        return;
      }
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.off(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events$1.ERROR, this.onError, this);
    }
    startLoad() {
      this.started = true;
      this.clearTimeout();
      if (this.enabled && this.uri) {
        if (this.updated) {
          const ttl = this.timeToLoad * 1000 - (performance.now() - this.updated);
          if (ttl > 0) {
            this.scheduleRefresh(this.uri, ttl);
            return;
          }
        }
        this.loadSteeringManifest(this.uri);
      }
    }
    stopLoad() {
      this.started = false;
      if (this.loader) {
        this.loader.destroy();
        this.loader = null;
      }
      this.clearTimeout();
    }
    clearTimeout() {
      if (this.reloadTimer !== -1) {
        self.clearTimeout(this.reloadTimer);
        this.reloadTimer = -1;
      }
    }
    destroy() {
      this.unregisterListeners();
      this.stopLoad();
      // @ts-ignore
      this.hls = null;
      this.levels = this.audioTracks = this.subtitleTracks = null;
    }
    removeLevel(levelToRemove) {
      const levels = this.levels;
      if (levels) {
        this.levels = levels.filter(level => level !== levelToRemove);
      }
    }
    onManifestLoading() {
      this.stopLoad();
      this.enabled = true;
      this.timeToLoad = 300;
      this.updated = 0;
      this.uri = null;
      this.pathwayId = '.';
      this.levels = this.audioTracks = this.subtitleTracks = null;
    }
    onManifestLoaded(event, data) {
      const {
        contentSteering
      } = data;
      if (contentSteering === null) {
        return;
      }
      this.pathwayId = contentSteering.pathwayId;
      this.uri = contentSteering.uri;
      if (this.started) {
        this.startLoad();
      }
    }
    onManifestParsed(event, data) {
      this.audioTracks = data.audioTracks;
      this.subtitleTracks = data.subtitleTracks;
    }
    onError(event, data) {
      const {
        errorAction
      } = data;
      if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {
        const levels = this.levels;
        let pathwayPriority = this.pathwayPriority;
        let errorPathway = this.pathwayId;
        if (data.context) {
          const {
            groupId,
            pathwayId,
            type
          } = data.context;
          if (groupId && levels) {
            errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);
          } else if (pathwayId) {
            errorPathway = pathwayId;
          }
        }
        if (!(errorPathway in this.penalizedPathways)) {
          this.penalizedPathways[errorPathway] = performance.now();
        }
        if (!pathwayPriority && levels) {
          // If PATHWAY-PRIORITY was not provided, list pathways for error handling
          pathwayPriority = levels.reduce((pathways, level) => {
            if (pathways.indexOf(level.pathwayId) === -1) {
              pathways.push(level.pathwayId);
            }
            return pathways;
          }, []);
        }
        if (pathwayPriority && pathwayPriority.length > 1) {
          this.updatePathwayPriority(pathwayPriority);
          errorAction.resolved = this.pathwayId !== errorPathway;
        }
        if (!errorAction.resolved) {
          logger.warn(`Could not resolve ${data.details} ("${data.error.message}") with content-steering for Pathway: ${errorPathway} levels: ${levels ? levels.length : levels} priorities: ${JSON.stringify(pathwayPriority)} penalized: ${JSON.stringify(this.penalizedPathways)}`);
        }
      }
    }
    filterParsedLevels(levels) {
      // Filter levels to only include those that are in the initial pathway
      this.levels = levels;
      let pathwayLevels = this.getLevelsForPathway(this.pathwayId);
      if (pathwayLevels.length === 0) {
        const pathwayId = levels[0].pathwayId;
        this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${pathwayId}"`);
        pathwayLevels = this.getLevelsForPathway(pathwayId);
        this.pathwayId = pathwayId;
      }
      if (pathwayLevels.length !== levels.length) {
        this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway "${this.pathwayId}"`);
        return pathwayLevels;
      }
      return levels;
    }
    getLevelsForPathway(pathwayId) {
      if (this.levels === null) {
        return [];
      }
      return this.levels.filter(level => pathwayId === level.pathwayId);
    }
    updatePathwayPriority(pathwayPriority) {
      this.pathwayPriority = pathwayPriority;
      let levels;

      // Evaluate if we should remove the pathway from the penalized list
      const penalizedPathways = this.penalizedPathways;
      const now = performance.now();
      Object.keys(penalizedPathways).forEach(pathwayId => {
        if (now - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {
          delete penalizedPathways[pathwayId];
        }
      });
      for (let i = 0; i < pathwayPriority.length; i++) {
        const pathwayId = pathwayPriority[i];
        if (pathwayId in penalizedPathways) {
          continue;
        }
        if (pathwayId === this.pathwayId) {
          return;
        }
        const selectedIndex = this.hls.nextLoadLevel;
        const selectedLevel = this.hls.levels[selectedIndex];
        levels = this.getLevelsForPathway(pathwayId);
        if (levels.length > 0) {
          this.log(`Setting Pathway to "${pathwayId}"`);
          this.pathwayId = pathwayId;
          reassignFragmentLevelIndexes(levels);
          this.hls.trigger(Events$1.LEVELS_UPDATED, {
            levels
          });
          // Set LevelController's level to trigger LEVEL_SWITCHING which loads playlist if needed
          const levelAfterChange = this.hls.levels[selectedIndex];
          if (selectedLevel && levelAfterChange && this.levels) {
            if (levelAfterChange.attrs['STABLE-VARIANT-ID'] !== selectedLevel.attrs['STABLE-VARIANT-ID'] && levelAfterChange.bitrate !== selectedLevel.bitrate) {
              this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);
            }
            this.hls.nextLoadLevel = selectedIndex;
          }
          break;
        }
      }
    }
    getPathwayForGroupId(groupId, type, defaultPathway) {
      const levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);
      for (let i = 0; i < levels.length; i++) {
        if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {
          return levels[i].pathwayId;
        }
      }
      return defaultPathway;
    }
    clonePathways(pathwayClones) {
      const levels = this.levels;
      if (!levels) {
        return;
      }
      const audioGroupCloneMap = {};
      const subtitleGroupCloneMap = {};
      pathwayClones.forEach(pathwayClone => {
        const {
          ID: cloneId,
          'BASE-ID': baseId,
          'URI-REPLACEMENT': uriReplacement
        } = pathwayClone;
        if (levels.some(level => level.pathwayId === cloneId)) {
          return;
        }
        const clonedVariants = this.getLevelsForPathway(baseId).map(baseLevel => {
          const attributes = new AttrList(baseLevel.attrs);
          attributes['PATHWAY-ID'] = cloneId;
          const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;
          const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;
          if (clonedAudioGroupId) {
            audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;
            attributes.AUDIO = clonedAudioGroupId;
          }
          if (clonedSubtitleGroupId) {
            subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;
            attributes.SUBTITLES = clonedSubtitleGroupId;
          }
          const url = performUriReplacement(baseLevel.uri, attributes['STABLE-VARIANT-ID'], 'PER-VARIANT-URIS', uriReplacement);
          const clonedLevel = new Level({
            attrs: attributes,
            audioCodec: baseLevel.audioCodec,
            bitrate: baseLevel.bitrate,
            height: baseLevel.height,
            name: baseLevel.name,
            url,
            videoCodec: baseLevel.videoCodec,
            width: baseLevel.width
          });
          if (baseLevel.audioGroups) {
            for (let i = 1; i < baseLevel.audioGroups.length; i++) {
              clonedLevel.addGroupId('audio', `${baseLevel.audioGroups[i]}_clone_${cloneId}`);
            }
          }
          if (baseLevel.subtitleGroups) {
            for (let i = 1; i < baseLevel.subtitleGroups.length; i++) {
              clonedLevel.addGroupId('text', `${baseLevel.subtitleGroups[i]}_clone_${cloneId}`);
            }
          }
          return clonedLevel;
        });
        levels.push(...clonedVariants);
        cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);
        cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);
      });
    }
    loadSteeringManifest(uri) {
      const config = this.hls.config;
      const Loader = config.loader;
      if (this.loader) {
        this.loader.destroy();
      }
      this.loader = new Loader(config);
      let url;
      try {
        url = new self.URL(uri);
      } catch (error) {
        this.enabled = false;
        this.log(`Failed to parse Steering Manifest URI: ${uri}`);
        return;
      }
      if (url.protocol !== 'data:') {
        const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;
        url.searchParams.set('_HLS_pathway', this.pathwayId);
        url.searchParams.set('_HLS_throughput', '' + throughput);
      }
      const context = {
        responseType: 'json',
        url: url.href
      };
      const loadPolicy = config.steeringManifestLoadPolicy.default;
      const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
        retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
        maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
      };
      const callbacks = {
        onSuccess: (response, stats, context, networkDetails) => {
          this.log(`Loaded steering manifest: "${url}"`);
          const steeringData = response.data;
          if (steeringData.VERSION !== 1) {
            this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);
            return;
          }
          this.updated = performance.now();
          this.timeToLoad = steeringData.TTL;
          const {
            'RELOAD-URI': reloadUri,
            'PATHWAY-CLONES': pathwayClones,
            'PATHWAY-PRIORITY': pathwayPriority
          } = steeringData;
          if (reloadUri) {
            try {
              this.uri = new self.URL(reloadUri, url).href;
            } catch (error) {
              this.enabled = false;
              this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);
              return;
            }
          }
          this.scheduleRefresh(this.uri || context.url);
          if (pathwayClones) {
            this.clonePathways(pathwayClones);
          }
          const loadedSteeringData = {
            steeringManifest: steeringData,
            url: url.toString()
          };
          this.hls.trigger(Events$1.STEERING_MANIFEST_LOADED, loadedSteeringData);
          if (pathwayPriority) {
            this.updatePathwayPriority(pathwayPriority);
          }
        },
        onError: (error, context, networkDetails, stats) => {
          this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context.url})`);
          this.stopLoad();
          if (error.code === 410) {
            this.enabled = false;
            this.log(`Steering manifest ${context.url} no longer available`);
            return;
          }
          let ttl = this.timeToLoad * 1000;
          if (error.code === 429) {
            const loader = this.loader;
            if (typeof (loader == null ? void 0 : loader.getResponseHeader) === 'function') {
              const retryAfter = loader.getResponseHeader('Retry-After');
              if (retryAfter) {
                ttl = parseFloat(retryAfter) * 1000;
              }
            }
            this.log(`Steering manifest ${context.url} rate limited`);
            return;
          }
          this.scheduleRefresh(this.uri || context.url, ttl);
        },
        onTimeout: (stats, context, networkDetails) => {
          this.log(`Timeout loading steering manifest (${context.url})`);
          this.scheduleRefresh(this.uri || context.url);
        }
      };
      this.log(`Requesting steering manifest: ${url}`);
      this.loader.load(context, loaderConfig, callbacks);
    }
    scheduleRefresh(uri, ttlMs = this.timeToLoad * 1000) {
      this.clearTimeout();
      this.reloadTimer = self.setTimeout(() => {
        var _this$hls;
        const media = (_this$hls = this.hls) == null ? void 0 : _this$hls.media;
        if (media && !media.ended) {
          this.loadSteeringManifest(uri);
          return;
        }
        this.scheduleRefresh(uri, this.timeToLoad * 1000);
      }, ttlMs);
    }
  }
  function cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {
    if (!tracks) {
      return;
    }
    Object.keys(groupCloneMap).forEach(audioGroupId => {
      const clonedTracks = tracks.filter(track => track.groupId === audioGroupId).map(track => {
        const clonedTrack = _extends$2({}, track);
        clonedTrack.details = undefined;
        clonedTrack.attrs = new AttrList(clonedTrack.attrs);
        clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs['STABLE-RENDITION-ID'], 'PER-RENDITION-URIS', uriReplacement);
        clonedTrack.groupId = clonedTrack.attrs['GROUP-ID'] = groupCloneMap[audioGroupId];
        clonedTrack.attrs['PATHWAY-ID'] = cloneId;
        return clonedTrack;
      });
      tracks.push(...clonedTracks);
    });
  }
  function performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {
    const {
      HOST: host,
      PARAMS: params,
      [perOptionKey]: perOptionUris
    } = uriReplacement;
    let perVariantUri;
    if (stableId) {
      perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];
      if (perVariantUri) {
        uri = perVariantUri;
      }
    }
    const url = new self.URL(uri);
    if (host && !perVariantUri) {
      url.host = host;
    }
    if (params) {
      Object.keys(params).sort().forEach(key => {
        if (key) {
          url.searchParams.set(key, params[key]);
        }
      });
    }
    return url.href;
  }

  const AGE_HEADER_LINE_REGEX = /^age:\s*[\d.]+\s*$/im;
  class XhrLoader {
    constructor(config) {
      this.xhrSetup = void 0;
      this.requestTimeout = void 0;
      this.retryTimeout = void 0;
      this.retryDelay = void 0;
      this.config = null;
      this.callbacks = null;
      this.context = null;
      this.loader = null;
      this.stats = void 0;
      this.xhrSetup = config ? config.xhrSetup || null : null;
      this.stats = new LoadStats();
      this.retryDelay = 0;
    }
    destroy() {
      this.callbacks = null;
      this.abortInternal();
      this.loader = null;
      this.config = null;
      this.context = null;
      this.xhrSetup = null;
    }
    abortInternal() {
      const loader = this.loader;
      self.clearTimeout(this.requestTimeout);
      self.clearTimeout(this.retryTimeout);
      if (loader) {
        loader.onreadystatechange = null;
        loader.onprogress = null;
        if (loader.readyState !== 4) {
          this.stats.aborted = true;
          loader.abort();
        }
      }
    }
    abort() {
      var _this$callbacks;
      this.abortInternal();
      if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
        this.callbacks.onAbort(this.stats, this.context, this.loader);
      }
    }
    load(context, config, callbacks) {
      if (this.stats.loading.start) {
        throw new Error('Loader can only be used once.');
      }
      this.stats.loading.start = self.performance.now();
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.loadInternal();
    }
    loadInternal() {
      const {
        config,
        context
      } = this;
      if (!config || !context) {
        return;
      }
      const xhr = this.loader = new self.XMLHttpRequest();
      const stats = this.stats;
      stats.loading.first = 0;
      stats.loaded = 0;
      stats.aborted = false;
      const xhrSetup = this.xhrSetup;
      if (xhrSetup) {
        Promise.resolve().then(() => {
          if (this.loader !== xhr || this.stats.aborted) return;
          return xhrSetup(xhr, context.url);
        }).catch(error => {
          if (this.loader !== xhr || this.stats.aborted) return;
          xhr.open('GET', context.url, true);
          return xhrSetup(xhr, context.url);
        }).then(() => {
          if (this.loader !== xhr || this.stats.aborted) return;
          this.openAndSendXhr(xhr, context, config);
        }).catch(error => {
          // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
          this.callbacks.onError({
            code: xhr.status,
            text: error.message
          }, context, xhr, stats);
          return;
        });
      } else {
        this.openAndSendXhr(xhr, context, config);
      }
    }
    openAndSendXhr(xhr, context, config) {
      if (!xhr.readyState) {
        xhr.open('GET', context.url, true);
      }
      const headers = context.headers;
      const {
        maxTimeToFirstByteMs,
        maxLoadTimeMs
      } = config.loadPolicy;
      if (headers) {
        for (const header in headers) {
          xhr.setRequestHeader(header, headers[header]);
        }
      }
      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }
      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);
      xhr.responseType = context.responseType;
      // setup timeout before we perform request
      self.clearTimeout(this.requestTimeout);
      config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
      this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
      xhr.send();
    }
    readystatechange() {
      const {
        context,
        loader: xhr,
        stats
      } = this;
      if (!context || !xhr) {
        return;
      }
      const readyState = xhr.readyState;
      const config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // >= HEADERS_RECEIVED
      if (readyState >= 2) {
        if (stats.loading.first === 0) {
          stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
          if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {
            self.clearTimeout(this.requestTimeout);
            config.timeout = config.loadPolicy.maxLoadTimeMs;
            this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));
          }
        }
        if (readyState === 4) {
          self.clearTimeout(this.requestTimeout);
          xhr.onreadystatechange = null;
          xhr.onprogress = null;
          const status = xhr.status;
          // http status between 200 to 299 are all successful
          const useResponse = xhr.responseType !== 'text';
          if (status >= 200 && status < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {
            stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
            const data = useResponse ? xhr.response : xhr.responseText;
            const len = xhr.responseType === 'arraybuffer' ? data.byteLength : data.length;
            stats.loaded = stats.total = len;
            stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);
            if (!this.callbacks) {
              return;
            }
            const onProgress = this.callbacks.onProgress;
            if (onProgress) {
              onProgress(stats, context, data, xhr);
            }
            if (!this.callbacks) {
              return;
            }
            const response = {
              url: xhr.responseURL,
              data: data,
              code: status
            };
            this.callbacks.onSuccess(response, stats, context, xhr);
          } else {
            const retryConfig = config.loadPolicy.errorRetry;
            const retryCount = stats.retry;
            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
            const response = {
              url: context.url,
              data: undefined,
              code: status
            };
            if (shouldRetry(retryConfig, retryCount, false, response)) {
              this.retry(retryConfig);
            } else {
              logger.error(`${status} while loading ${context.url}`);
              this.callbacks.onError({
                code: status,
                text: xhr.statusText
              }, context, xhr, stats);
            }
          }
        }
      }
    }
    loadtimeout() {
      if (!this.config) return;
      const retryConfig = this.config.loadPolicy.timeoutRetry;
      const retryCount = this.stats.retry;
      if (shouldRetry(retryConfig, retryCount, true)) {
        this.retry(retryConfig);
      } else {
        var _this$context;
        logger.warn(`timeout while loading ${(_this$context = this.context) == null ? void 0 : _this$context.url}`);
        const callbacks = this.callbacks;
        if (callbacks) {
          this.abortInternal();
          callbacks.onTimeout(this.stats, this.context, this.loader);
        }
      }
    }
    retry(retryConfig) {
      const {
        context,
        stats
      } = this;
      this.retryDelay = getRetryDelay(retryConfig, stats.retry);
      stats.retry++;
      logger.warn(`${status ? 'HTTP Status ' + status : 'Timeout'} while loading ${context == null ? void 0 : context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);
      // abort and reset internal state
      this.abortInternal();
      this.loader = null;
      // schedule retry
      self.clearTimeout(this.retryTimeout);
      this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
    }
    loadprogress(event) {
      const stats = this.stats;
      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }
    }
    getCacheAge() {
      let result = null;
      if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {
        const ageHeader = this.loader.getResponseHeader('age');
        result = ageHeader ? parseFloat(ageHeader) : null;
      }
      return result;
    }
    getResponseHeader(name) {
      if (this.loader && new RegExp(`^${name}:\\s*[\\d.]+\\s*$`, 'im').test(this.loader.getAllResponseHeaders())) {
        return this.loader.getResponseHeader(name);
      }
      return null;
    }
  }

  function fetchSupported() {
    if (
    // @ts-ignore
    self.fetch && self.AbortController && self.ReadableStream && self.Request) {
      try {
        new self.ReadableStream({}); // eslint-disable-line no-new
        return true;
      } catch (e) {
        /* noop */
      }
    }
    return false;
  }
  const BYTERANGE = /(\d+)-(\d+)\/(\d+)/;
  class FetchLoader {
    constructor(config /* HlsConfig */) {
      this.fetchSetup = void 0;
      this.requestTimeout = void 0;
      this.request = null;
      this.response = null;
      this.controller = void 0;
      this.context = null;
      this.config = null;
      this.callbacks = null;
      this.stats = void 0;
      this.loader = null;
      this.fetchSetup = config.fetchSetup || getRequest;
      this.controller = new self.AbortController();
      this.stats = new LoadStats();
    }
    destroy() {
      this.loader = this.callbacks = this.context = this.config = this.request = null;
      this.abortInternal();
      this.response = null;
      // @ts-ignore
      this.fetchSetup = this.controller = this.stats = null;
    }
    abortInternal() {
      if (this.controller && !this.stats.loading.end) {
        this.stats.aborted = true;
        this.controller.abort();
      }
    }
    abort() {
      var _this$callbacks;
      this.abortInternal();
      if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
        this.callbacks.onAbort(this.stats, this.context, this.response);
      }
    }
    load(context, config, callbacks) {
      const stats = this.stats;
      if (stats.loading.start) {
        throw new Error('Loader can only be used once.');
      }
      stats.loading.start = self.performance.now();
      const initParams = getRequestParameters(context, this.controller.signal);
      const onProgress = callbacks.onProgress;
      const isArrayBuffer = context.responseType === 'arraybuffer';
      const LENGTH = isArrayBuffer ? 'byteLength' : 'length';
      const {
        maxTimeToFirstByteMs,
        maxLoadTimeMs
      } = config.loadPolicy;
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.request = this.fetchSetup(context, initParams);
      self.clearTimeout(this.requestTimeout);
      config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
      this.requestTimeout = self.setTimeout(() => {
        this.abortInternal();
        callbacks.onTimeout(stats, context, this.response);
      }, config.timeout);
      self.fetch(this.request).then(response => {
        this.response = this.loader = response;
        const first = Math.max(self.performance.now(), stats.loading.start);
        self.clearTimeout(this.requestTimeout);
        config.timeout = maxLoadTimeMs;
        this.requestTimeout = self.setTimeout(() => {
          this.abortInternal();
          callbacks.onTimeout(stats, context, this.response);
        }, maxLoadTimeMs - (first - stats.loading.start));
        if (!response.ok) {
          const {
            status,
            statusText
          } = response;
          throw new FetchError(statusText || 'fetch, bad network response', status, response);
        }
        stats.loading.first = first;
        stats.total = getContentLength(response.headers) || stats.total;
        if (onProgress && isFiniteNumber(config.highWaterMark)) {
          return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);
        }
        if (isArrayBuffer) {
          return response.arrayBuffer();
        }
        if (context.responseType === 'json') {
          return response.json();
        }
        return response.text();
      }).then(responseData => {
        const response = this.response;
        if (!response) {
          throw new Error('loader destroyed');
        }
        self.clearTimeout(this.requestTimeout);
        stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
        const total = responseData[LENGTH];
        if (total) {
          stats.loaded = stats.total = total;
        }
        const loaderResponse = {
          url: response.url,
          data: responseData,
          code: response.status
        };
        if (onProgress && !isFiniteNumber(config.highWaterMark)) {
          onProgress(stats, context, responseData, response);
        }
        callbacks.onSuccess(loaderResponse, stats, context, response);
      }).catch(error => {
        self.clearTimeout(this.requestTimeout);
        if (stats.aborted) {
          return;
        }
        // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior
        // when destroying, 'error' itself can be undefined
        const code = !error ? 0 : error.code || 0;
        const text = !error ? null : error.message;
        callbacks.onError({
          code,
          text
        }, context, error ? error.details : null, stats);
      });
    }
    getCacheAge() {
      let result = null;
      if (this.response) {
        const ageHeader = this.response.headers.get('age');
        result = ageHeader ? parseFloat(ageHeader) : null;
      }
      return result;
    }
    getResponseHeader(name) {
      return this.response ? this.response.headers.get(name) : null;
    }
    loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {
      const chunkCache = new ChunkCache();
      const reader = response.body.getReader();
      const pump = () => {
        return reader.read().then(data => {
          if (data.done) {
            if (chunkCache.dataLength) {
              onProgress(stats, context, chunkCache.flush(), response);
            }
            return Promise.resolve(new ArrayBuffer(0));
          }
          const chunk = data.value;
          const len = chunk.length;
          stats.loaded += len;
          if (len < highWaterMark || chunkCache.dataLength) {
            // The current chunk is too small to to be emitted or the cache already has data
            // Push it to the cache
            chunkCache.push(chunk);
            if (chunkCache.dataLength >= highWaterMark) {
              // flush in order to join the typed arrays
              onProgress(stats, context, chunkCache.flush(), response);
            }
          } else {
            // If there's nothing cached already, and the chache is large enough
            // just emit the progress event
            onProgress(stats, context, chunk, response);
          }
          return pump();
        }).catch(() => {
          /* aborted */
          return Promise.reject();
        });
      };
      return pump();
    }
  }
  function getRequestParameters(context, signal) {
    const initParams = {
      method: 'GET',
      mode: 'cors',
      credentials: 'same-origin',
      signal,
      headers: new self.Headers(_extends$2({}, context.headers))
    };
    if (context.rangeEnd) {
      initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));
    }
    return initParams;
  }
  function getByteRangeLength(byteRangeHeader) {
    const result = BYTERANGE.exec(byteRangeHeader);
    if (result) {
      return parseInt(result[2]) - parseInt(result[1]) + 1;
    }
  }
  function getContentLength(headers) {
    const contentRange = headers.get('Content-Range');
    if (contentRange) {
      const byteRangeLength = getByteRangeLength(contentRange);
      if (isFiniteNumber(byteRangeLength)) {
        return byteRangeLength;
      }
    }
    const contentLength = headers.get('Content-Length');
    if (contentLength) {
      return parseInt(contentLength);
    }
  }
  function getRequest(context, initParams) {
    return new self.Request(context.url, initParams);
  }
  class FetchError extends Error {
    constructor(message, code, details) {
      super(message);
      this.code = void 0;
      this.details = void 0;
      this.code = code;
      this.details = details;
    }
  }

  const WHITESPACE_CHAR = /\s/;
  const Cues = {
    newCue(track, startTime, endTime, captionScreen) {
      const result = [];
      let row;
      // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers
      let cue;
      let indenting;
      let indent;
      let text;
      const Cue = self.VTTCue || self.TextTrackCue;
      for (let r = 0; r < captionScreen.rows.length; r++) {
        row = captionScreen.rows[r];
        indenting = true;
        indent = 0;
        text = '';
        if (!row.isEmpty()) {
          var _track$cues;
          for (let c = 0; c < row.chars.length; c++) {
            if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {
              indent++;
            } else {
              text += row.chars[c].uchar;
              indenting = false;
            }
          }
          // To be used for cleaning-up orphaned roll-up captions
          row.cueStartTime = startTime;

          // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
          if (startTime === endTime) {
            endTime += 0.0001;
          }
          if (indent >= 16) {
            indent--;
          } else {
            indent++;
          }
          const cueText = fixLineBreaks(text.trim());
          const id = generateCueId(startTime, endTime, cueText);

          // If this cue already exists in the track do not push it
          if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {
            cue = new Cue(startTime, endTime, cueText);
            cue.id = id;
            cue.line = r + 1;
            cue.align = 'left';
            // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)
            // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608
            // Firefox throws an exception and captions break with out of bounds 0-100 values
            cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);
            result.push(cue);
          }
        }
      }
      if (track && result.length) {
        // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome
        result.sort((cueA, cueB) => {
          if (cueA.line === 'auto' || cueB.line === 'auto') {
            return 0;
          }
          if (cueA.line > 8 && cueB.line > 8) {
            return cueB.line - cueA.line;
          }
          return cueA.line - cueB.line;
        });
        result.forEach(cue => addCueToTrack(track, cue));
      }
      return result;
    }
  };

  /**
   * @deprecated use fragLoadPolicy.default
   */

  /**
   * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default
   */

  const defaultLoadPolicy = {
    maxTimeToFirstByteMs: 8000,
    maxLoadTimeMs: 20000,
    timeoutRetry: null,
    errorRetry: null
  };

  /**
   * @ignore
   * If possible, keep hlsDefaultConfig shallow
   * It is cloned whenever a new Hls instance is created, by keeping the config
   * shallow the properties are cloned, and we don't end up manipulating the default
   */
  const hlsDefaultConfig = _objectSpread2(_objectSpread2({
    autoStartLoad: true,
    // used by stream-controller
    startPosition: -1,
    // used by stream-controller
    defaultAudioCodec: undefined,
    // used by stream-controller
    debug: false,
    // used by logger
    capLevelOnFPSDrop: false,
    // used by fps-controller
    capLevelToPlayerSize: false,
    // used by cap-level-controller
    ignoreDevicePixelRatio: false,
    // used by cap-level-controller
    preferManagedMediaSource: true,
    initialLiveManifestSize: 1,
    // used by stream-controller
    maxBufferLength: 30,
    // used by stream-controller
    backBufferLength: Infinity,
    // used by buffer-controller
    frontBufferFlushThreshold: Infinity,
    maxBufferSize: 60 * 1000 * 1000,
    // used by stream-controller
    maxBufferHole: 0.1,
    // used by stream-controller
    highBufferWatchdogPeriod: 2,
    // used by stream-controller
    nudgeOffset: 0.1,
    // used by stream-controller
    nudgeMaxRetry: 3,
    // used by stream-controller
    maxFragLookUpTolerance: 0.25,
    // used by stream-controller
    liveSyncDurationCount: 3,
    // used by latency-controller
    liveMaxLatencyDurationCount: Infinity,
    // used by latency-controller
    liveSyncDuration: undefined,
    // used by latency-controller
    liveMaxLatencyDuration: undefined,
    // used by latency-controller
    maxLiveSyncPlaybackRate: 1,
    // used by latency-controller
    liveDurationInfinity: false,
    // used by buffer-controller
    /**
     * @deprecated use backBufferLength
     */
    liveBackBufferLength: null,
    // used by buffer-controller
    maxMaxBufferLength: 600,
    // used by stream-controller
    enableWorker: true,
    // used by transmuxer
    workerPath: null,
    // used by transmuxer
    enableSoftwareAES: true,
    // used by decrypter
    startLevel: undefined,
    // used by level-controller
    startFragPrefetch: false,
    // used by stream-controller
    fpsDroppedMonitoringPeriod: 5000,
    // used by fps-controller
    fpsDroppedMonitoringThreshold: 0.2,
    // used by fps-controller
    appendErrorMaxRetry: 3,
    // used by buffer-controller
    loader: XhrLoader,
    // loader: FetchLoader,
    fLoader: undefined,
    // used by fragment-loader
    pLoader: undefined,
    // used by playlist-loader
    xhrSetup: undefined,
    // used by xhr-loader
    licenseXhrSetup: undefined,
    // used by eme-controller
    licenseResponseCallback: undefined,
    // used by eme-controller
    abrController: AbrController,
    bufferController: BufferController,
    capLevelController: CapLevelController,
    errorController: ErrorController,
    fpsController: FPSController,
    stretchShortVideoTrack: false,
    // used by mp4-remuxer
    maxAudioFramesDrift: 1,
    // used by mp4-remuxer
    forceKeyFrameOnDiscontinuity: true,
    // used by ts-demuxer
    abrEwmaFastLive: 3,
    // used by abr-controller
    abrEwmaSlowLive: 9,
    // used by abr-controller
    abrEwmaFastVoD: 3,
    // used by abr-controller
    abrEwmaSlowVoD: 9,
    // used by abr-controller
    abrEwmaDefaultEstimate: 5e5,
    // 500 kbps  // used by abr-controller
    abrEwmaDefaultEstimateMax: 5e6,
    // 5 mbps
    abrBandWidthFactor: 0.95,
    // used by abr-controller
    abrBandWidthUpFactor: 0.7,
    // used by abr-controller
    abrMaxWithRealBitrate: false,
    // used by abr-controller
    maxStarvationDelay: 4,
    // used by abr-controller
    maxLoadingDelay: 4,
    // used by abr-controller
    minAutoBitrate: 0,
    // used by hls
    emeEnabled: false,
    // used by eme-controller
    widevineLicenseUrl: undefined,
    // used by eme-controller
    drmSystems: {},
    // used by eme-controller
    drmSystemOptions: {},
    // used by eme-controller
    requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess ,
    // used by eme-controller
    testBandwidth: true,
    progressive: false,
    lowLatencyMode: true,
    cmcd: undefined,
    enableDateRangeMetadataCues: true,
    enableEmsgMetadataCues: true,
    enableID3MetadataCues: true,
    useMediaCapabilities: true,
    certLoadPolicy: {
      default: defaultLoadPolicy
    },
    keyLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 8000,
        maxLoadTimeMs: 20000,
        timeoutRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1000,
          maxRetryDelayMs: 20000,
          backoff: 'linear'
        },
        errorRetry: {
          maxNumRetry: 8,
          retryDelayMs: 1000,
          maxRetryDelayMs: 20000,
          backoff: 'linear'
        }
      }
    },
    manifestLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: Infinity,
        maxLoadTimeMs: 20000,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1000,
          maxRetryDelayMs: 8000
        }
      }
    },
    playlistLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 10000,
        maxLoadTimeMs: 20000,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 2,
          retryDelayMs: 1000,
          maxRetryDelayMs: 8000
        }
      }
    },
    fragLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 10000,
        maxLoadTimeMs: 120000,
        timeoutRetry: {
          maxNumRetry: 4,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 6,
          retryDelayMs: 1000,
          maxRetryDelayMs: 8000
        }
      }
    },
    steeringManifestLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 10000,
        maxLoadTimeMs: 20000,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1000,
          maxRetryDelayMs: 8000
        }
      } 
    },
    // These default settings are deprecated in favor of the above policies
    // and are maintained for backwards compatibility
    manifestLoadingTimeOut: 10000,
    manifestLoadingMaxRetry: 1,
    manifestLoadingRetryDelay: 1000,
    manifestLoadingMaxRetryTimeout: 64000,
    levelLoadingTimeOut: 10000,
    levelLoadingMaxRetry: 4,
    levelLoadingRetryDelay: 1000,
    levelLoadingMaxRetryTimeout: 64000,
    fragLoadingTimeOut: 20000,
    fragLoadingMaxRetry: 6,
    fragLoadingRetryDelay: 1000,
    fragLoadingMaxRetryTimeout: 64000
  }, timelineConfig()), {}, {
    subtitleStreamController: SubtitleStreamController ,
    subtitleTrackController: SubtitleTrackController ,
    timelineController: TimelineController ,
    audioStreamController: AudioStreamController ,
    audioTrackController: AudioTrackController ,
    emeController: EMEController ,
    cmcdController: CMCDController ,
    contentSteeringController: ContentSteeringController 
  });
  function timelineConfig() {
    return {
      cueHandler: Cues,
      // used by timeline-controller
      enableWebVTT: true,
      // used by timeline-controller
      enableIMSC1: true,
      // used by timeline-controller
      enableCEA708Captions: true,
      // used by timeline-controller
      captionsTextTrack1Label: 'English',
      // used by timeline-controller
      captionsTextTrack1LanguageCode: 'en',
      // used by timeline-controller
      captionsTextTrack2Label: 'Spanish',
      // used by timeline-controller
      captionsTextTrack2LanguageCode: 'es',
      // used by timeline-controller
      captionsTextTrack3Label: 'Unknown CC',
      // used by timeline-controller
      captionsTextTrack3LanguageCode: '',
      // used by timeline-controller
      captionsTextTrack4Label: 'Unknown CC',
      // used by timeline-controller
      captionsTextTrack4LanguageCode: '',
      // used by timeline-controller
      renderTextTracksNatively: true
    };
  }

  /**
   * @ignore
   */
  function mergeConfig(defaultConfig, userConfig) {
    if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
      throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
    }
    if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
    }
    if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
    }
    const defaultsCopy = deepCpy(defaultConfig);

    // Backwards compatibility with deprecated config values
    const deprecatedSettingTypes = ['manifest', 'level', 'frag'];
    const deprecatedSettings = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout'];
    deprecatedSettingTypes.forEach(type => {
      const policyName = `${type === 'level' ? 'playlist' : type}LoadPolicy`;
      const policyNotSet = userConfig[policyName] === undefined;
      const report = [];
      deprecatedSettings.forEach(setting => {
        const deprecatedSetting = `${type}Loading${setting}`;
        const value = userConfig[deprecatedSetting];
        if (value !== undefined && policyNotSet) {
          report.push(deprecatedSetting);
          const settings = defaultsCopy[policyName].default;
          userConfig[policyName] = {
            default: settings
          };
          switch (setting) {
            case 'TimeOut':
              settings.maxLoadTimeMs = value;
              settings.maxTimeToFirstByteMs = value;
              break;
            case 'MaxRetry':
              settings.errorRetry.maxNumRetry = value;
              settings.timeoutRetry.maxNumRetry = value;
              break;
            case 'RetryDelay':
              settings.errorRetry.retryDelayMs = value;
              settings.timeoutRetry.retryDelayMs = value;
              break;
            case 'MaxRetryTimeout':
              settings.errorRetry.maxRetryDelayMs = value;
              settings.timeoutRetry.maxRetryDelayMs = value;
              break;
          }
        }
      });
      if (report.length) {
        logger.warn(`hls.js config: "${report.join('", "')}" setting(s) are deprecated, use "${policyName}": ${JSON.stringify(userConfig[policyName])}`);
      }
    });
    return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);
  }
  function deepCpy(obj) {
    if (obj && typeof obj === 'object') {
      if (Array.isArray(obj)) {
        return obj.map(deepCpy);
      }
      return Object.keys(obj).reduce((result, key) => {
        result[key] = deepCpy(obj[key]);
        return result;
      }, {});
    }
    return obj;
  }

  /**
   * @ignore
   */
  function enableStreamingMode(config) {
    const currentLoader = config.loader;
    if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {
      // If a developer has configured their own loader, respect that choice
      logger.log('[config]: Custom loader detected, cannot enable progressive streaming');
      config.progressive = false;
    } else {
      const canStreamProgressively = fetchSupported();
      if (canStreamProgressively) {
        config.loader = FetchLoader;
        config.progressive = true;
        config.enableSoftwareAES = true;
        logger.log('[config]: Progressive streaming enabled, using FetchLoader');
      }
    }
  }

  let chromeOrFirefox;
  class LevelController extends BasePlaylistController {
    constructor(hls, contentSteeringController) {
      super(hls, '[level-controller]');
      this._levels = [];
      this._firstLevel = -1;
      this._maxAutoLevel = -1;
      this._startLevel = void 0;
      this.currentLevel = null;
      this.currentLevelIndex = -1;
      this.manualLevelIndex = -1;
      this.steering = void 0;
      this.onParsedComplete = void 0;
      this.steering = contentSteeringController;
      this._registerListeners();
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.on(Events$1.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events$1.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.on(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.on(Events$1.ERROR, this.onError, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.off(Events$1.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events$1.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.off(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.off(Events$1.ERROR, this.onError, this);
    }
    destroy() {
      this._unregisterListeners();
      this.steering = null;
      this.resetLevels();
      super.destroy();
    }
    stopLoad() {
      const levels = this._levels;

      // clean up live level details to force reload them, and reset load errors
      levels.forEach(level => {
        level.loadError = 0;
        level.fragmentError = 0;
      });
      super.stopLoad();
    }
    resetLevels() {
      this._startLevel = undefined;
      this.manualLevelIndex = -1;
      this.currentLevelIndex = -1;
      this.currentLevel = null;
      this._levels = [];
      this._maxAutoLevel = -1;
    }
    onManifestLoading(event, data) {
      this.resetLevels();
    }
    onManifestLoaded(event, data) {
      const preferManagedMediaSource = this.hls.config.preferManagedMediaSource;
      const levels = [];
      const redundantSet = {};
      const generatePathwaySet = {};
      let resolutionFound = false;
      let videoCodecFound = false;
      let audioCodecFound = false;
      data.levels.forEach(levelParsed => {
        var _audioCodec, _videoCodec;
        const attributes = levelParsed.attrs;

        // erase audio codec info if browser does not support mp4a.40.34.
        // demuxer will autodetect codec and fallback to mpeg/audio
        let {
          audioCodec,
          videoCodec
        } = levelParsed;
        if (((_audioCodec = audioCodec) == null ? void 0 : _audioCodec.indexOf('mp4a.40.34')) !== -1) {
          chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));
          if (chromeOrFirefox) {
            levelParsed.audioCodec = audioCodec = undefined;
          }
        }
        if (audioCodec) {
          levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource);
        }
        if (((_videoCodec = videoCodec) == null ? void 0 : _videoCodec.indexOf('avc1')) === 0) {
          videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);
        }

        // only keep levels with supported audio/video codecs
        const {
          width,
          height,
          unknownCodecs
        } = levelParsed;
        resolutionFound || (resolutionFound = !!(width && height));
        videoCodecFound || (videoCodecFound = !!videoCodec);
        audioCodecFound || (audioCodecFound = !!audioCodec);
        if (unknownCodecs != null && unknownCodecs.length || audioCodec && !areCodecsMediaSourceSupported(audioCodec, 'audio', preferManagedMediaSource) || videoCodec && !areCodecsMediaSourceSupported(videoCodec, 'video', preferManagedMediaSource)) {
          return;
        }
        const {
          CODECS,
          'FRAME-RATE': FRAMERATE,
          'HDCP-LEVEL': HDCP,
          'PATHWAY-ID': PATHWAY,
          RESOLUTION,
          'VIDEO-RANGE': VIDEO_RANGE
        } = attributes;
        const contentSteeringPrefix = `${PATHWAY || '.'}-`;
        const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}-${VIDEO_RANGE}-${HDCP}`;
        if (!redundantSet[levelKey]) {
          const level = new Level(levelParsed);
          redundantSet[levelKey] = level;
          generatePathwaySet[levelKey] = 1;
          levels.push(level);
        } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs['PATHWAY-ID']) {
          // Assign Pathway IDs to Redundant Streams (default Pathways is ".". Redundant Streams "..", "...", and so on.)
          // Content Steering controller to handles Pathway fallback on error
          const pathwayCount = generatePathwaySet[levelKey] += 1;
          levelParsed.attrs['PATHWAY-ID'] = new Array(pathwayCount + 1).join('.');
          const level = new Level(levelParsed);
          redundantSet[levelKey] = level;
          levels.push(level);
        } else {
          redundantSet[levelKey].addGroupId('audio', attributes.AUDIO);
          redundantSet[levelKey].addGroupId('text', attributes.SUBTITLES);
        }
      });
      this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);
    }
    filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {
      let audioTracks = [];
      let subtitleTracks = [];
      let levels = filteredLevels;

      // remove audio-only and invalid video-range levels if we also have levels with video codecs or RESOLUTION signalled
      if ((resolutionFound || videoCodecFound) && audioCodecFound) {
        levels = levels.filter(({
          videoCodec,
          videoRange,
          width,
          height
        }) => (!!videoCodec || !!(width && height)) && isVideoRange(videoRange));
      }
      if (levels.length === 0) {
        // Dispatch error after MANIFEST_LOADED is done propagating
        Promise.resolve().then(() => {
          if (this.hls) {
            if (data.levels.length) {
              this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(data.levels[0].attrs)}`);
            }
            const error = new Error('no level with compatible codecs found in manifest');
            this.hls.trigger(Events$1.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
              fatal: true,
              url: data.url,
              error,
              reason: error.message
            });
          }
        });
        return;
      }
      if (data.audioTracks) {
        const {
          preferManagedMediaSource
        } = this.hls.config;
        audioTracks = data.audioTracks.filter(track => !track.audioCodec || areCodecsMediaSourceSupported(track.audioCodec, 'audio', preferManagedMediaSource));
        // Assign ids after filtering as array indices by group-id
        assignTrackIdsByGroup(audioTracks);
      }
      if (data.subtitles) {
        subtitleTracks = data.subtitles;
        assignTrackIdsByGroup(subtitleTracks);
      }
      // start bitrate is the first bitrate of the manifest
      const unsortedLevels = levels.slice(0);
      // sort levels from lowest to highest
      levels.sort((a, b) => {
        if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {
          return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;
        }
        // sort on height before bitrate for cap-level-controller
        if (resolutionFound && a.height !== b.height) {
          return a.height - b.height;
        }
        if (a.frameRate !== b.frameRate) {
          return a.frameRate - b.frameRate;
        }
        if (a.videoRange !== b.videoRange) {
          return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);
        }
        if (a.videoCodec !== b.videoCodec) {
          const valueA = videoCodecPreferenceValue(a.videoCodec);
          const valueB = videoCodecPreferenceValue(b.videoCodec);
          if (valueA !== valueB) {
            return valueB - valueA;
          }
        }
        if (a.uri === b.uri && a.codecSet !== b.codecSet) {
          const valueA = codecsSetSelectionPreferenceValue(a.codecSet);
          const valueB = codecsSetSelectionPreferenceValue(b.codecSet);
          if (valueA !== valueB) {
            return valueB - valueA;
          }
        }
        if (a.averageBitrate !== b.averageBitrate) {
          return a.averageBitrate - b.averageBitrate;
        }
        return 0;
      });
      let firstLevelInPlaylist = unsortedLevels[0];
      if (this.steering) {
        levels = this.steering.filterParsedLevels(levels);
        if (levels.length !== unsortedLevels.length) {
          for (let i = 0; i < unsortedLevels.length; i++) {
            if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {
              firstLevelInPlaylist = unsortedLevels[i];
              break;
            }
          }
        }
      }
      this._levels = levels;

      // find index of first level in sorted levels
      for (let i = 0; i < levels.length; i++) {
        if (levels[i] === firstLevelInPlaylist) {
          var _this$hls$userConfig;
          this._firstLevel = i;
          const firstLevelBitrate = firstLevelInPlaylist.bitrate;
          const bandwidthEstimate = this.hls.bandwidthEstimate;
          this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelBitrate}`);
          // Update default bwe to first variant bitrate as long it has not been configured or set
          if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === undefined) {
            const startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);
            if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === hlsDefaultConfig.abrEwmaDefaultEstimate) {
              this.hls.bandwidthEstimate = startingBwEstimate;
            }
          }
          break;
        }
      }

      // Audio is only alternate if manifest include a URI along with the audio group tag,
      // and this is not an audio-only stream where levels contain audio-only
      const audioOnly = audioCodecFound && !videoCodecFound;
      const edata = {
        levels,
        audioTracks,
        subtitleTracks,
        sessionData: data.sessionData,
        sessionKeys: data.sessionKeys,
        firstLevel: this._firstLevel,
        stats: data.stats,
        audio: audioCodecFound,
        video: videoCodecFound,
        altAudio: !audioOnly && audioTracks.some(t => !!t.url)
      };
      this.hls.trigger(Events$1.MANIFEST_PARSED, edata);

      // Initiate loading after all controllers have received MANIFEST_PARSED
      if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {
        this.hls.startLoad(this.hls.config.startPosition);
      }
    }
    get levels() {
      if (this._levels.length === 0) {
        return null;
      }
      return this._levels;
    }
    get level() {
      return this.currentLevelIndex;
    }
    set level(newLevel) {
      const levels = this._levels;
      if (levels.length === 0) {
        return;
      }
      // check if level idx is valid
      if (newLevel < 0 || newLevel >= levels.length) {
        // invalid level id given, trigger error
        const error = new Error('invalid level idx');
        const fatal = newLevel < 0;
        this.hls.trigger(Events$1.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.LEVEL_SWITCH_ERROR,
          level: newLevel,
          fatal,
          error,
          reason: error.message
        });
        if (fatal) {
          return;
        }
        newLevel = Math.min(newLevel, levels.length - 1);
      }
      const lastLevelIndex = this.currentLevelIndex;
      const lastLevel = this.currentLevel;
      const lastPathwayId = lastLevel ? lastLevel.attrs['PATHWAY-ID'] : undefined;
      const level = levels[newLevel];
      const pathwayId = level.attrs['PATHWAY-ID'];
      this.currentLevelIndex = newLevel;
      this.currentLevel = level;
      if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {
        return;
      }
      this.log(`Switching to level ${newLevel} (${level.height ? level.height + 'p ' : ''}${level.videoRange ? level.videoRange + ' ' : ''}${level.codecSet ? level.codecSet + ' ' : ''}@${level.bitrate})${pathwayId ? ' with Pathway ' + pathwayId : ''} from level ${lastLevelIndex}${lastPathwayId ? ' with Pathway ' + lastPathwayId : ''}`);
      const levelSwitchingData = {
        level: newLevel,
        attrs: level.attrs,
        details: level.details,
        bitrate: level.bitrate,
        averageBitrate: level.averageBitrate,
        maxBitrate: level.maxBitrate,
        realBitrate: level.realBitrate,
        width: level.width,
        height: level.height,
        codecSet: level.codecSet,
        audioCodec: level.audioCodec,
        videoCodec: level.videoCodec,
        audioGroups: level.audioGroups,
        subtitleGroups: level.subtitleGroups,
        loaded: level.loaded,
        loadError: level.loadError,
        fragmentError: level.fragmentError,
        name: level.name,
        id: level.id,
        uri: level.uri,
        url: level.url,
        urlId: 0,
        audioGroupIds: level.audioGroupIds,
        textGroupIds: level.textGroupIds
      };
      this.hls.trigger(Events$1.LEVEL_SWITCHING, levelSwitchingData);
      // check if we need to load playlist for this level
      const levelDetails = level.details;
      if (!levelDetails || levelDetails.live) {
        // level not retrieved yet, or live playlist we need to (re)load it
        const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details, levelDetails);
        this.loadPlaylist(hlsUrlParameters);
      }
    }
    get manualLevel() {
      return this.manualLevelIndex;
    }
    set manualLevel(newLevel) {
      this.manualLevelIndex = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }
      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
    get firstLevel() {
      return this._firstLevel;
    }
    set firstLevel(newLevel) {
      this._firstLevel = newLevel;
    }
    get startLevel() {
      // Setting hls.startLevel (this._startLevel) overrides config.startLevel
      if (this._startLevel === undefined) {
        const configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== undefined) {
          return configStartLevel;
        }
        return this.hls.firstAutoLevel;
      }
      return this._startLevel;
    }
    set startLevel(newLevel) {
      this._startLevel = newLevel;
    }
    onError(event, data) {
      if (data.fatal || !data.context) {
        return;
      }
      if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {
        this.checkRetry(data);
      }
    }

    // reset errors on the successful load of a fragment
    onFragBuffered(event, {
      frag
    }) {
      if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {
        const el = frag.elementaryStreams;
        if (!Object.keys(el).some(type => !!el[type])) {
          return;
        }
        const level = this._levels[frag.level];
        if (level != null && level.loadError) {
          this.log(`Resetting level error count of ${level.loadError} on frag buffered`);
          level.loadError = 0;
        }
      }
    }
    onLevelLoaded(event, data) {
      var _data$deliveryDirecti2;
      const {
        level,
        details
      } = data;
      const curLevel = this._levels[level];
      if (!curLevel) {
        var _data$deliveryDirecti;
        this.warn(`Invalid level index ${level}`);
        if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {
          details.deltaUpdateFailed = true;
        }
        return;
      }

      // only process level loaded events matching with expected level
      if (level === this.currentLevelIndex) {
        // reset level load error counter on successful level loaded only if there is no issues with fragments
        if (curLevel.fragmentError === 0) {
          curLevel.loadError = 0;
        }
        this.playlistLoaded(level, data, curLevel.details);
      } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {
        // received a delta playlist update that cannot be merged
        details.deltaUpdateFailed = true;
      }
    }
    loadPlaylist(hlsUrlParameters) {
      super.loadPlaylist();
      const currentLevelIndex = this.currentLevelIndex;
      const currentLevel = this.currentLevel;
      if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {
        let url = currentLevel.uri;
        if (hlsUrlParameters) {
          try {
            url = hlsUrlParameters.addDirectives(url);
          } catch (error) {
            this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
          }
        }
        const pathwayId = currentLevel.attrs['PATHWAY-ID'];
        this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : ''} with${pathwayId ? ' Pathway ' + pathwayId : ''} ${url}`);

        // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
        // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);
        this.clearTimer();
        this.hls.trigger(Events$1.LEVEL_LOADING, {
          url,
          level: currentLevelIndex,
          pathwayId: currentLevel.attrs['PATHWAY-ID'],
          id: 0,
          // Deprecated Level urlId
          deliveryDirectives: hlsUrlParameters || null
        });
      }
    }
    get nextLoadLevel() {
      if (this.manualLevelIndex !== -1) {
        return this.manualLevelIndex;
      } else {
        return this.hls.nextAutoLevel;
      }
    }
    set nextLoadLevel(nextLevel) {
      this.level = nextLevel;
      if (this.manualLevelIndex === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
    removeLevel(levelIndex) {
      var _this$currentLevel;
      const levels = this._levels.filter((level, index) => {
        if (index !== levelIndex) {
          return true;
        }
        if (this.steering) {
          this.steering.removeLevel(level);
        }
        if (level === this.currentLevel) {
          this.currentLevel = null;
          this.currentLevelIndex = -1;
          if (level.details) {
            level.details.fragments.forEach(f => f.level = -1);
          }
        }
        return false;
      });
      reassignFragmentLevelIndexes(levels);
      this._levels = levels;
      if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {
        this.currentLevelIndex = this.currentLevel.details.fragments[0].level;
      }
      this.hls.trigger(Events$1.LEVELS_UPDATED, {
        levels
      });
    }
    onLevelsUpdated(event, {
      levels
    }) {
      this._levels = levels;
    }
    checkMaxAutoUpdated() {
      const {
        autoLevelCapping,
        maxAutoLevel,
        maxHdcpLevel
      } = this.hls;
      if (this._maxAutoLevel !== maxAutoLevel) {
        this._maxAutoLevel = maxAutoLevel;
        this.hls.trigger(Events$1.MAX_AUTO_LEVEL_UPDATED, {
          autoLevelCapping,
          levels: this.levels,
          maxAutoLevel,
          minAutoLevel: this.hls.minAutoLevel,
          maxHdcpLevel
        });
      }
    }
  }
  function assignTrackIdsByGroup(tracks) {
    const groups = {};
    tracks.forEach(track => {
      const groupId = track.groupId || '';
      track.id = groups[groupId] = groups[groupId] || 0;
      groups[groupId]++;
    });
  }

  class KeyLoader {
    constructor(config) {
      this.config = void 0;
      this.keyUriToKeyInfo = {};
      this.emeController = null;
      this.config = config;
    }
    abort(type) {
      for (const uri in this.keyUriToKeyInfo) {
        const loader = this.keyUriToKeyInfo[uri].loader;
        if (loader) {
          var _loader$context;
          if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {
            return;
          }
          loader.abort();
        }
      }
    }
    detach() {
      for (const uri in this.keyUriToKeyInfo) {
        const keyInfo = this.keyUriToKeyInfo[uri];
        // Remove cached EME keys on detach
        if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {
          delete this.keyUriToKeyInfo[uri];
        }
      }
    }
    destroy() {
      this.detach();
      for (const uri in this.keyUriToKeyInfo) {
        const loader = this.keyUriToKeyInfo[uri].loader;
        if (loader) {
          loader.destroy();
        }
      }
      this.keyUriToKeyInfo = {};
    }
    createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {
      return new LoadError({
        type: ErrorTypes.NETWORK_ERROR,
        details,
        fatal: false,
        frag,
        response,
        error,
        networkDetails
      });
    }
    loadClear(loadingFrag, encryptedFragments) {
      if (this.emeController && this.config.emeEnabled) {
        // access key-system with nearest key on start (loaidng frag is unencrypted)
        const {
          sn,
          cc
        } = loadingFrag;
        for (let i = 0; i < encryptedFragments.length; i++) {
          const frag = encryptedFragments[i];
          if (cc <= frag.cc && (sn === 'initSegment' || frag.sn === 'initSegment' || sn < frag.sn)) {
            this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {
              frag.setKeyFormat(keySystemFormat);
            });
            break;
          }
        }
      }
    }
    load(frag) {
      if (!frag.decryptdata && frag.encrypted && this.emeController) {
        // Multiple keys, but none selected, resolve in eme-controller
        return this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {
          return this.loadInternal(frag, keySystemFormat);
        });
      }
      return this.loadInternal(frag);
    }
    loadInternal(frag, keySystemFormat) {
      var _keyInfo, _keyInfo2;
      if (keySystemFormat) {
        frag.setKeyFormat(keySystemFormat);
      }
      const decryptdata = frag.decryptdata;
      if (!decryptdata) {
        const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : 'Missing decryption data on fragment in onKeyLoading');
        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));
      }
      const uri = decryptdata.uri;
      if (!uri) {
        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${uri}"`)));
      }
      let keyInfo = this.keyUriToKeyInfo[uri];
      if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {
        decryptdata.key = keyInfo.decryptdata.key;
        return Promise.resolve({
          frag,
          keyInfo
        });
      }
      // Return key load promise as long as it does not have a mediakey session with an unusable key status
      if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {
        var _keyInfo$mediaKeySess;
        switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {
          case undefined:
          case 'status-pending':
          case 'usable':
          case 'usable-in-future':
            return keyInfo.keyLoadPromise.then(keyLoadedData => {
              // Return the correct fragment with updated decryptdata key and loaded keyInfo
              decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;
              return {
                frag,
                keyInfo
              };
            });
        }
        // If we have a key session and status and it is not pending or usable, continue
        // This will go back to the eme-controller for expired keys to get a new keyLoadPromise
      }

      // Load the key or return the loading promise
      keyInfo = this.keyUriToKeyInfo[uri] = {
        decryptdata,
        keyLoadPromise: null,
        loader: null,
        mediaKeySessionContext: null
      };
      switch (decryptdata.method) {
        case 'ISO-23001-7':
        case 'SAMPLE-AES':
        case 'SAMPLE-AES-CENC':
        case 'SAMPLE-AES-CTR':
          if (decryptdata.keyFormat === 'identity') {
            // loadKeyHTTP handles http(s) and data URLs
            return this.loadKeyHTTP(keyInfo, frag);
          }
          return this.loadKeyEME(keyInfo, frag);
        case 'AES-128':
          return this.loadKeyHTTP(keyInfo, frag);
        default:
          return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${decryptdata.method}"`)));
      }
    }
    loadKeyEME(keyInfo, frag) {
      const keyLoadedData = {
        frag,
        keyInfo
      };
      if (this.emeController && this.config.emeEnabled) {
        const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);
        if (keySessionContextPromise) {
          return (keyInfo.keyLoadPromise = keySessionContextPromise.then(keySessionContext => {
            keyInfo.mediaKeySessionContext = keySessionContext;
            return keyLoadedData;
          })).catch(error => {
            // Remove promise for license renewal or retry
            keyInfo.keyLoadPromise = null;
            throw error;
          });
        }
      }
      return Promise.resolve(keyLoadedData);
    }
    loadKeyHTTP(keyInfo, frag) {
      const config = this.config;
      const Loader = config.loader;
      const keyLoader = new Loader(config);
      frag.keyLoader = keyInfo.loader = keyLoader;
      return keyInfo.keyLoadPromise = new Promise((resolve, reject) => {
        const loaderContext = {
          keyInfo,
          frag,
          responseType: 'arraybuffer',
          url: keyInfo.decryptdata.uri
        };

        // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,
        // key-loader will trigger an error and rely on stream-controller to handle retry logic.
        // this will also align retry logic with fragment-loader
        const loadPolicy = config.keyLoadPolicy.default;
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0
        };
        const loaderCallbacks = {
          onSuccess: (response, stats, context, networkDetails) => {
            const {
              frag,
              keyInfo,
              url: uri
            } = context;
            if (!frag.decryptdata || keyInfo !== this.keyUriToKeyInfo[uri]) {
              return reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), networkDetails));
            }
            keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);

            // detach fragment key loader on load success
            frag.keyLoader = null;
            keyInfo.loader = null;
            resolve({
              frag,
              keyInfo
            });
          },
          onError: (response, context, networkDetails, stats) => {
            this.resetLoader(context);
            reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({
              url: loaderContext.url,
              data: undefined
            }, response)));
          },
          onTimeout: (stats, context, networkDetails) => {
            this.resetLoader(context);
            reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), networkDetails));
          },
          onAbort: (stats, context, networkDetails) => {
            this.resetLoader(context);
            reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error('key loading aborted'), networkDetails));
          }
        };
        keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);
      });
    }
    resetLoader(context) {
      const {
        frag,
        keyInfo,
        url: uri
      } = context;
      const loader = keyInfo.loader;
      if (frag.keyLoader === loader) {
        frag.keyLoader = null;
        keyInfo.loader = null;
      }
      delete this.keyUriToKeyInfo[uri];
      if (loader) {
        loader.destroy();
      }
    }
  }

  function getSourceBuffer() {
    return self.SourceBuffer || self.WebKitSourceBuffer;
  }
  function isMSESupported() {
    const mediaSource = getMediaSource();
    if (!mediaSource) {
      return false;
    }

    // if SourceBuffer is exposed ensure its API is valid
    // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
    const sourceBuffer = getSourceBuffer();
    return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';
  }
  function isSupported() {
    if (!isMSESupported()) {
      return false;
    }
    const mediaSource = getMediaSource();
    return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === 'function' && (['avc1.42E01E,mp4a.40.2', 'av01.0.01M.08', 'vp09.00.50.08'].some(codecsForVideoContainer => mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, 'video'))) || ['mp4a.40.2', 'fLaC'].some(codecForAudioContainer => mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, 'audio'))));
  }
  function changeTypeSupported() {
    var _sourceBuffer$prototy;
    const sourceBuffer = getSourceBuffer();
    return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === 'function';
  }

  const STALL_MINIMUM_DURATION_MS = 250;
  const MAX_START_GAP_JUMP = 2.0;
  const SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
  const SKIP_BUFFER_RANGE_START = 0.05;
  class GapController {
    constructor(config, media, fragmentTracker, hls) {
      this.config = void 0;
      this.media = null;
      this.fragmentTracker = void 0;
      this.hls = void 0;
      this.nudgeRetry = 0;
      this.stallReported = false;
      this.stalled = null;
      this.moved = false;
      this.seeking = false;
      this.config = config;
      this.media = media;
      this.fragmentTracker = fragmentTracker;
      this.hls = hls;
    }
    destroy() {
      this.media = null;
      // @ts-ignore
      this.hls = this.fragmentTracker = null;
    }

    /**
     * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
     * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
     *
     * @param lastCurrentTime - Previously read playhead position
     */
    poll(lastCurrentTime, activeFrag) {
      const {
        config,
        media,
        stalled
      } = this;
      if (media === null) {
        return;
      }
      const {
        currentTime,
        seeking
      } = media;
      const seeked = this.seeking && !seeking;
      const beginSeek = !this.seeking && seeking;
      this.seeking = seeking;

      // The playhead is moving, no-op
      if (currentTime !== lastCurrentTime) {
        this.moved = true;
        if (!seeking) {
          this.nudgeRetry = 0;
        }
        if (stalled !== null) {
          // The playhead is now moving, but was previously stalled
          if (this.stallReported) {
            const _stalledDuration = self.performance.now() - stalled;
            logger.warn(`playback not stuck anymore @${currentTime}, after ${Math.round(_stalledDuration)}ms`);
            this.stallReported = false;
          }
          this.stalled = null;
        }
        return;
      }

      // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek
      if (beginSeek || seeked) {
        this.stalled = null;
        return;
      }

      // The playhead should not be moving
      if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {
        this.nudgeRetry = 0;
        return;
      }
      const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
      const nextStart = bufferInfo.nextStart || 0;
      if (seeking) {
        // Waiting for seeking in a buffered range to complete
        const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
        // Next buffered range is too far ahead to jump to while still seeking
        const noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);
        if (hasEnoughBuffer || noBufferGap) {
          return;
        }
        // Reset moved state when seeking to a point in or before a gap
        this.moved = false;
      }

      // Skip start gaps if we haven't played, but the last poll detected the start of a stall
      // The addition poll gives the browser a chance to jump the gap for us
      if (!this.moved && this.stalled !== null) {
        var _level$details;
        // There is no playable buffer (seeked, waiting for buffer)
        const isBuffered = bufferInfo.len > 0;
        if (!isBuffered && !nextStart) {
          return;
        }
        // Jump start gaps within jump threshold
        const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;

        // When joining a live stream with audio tracks, account for live playlist window sliding by allowing
        // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment
        // that begins over 1 target duration after the video start position.
        const level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;
        const isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;
        const maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;
        const partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);
        if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {
          if (!media.paused) {
            this._trySkipBufferHole(partialOrGap);
          }
          return;
        }
      }

      // Start tracking stall time
      const tnow = self.performance.now();
      if (stalled === null) {
        this.stalled = tnow;
        return;
      }
      const stalledDuration = tnow - stalled;
      if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {
        // Report stalling after trying to fix
        this._reportStall(bufferInfo);
        if (!this.media) {
          return;
        }
      }
      const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
      this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
    }

    /**
     * Detects and attempts to fix known buffer stalling issues.
     * @param bufferInfo - The properties of the current buffer.
     * @param stalledDurationMs - The amount of time Hls.js has been stalling for.
     * @private
     */
    _tryFixBufferStall(bufferInfo, stalledDurationMs) {
      const {
        config,
        fragmentTracker,
        media
      } = this;
      if (media === null) {
        return;
      }
      const currentTime = media.currentTime;
      const partial = fragmentTracker.getPartialFragment(currentTime);
      if (partial) {
        // Try to skip over the buffer hole caused by a partial fragment
        // This method isn't limited by the size of the gap between buffered ranges
        const targetTime = this._trySkipBufferHole(partial);
        // we return here in this case, meaning
        // the branch below only executes when we haven't seeked to a new position
        if (targetTime || !this.media) {
          return;
        }
      }

      // if we haven't had to skip over a buffer hole of a partial fragment
      // we may just have to "nudge" the playlist as the browser decoding/rendering engine
      // needs to cross some sort of threshold covering all source-buffers content
      // to start playing properly.
      if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {
        logger.warn('Trying to nudge playhead over buffer-hole');
        // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds
        // We only try to jump the hole if it's under the configured size
        // Reset stalled so to rearm watchdog timer
        this.stalled = null;
        this._tryNudgeBuffer();
      }
    }

    /**
     * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
     * @param bufferLen - The playhead distance from the end of the current buffer segment.
     * @private
     */
    _reportStall(bufferInfo) {
      const {
        hls,
        media,
        stallReported
      } = this;
      if (!stallReported && media) {
        // Report stalled error once
        this.stallReported = true;
        const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${JSON.stringify(bufferInfo)})`);
        logger.warn(error.message);
        hls.trigger(Events$1.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_STALLED_ERROR,
          fatal: false,
          error,
          buffer: bufferInfo.len
        });
      }
    }

    /**
     * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
     * @param partial - The partial fragment found at the current time (where playback is stalling).
     * @private
     */
    _trySkipBufferHole(partial) {
      const {
        config,
        hls,
        media
      } = this;
      if (media === null) {
        return 0;
      }

      // Check if currentTime is between unbuffered regions of partial fragments
      const currentTime = media.currentTime;
      const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
      const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;
      if (startTime) {
        const bufferStarved = bufferInfo.len <= config.maxBufferHole;
        const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;
        const gapLength = startTime - currentTime;
        if (gapLength > 0 && (bufferStarved || waiting)) {
          // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial
          if (gapLength > config.maxBufferHole) {
            const {
              fragmentTracker
            } = this;
            let startGap = false;
            if (currentTime === 0) {
              const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);
              if (startFrag && startTime < startFrag.end) {
                startGap = true;
              }
            }
            if (!startGap) {
              const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);
              if (startProvisioned) {
                let moreToLoad = false;
                let pos = startProvisioned.end;
                while (pos < startTime) {
                  const provisioned = fragmentTracker.getPartialFragment(pos);
                  if (provisioned) {
                    pos += provisioned.duration;
                  } else {
                    moreToLoad = true;
                    break;
                  }
                }
                if (moreToLoad) {
                  return 0;
                }
              }
            }
          }
          const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
          logger.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);
          this.moved = true;
          this.stalled = null;
          media.currentTime = targetTime;
          if (partial && !partial.gap) {
            const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);
            hls.trigger(Events$1.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,
              fatal: false,
              error,
              reason: error.message,
              frag: partial
            });
          }
          return targetTime;
        }
      }
      return 0;
    }

    /**
     * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
     * @private
     */
    _tryNudgeBuffer() {
      const {
        config,
        hls,
        media,
        nudgeRetry
      } = this;
      if (media === null) {
        return;
      }
      const currentTime = media.currentTime;
      this.nudgeRetry++;
      if (nudgeRetry < config.nudgeMaxRetry) {
        const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;
        // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
        const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);
        logger.warn(error.message);
        media.currentTime = targetTime;
        hls.trigger(Events$1.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_NUDGE_ON_STALL,
          error,
          fatal: false
        });
      } else {
        const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);
        logger.error(error.message);
        hls.trigger(Events$1.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_STALLED_ERROR,
          error,
          fatal: true
        });
      }
    }
  }

  const TICK_INTERVAL = 100; // how often to tick in ms

  class StreamController extends BaseStreamController {
    constructor(hls, fragmentTracker, keyLoader) {
      super(hls, fragmentTracker, keyLoader, '[stream-controller]', PlaylistLevelType.MAIN);
      this.audioCodecSwap = false;
      this.gapController = null;
      this.level = -1;
      this._forceStartLoad = false;
      this.altAudio = false;
      this.audioOnly = false;
      this.fragPlaying = null;
      this.onvplaying = null;
      this.onvseeked = null;
      this.fragLastKbps = 0;
      this.couldBacktrack = false;
      this.backtrackFragment = null;
      this.audioCodecSwitch = false;
      this.videoBuffer = null;
      this._registerListeners();
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events$1.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events$1.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events$1.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
      hls.on(Events$1.ERROR, this.onError, this);
      hls.on(Events$1.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.on(Events$1.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
      hls.on(Events$1.BUFFER_CREATED, this.onBufferCreated, this);
      hls.on(Events$1.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.on(Events$1.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.on(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events$1.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events$1.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events$1.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events$1.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events$1.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events$1.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
      hls.off(Events$1.ERROR, this.onError, this);
      hls.off(Events$1.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.off(Events$1.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
      hls.off(Events$1.BUFFER_CREATED, this.onBufferCreated, this);
      hls.off(Events$1.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.off(Events$1.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.off(Events$1.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    onHandlerDestroying() {
      this._unregisterListeners();
      super.onHandlerDestroying();
    }
    startLoad(startPosition) {
      if (this.levels) {
        const {
          lastCurrentTime,
          hls
        } = this;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL);
        this.level = -1;
        if (!this.startFragRequested) {
          // determine load level
          let startLevel = hls.startLevel;
          if (startLevel === -1) {
            if (hls.config.testBandwidth && this.levels.length > 1) {
              // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
              startLevel = 0;
              this.bitrateTest = true;
            } else {
              startLevel = hls.firstAutoLevel;
            }
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          hls.nextLoadLevel = startLevel;
          this.level = hls.loadLevel;
          this.loadedmetadata = false;
        }
        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
        if (lastCurrentTime > 0 && startPosition === -1) {
          this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);
          startPosition = lastCurrentTime;
        }
        this.state = State.IDLE;
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      } else {
        this._forceStartLoad = true;
        this.state = State.STOPPED;
      }
    }
    stopLoad() {
      this._forceStartLoad = false;
      super.stopLoad();
    }
    doTick() {
      switch (this.state) {
        case State.WAITING_LEVEL:
          {
            const {
              levels,
              level
            } = this;
            const currentLevel = levels == null ? void 0 : levels[level];
            const details = currentLevel == null ? void 0 : currentLevel.details;
            if (details && (!details.live || this.levelLastLoaded === currentLevel)) {
              if (this.waitForCdnTuneIn(details)) {
                break;
              }
              this.state = State.IDLE;
              break;
            } else if (this.hls.nextLoadLevel !== this.level) {
              this.state = State.IDLE;
              break;
            }
            break;
          }
        case State.FRAG_LOADING_WAITING_RETRY:
          {
            var _this$media;
            const now = self.performance.now();
            const retryDate = this.retryDate;
            // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
            if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
              const {
                levels,
                level
              } = this;
              const currentLevel = levels == null ? void 0 : levels[level];
              this.resetStartWhenNotLoaded(currentLevel || null);
              this.state = State.IDLE;
            }
          }
          break;
      }
      if (this.state === State.IDLE) {
        this.doTickIdle();
      }
      this.onTickEnd();
    }
    onTickEnd() {
      super.onTickEnd();
      this.checkBuffer();
      this.checkFragmentChanged();
    }
    doTickIdle() {
      const {
        hls,
        levelLastLoaded,
        levels,
        media
      } = this;

      // if start level not parsed yet OR
      // if video not attached AND start fragment already requested OR start frag prefetch not enabled
      // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment
      if (levelLastLoaded === null || !media && (this.startFragRequested || !hls.config.startFragPrefetch)) {
        return;
      }

      // If the "main" level is audio-only but we are loading an alternate track in the same group, do not load anything
      if (this.altAudio && this.audioOnly) {
        return;
      }
      const level = hls.nextLoadLevel;
      if (!(levels != null && levels[level])) {
        return;
      }
      const levelInfo = levels[level];

      // if buffer length is less than maxBufLen try to load a new fragment

      const bufferInfo = this.getMainFwdBufferInfo();
      if (bufferInfo === null) {
        return;
      }
      const lastDetails = this.getLevelDetails();
      if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {
        const data = {};
        if (this.altAudio) {
          data.type = 'video';
        }
        this.hls.trigger(Events$1.BUFFER_EOS, data);
        this.state = State.ENDED;
        return;
      }

      // set next load level : this will trigger a playlist load if needed
      if (hls.loadLevel !== level && hls.manualLevel === -1) {
        this.log(`Adapting to level ${level} from level ${this.level}`);
      }
      this.level = hls.nextLoadLevel = level;
      const levelDetails = levelInfo.details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== levelInfo) {
        this.level = level;
        this.state = State.WAITING_LEVEL;
        return;
      }
      const bufferLen = bufferInfo.len;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);

      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return;
      }
      if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {
        this.backtrackFragment = null;
      }
      const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;
      let frag = this.getNextFragment(targetBufferTime, levelDetails);
      // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)
      if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== 'initSegment' && this.fragmentTracker.getState(frag) !== FragmentState.OK) {
        var _this$backtrackFragme;
        const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;
        const fragIdx = backtrackSn - levelDetails.startSN;
        const backtrackFrag = levelDetails.fragments[fragIdx - 1];
        if (backtrackFrag && frag.cc === backtrackFrag.cc) {
          frag = backtrackFrag;
          this.fragmentTracker.removeFragment(backtrackFrag);
        }
      } else if (this.backtrackFragment && bufferInfo.len) {
        this.backtrackFragment = null;
      }
      // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags
      if (frag && this.isLoopLoading(frag, targetBufferTime)) {
        const gapStart = frag.gap;
        if (!gapStart) {
          // Cleanup the fragment tracker before trying to find the next unbuffered fragment
          const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;
          const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
          if (mediaBuffer) {
            this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
          }
        }
        frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
      }
      if (!frag) {
        return;
      }
      if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {
        frag = frag.initSegment;
      }
      this.loadFragment(frag, levelInfo, targetBufferTime);
    }
    loadFragment(frag, level, targetBufferTime) {
      // Check if fragment is not loaded
      const fragState = this.fragmentTracker.getState(frag);
      this.fragCurrent = frag;
      if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
        if (frag.sn === 'initSegment') {
          this._loadInitSegment(frag, level);
        } else if (this.bitrateTest) {
          this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);
          this._loadBitrateTestFrag(frag, level);
        } else {
          this.startFragRequested = true;
          super.loadFragment(frag, level, targetBufferTime);
        }
      } else {
        this.clearTrackerIfNeeded(frag);
      }
    }
    getBufferedFrag(position) {
      return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);
    }
    followingBufferedFrag(frag) {
      if (frag) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferedFrag(frag.end + 0.5);
      }
      return null;
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */
    immediateLevelSwitch() {
      this.abortCurrentFrag();
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }

    /**
     * try to switch ASAP without breaking video playback:
     * in order to ensure smooth but quick level switching,
     * we need to find the next flushable buffer range
     * we should take into account new segment fetch time
     */
    nextLevelSwitch() {
      const {
        levels,
        media
      } = this;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media != null && media.readyState) {
        let fetchdelay;
        const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);
        if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.flushMainBuffer(0, fragPlayingCurrent.start - 1);
        }
        const levelDetails = this.getLevelDetails();
        if (levelDetails != null && levelDetails.live) {
          const bufferInfo = this.getMainFwdBufferInfo();
          // Do not flush in live stream with low buffer
          if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {
            return;
          }
        }
        if (!media.paused && levels) {
          // add a safety delay of 1s
          const nextLevelId = this.hls.nextLoadLevel;
          const nextLevel = levels[nextLevelId];
          const fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        // this.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
        if (bufferedFrag) {
          // we can flush buffer range following this one without stalling playback
          const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);
          if (nextBufferedFrag) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            this.abortCurrentFrag();
            // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.
            const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;
            const fragDuration = nextBufferedFrag.duration;
            const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));
            this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
    abortCurrentFrag() {
      const fragCurrent = this.fragCurrent;
      this.fragCurrent = null;
      this.backtrackFragment = null;
      if (fragCurrent) {
        fragCurrent.abortRequests();
        this.fragmentTracker.removeFragment(fragCurrent);
      }
      switch (this.state) {
        case State.KEY_LOADING:
        case State.FRAG_LOADING:
        case State.FRAG_LOADING_WAITING_RETRY:
        case State.PARSING:
        case State.PARSED:
          this.state = State.IDLE;
          break;
      }
      this.nextLoadPosition = this.getLoadPosition();
    }
    flushMainBuffer(startOffset, endOffset) {
      super.flushMainBuffer(startOffset, endOffset, this.altAudio ? 'video' : null);
    }
    onMediaAttached(event, data) {
      super.onMediaAttached(event, data);
      const media = data.media;
      this.onvplaying = this.onMediaPlaying.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      media.addEventListener('playing', this.onvplaying);
      media.addEventListener('seeked', this.onvseeked);
      this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);
    }
    onMediaDetaching() {
      const {
        media
      } = this;
      if (media && this.onvplaying && this.onvseeked) {
        media.removeEventListener('playing', this.onvplaying);
        media.removeEventListener('seeked', this.onvseeked);
        this.onvplaying = this.onvseeked = null;
        this.videoBuffer = null;
      }
      this.fragPlaying = null;
      if (this.gapController) {
        this.gapController.destroy();
        this.gapController = null;
      }
      super.onMediaDetaching();
    }
    onMediaPlaying() {
      // tick to speed up FRAG_CHANGED triggering
      this.tick();
    }
    onMediaSeeked() {
      const media = this.media;
      const currentTime = media ? media.currentTime : null;
      if (isFiniteNumber(currentTime)) {
        this.log(`Media seeked to ${currentTime.toFixed(3)}`);
      }

      // If seeked was issued before buffer was appended do not tick immediately
      const bufferInfo = this.getMainFwdBufferInfo();
      if (bufferInfo === null || bufferInfo.len === 0) {
        this.warn(`Main forward buffer length on "seeked" event ${bufferInfo ? bufferInfo.len : 'empty'})`);
        return;
      }

      // tick to speed up FRAG_CHANGED triggering
      this.tick();
    }
    onManifestLoading() {
      // reset buffer on manifest loading
      this.log('Trigger BUFFER_RESET');
      this.hls.trigger(Events$1.BUFFER_RESET, undefined);
      this.fragmentTracker.removeAllFragments();
      this.couldBacktrack = false;
      this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0;
      this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null;
      this.altAudio = this.audioOnly = this.startFragRequested = false;
    }
    onManifestParsed(event, data) {
      // detect if we have different kind of audio codecs used amongst playlists
      let aac = false;
      let heaac = false;
      data.levels.forEach(level => {
        const codec = level.audioCodec;
        if (codec) {
          aac = aac || codec.indexOf('mp4a.40.2') !== -1;
          heaac = heaac || codec.indexOf('mp4a.40.5') !== -1;
        }
      });
      this.audioCodecSwitch = aac && heaac && !changeTypeSupported();
      if (this.audioCodecSwitch) {
        this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }
      this.levels = data.levels;
      this.startFragRequested = false;
    }
    onLevelLoading(event, data) {
      const {
        levels
      } = this;
      if (!levels || this.state !== State.IDLE) {
        return;
      }
      const level = levels[data.level];
      if (!level.details || level.details.live && this.levelLastLoaded !== level || this.waitForCdnTuneIn(level.details)) {
        this.state = State.WAITING_LEVEL;
      }
    }
    onLevelLoaded(event, data) {
      var _curLevel$details;
      const {
        levels
      } = this;
      const newLevelId = data.level;
      const newDetails = data.details;
      const duration = newDetails.totalduration;
      if (!levels) {
        this.warn(`Levels were reset while loading level ${newLevelId}`);
        return;
      }
      this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);
      const curLevel = levels[newLevelId];
      const fragCurrent = this.fragCurrent;
      if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {
        if (fragCurrent.level !== data.level && fragCurrent.loader) {
          this.abortCurrentFrag();
        }
      }
      let sliding = 0;
      if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {
        var _this$levelLastLoaded;
        this.checkLiveUpdate(newDetails);
        if (newDetails.deltaUpdateFailed) {
          return;
        }
        sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);
      }
      // override level info
      curLevel.details = newDetails;
      this.levelLastLoaded = curLevel;
      this.hls.trigger(Events$1.LEVEL_UPDATED, {
        details: newDetails,
        level: newLevelId
      });

      // only switch back to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === State.WAITING_LEVEL) {
        if (this.waitForCdnTuneIn(newDetails)) {
          // Wait for Low-Latency CDN Tune-in
          return;
        }
        this.state = State.IDLE;
      }
      if (!this.startFragRequested) {
        this.setStartPosition(newDetails, sliding);
      } else if (newDetails.live) {
        this.synchronizeToLiveEdge(newDetails);
      }

      // trigger handler right now
      this.tick();
    }
    _handleFragmentLoadProgress(data) {
      var _frag$initSegment;
      const {
        frag,
        part,
        payload
      } = data;
      const {
        levels
      } = this;
      if (!levels) {
        this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);
        return;
      }
      const currentLevel = levels[frag.level];
      const details = currentLevel.details;
      if (!details) {
        this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);
        this.fragmentTracker.removeFragment(frag);
        return;
      }
      const videoCodec = currentLevel.videoCodec;

      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
      const accurateTimeOffset = details.PTSKnown || !details.live;
      const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;
      const audioCodec = this._getAudioCodec(currentLevel);

      // transmux the MPEG-TS data to ISO-BMFF segments
      // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);
      const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
      const partIndex = part ? part.index : -1;
      const partial = partIndex !== -1;
      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
      const initPTS = this.initPTS[frag.cc];
      transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
    }
    onAudioTrackSwitching(event, data) {
      // if any URL found on new audio track, it is an alternate audio track
      const fromAltAudio = this.altAudio;
      const altAudio = !!data.url;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      // don't do anything if we switch to alt audio: audio stream controller is handling it.
      // we will just have to change buffer scheduling on audioTrackSwitched
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          this.log('Switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          const fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent) {
            this.log('Switching to main audio track, cancel main fragment load');
            fragCurrent.abortRequests();
            this.fragmentTracker.removeFragment(fragCurrent);
          }
          // destroy transmuxer to force init segment generation (following audio switch)
          this.resetTransmuxer();
          // switch to IDLE state to load new fragment
          this.resetLoadingState();
        } else if (this.audioOnly) {
          // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off
          this.resetTransmuxer();
        }
        const hls = this.hls;
        // If switching from alt to main audio, flush all audio and trigger track switched
        if (fromAltAudio) {
          hls.trigger(Events$1.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: Number.POSITIVE_INFINITY,
            type: null
          });
          this.fragmentTracker.removeAllFragments();
        }
        hls.trigger(Events$1.AUDIO_TRACK_SWITCHED, data);
      }
    }
    onAudioTrackSwitched(event, data) {
      const trackId = data.id;
      const altAudio = !!this.hls.audioTracks[trackId].url;
      if (altAudio) {
        const videoBuffer = this.videoBuffer;
        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (videoBuffer && this.mediaBuffer !== videoBuffer) {
          this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = videoBuffer;
        }
      }
      this.altAudio = altAudio;
      this.tick();
    }
    onBufferCreated(event, data) {
      const tracks = data.tracks;
      let mediaTrack;
      let name;
      let alternate = false;
      for (const type in tracks) {
        const track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            const videoTrack = tracks[type];
            if (videoTrack) {
              this.videoBuffer = videoTrack.buffer;
            }
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
    onFragBuffered(event, data) {
      const {
        frag,
        part
      } = data;
      if (frag && frag.type !== PlaylistLevelType.MAIN) {
        return;
      }
      if (this.fragContextChanged(frag)) {
        // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion
        // Avoid setting state back to IDLE, since that will interfere with a level switch
        this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);
        if (this.state === State.PARSED) {
          this.state = State.IDLE;
        }
        return;
      }
      const stats = part ? part.stats : frag.stats;
      this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));
      if (frag.sn !== 'initSegment') {
        this.fragPrevious = frag;
      }
      this.fragBufferedComplete(frag, part);
    }
    onError(event, data) {
      var _data$context;
      if (data.fatal) {
        this.state = State.ERROR;
        return;
      }
      switch (data.details) {
        case ErrorDetails.FRAG_GAP:
        case ErrorDetails.FRAG_PARSING_ERROR:
        case ErrorDetails.FRAG_DECRYPT_ERROR:
        case ErrorDetails.FRAG_LOAD_ERROR:
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
        case ErrorDetails.KEY_LOAD_ERROR:
        case ErrorDetails.KEY_LOAD_TIMEOUT:
          this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);
          break;
        case ErrorDetails.LEVEL_LOAD_ERROR:
        case ErrorDetails.LEVEL_LOAD_TIMEOUT:
        case ErrorDetails.LEVEL_PARSING_ERROR:
          // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE
          if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {
            this.state = State.IDLE;
          }
          break;
        case ErrorDetails.BUFFER_APPEND_ERROR:
        case ErrorDetails.BUFFER_FULL_ERROR:
          if (!data.parent || data.parent !== 'main') {
            return;
          }
          if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {
            this.resetLoadingState();
            return;
          }
          if (this.reduceLengthAndFlushBuffer(data)) {
            this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
          }
          break;
        case ErrorDetails.INTERNAL_EXCEPTION:
          this.recoverWorkerError(data);
          break;
      }
    }

    // Checks the health of the buffer and attempts to resolve playback stalls.
    checkBuffer() {
      const {
        media,
        gapController
      } = this;
      if (!media || !gapController || !media.readyState) {
        // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)
        return;
      }
      if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {
        // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers
        const activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;
        gapController.poll(this.lastCurrentTime, activeFrag);
      }
      this.lastCurrentTime = media.currentTime;
    }
    onFragLoadEmergencyAborted() {
      this.state = State.IDLE;
      // if loadedmetadata is not set, it means that we are emergency switch down on first frag
      // in that case, reset startFragRequested flag
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
        this.nextLoadPosition = this.startPosition;
      }
      this.tickImmediate();
    }
    onBufferFlushed(event, {
      type
    }) {
      if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {
        const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
        this.tick();
      }
    }
    onLevelsUpdated(event, data) {
      if (this.level > -1 && this.fragCurrent) {
        this.level = this.fragCurrent.level;
      }
      this.levels = data.levels;
    }
    swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }

    /**
     * Seeks to the set startPosition if not equal to the mediaElement's current time.
     */
    seekToStartPos() {
      const {
        media
      } = this;
      if (!media) {
        return;
      }
      const currentTime = media.currentTime;
      let startPosition = this.startPosition;
      // only adjust currentTime if different from startPosition or if startPosition not buffered
      // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
      if (startPosition >= 0 && currentTime < startPosition) {
        if (media.seeking) {
          this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);
          return;
        }
        const buffered = BufferHelper.getBuffered(media);
        const bufferStart = buffered.length ? buffered.start(0) : 0;
        const delta = bufferStart - startPosition;
        if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {
          this.log(`adjusting start position by ${delta} to match buffer start`);
          startPosition += delta;
          this.startPosition = startPosition;
        }
        this.log(`seek to target start position ${startPosition} from current time ${currentTime}`);
        media.currentTime = startPosition;
      }
    }
    _getAudioCodec(currentLevel) {
      let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
      if (this.audioCodecSwap && audioCodec) {
        this.log('Swapping audio codec');
        if (audioCodec.indexOf('mp4a.40.5') !== -1) {
          audioCodec = 'mp4a.40.2';
        } else {
          audioCodec = 'mp4a.40.5';
        }
      }
      return audioCodec;
    }
    _loadBitrateTestFrag(frag, level) {
      frag.bitrateTest = true;
      this._doFragLoad(frag, level).then(data => {
        const {
          hls
        } = this;
        if (!data || this.fragContextChanged(frag)) {
          return;
        }
        level.fragmentError = 0;
        this.state = State.IDLE;
        this.startFragRequested = false;
        this.bitrateTest = false;
        const stats = frag.stats;
        // Bitrate tests fragments are neither parsed nor buffered
        stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();
        hls.trigger(Events$1.FRAG_LOADED, data);
        frag.bitrateTest = false;
      });
    }
    _handleTransmuxComplete(transmuxResult) {
      var _id3$samples;
      const id = 'main';
      const {
        hls
      } = this;
      const {
        remuxResult,
        chunkMeta
      } = transmuxResult;
      const context = this.getCurrentContext(chunkMeta);
      if (!context) {
        this.resetWhenMissingContext(chunkMeta);
        return;
      }
      const {
        frag,
        part,
        level
      } = context;
      const {
        video,
        text,
        id3,
        initSegment
      } = remuxResult;
      const {
        details
      } = level;
      // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track
      const audio = this.altAudio ? undefined : remuxResult.audio;

      // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.
      // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.
      if (this.fragContextChanged(frag)) {
        this.fragmentTracker.removeFragment(frag);
        return;
      }
      this.state = State.PARSING;
      if (initSegment) {
        if (initSegment != null && initSegment.tracks) {
          const mapFragment = frag.initSegment || frag;
          this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
          hls.trigger(Events$1.FRAG_PARSING_INIT_SEGMENT, {
            frag: mapFragment,
            id,
            tracks: initSegment.tracks
          });
        }

        // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038
        const initPTS = initSegment.initPTS;
        const timescale = initSegment.timescale;
        if (isFiniteNumber(initPTS)) {
          this.initPTS[frag.cc] = {
            baseTime: initPTS,
            timescale
          };
          hls.trigger(Events$1.INIT_PTS_FOUND, {
            frag,
            id,
            initPTS,
            timescale
          });
        }
      }

      // Avoid buffering if backtracking this fragment
      if (video && details && frag.sn !== 'initSegment') {
        const prevFrag = details.fragments[frag.sn - 1 - details.startSN];
        const isFirstFragment = frag.sn === details.startSN;
        const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;
        if (remuxResult.independent !== false) {
          const {
            startPTS,
            endPTS,
            startDTS,
            endDTS
          } = video;
          if (part) {
            part.elementaryStreams[video.type] = {
              startPTS,
              endPTS,
              startDTS,
              endDTS
            };
          } else {
            if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {
              this.couldBacktrack = true;
            }
            if (video.dropped && video.independent) {
              // Backtrack if dropped frames create a gap after currentTime

              const bufferInfo = this.getMainFwdBufferInfo();
              const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;
              const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;
              if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {
                this.backtrack(frag);
                return;
              } else if (isFirstInDiscontinuity) {
                // Mark segment with a gap to avoid loop loading
                frag.gap = true;
              }
              // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial
              frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);
            } else if (isFirstFragment && startPTS > MAX_START_GAP_JUMP) {
              // Mark segment with a gap to skip large start gap
              frag.gap = true;
            }
          }
          frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);
          if (this.backtrackFragment) {
            this.backtrackFragment = frag;
          }
          this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);
        } else if (isFirstFragment || isFirstInDiscontinuity) {
          // Mark segment with a gap to avoid loop loading
          frag.gap = true;
        } else {
          this.backtrack(frag);
          return;
        }
      }
      if (audio) {
        const {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        } = audio;
        if (part) {
          part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
            startPTS,
            endPTS,
            startDTS,
            endDTS
          };
        }
        frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
        this.bufferFragmentData(audio, frag, part, chunkMeta);
      }
      if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
        const emittedID3 = {
          id,
          frag,
          details,
          samples: id3.samples
        };
        hls.trigger(Events$1.FRAG_PARSING_METADATA, emittedID3);
      }
      if (details && text) {
        const emittedText = {
          id,
          frag,
          details,
          samples: text.samples
        };
        hls.trigger(Events$1.FRAG_PARSING_USERDATA, emittedText);
      }
    }
    _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
      if (this.state !== State.PARSING) {
        return;
      }
      this.audioOnly = !!tracks.audio && !tracks.video;

      // if audio track is expected to come from audio stream controller, discard any coming from main
      if (this.altAudio && !this.audioOnly) {
        delete tracks.audio;
      }
      // include levelCodec in audio and video tracks
      const {
        audio,
        video,
        audiovideo
      } = tracks;
      if (audio) {
        let audioCodec = currentLevel.audioCodec;
        const ua = navigator.userAgent.toLowerCase();
        if (this.audioCodecSwitch) {
          if (audioCodec) {
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // In the case that AAC and HE-AAC audio codecs are signalled in manifest,
          // force HE-AAC, as it seems that most browsers prefers it.
          // don't force HE-AAC if mono stream, or in Firefox
          const audioMetadata = audio.metadata;
          if (audioMetadata && 'channelCount' in audioMetadata && (audioMetadata.channelCount || 1) !== 1 && ua.indexOf('firefox') === -1) {
            audioCodec = 'mp4a.40.5';
          }
        }
        // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
        if (audioCodec && audioCodec.indexOf('mp4a.40.5') !== -1 && ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {
          // Exclude mpeg audio
          audioCodec = 'mp4a.40.2';
          this.log(`Android: force audio codec to ${audioCodec}`);
        }
        if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {
          this.log(`Swapping manifest audio codec "${currentLevel.audioCodec}" for "${audioCodec}"`);
        }
        audio.levelCodec = audioCodec;
        audio.id = 'main';
        this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || ''}/${currentLevel.audioCodec || ''}/${audio.codec}]`);
      }
      if (video) {
        video.levelCodec = currentLevel.videoCodec;
        video.id = 'main';
        this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || ''}/${video.codec}]`);
      }
      if (audiovideo) {
        this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.codecs}/${audiovideo.codec}]`);
      }
      this.hls.trigger(Events$1.BUFFER_CODECS, tracks);
      // loop through tracks that are going to be provided to bufferController
      Object.keys(tracks).forEach(trackName => {
        const track = tracks[trackName];
        const initSegment = track.initSegment;
        if (initSegment != null && initSegment.byteLength) {
          this.hls.trigger(Events$1.BUFFER_APPENDING, {
            type: trackName,
            data: initSegment,
            frag,
            part: null,
            chunkMeta,
            parent: frag.type
          });
        }
      });
      // trigger handler right now
      this.tickImmediate();
    }
    getMainFwdBufferInfo() {
      return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);
    }
    backtrack(frag) {
      this.couldBacktrack = true;
      // Causes findFragments to backtrack through fragments to find the keyframe
      this.backtrackFragment = frag;
      this.resetTransmuxer();
      this.flushBufferGap(frag);
      this.fragmentTracker.removeFragment(frag);
      this.fragPrevious = null;
      this.nextLoadPosition = frag.start;
      this.state = State.IDLE;
    }
    checkFragmentChanged() {
      const video = this.media;
      let fragPlayingCurrent = null;
      if (video && video.readyState > 1 && video.seeking === false) {
        const currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */

        if (BufferHelper.isBuffered(video, currentTime)) {
          fragPlayingCurrent = this.getAppendedFrag(currentTime);
        } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);
        }
        if (fragPlayingCurrent) {
          this.backtrackFragment = null;
          const fragPlaying = this.fragPlaying;
          const fragCurrentLevel = fragPlayingCurrent.level;
          if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {
            this.fragPlaying = fragPlayingCurrent;
            this.hls.trigger(Events$1.FRAG_CHANGED, {
              frag: fragPlayingCurrent
            });
            if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {
              this.hls.trigger(Events$1.LEVEL_SWITCHED, {
                level: fragCurrentLevel
              });
            }
          }
        }
      }
    }
    get nextLevel() {
      const frag = this.nextBufferedFrag;
      if (frag) {
        return frag.level;
      }
      return -1;
    }
    get currentFrag() {
      const media = this.media;
      if (media) {
        return this.fragPlaying || this.getAppendedFrag(media.currentTime);
      }
      return null;
    }
    get currentProgramDateTime() {
      const media = this.media;
      if (media) {
        const currentTime = media.currentTime;
        const frag = this.currentFrag;
        if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {
          const epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;
          return new Date(epocMs);
        }
      }
      return null;
    }
    get currentLevel() {
      const frag = this.currentFrag;
      if (frag) {
        return frag.level;
      }
      return -1;
    }
    get nextBufferedFrag() {
      const frag = this.currentFrag;
      if (frag) {
        return this.followingBufferedFrag(frag);
      }
      return null;
    }
    get forceStartLoad() {
      return this._forceStartLoad;
    }
  }

  /**
   * The `Hls` class is the core of the HLS.js library used to instantiate player instances.
   * @public
   */
  class Hls {
    /**
     * Get the video-dev/hls.js package version.
     */
    static get version() {
      return "1.5.15";
    }

    /**
     * Check if the required MediaSource Extensions are available.
     */
    static isMSESupported() {
      return isMSESupported();
    }

    /**
     * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.
     */
    static isSupported() {
      return isSupported();
    }

    /**
     * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).
     */
    static getMediaSource() {
      return getMediaSource();
    }
    static get Events() {
      return Events$1;
    }
    static get ErrorTypes() {
      return ErrorTypes;
    }
    static get ErrorDetails() {
      return ErrorDetails;
    }

    /**
     * Get the default configuration applied to new instances.
     */
    static get DefaultConfig() {
      if (!Hls.defaultConfig) {
        return hlsDefaultConfig;
      }
      return Hls.defaultConfig;
    }

    /**
     * Replace the default configuration applied to new instances.
     */
    static set DefaultConfig(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }

    /**
     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
     * @param userConfig - Configuration options applied over `Hls.DefaultConfig`
     */
    constructor(userConfig = {}) {
      /**
       * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.
       */
      this.config = void 0;
      /**
       * The configuration object provided on player instantiation.
       */
      this.userConfig = void 0;
      this.coreComponents = void 0;
      this.networkControllers = void 0;
      this.started = false;
      this._emitter = new EventEmitter();
      this._autoLevelCapping = -1;
      this._maxHdcpLevel = null;
      this.abrController = void 0;
      this.bufferController = void 0;
      this.capLevelController = void 0;
      this.latencyController = void 0;
      this.levelController = void 0;
      this.streamController = void 0;
      this.audioTrackController = void 0;
      this.subtitleTrackController = void 0;
      this.emeController = void 0;
      this.cmcdController = void 0;
      this._media = null;
      this.url = null;
      this.triggeringException = void 0;
      enableLogs(userConfig.debug || false, 'Hls instance');
      const config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);
      this.userConfig = userConfig;
      if (config.progressive) {
        enableStreamingMode(config);
      }

      // core controllers and network loaders
      const {
        abrController: ConfigAbrController,
        bufferController: ConfigBufferController,
        capLevelController: ConfigCapLevelController,
        errorController: ConfigErrorController,
        fpsController: ConfigFpsController
      } = config;
      const errorController = new ConfigErrorController(this);
      const abrController = this.abrController = new ConfigAbrController(this);
      const bufferController = this.bufferController = new ConfigBufferController(this);
      const capLevelController = this.capLevelController = new ConfigCapLevelController(this);
      const fpsController = new ConfigFpsController(this);
      const playListLoader = new PlaylistLoader(this);
      const id3TrackController = new ID3TrackController(this);
      const ConfigContentSteeringController = config.contentSteeringController;
      // ConentSteeringController is defined before LevelController to receive Multivariant Playlist events first
      const contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;
      const levelController = this.levelController = new LevelController(this, contentSteering);
      // FragmentTracker must be defined before StreamController because the order of event handling is important
      const fragmentTracker = new FragmentTracker(this);
      const keyLoader = new KeyLoader(this.config);
      const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);

      // Cap level controller uses streamController to flush the buffer
      capLevelController.setStreamController(streamController);
      // fpsController uses streamController to switch when frames are being dropped
      fpsController.setStreamController(streamController);
      const networkControllers = [playListLoader, levelController, streamController];
      if (contentSteering) {
        networkControllers.splice(1, 0, contentSteering);
      }
      this.networkControllers = networkControllers;
      const coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];
      this.audioTrackController = this.createController(config.audioTrackController, networkControllers);
      const AudioStreamControllerClass = config.audioStreamController;
      if (AudioStreamControllerClass) {
        networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));
      }
      // subtitleTrackController must be defined before subtitleStreamController because the order of event handling is important
      this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);
      const SubtitleStreamControllerClass = config.subtitleStreamController;
      if (SubtitleStreamControllerClass) {
        networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));
      }
      this.createController(config.timelineController, coreComponents);
      keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);
      this.cmcdController = this.createController(config.cmcdController, coreComponents);
      this.latencyController = this.createController(LatencyController, coreComponents);
      this.coreComponents = coreComponents;

      // Error controller handles errors before and after all other controllers
      // This listener will be invoked after all other controllers error listeners
      networkControllers.push(errorController);
      const onErrorOut = errorController.onErrorOut;
      if (typeof onErrorOut === 'function') {
        this.on(Events$1.ERROR, onErrorOut, errorController);
      }
    }
    createController(ControllerClass, components) {
      if (ControllerClass) {
        const controllerInstance = new ControllerClass(this);
        if (components) {
          components.push(controllerInstance);
        }
        return controllerInstance;
      }
      return null;
    }

    // Delegate the EventEmitter through the public API of Hls.js
    on(event, listener, context = this) {
      this._emitter.on(event, listener, context);
    }
    once(event, listener, context = this) {
      this._emitter.once(event, listener, context);
    }
    removeAllListeners(event) {
      this._emitter.removeAllListeners(event);
    }
    off(event, listener, context = this, once) {
      this._emitter.off(event, listener, context, once);
    }
    listeners(event) {
      return this._emitter.listeners(event);
    }
    emit(event, name, eventObject) {
      return this._emitter.emit(event, name, eventObject);
    }
    trigger(event, eventObject) {
      if (this.config.debug) {
        return this.emit(event, event, eventObject);
      } else {
        try {
          return this.emit(event, event, eventObject);
        } catch (error) {
          logger.error('An internal error happened while handling event ' + event + '. Error message: "' + error.message + '". Here is a stacktrace:', error);
          // Prevent recursion in error event handlers that throw #5497
          if (!this.triggeringException) {
            this.triggeringException = true;
            const fatal = event === Events$1.ERROR;
            this.trigger(Events$1.ERROR, {
              type: ErrorTypes.OTHER_ERROR,
              details: ErrorDetails.INTERNAL_EXCEPTION,
              fatal,
              event,
              error
            });
            this.triggeringException = false;
          }
        }
      }
      return false;
    }
    listenerCount(event) {
      return this._emitter.listenerCount(event);
    }

    /**
     * Dispose of the instance
     */
    destroy() {
      logger.log('destroy');
      this.trigger(Events$1.DESTROYING, undefined);
      this.detachMedia();
      this.removeAllListeners();
      this._autoLevelCapping = -1;
      this.url = null;
      this.networkControllers.forEach(component => component.destroy());
      this.networkControllers.length = 0;
      this.coreComponents.forEach(component => component.destroy());
      this.coreComponents.length = 0;
      // Remove any references that could be held in config options or callbacks
      const config = this.config;
      config.xhrSetup = config.fetchSetup = undefined;
      // @ts-ignore
      this.userConfig = null;
    }

    /**
     * Attaches Hls.js to a media element
     */
    attachMedia(media) {
      logger.log('attachMedia');
      this._media = media;
      this.trigger(Events$1.MEDIA_ATTACHING, {
        media: media
      });
    }

    /**
     * Detach Hls.js from the media
     */
    detachMedia() {
      logger.log('detachMedia');
      this.trigger(Events$1.MEDIA_DETACHING, undefined);
      this._media = null;
    }

    /**
     * Set the source URL. Can be relative or absolute.
     */
    loadSource(url) {
      this.stopLoad();
      const media = this.media;
      const loadedSource = this.url;
      const loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {
        alwaysNormalize: true
      });
      this._autoLevelCapping = -1;
      this._maxHdcpLevel = null;
      logger.log(`loadSource:${loadingSource}`);
      if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {
        this.detachMedia();
        this.attachMedia(media);
      }
      // when attaching to a source URL, trigger a playlist load
      this.trigger(Events$1.MANIFEST_LOADING, {
        url: url
      });
    }

    /**
     * Start loading data from the stream source.
     * Depending on default config, client starts loading automatically when a source is set.
     *
     * @param startPosition - Set the start position to stream from.
     * Defaults to -1 (None: starts from earliest point)
     */
    startLoad(startPosition = -1) {
      logger.log(`startLoad(${startPosition})`);
      this.started = true;
      this.networkControllers.forEach(controller => {
        controller.startLoad(startPosition);
      });
    }

    /**
     * Stop loading of any stream data.
     */
    stopLoad() {
      logger.log('stopLoad');
      this.started = false;
      this.networkControllers.forEach(controller => {
        controller.stopLoad();
      });
    }

    /**
     * Resumes stream controller segment loading if previously started.
     */
    resumeBuffering() {
      if (this.started) {
        this.networkControllers.forEach(controller => {
          if ('fragmentLoader' in controller) {
            controller.startLoad(-1);
          }
        });
      }
    }

    /**
     * Stops stream controller segment loading without changing 'started' state like stopLoad().
     * This allows for media buffering to be paused without interupting playlist loading.
     */
    pauseBuffering() {
      this.networkControllers.forEach(controller => {
        if ('fragmentLoader' in controller) {
          controller.stopLoad();
        }
      });
    }

    /**
     * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
     */
    swapAudioCodec() {
      logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }

    /**
     * When the media-element fails, this allows to detach and then re-attach it
     * as one call (convenience method).
     *
     * Automatic recovery of media-errors by this process is configurable.
     */
    recoverMediaError() {
      logger.log('recoverMediaError');
      const media = this._media;
      this.detachMedia();
      if (media) {
        this.attachMedia(media);
      }
    }
    removeLevel(levelIndex) {
      this.levelController.removeLevel(levelIndex);
    }

    /**
     * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH
     */
    get levels() {
      const levels = this.levelController.levels;
      return levels ? levels : [];
    }

    /**
     * Index of quality level (variant) currently played
     */
    get currentLevel() {
      return this.streamController.currentLevel;
    }

    /**
     * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.
     */
    set currentLevel(newLevel) {
      logger.log(`set currentLevel:${newLevel}`);
      this.levelController.manualLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /**
     * Index of next quality level loaded as scheduled by stream controller.
     */
    get nextLevel() {
      return this.streamController.nextLevel;
    }

    /**
     * Set quality level index for next loaded data.
     * This will switch the video quality asap, without interrupting playback.
     * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
     * @param newLevel - Pass -1 for automatic level selection
     */
    set nextLevel(newLevel) {
      logger.log(`set nextLevel:${newLevel}`);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /**
     * Return the quality level of the currently or last (of none is loaded currently) segment
     */
    get loadLevel() {
      return this.levelController.level;
    }

    /**
     * Set quality level index for next loaded data in a conservative way.
     * This will switch the quality without flushing, but interrupt current loading.
     * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
     * @param newLevel - Pass -1 for automatic level selection
     */
    set loadLevel(newLevel) {
      logger.log(`set loadLevel:${newLevel}`);
      this.levelController.manualLevel = newLevel;
    }

    /**
     * get next quality level loaded
     */
    get nextLoadLevel() {
      return this.levelController.nextLoadLevel;
    }

    /**
     * Set quality level of next loaded segment in a fully "non-destructive" way.
     * Same as `loadLevel` but will wait for next switch (until current loading is done).
     */
    set nextLoadLevel(level) {
      this.levelController.nextLoadLevel = level;
    }

    /**
     * Return "first level": like a default level, if not set,
     * falls back to index of first level referenced in manifest
     */
    get firstLevel() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }

    /**
     * Sets "first-level", see getter.
     */
    set firstLevel(newLevel) {
      logger.log(`set firstLevel:${newLevel}`);
      this.levelController.firstLevel = newLevel;
    }

    /**
     * Return the desired start level for the first fragment that will be loaded.
     * The default value of -1 indicates automatic start level selection.
     * Setting hls.nextAutoLevel without setting a startLevel will result in
     * the nextAutoLevel value being used for one fragment load.
     */
    get startLevel() {
      const startLevel = this.levelController.startLevel;
      if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {
        return this.abrController.forcedAutoLevel;
      }
      return startLevel;
    }

    /**
     * set  start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     */
    set startLevel(newLevel) {
      logger.log(`set startLevel:${newLevel}`);
      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, this.minAutoLevel);
      }
      this.levelController.startLevel = newLevel;
    }

    /**
     * Whether level capping is enabled.
     * Default value is set via `config.capLevelToPlayerSize`.
     */
    get capLevelToPlayerSize() {
      return this.config.capLevelToPlayerSize;
    }

    /**
     * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.
     */
    set capLevelToPlayerSize(shouldStartCapping) {
      const newCapLevelToPlayerSize = !!shouldStartCapping;
      if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
        if (newCapLevelToPlayerSize) {
          this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.
        } else {
          this.capLevelController.stopCapping();
          this.autoLevelCapping = -1;
          this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.
        }
        this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
      }
    }

    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     */
    get autoLevelCapping() {
      return this._autoLevelCapping;
    }

    /**
     * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.
     */
    get bandwidthEstimate() {
      const {
        bwEstimator
      } = this.abrController;
      if (!bwEstimator) {
        return NaN;
      }
      return bwEstimator.getEstimate();
    }
    set bandwidthEstimate(abrEwmaDefaultEstimate) {
      this.abrController.resetEstimator(abrEwmaDefaultEstimate);
    }

    /**
     * get time to first byte estimate
     * @type {number}
     */
    get ttfbEstimate() {
      const {
        bwEstimator
      } = this.abrController;
      if (!bwEstimator) {
        return NaN;
      }
      return bwEstimator.getEstimateTTFB();
    }

    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     */
    set autoLevelCapping(newLevel) {
      if (this._autoLevelCapping !== newLevel) {
        logger.log(`set autoLevelCapping:${newLevel}`);
        this._autoLevelCapping = newLevel;
        this.levelController.checkMaxAutoUpdated();
      }
    }
    get maxHdcpLevel() {
      return this._maxHdcpLevel;
    }
    set maxHdcpLevel(value) {
      if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {
        this._maxHdcpLevel = value;
        this.levelController.checkMaxAutoUpdated();
      }
    }

    /**
     * True when automatic level selection enabled
     */
    get autoLevelEnabled() {
      return this.levelController.manualLevel === -1;
    }

    /**
     * Level set manually (if any)
     */
    get manualLevel() {
      return this.levelController.manualLevel;
    }

    /**
     * min level selectable in auto mode according to config.minAutoBitrate
     */
    get minAutoLevel() {
      const {
        levels,
        config: {
          minAutoBitrate
        }
      } = this;
      if (!levels) return 0;
      const len = levels.length;
      for (let i = 0; i < len; i++) {
        if (levels[i].maxBitrate >= minAutoBitrate) {
          return i;
        }
      }
      return 0;
    }

    /**
     * max level selectable in auto mode according to autoLevelCapping
     */
    get maxAutoLevel() {
      const {
        levels,
        autoLevelCapping,
        maxHdcpLevel
      } = this;
      let maxAutoLevel;
      if (autoLevelCapping === -1 && levels != null && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }
      if (maxHdcpLevel) {
        for (let i = maxAutoLevel; i--;) {
          const hdcpLevel = levels[i].attrs['HDCP-LEVEL'];
          if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {
            return i;
          }
        }
      }
      return maxAutoLevel;
    }
    get firstAutoLevel() {
      return this.abrController.firstAutoLevel;
    }

    /**
     * next automatically selected quality level
     */
    get nextAutoLevel() {
      return this.abrController.nextAutoLevel;
    }

    /**
     * this setter is used to force next auto level.
     * this is useful to force a switch down in auto mode:
     * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
     * forced value is valid for one fragment. upon successful frag loading at forced level,
     * this value will be resetted to -1 by ABR controller.
     */
    set nextAutoLevel(nextLevel) {
      this.abrController.nextAutoLevel = nextLevel;
    }

    /**
     * get the datetime value relative to media.currentTime for the active level Program Date Time if present
     */
    get playingDate() {
      return this.streamController.currentProgramDateTime;
    }
    get mainForwardBufferInfo() {
      return this.streamController.getMainFwdBufferInfo();
    }

    /**
     * Find and select the best matching audio track, making a level switch when a Group change is necessary.
     * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.
     */
    setAudioOption(audioOption) {
      var _this$audioTrackContr;
      return (_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption);
    }
    /**
     * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.
     * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.
     */
    setSubtitleOption(subtitleOption) {
      var _this$subtitleTrackCo;
      (_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption);
      return null;
    }

    /**
     * Get the complete list of audio tracks across all media groups
     */
    get allAudioTracks() {
      const audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.allAudioTracks : [];
    }

    /**
     * Get the list of selectable audio tracks
     */
    get audioTracks() {
      const audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }

    /**
     * index of the selected audio track (index in audio track lists)
     */
    get audioTrack() {
      const audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }

    /**
     * selects an audio track, based on its index in audio track lists
     */
    set audioTrack(audioTrackId) {
      const audioTrackController = this.audioTrackController;
      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }

    /**
     * get the complete list of subtitle tracks across all media groups
     */
    get allSubtitleTracks() {
      const subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];
    }

    /**
     * get alternate subtitle tracks list from playlist
     */
    get subtitleTracks() {
      const subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }

    /**
     * index of the selected subtitle track (index in subtitle track lists)
     */
    get subtitleTrack() {
      const subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    }
    get media() {
      return this._media;
    }

    /**
     * select an subtitle track, based on its index in subtitle track lists
     */
    set subtitleTrack(subtitleTrackId) {
      const subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }

    /**
     * Whether subtitle display is enabled or not
     */
    get subtitleDisplay() {
      const subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
    }

    /**
     * Enable/disable subtitle display rendering
     */
    set subtitleDisplay(value) {
      const subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleDisplay = value;
      }
    }

    /**
     * get mode for Low-Latency HLS loading
     */
    get lowLatencyMode() {
      return this.config.lowLatencyMode;
    }

    /**
     * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.
     */
    set lowLatencyMode(mode) {
      this.config.lowLatencyMode = mode;
    }

    /**
     * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
     * @returns null prior to loading live Playlist
     */
    get liveSyncPosition() {
      return this.latencyController.liveSyncPosition;
    }

    /**
     * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
     * @returns 0 before first playlist is loaded
     */
    get latency() {
      return this.latencyController.latency;
    }

    /**
     * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
     * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
     * @returns 0 before first playlist is loaded
     */
    get maxLatency() {
      return this.latencyController.maxLatency;
    }

    /**
     * target distance from the edge as calculated by the latency controller
     */
    get targetLatency() {
      return this.latencyController.targetLatency;
    }

    /**
     * the rate at which the edge of the current live playlist is advancing or 1 if there is none
     */
    get drift() {
      return this.latencyController.drift;
    }

    /**
     * set to true when startLoad is called before MANIFEST_PARSED event
     */
    get forceStartLoad() {
      return this.streamController.forceStartLoad;
    }
  }
  Hls.defaultConfig = void 0;

  var win;

  if (typeof window !== "undefined") {
      win = window;
  } else if (typeof commonjsGlobal !== "undefined") {
      win = commonjsGlobal;
  } else if (typeof self !== "undefined"){
      win = self;
  } else {
      win = {};
  }

  var window_1 = win;

  var slice = Array.prototype.slice;

  var domWalk$2 = iterativelyWalk;

  function iterativelyWalk(nodes, cb) {
      if (!('length' in nodes)) {
          nodes = [nodes];
      }
      
      nodes = slice.call(nodes);

      while(nodes.length) {
          var node = nodes.shift(),
              ret = cb(node);

          if (ret) {
              return ret
          }

          if (node.childNodes && node.childNodes.length) {
              nodes = slice.call(node.childNodes).concat(nodes);
          }
      }
  }

  var domComment = Comment$1;

  function Comment$1(data, owner) {
      if (!(this instanceof Comment$1)) {
          return new Comment$1(data, owner)
      }

      this.data = data;
      this.nodeValue = data;
      this.length = data.length;
      this.ownerDocument = owner || null;
  }

  Comment$1.prototype.nodeType = 8;
  Comment$1.prototype.nodeName = "#comment";

  Comment$1.prototype.toString = function _Comment_toString() {
      return "[object Comment]"
  };

  var domText = DOMText$1;

  function DOMText$1(value, owner) {
      if (!(this instanceof DOMText$1)) {
          return new DOMText$1(value)
      }

      this.data = value || "";
      this.length = this.data.length;
      this.ownerDocument = owner || null;
  }

  DOMText$1.prototype.type = "DOMTextNode";
  DOMText$1.prototype.nodeType = 3;
  DOMText$1.prototype.nodeName = "#text";

  DOMText$1.prototype.toString = function _Text_toString() {
      return this.data
  };

  DOMText$1.prototype.replaceData = function replaceData(index, length, value) {
      var current = this.data;
      var left = current.substring(0, index);
      var right = current.substring(index + length, current.length);
      this.data = left + value + right;
      this.length = this.data.length;
  };

  var dispatchEvent_1 = dispatchEvent$2;

  function dispatchEvent$2(ev) {
      var elem = this;
      var type = ev.type;

      if (!ev.target) {
          ev.target = elem;
      }

      if (!elem.listeners) {
          elem.listeners = {};
      }

      var listeners = elem.listeners[type];

      if (listeners) {
          return listeners.forEach(function (listener) {
              ev.currentTarget = elem;
              if (typeof listener === 'function') {
                  listener(ev);
              } else {
                  listener.handleEvent(ev);
              }
          })
      }

      if (elem.parentNode) {
          elem.parentNode.dispatchEvent(ev);
      }
  }

  var addEventListener_1 = addEventListener$2;

  function addEventListener$2(type, listener) {
      var elem = this;

      if (!elem.listeners) {
          elem.listeners = {};
      }

      if (!elem.listeners[type]) {
          elem.listeners[type] = [];
      }

      if (elem.listeners[type].indexOf(listener) === -1) {
          elem.listeners[type].push(listener);
      }
  }

  var removeEventListener_1 = removeEventListener$2;

  function removeEventListener$2(type, listener) {
      var elem = this;

      if (!elem.listeners) {
          return
      }

      if (!elem.listeners[type]) {
          return
      }

      var list = elem.listeners[type];
      var index = list.indexOf(listener);
      if (index !== -1) {
          list.splice(index, 1);
      }
  }

  var serialize = serializeNode$1;

  var voidElements = ["area","base","br","col","embed","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"];

  function serializeNode$1(node) {
      switch (node.nodeType) {
          case 3:
              return escapeText(node.data)
          case 8:
              return "<!--" + node.data + "-->"
          default:
              return serializeElement(node)
      }
  }

  function serializeElement(elem) {
      var strings = [];

      var tagname = elem.tagName;

      if (elem.namespaceURI === "http://www.w3.org/1999/xhtml") {
          tagname = tagname.toLowerCase();
      }

      strings.push("<" + tagname + properties(elem) + datasetify(elem));

      if (voidElements.indexOf(tagname) > -1) {
          strings.push(" />");
      } else {
          strings.push(">");

          if (elem.childNodes.length) {
              strings.push.apply(strings, elem.childNodes.map(serializeNode$1));
          } else if (elem.textContent || elem.innerText) {
              strings.push(escapeText(elem.textContent || elem.innerText));
          } else if (elem.innerHTML) {
              strings.push(elem.innerHTML);
          }

          strings.push("</" + tagname + ">");
      }

      return strings.join("")
  }

  function isProperty(elem, key) {
      var type = typeof elem[key];

      if (key === "style" && Object.keys(elem.style).length > 0) {
        return true
      }

      return elem.hasOwnProperty(key) &&
          (type === "string" || type === "boolean" || type === "number") &&
          key !== "nodeName" && key !== "className" && key !== "tagName" &&
          key !== "textContent" && key !== "innerText" && key !== "namespaceURI" &&  key !== "innerHTML"
  }

  function stylify(styles) {
      if (typeof styles === 'string') return styles
      var attr = "";
      Object.keys(styles).forEach(function (key) {
          var value = styles[key];
          key = key.replace(/[A-Z]/g, function(c) {
              return "-" + c.toLowerCase();
          });
          attr += key + ":" + value + ";";
      });
      return attr
  }

  function datasetify(elem) {
      var ds = elem.dataset;
      var props = [];

      for (var key in ds) {
          props.push({ name: "data-" + key, value: ds[key] });
      }

      return props.length ? stringify(props) : ""
  }

  function stringify(list) {
      var attributes = [];
      list.forEach(function (tuple) {
          var name = tuple.name;
          var value = tuple.value;

          if (name === "style") {
              value = stylify(value);
          }

          attributes.push(name + "=" + "\"" + escapeAttributeValue(value) + "\"");
      });

      return attributes.length ? " " + attributes.join(" ") : ""
  }

  function properties(elem) {
      var props = [];
      for (var key in elem) {
          if (isProperty(elem, key)) {
              props.push({ name: key, value: elem[key] });
          }
      }

      for (var ns in elem._attributes) {
        for (var attribute in elem._attributes[ns]) {
          var prop = elem._attributes[ns][attribute];
          var name = (prop.prefix ? prop.prefix + ":" : "") + attribute;
          props.push({ name: name, value: prop.value });
        }
      }

      if (elem.className) {
          props.push({ name: "class", value: elem.className });
      }

      return props.length ? stringify(props) : ""
  }

  function escapeText(s) {
      var str = '';

      if (typeof(s) === 'string') { 
          str = s; 
      } else if (s) {
          str = s.toString();
      }

      return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
  }

  function escapeAttributeValue(str) {
      return escapeText(str).replace(/"/g, "&quot;")
  }

  var domWalk$1 = domWalk$2;
  var dispatchEvent$1 = dispatchEvent_1;
  var addEventListener$1 = addEventListener_1;
  var removeEventListener$1 = removeEventListener_1;
  var serializeNode = serialize;

  var htmlns = "http://www.w3.org/1999/xhtml";

  var domElement = DOMElement$2;

  function DOMElement$2(tagName, owner, namespace) {
      if (!(this instanceof DOMElement$2)) {
          return new DOMElement$2(tagName)
      }

      var ns = namespace === undefined ? htmlns : (namespace || null);

      this.tagName = ns === htmlns ? String(tagName).toUpperCase() : tagName;
      this.nodeName = this.tagName;
      this.className = "";
      this.dataset = {};
      this.childNodes = [];
      this.parentNode = null;
      this.style = {};
      this.ownerDocument = owner || null;
      this.namespaceURI = ns;
      this._attributes = {};

      if (this.tagName === 'INPUT') {
        this.type = 'text';
      }
  }

  DOMElement$2.prototype.type = "DOMElement";
  DOMElement$2.prototype.nodeType = 1;

  DOMElement$2.prototype.appendChild = function _Element_appendChild(child) {
      if (child.parentNode) {
          child.parentNode.removeChild(child);
      }

      this.childNodes.push(child);
      child.parentNode = this;

      return child
  };

  DOMElement$2.prototype.replaceChild =
      function _Element_replaceChild(elem, needle) {
          // TODO: Throw NotFoundError if needle.parentNode !== this

          if (elem.parentNode) {
              elem.parentNode.removeChild(elem);
          }

          var index = this.childNodes.indexOf(needle);

          needle.parentNode = null;
          this.childNodes[index] = elem;
          elem.parentNode = this;

          return needle
      };

  DOMElement$2.prototype.removeChild = function _Element_removeChild(elem) {
      // TODO: Throw NotFoundError if elem.parentNode !== this

      var index = this.childNodes.indexOf(elem);
      this.childNodes.splice(index, 1);

      elem.parentNode = null;
      return elem
  };

  DOMElement$2.prototype.insertBefore =
      function _Element_insertBefore(elem, needle) {
          // TODO: Throw NotFoundError if referenceElement is a dom node
          // and parentNode !== this

          if (elem.parentNode) {
              elem.parentNode.removeChild(elem);
          }

          var index = needle === null || needle === undefined ?
              -1 :
              this.childNodes.indexOf(needle);

          if (index > -1) {
              this.childNodes.splice(index, 0, elem);
          } else {
              this.childNodes.push(elem);
          }

          elem.parentNode = this;
          return elem
      };

  DOMElement$2.prototype.setAttributeNS =
      function _Element_setAttributeNS(namespace, name, value) {
          var prefix = null;
          var localName = name;
          var colonPosition = name.indexOf(":");
          if (colonPosition > -1) {
              prefix = name.substr(0, colonPosition);
              localName = name.substr(colonPosition + 1);
          }
          if (this.tagName === 'INPUT' && name === 'type') {
            this.type = value;
          }
          else {
            var attributes = this._attributes[namespace] || (this._attributes[namespace] = {});
            attributes[localName] = {value: value, prefix: prefix};
          }
      };

  DOMElement$2.prototype.getAttributeNS =
      function _Element_getAttributeNS(namespace, name) {
          var attributes = this._attributes[namespace];
          var value = attributes && attributes[name] && attributes[name].value;
          if (this.tagName === 'INPUT' && name === 'type') {
            return this.type;
          }
          if (typeof value !== "string") {
              return null
          }
          return value
      };

  DOMElement$2.prototype.removeAttributeNS =
      function _Element_removeAttributeNS(namespace, name) {
          var attributes = this._attributes[namespace];
          if (attributes) {
              delete attributes[name];
          }
      };

  DOMElement$2.prototype.hasAttributeNS =
      function _Element_hasAttributeNS(namespace, name) {
          var attributes = this._attributes[namespace];
          return !!attributes && name in attributes;
      };

  DOMElement$2.prototype.setAttribute = function _Element_setAttribute(name, value) {
      return this.setAttributeNS(null, name, value)
  };

  DOMElement$2.prototype.getAttribute = function _Element_getAttribute(name) {
      return this.getAttributeNS(null, name)
  };

  DOMElement$2.prototype.removeAttribute = function _Element_removeAttribute(name) {
      return this.removeAttributeNS(null, name)
  };

  DOMElement$2.prototype.hasAttribute = function _Element_hasAttribute(name) {
      return this.hasAttributeNS(null, name)
  };

  DOMElement$2.prototype.removeEventListener = removeEventListener$1;
  DOMElement$2.prototype.addEventListener = addEventListener$1;
  DOMElement$2.prototype.dispatchEvent = dispatchEvent$1;

  // Un-implemented
  DOMElement$2.prototype.focus = function _Element_focus() {
      return void 0
  };

  DOMElement$2.prototype.toString = function _Element_toString() {
      return serializeNode(this)
  };

  DOMElement$2.prototype.getElementsByClassName = function _Element_getElementsByClassName(classNames) {
      var classes = classNames.split(" ");
      var elems = [];

      domWalk$1(this, function (node) {
          if (node.nodeType === 1) {
              var nodeClassName = node.className || "";
              var nodeClasses = nodeClassName.split(" ");

              if (classes.every(function (item) {
                  return nodeClasses.indexOf(item) !== -1
              })) {
                  elems.push(node);
              }
          }
      });

      return elems
  };

  DOMElement$2.prototype.getElementsByTagName = function _Element_getElementsByTagName(tagName) {
      tagName = tagName.toLowerCase();
      var elems = [];

      domWalk$1(this.childNodes, function (node) {
          if (node.nodeType === 1 && (tagName === '*' || node.tagName.toLowerCase() === tagName)) {
              elems.push(node);
          }
      });

      return elems
  };

  DOMElement$2.prototype.contains = function _Element_contains(element) {
      return domWalk$1(this, function (node) {
          return element === node
      }) || false
  };

  var DOMElement$1 = domElement;

  var domFragment = DocumentFragment$1;

  function DocumentFragment$1(owner) {
      if (!(this instanceof DocumentFragment$1)) {
          return new DocumentFragment$1()
      }

      this.childNodes = [];
      this.parentNode = null;
      this.ownerDocument = owner || null;
  }

  DocumentFragment$1.prototype.type = "DocumentFragment";
  DocumentFragment$1.prototype.nodeType = 11;
  DocumentFragment$1.prototype.nodeName = "#document-fragment";

  DocumentFragment$1.prototype.appendChild  = DOMElement$1.prototype.appendChild;
  DocumentFragment$1.prototype.replaceChild = DOMElement$1.prototype.replaceChild;
  DocumentFragment$1.prototype.removeChild  = DOMElement$1.prototype.removeChild;

  DocumentFragment$1.prototype.toString =
      function _DocumentFragment_toString() {
          return this.childNodes.map(function (node) {
              return String(node)
          }).join("")
      };

  var event = Event$2;

  function Event$2(family) {}

  Event$2.prototype.initEvent = function _Event_initEvent(type, bubbles, cancelable) {
      this.type = type;
      this.bubbles = bubbles;
      this.cancelable = cancelable;
  };

  Event$2.prototype.preventDefault = function _Event_preventDefault() {
      
  };

  var domWalk = domWalk$2;

  var Comment = domComment;
  var DOMText = domText;
  var DOMElement = domElement;
  var DocumentFragment = domFragment;
  var Event$1 = event;
  var dispatchEvent = dispatchEvent_1;
  var addEventListener = addEventListener_1;
  var removeEventListener = removeEventListener_1;

  var document$3 = Document$2;

  function Document$2() {
      if (!(this instanceof Document$2)) {
          return new Document$2();
      }

      this.head = this.createElement("head");
      this.body = this.createElement("body");
      this.documentElement = this.createElement("html");
      this.documentElement.appendChild(this.head);
      this.documentElement.appendChild(this.body);
      this.childNodes = [this.documentElement];
      this.nodeType = 9;
  }

  var proto = Document$2.prototype;
  proto.createTextNode = function createTextNode(value) {
      return new DOMText(value, this)
  };

  proto.createElementNS = function createElementNS(namespace, tagName) {
      var ns = namespace === null ? null : String(namespace);
      return new DOMElement(tagName, this, ns)
  };

  proto.createElement = function createElement(tagName) {
      return new DOMElement(tagName, this)
  };

  proto.createDocumentFragment = function createDocumentFragment() {
      return new DocumentFragment(this)
  };

  proto.createEvent = function createEvent(family) {
      return new Event$1()
  };

  proto.createComment = function createComment(data) {
      return new Comment(data, this)
  };

  proto.getElementById = function getElementById(id) {
      id = String(id);

      var result = domWalk(this.childNodes, function (node) {
          if (String(node.id) === id) {
              return node
          }
      });

      return result || null
  };

  proto.getElementsByClassName = DOMElement.prototype.getElementsByClassName;
  proto.getElementsByTagName = DOMElement.prototype.getElementsByTagName;
  proto.contains = DOMElement.prototype.contains;

  proto.removeEventListener = removeEventListener;
  proto.addEventListener = addEventListener;
  proto.dispatchEvent = dispatchEvent;

  var Document$1 = document$3;

  var minDocument = new Document$1();

  var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal :
      typeof window !== 'undefined' ? window : {};
  var minDoc = minDocument;

  var doccy;

  if (typeof document !== 'undefined') {
      doccy = document;
  } else {
      doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

      if (!doccy) {
          doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
      }
  }

  var document_1 = doccy;

  var lib = {exports: {}};

  var _extends$1 = {exports: {}};

  (function (module) {
  	function _extends() {
  	  return module.exports = _extends = Object.assign ? Object.assign.bind() : function (n) {
  	    for (var e = 1; e < arguments.length; e++) {
  	      var t = arguments[e];
  	      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
  	    }
  	    return n;
  	  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends.apply(null, arguments);
  	}
  	module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports; 
  } (_extends$1));

  var _extendsExports = _extends$1.exports;

  var isFunction_1 = isFunction$1;

  var toString$1 = Object.prototype.toString;

  function isFunction$1 (fn) {
    if (!fn) {
      return false
    }
    var string = toString$1.call(fn);
    return string === '[object Function]' ||
      (typeof fn === 'function' && string !== '[object RegExp]') ||
      (typeof window !== 'undefined' &&
       // IE8 and below
       (fn === window.setTimeout ||
        fn === window.alert ||
        fn === window.confirm ||
        fn === window.prompt))
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var InterceptorsStorage$1 = /*#__PURE__*/function () {
    function InterceptorsStorage() {
      this.typeToInterceptorsMap_ = new Map();
      this.enabled_ = false;
    }

    var _proto = InterceptorsStorage.prototype;

    _proto.getIsEnabled = function getIsEnabled() {
      return this.enabled_;
    };

    _proto.enable = function enable() {
      this.enabled_ = true;
    };

    _proto.disable = function disable() {
      this.enabled_ = false;
    };

    _proto.reset = function reset() {
      this.typeToInterceptorsMap_ = new Map();
      this.enabled_ = false;
    };

    _proto.addInterceptor = function addInterceptor(type, interceptor) {
      if (!this.typeToInterceptorsMap_.has(type)) {
        this.typeToInterceptorsMap_.set(type, new Set());
      }

      var interceptorsSet = this.typeToInterceptorsMap_.get(type);

      if (interceptorsSet.has(interceptor)) {
        // already have this interceptor
        return false;
      }

      interceptorsSet.add(interceptor);
      return true;
    };

    _proto.removeInterceptor = function removeInterceptor(type, interceptor) {
      var interceptorsSet = this.typeToInterceptorsMap_.get(type);

      if (interceptorsSet && interceptorsSet.has(interceptor)) {
        interceptorsSet.delete(interceptor);
        return true;
      }

      return false;
    };

    _proto.clearInterceptorsByType = function clearInterceptorsByType(type) {
      var interceptorsSet = this.typeToInterceptorsMap_.get(type);

      if (!interceptorsSet) {
        return false;
      }

      this.typeToInterceptorsMap_.delete(type);
      this.typeToInterceptorsMap_.set(type, new Set());
      return true;
    };

    _proto.clear = function clear() {
      if (!this.typeToInterceptorsMap_.size) {
        return false;
      }

      this.typeToInterceptorsMap_ = new Map();
      return true;
    };

    _proto.getForType = function getForType(type) {
      return this.typeToInterceptorsMap_.get(type) || new Set();
    };

    _proto.execute = function execute(type, payload) {
      var interceptors = this.getForType(type);

      for (var _iterator = _createForOfIteratorHelperLoose(interceptors), _step; !(_step = _iterator()).done;) {
        var interceptor = _step.value;

        try {
          payload = interceptor(payload);
        } catch (e) {//ignore
        }
      }

      return payload;
    };

    return InterceptorsStorage;
  }();

  var interceptors = InterceptorsStorage$1;

  var RetryManager$1 = /*#__PURE__*/function () {
    function RetryManager() {
      this.maxAttempts_ = 1;
      this.delayFactor_ = 0.1;
      this.fuzzFactor_ = 0.1;
      this.initialDelay_ = 1000;
      this.enabled_ = false;
    }

    var _proto = RetryManager.prototype;

    _proto.getIsEnabled = function getIsEnabled() {
      return this.enabled_;
    };

    _proto.enable = function enable() {
      this.enabled_ = true;
    };

    _proto.disable = function disable() {
      this.enabled_ = false;
    };

    _proto.reset = function reset() {
      this.maxAttempts_ = 1;
      this.delayFactor_ = 0.1;
      this.fuzzFactor_ = 0.1;
      this.initialDelay_ = 1000;
      this.enabled_ = false;
    };

    _proto.getMaxAttempts = function getMaxAttempts() {
      return this.maxAttempts_;
    };

    _proto.setMaxAttempts = function setMaxAttempts(maxAttempts) {
      this.maxAttempts_ = maxAttempts;
    };

    _proto.getDelayFactor = function getDelayFactor() {
      return this.delayFactor_;
    };

    _proto.setDelayFactor = function setDelayFactor(delayFactor) {
      this.delayFactor_ = delayFactor;
    };

    _proto.getFuzzFactor = function getFuzzFactor() {
      return this.fuzzFactor_;
    };

    _proto.setFuzzFactor = function setFuzzFactor(fuzzFactor) {
      this.fuzzFactor_ = fuzzFactor;
    };

    _proto.getInitialDelay = function getInitialDelay() {
      return this.initialDelay_;
    };

    _proto.setInitialDelay = function setInitialDelay(initialDelay) {
      this.initialDelay_ = initialDelay;
    };

    _proto.createRetry = function createRetry(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          maxAttempts = _ref.maxAttempts,
          delayFactor = _ref.delayFactor,
          fuzzFactor = _ref.fuzzFactor,
          initialDelay = _ref.initialDelay;

      return new Retry({
        maxAttempts: maxAttempts || this.maxAttempts_,
        delayFactor: delayFactor || this.delayFactor_,
        fuzzFactor: fuzzFactor || this.fuzzFactor_,
        initialDelay: initialDelay || this.initialDelay_
      });
    };

    return RetryManager;
  }();

  var Retry = /*#__PURE__*/function () {
    function Retry(options) {
      this.maxAttempts_ = options.maxAttempts;
      this.delayFactor_ = options.delayFactor;
      this.fuzzFactor_ = options.fuzzFactor;
      this.currentDelay_ = options.initialDelay;
      this.currentAttempt_ = 1;
    }

    var _proto2 = Retry.prototype;

    _proto2.moveToNextAttempt = function moveToNextAttempt() {
      this.currentAttempt_++;
      var delayDelta = this.currentDelay_ * this.delayFactor_;
      this.currentDelay_ = this.currentDelay_ + delayDelta;
    };

    _proto2.shouldRetry = function shouldRetry() {
      return this.currentAttempt_ < this.maxAttempts_;
    };

    _proto2.getCurrentDelay = function getCurrentDelay() {
      return this.currentDelay_;
    };

    _proto2.getCurrentMinPossibleDelay = function getCurrentMinPossibleDelay() {
      return (1 - this.fuzzFactor_) * this.currentDelay_;
    };

    _proto2.getCurrentMaxPossibleDelay = function getCurrentMaxPossibleDelay() {
      return (1 + this.fuzzFactor_) * this.currentDelay_;
    }
    /**
     * For example fuzzFactor is 0.1
     * This means ±10% deviation
     * So if we have delay as 1000
     * This function can generate any value from 900 to 1100
     */
    ;

    _proto2.getCurrentFuzzedDelay = function getCurrentFuzzedDelay() {
      var lowValue = this.getCurrentMinPossibleDelay();
      var highValue = this.getCurrentMaxPossibleDelay();
      return lowValue + Math.random() * (highValue - lowValue);
    };

    return Retry;
  }();

  var retry = RetryManager$1;

  var window$4 = window_1;

  var httpResponseHandler = function httpResponseHandler(callback, decodeResponseBody) {
    if (decodeResponseBody === void 0) {
      decodeResponseBody = false;
    }

    return function (err, response, responseBody) {
      // if the XHR failed, return that error
      if (err) {
        callback(err);
        return;
      } // if the HTTP status code is 4xx or 5xx, the request also failed


      if (response.statusCode >= 400 && response.statusCode <= 599) {
        var cause = responseBody;

        if (decodeResponseBody) {
          if (window$4.TextDecoder) {
            var charset = getCharset(response.headers && response.headers['content-type']);

            try {
              cause = new TextDecoder(charset).decode(responseBody);
            } catch (e) {}
          } else {
            cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));
          }
        }

        callback({
          cause: cause
        });
        return;
      } // otherwise, request succeeded


      callback(null, responseBody);
    };
  };

  function getCharset(contentTypeHeader) {
    if (contentTypeHeader === void 0) {
      contentTypeHeader = '';
    }

    return contentTypeHeader.toLowerCase().split(';').reduce(function (charset, contentType) {
      var _contentType$split = contentType.split('='),
          type = _contentType$split[0],
          value = _contentType$split[1];

      if (type.trim() === 'charset') {
        return value.trim();
      }

      return charset;
    }, 'utf-8');
  }

  var httpHandler = httpResponseHandler;

  var window$3 = window_1;

  var _extends = _extendsExports;

  var isFunction = isFunction_1;

  var InterceptorsStorage = interceptors;

  var RetryManager = retry;

  createXHR.httpHandler = httpHandler;
  createXHR.requestInterceptorsStorage = new InterceptorsStorage();
  createXHR.responseInterceptorsStorage = new InterceptorsStorage();
  createXHR.retryManager = new RetryManager();
  /**
   * @license
   * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
   * Copyright (c) 2014 David Björklund
   * Available under the MIT license
   * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
   */

  var parseHeaders = function parseHeaders(headers) {
    var result = {};

    if (!headers) {
      return result;
    }

    headers.trim().split('\n').forEach(function (row) {
      var index = row.indexOf(':');
      var key = row.slice(0, index).trim().toLowerCase();
      var value = row.slice(index + 1).trim();

      if (typeof result[key] === 'undefined') {
        result[key] = value;
      } else if (Array.isArray(result[key])) {
        result[key].push(value);
      } else {
        result[key] = [result[key], value];
      }
    });
    return result;
  };

  lib.exports = createXHR; // Allow use of default import syntax in TypeScript

  lib.exports.default = createXHR;
  createXHR.XMLHttpRequest = window$3.XMLHttpRequest || noop;
  createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window$3.XDomainRequest;
  forEachArray(["get", "put", "post", "patch", "head", "delete"], function (method) {
    createXHR[method === "delete" ? "del" : method] = function (uri, options, callback) {
      options = initParams(uri, options, callback);
      options.method = method.toUpperCase();
      return _createXHR(options);
    };
  });

  function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
      iterator(array[i]);
    }
  }

  function isEmpty(obj) {
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) return false;
    }

    return true;
  }

  function initParams(uri, options, callback) {
    var params = uri;

    if (isFunction(options)) {
      callback = options;

      if (typeof uri === "string") {
        params = {
          uri: uri
        };
      }
    } else {
      params = _extends({}, options, {
        uri: uri
      });
    }

    params.callback = callback;
    return params;
  }

  function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback);
    return _createXHR(options);
  }

  function _createXHR(options) {
    if (typeof options.callback === "undefined") {
      throw new Error("callback argument missing");
    } // call all registered request interceptors for a given request type:


    if (options.requestType && createXHR.requestInterceptorsStorage.getIsEnabled()) {
      var requestInterceptorPayload = {
        uri: options.uri || options.url,
        headers: options.headers || {},
        body: options.body,
        metadata: options.metadata || {},
        retry: options.retry,
        timeout: options.timeout
      };
      var updatedPayload = createXHR.requestInterceptorsStorage.execute(options.requestType, requestInterceptorPayload);
      options.uri = updatedPayload.uri;
      options.headers = updatedPayload.headers;
      options.body = updatedPayload.body;
      options.metadata = updatedPayload.metadata;
      options.retry = updatedPayload.retry;
      options.timeout = updatedPayload.timeout;
    }

    var called = false;

    var callback = function cbOnce(err, response, body) {
      if (!called) {
        called = true;
        options.callback(err, response, body);
      }
    };

    function readystatechange() {
      // do not call load 2 times when response interceptors are enabled
      // why do we even need this 2nd load?
      if (xhr.readyState === 4 && !createXHR.responseInterceptorsStorage.getIsEnabled()) {
        setTimeout(loadFunc, 0);
      }
    }

    function getBody() {
      // Chrome with requestType=blob throws errors arround when even testing access to responseText
      var body = undefined;

      if (xhr.response) {
        body = xhr.response;
      } else {
        body = xhr.responseText || getXml(xhr);
      }

      if (isJson) {
        try {
          body = JSON.parse(body);
        } catch (e) {}
      }

      return body;
    }

    function errorFunc(evt) {
      clearTimeout(timeoutTimer);
      clearTimeout(options.retryTimeout);

      if (!(evt instanceof Error)) {
        evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
      }

      evt.statusCode = 0; // we would like to retry on error:

      if (!aborted && createXHR.retryManager.getIsEnabled() && options.retry && options.retry.shouldRetry()) {
        options.retryTimeout = setTimeout(function () {
          options.retry.moveToNextAttempt(); // we want to re-use the same options and the same xhr object:

          options.xhr = xhr;

          _createXHR(options);
        }, options.retry.getCurrentFuzzedDelay());
        return;
      } // call all registered response interceptors for a given request type:


      if (options.requestType && createXHR.responseInterceptorsStorage.getIsEnabled()) {
        var responseInterceptorPayload = {
          headers: failureResponse.headers || {},
          body: failureResponse.body,
          responseUrl: xhr.responseURL,
          responseType: xhr.responseType
        };

        var _updatedPayload = createXHR.responseInterceptorsStorage.execute(options.requestType, responseInterceptorPayload);

        failureResponse.body = _updatedPayload.body;
        failureResponse.headers = _updatedPayload.headers;
      }

      return callback(evt, failureResponse);
    } // will load the data & process the response in a special response object


    function loadFunc() {
      if (aborted) return;
      var status;
      clearTimeout(timeoutTimer);
      clearTimeout(options.retryTimeout);

      if (options.useXDR && xhr.status === undefined) {
        //IE8 CORS GET successful response doesn't have a status field, but body is fine
        status = 200;
      } else {
        status = xhr.status === 1223 ? 204 : xhr.status;
      }

      var response = failureResponse;
      var err = null;

      if (status !== 0) {
        response = {
          body: getBody(),
          statusCode: status,
          method: method,
          headers: {},
          url: uri,
          rawRequest: xhr
        };

        if (xhr.getAllResponseHeaders) {
          //remember xhr can in fact be XDR for CORS in IE
          response.headers = parseHeaders(xhr.getAllResponseHeaders());
        }
      } else {
        err = new Error("Internal XMLHttpRequest Error");
      } // call all registered response interceptors for a given request type:


      if (options.requestType && createXHR.responseInterceptorsStorage.getIsEnabled()) {
        var responseInterceptorPayload = {
          headers: response.headers || {},
          body: response.body,
          responseUrl: xhr.responseURL,
          responseType: xhr.responseType
        };

        var _updatedPayload2 = createXHR.responseInterceptorsStorage.execute(options.requestType, responseInterceptorPayload);

        response.body = _updatedPayload2.body;
        response.headers = _updatedPayload2.headers;
      }

      return callback(err, response, response.body);
    }

    var xhr = options.xhr || null;

    if (!xhr) {
      if (options.cors || options.useXDR) {
        xhr = new createXHR.XDomainRequest();
      } else {
        xhr = new createXHR.XMLHttpRequest();
      }
    }

    var key;
    var aborted;
    var uri = xhr.url = options.uri || options.url;
    var method = xhr.method = options.method || "GET";
    var body = options.body || options.data;
    var headers = xhr.headers = options.headers || {};
    var sync = !!options.sync;
    var isJson = false;
    var timeoutTimer;
    var failureResponse = {
      body: undefined,
      headers: {},
      statusCode: 0,
      method: method,
      url: uri,
      rawRequest: xhr
    };

    if ("json" in options && options.json !== false) {
      isJson = true;
      headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json"); //Don't override existing accept header declared by user

      if (method !== "GET" && method !== "HEAD") {
        headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"); //Don't override existing accept header declared by user

        body = JSON.stringify(options.json === true ? body : options.json);
      }
    }

    xhr.onreadystatechange = readystatechange;
    xhr.onload = loadFunc;
    xhr.onerror = errorFunc; // IE9 must have onprogress be set to a unique function.

    xhr.onprogress = function () {// IE must die
    };

    xhr.onabort = function () {
      aborted = true;
      clearTimeout(options.retryTimeout);
    };

    xhr.ontimeout = errorFunc;
    xhr.open(method, uri, !sync, options.username, options.password); //has to be after open

    if (!sync) {
      xhr.withCredentials = !!options.withCredentials;
    } // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent


    if (!sync && options.timeout > 0) {
      timeoutTimer = setTimeout(function () {
        if (aborted) return;
        aborted = true; //IE9 may still call readystatechange

        xhr.abort("timeout");
        var e = new Error("XMLHttpRequest timeout");
        e.code = "ETIMEDOUT";
        errorFunc(e);
      }, options.timeout);
    }

    if (xhr.setRequestHeader) {
      for (key in headers) {
        if (headers.hasOwnProperty(key)) {
          xhr.setRequestHeader(key, headers[key]);
        }
      }
    } else if (options.headers && !isEmpty(options.headers)) {
      throw new Error("Headers cannot be set on an XDomainRequest object");
    }

    if ("responseType" in options) {
      xhr.responseType = options.responseType;
    }

    if ("beforeSend" in options && typeof options.beforeSend === "function") {
      options.beforeSend(xhr);
    } // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.


    xhr.send(body || null);
    return xhr;
  }

  function getXml(xhr) {
    // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
    try {
      if (xhr.responseType === "document") {
        return xhr.responseXML;
      }

      var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";

      if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML;
      }
    } catch (e) {}

    return null;
  }

  function noop() {}

  var libExports = lib.exports;

  var browserIndex = {exports: {}};

  /**
   * Copyright 2013 vtt.js Contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
  /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
  var document$2 = document_1;

  var _objCreate = Object.create || (function() {
    function F() {}
    return function(o) {
      if (arguments.length !== 1) {
        throw new Error('Object.create shim only accepts one parameter.');
      }
      F.prototype = o;
      return new F();
    };
  })();

  // Creates a new ParserError object from an errorData object. The errorData
  // object should have default code and message properties. The default message
  // property can be overriden by passing in a message parameter.
  // See ParsingError.Errors below for acceptable errors.
  function ParsingError(errorData, message) {
    this.name = "ParsingError";
    this.code = errorData.code;
    this.message = message || errorData.message;
  }
  ParsingError.prototype = _objCreate(Error.prototype);
  ParsingError.prototype.constructor = ParsingError;

  // ParsingError metadata for acceptable ParsingErrors.
  ParsingError.Errors = {
    BadSignature: {
      code: 0,
      message: "Malformed WebVTT signature."
    },
    BadTimeStamp: {
      code: 1,
      message: "Malformed time stamp."
    }
  };

  // Try to parse input as a time stamp.
  function parseTimeStamp(input) {

    function computeSeconds(h, m, s, f) {
      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
    }

    var m = input.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
    if (!m) {
      return null;
    }

    if (m[3]) {
      // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
      return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
    } else if (m[1] > 59) {
      // Timestamp takes the form of [hours]:[minutes].[milliseconds]
      // First position is hours as it's over 59.
      return computeSeconds(m[1], m[2], 0,  m[4]);
    } else {
      // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
      return computeSeconds(0, m[1], m[2], m[4]);
    }
  }

  // A settings object holds key/value pairs and will ignore anything but the first
  // assignment to a specific key.
  function Settings() {
    this.values = _objCreate(null);
  }

  Settings.prototype = {
    // Only accept the first assignment to any key.
    set: function(k, v) {
      if (!this.get(k) && v !== "") {
        this.values[k] = v;
      }
    },
    // Return the value for a key, or a default value.
    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
    // a number of possible default values as properties where 'defaultKey' is
    // the key of the property that will be chosen; otherwise it's assumed to be
    // a single value.
    get: function(k, dflt, defaultKey) {
      if (defaultKey) {
        return this.has(k) ? this.values[k] : dflt[defaultKey];
      }
      return this.has(k) ? this.values[k] : dflt;
    },
    // Check whether we have a value for a key.
    has: function(k) {
      return k in this.values;
    },
    // Accept a setting if its one of the given alternatives.
    alt: function(k, v, a) {
      for (var n = 0; n < a.length; ++n) {
        if (v === a[n]) {
          this.set(k, v);
          break;
        }
      }
    },
    // Accept a setting if its a valid (signed) integer.
    integer: function(k, v) {
      if (/^-?\d+$/.test(v)) { // integer
        this.set(k, parseInt(v, 10));
      }
    },
    // Accept a setting if its a valid percentage.
    percent: function(k, v) {
      if ((v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
        v = parseFloat(v);
        if (v >= 0 && v <= 100) {
          this.set(k, v);
          return true;
        }
      }
      return false;
    }
  };

  // Helper function to parse input into groups separated by 'groupDelim', and
  // interprete each group as a key/value pair separated by 'keyValueDelim'.
  function parseOptions(input, callback, keyValueDelim, groupDelim) {
    var groups = groupDelim ? input.split(groupDelim) : [input];
    for (var i in groups) {
      if (typeof groups[i] !== "string") {
        continue;
      }
      var kv = groups[i].split(keyValueDelim);
      if (kv.length !== 2) {
        continue;
      }
      var k = kv[0].trim();
      var v = kv[1].trim();
      callback(k, v);
    }
  }

  function parseCue(input, cue, regionList) {
    // Remember the original input if we need to throw an error.
    var oInput = input;
    // 4.1 WebVTT timestamp
    function consumeTimeStamp() {
      var ts = parseTimeStamp(input);
      if (ts === null) {
        throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                              "Malformed timestamp: " + oInput);
      }
      // Remove time stamp from input.
      input = input.replace(/^[^\sa-zA-Z-]+/, "");
      return ts;
    }

    // 4.4.2 WebVTT cue settings
    function consumeCueSettings(input, cue) {
      var settings = new Settings();

      parseOptions(input, function (k, v) {
        switch (k) {
        case "region":
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case "vertical":
          settings.alt(k, v, ["rl", "lr"]);
          break;
        case "line":
          var vals = v.split(","),
              vals0 = vals[0];
          settings.integer(k, vals0);
          settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
          settings.alt(k, vals0, ["auto"]);
          if (vals.length === 2) {
            settings.alt("lineAlign", vals[1], ["start", "center", "end"]);
          }
          break;
        case "position":
          vals = v.split(",");
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt("positionAlign", vals[1], ["start", "center", "end"]);
          }
          break;
        case "size":
          settings.percent(k, v);
          break;
        case "align":
          settings.alt(k, v, ["start", "center", "end", "left", "right"]);
          break;
        }
      }, /:/, /\s/);

      // Apply default values for any missing fields.
      cue.region = settings.get("region", null);
      cue.vertical = settings.get("vertical", "");
      try {
        cue.line = settings.get("line", "auto");
      } catch (e) {}
      cue.lineAlign = settings.get("lineAlign", "start");
      cue.snapToLines = settings.get("snapToLines", true);
      cue.size = settings.get("size", 100);
      // Safari still uses the old middle value and won't accept center
      try {
        cue.align = settings.get("align", "center");
      } catch (e) {
        cue.align = settings.get("align", "middle");
      }
      try {
        cue.position = settings.get("position", "auto");
      } catch (e) {
        cue.position = settings.get("position", {
          start: 0,
          left: 0,
          center: 50,
          middle: 50,
          end: 100,
          right: 100
        }, cue.align);
      }


      cue.positionAlign = settings.get("positionAlign", {
        start: "start",
        left: "start",
        center: "center",
        middle: "center",
        end: "end",
        right: "end"
      }, cue.align);
    }

    function skipWhitespace() {
      input = input.replace(/^\s+/, "");
    }

    // 4.1 WebVTT cue timings.
    skipWhitespace();
    cue.startTime = consumeTimeStamp();   // (1) collect cue start time
    skipWhitespace();
    if (input.substr(0, 3) !== "-->") {     // (3) next characters must match "-->"
      throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                             "Malformed time stamp (time stamps must be separated by '-->'): " +
                             oInput);
    }
    input = input.substr(3);
    skipWhitespace();
    cue.endTime = consumeTimeStamp();     // (5) collect cue end time

    // 4.1 WebVTT cue settings list.
    skipWhitespace();
    consumeCueSettings(input, cue);
  }

  // When evaluating this file as part of a Webpack bundle for server
  // side rendering, `document` is an empty object.
  var TEXTAREA_ELEMENT = document$2.createElement && document$2.createElement("textarea");

  var TAG_NAME = {
    c: "span",
    i: "i",
    b: "b",
    u: "u",
    ruby: "ruby",
    rt: "rt",
    v: "span",
    lang: "span"
  };

  // 5.1 default text color
  // 5.2 default text background color is equivalent to text color with bg_ prefix
  var DEFAULT_COLOR_CLASS = {
    white: 'rgba(255,255,255,1)',
    lime: 'rgba(0,255,0,1)',
    cyan: 'rgba(0,255,255,1)',
    red: 'rgba(255,0,0,1)',
    yellow: 'rgba(255,255,0,1)',
    magenta: 'rgba(255,0,255,1)',
    blue: 'rgba(0,0,255,1)',
    black: 'rgba(0,0,0,1)'
  };

  var TAG_ANNOTATION = {
    v: "title",
    lang: "lang"
  };

  var NEEDS_PARENT = {
    rt: "ruby"
  };

  // Parse content into a document fragment.
  function parseContent(window, input) {
    function nextToken() {
      // Check for end-of-string.
      if (!input) {
        return null;
      }

      // Consume 'n' characters from the input.
      function consume(result) {
        input = input.substr(result.length);
        return result;
      }

      var m = input.match(/^([^<]*)(<[^>]*>?)?/);
      // If there is some text before the next tag, return it, otherwise return
      // the tag.
      return consume(m[1] ? m[1] : m[2]);
    }

    function unescape(s) {
      TEXTAREA_ELEMENT.innerHTML = s;
      s = TEXTAREA_ELEMENT.textContent;
      TEXTAREA_ELEMENT.textContent = "";
      return s;
    }

    function shouldAdd(current, element) {
      return !NEEDS_PARENT[element.localName] ||
             NEEDS_PARENT[element.localName] === current.localName;
    }

    // Create an element for this tag.
    function createElement(type, annotation) {
      var tagName = TAG_NAME[type];
      if (!tagName) {
        return null;
      }
      var element = window.document.createElement(tagName);
      var name = TAG_ANNOTATION[type];
      if (name && annotation) {
        element[name] = annotation.trim();
      }
      return element;
    }

    var rootDiv = window.document.createElement("div"),
        current = rootDiv,
        t,
        tagStack = [];

    while ((t = nextToken()) !== null) {
      if (t[0] === '<') {
        if (t[1] === "/") {
          // If the closing tag matches, move back up to the parent node.
          if (tagStack.length &&
              tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
            tagStack.pop();
            current = current.parentNode;
          }
          // Otherwise just ignore the end tag.
          continue;
        }
        var ts = parseTimeStamp(t.substr(1, t.length - 2));
        var node;
        if (ts) {
          // Timestamps are lead nodes as well.
          node = window.document.createProcessingInstruction("timestamp", ts);
          current.appendChild(node);
          continue;
        }
        var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
        // If we can't parse the tag, skip to the next tag.
        if (!m) {
          continue;
        }
        // Try to construct an element, and ignore the tag if we couldn't.
        node = createElement(m[1], m[3]);
        if (!node) {
          continue;
        }
        // Determine if the tag should be added based on the context of where it
        // is placed in the cuetext.
        if (!shouldAdd(current, node)) {
          continue;
        }
        // Set the class list (as a list of classes, separated by space).
        if (m[2]) {
          var classes = m[2].split('.');

          classes.forEach(function(cl) {
            var bgColor = /^bg_/.test(cl);
            // slice out `bg_` if it's a background color
            var colorName = bgColor ? cl.slice(3) : cl;

            if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {
              var propName = bgColor ? 'background-color' : 'color';
              var propValue = DEFAULT_COLOR_CLASS[colorName];

              node.style[propName] = propValue;
            }
          });

          node.className = classes.join(' ');
        }
        // Append the node to the current node, and enter the scope of the new
        // node.
        tagStack.push(m[1]);
        current.appendChild(node);
        current = node;
        continue;
      }

      // Text nodes are leaf nodes.
      current.appendChild(window.document.createTextNode(unescape(t)));
    }

    return rootDiv;
  }

  // This is a list of all the Unicode characters that have a strong
  // right-to-left category. What this means is that these characters are
  // written right-to-left for sure. It was generated by pulling all the strong
  // right-to-left characters out of the Unicode data table. That table can
  // found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
  var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6],
   [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d],
   [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6],
   [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5],
   [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815],
   [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858],
   [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f],
   [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c],
   [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1],
   [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc],
   [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808],
   [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855],
   [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f],
   [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13],
   [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58],
   [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72],
   [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f],
   [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32],
   [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42],
   [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f],
   [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59],
   [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62],
   [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77],
   [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b],
   [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];

  function isStrongRTLChar(charCode) {
    for (var i = 0; i < strongRTLRanges.length; i++) {
      var currentRange = strongRTLRanges[i];
      if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
        return true;
      }
    }

    return false;
  }

  function determineBidi(cueDiv) {
    var nodeStack = [],
        text = "",
        charCode;

    if (!cueDiv || !cueDiv.childNodes) {
      return "ltr";
    }

    function pushNodes(nodeStack, node) {
      for (var i = node.childNodes.length - 1; i >= 0; i--) {
        nodeStack.push(node.childNodes[i]);
      }
    }

    function nextTextNode(nodeStack) {
      if (!nodeStack || !nodeStack.length) {
        return null;
      }

      var node = nodeStack.pop(),
          text = node.textContent || node.innerText;
      if (text) {
        // TODO: This should match all unicode type B characters (paragraph
        // separator characters). See issue #115.
        var m = text.match(/^.*(\n|\r)/);
        if (m) {
          nodeStack.length = 0;
          return m[0];
        }
        return text;
      }
      if (node.tagName === "ruby") {
        return nextTextNode(nodeStack);
      }
      if (node.childNodes) {
        pushNodes(nodeStack, node);
        return nextTextNode(nodeStack);
      }
    }

    pushNodes(nodeStack, cueDiv);
    while ((text = nextTextNode(nodeStack))) {
      for (var i = 0; i < text.length; i++) {
        charCode = text.charCodeAt(i);
        if (isStrongRTLChar(charCode)) {
          return "rtl";
        }
      }
    }
    return "ltr";
  }

  function computeLinePos(cue) {
    if (typeof cue.line === "number" &&
        (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {
      return cue.line;
    }
    if (!cue.track || !cue.track.textTrackList ||
        !cue.track.textTrackList.mediaElement) {
      return -1;
    }
    var track = cue.track,
        trackList = track.textTrackList,
        count = 0;
    for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
      if (trackList[i].mode === "showing") {
        count++;
      }
    }
    return ++count * -1;
  }

  function StyleBox() {
  }

  // Apply styles to a div. If there is no div passed then it defaults to the
  // div on 'this'.
  StyleBox.prototype.applyStyles = function(styles, div) {
    div = div || this.div;
    for (var prop in styles) {
      if (styles.hasOwnProperty(prop)) {
        div.style[prop] = styles[prop];
      }
    }
  };

  StyleBox.prototype.formatStyle = function(val, unit) {
    return val === 0 ? 0 : val + unit;
  };

  // Constructs the computed display state of the cue (a div). Places the div
  // into the overlay which should be a block level element (usually a div).
  function CueStyleBox(window, cue, styleOptions) {
    StyleBox.call(this);
    this.cue = cue;

    // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will
    // have inline positioning and will function as the cue background box.
    this.cueDiv = parseContent(window, cue.text);
    var styles = {
      color: "rgba(255, 255, 255, 1)",
      backgroundColor:  "rgba(0, 0, 0, 0.8)",
      position: "relative",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      display: "inline",
      writingMode: cue.vertical === "" ? "horizontal-tb"
                                       : cue.vertical === "lr" ? "vertical-lr"
                                                               : "vertical-rl",
      unicodeBidi: "plaintext"
    };

    this.applyStyles(styles, this.cueDiv);

    // Create an absolutely positioned div that will be used to position the cue
    // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS
    // mirrors of them except middle instead of center on Safari.
    this.div = window.document.createElement("div");
    styles = {
      direction: determineBidi(this.cueDiv),
      writingMode: cue.vertical === "" ? "horizontal-tb"
                                       : cue.vertical === "lr" ? "vertical-lr"
                                                               : "vertical-rl",
      unicodeBidi: "plaintext",
      textAlign: cue.align === "middle" ? "center" : cue.align,
      font: styleOptions.font,
      whiteSpace: "pre-line",
      position: "absolute"
    };

    this.applyStyles(styles);
    this.div.appendChild(this.cueDiv);

    // Calculate the distance from the reference edge of the viewport to the text
    // position of the cue box. The reference edge will be resolved later when
    // the box orientation styles are applied.
    var textPos = 0;
    switch (cue.positionAlign) {
    case "start":
    case "line-left":
      textPos = cue.position;
      break;
    case "center":
      textPos = cue.position - (cue.size / 2);
      break;
    case "end":
    case "line-right":
      textPos = cue.position - cue.size;
      break;
    }

    // Horizontal box orientation; textPos is the distance from the left edge of the
    // area to the left edge of the box and cue.size is the distance extending to
    // the right from there.
    if (cue.vertical === "") {
      this.applyStyles({
        left:  this.formatStyle(textPos, "%"),
        width: this.formatStyle(cue.size, "%")
      });
    // Vertical box orientation; textPos is the distance from the top edge of the
    // area to the top edge of the box and cue.size is the height extending
    // downwards from there.
    } else {
      this.applyStyles({
        top: this.formatStyle(textPos, "%"),
        height: this.formatStyle(cue.size, "%")
      });
    }

    this.move = function(box) {
      this.applyStyles({
        top: this.formatStyle(box.top, "px"),
        bottom: this.formatStyle(box.bottom, "px"),
        left: this.formatStyle(box.left, "px"),
        right: this.formatStyle(box.right, "px"),
        height: this.formatStyle(box.height, "px"),
        width: this.formatStyle(box.width, "px")
      });
    };
  }
  CueStyleBox.prototype = _objCreate(StyleBox.prototype);
  CueStyleBox.prototype.constructor = CueStyleBox;

  // Represents the co-ordinates of an Element in a way that we can easily
  // compute things with such as if it overlaps or intersects with another Element.
  // Can initialize it with either a StyleBox or another BoxPosition.
  function BoxPosition(obj) {
    // Either a BoxPosition was passed in and we need to copy it, or a StyleBox
    // was passed in and we need to copy the results of 'getBoundingClientRect'
    // as the object returned is readonly. All co-ordinate values are in reference
    // to the viewport origin (top left).
    var lh, height, width, top;
    if (obj.div) {
      height = obj.div.offsetHeight;
      width = obj.div.offsetWidth;
      top = obj.div.offsetTop;

      var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&
                  rects.getClientRects && rects.getClientRects();
      obj = obj.div.getBoundingClientRect();
      // In certain cases the outter div will be slightly larger then the sum of
      // the inner div's lines. This could be due to bold text, etc, on some platforms.
      // In this case we should get the average line height and use that. This will
      // result in the desired behaviour.
      lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)
                 : 0;

    }
    this.left = obj.left;
    this.right = obj.right;
    this.top = obj.top || top;
    this.height = obj.height || height;
    this.bottom = obj.bottom || (top + (obj.height || height));
    this.width = obj.width || width;
    this.lineHeight = lh !== undefined ? lh : obj.lineHeight;
  }

  // Move the box along a particular axis. Optionally pass in an amount to move
  // the box. If no amount is passed then the default is the line height of the
  // box.
  BoxPosition.prototype.move = function(axis, toMove) {
    toMove = toMove !== undefined ? toMove : this.lineHeight;
    switch (axis) {
    case "+x":
      this.left += toMove;
      this.right += toMove;
      break;
    case "-x":
      this.left -= toMove;
      this.right -= toMove;
      break;
    case "+y":
      this.top += toMove;
      this.bottom += toMove;
      break;
    case "-y":
      this.top -= toMove;
      this.bottom -= toMove;
      break;
    }
  };

  // Check if this box overlaps another box, b2.
  BoxPosition.prototype.overlaps = function(b2) {
    return this.left < b2.right &&
           this.right > b2.left &&
           this.top < b2.bottom &&
           this.bottom > b2.top;
  };

  // Check if this box overlaps any other boxes in boxes.
  BoxPosition.prototype.overlapsAny = function(boxes) {
    for (var i = 0; i < boxes.length; i++) {
      if (this.overlaps(boxes[i])) {
        return true;
      }
    }
    return false;
  };

  // Check if this box is within another box.
  BoxPosition.prototype.within = function(container) {
    return this.top >= container.top &&
           this.bottom <= container.bottom &&
           this.left >= container.left &&
           this.right <= container.right;
  };

  // Check if this box is entirely within the container or it is overlapping
  // on the edge opposite of the axis direction passed. For example, if "+x" is
  // passed and the box is overlapping on the left edge of the container, then
  // return true.
  BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
    switch (axis) {
    case "+x":
      return this.left < container.left;
    case "-x":
      return this.right > container.right;
    case "+y":
      return this.top < container.top;
    case "-y":
      return this.bottom > container.bottom;
    }
  };

  // Find the percentage of the area that this box is overlapping with another
  // box.
  BoxPosition.prototype.intersectPercentage = function(b2) {
    var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),
        y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),
        intersectArea = x * y;
    return intersectArea / (this.height * this.width);
  };

  // Convert the positions from this box to CSS compatible positions using
  // the reference container's positions. This has to be done because this
  // box's positions are in reference to the viewport origin, whereas, CSS
  // values are in referecne to their respective edges.
  BoxPosition.prototype.toCSSCompatValues = function(reference) {
    return {
      top: this.top - reference.top,
      bottom: reference.bottom - this.bottom,
      left: this.left - reference.left,
      right: reference.right - this.right,
      height: this.height,
      width: this.width
    };
  };

  // Get an object that represents the box's position without anything extra.
  // Can pass a StyleBox, HTMLElement, or another BoxPositon.
  BoxPosition.getSimpleBoxPosition = function(obj) {
    var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
    var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
    var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;

    obj = obj.div ? obj.div.getBoundingClientRect() :
                  obj.tagName ? obj.getBoundingClientRect() : obj;
    var ret = {
      left: obj.left,
      right: obj.right,
      top: obj.top || top,
      height: obj.height || height,
      bottom: obj.bottom || (top + (obj.height || height)),
      width: obj.width || width
    };
    return ret;
  };

  // Move a StyleBox to its specified, or next best, position. The containerBox
  // is the box that contains the StyleBox, such as a div. boxPositions are
  // a list of other boxes that the styleBox can't overlap with.
  function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {

    // Find the best position for a cue box, b, on the video. The axis parameter
    // is a list of axis, the order of which, it will move the box along. For example:
    // Passing ["+x", "-x"] will move the box first along the x axis in the positive
    // direction. If it doesn't find a good position for it there it will then move
    // it along the x axis in the negative direction.
    function findBestPosition(b, axis) {
      var bestPosition,
          specifiedPosition = new BoxPosition(b),
          percentage = 1; // Highest possible so the first thing we get is better.

      for (var i = 0; i < axis.length; i++) {
        while (b.overlapsOppositeAxis(containerBox, axis[i]) ||
               (b.within(containerBox) && b.overlapsAny(boxPositions))) {
          b.move(axis[i]);
        }
        // We found a spot where we aren't overlapping anything. This is our
        // best position.
        if (b.within(containerBox)) {
          return b;
        }
        var p = b.intersectPercentage(containerBox);
        // If we're outside the container box less then we were on our last try
        // then remember this position as the best position.
        if (percentage > p) {
          bestPosition = new BoxPosition(b);
          percentage = p;
        }
        // Reset the box position to the specified position.
        b = new BoxPosition(specifiedPosition);
      }
      return bestPosition || specifiedPosition;
    }

    var boxPosition = new BoxPosition(styleBox),
        cue = styleBox.cue,
        linePos = computeLinePos(cue),
        axis = [];

    // If we have a line number to align the cue to.
    if (cue.snapToLines) {
      var size;
      switch (cue.vertical) {
      case "":
        axis = [ "+y", "-y" ];
        size = "height";
        break;
      case "rl":
        axis = [ "+x", "-x" ];
        size = "width";
        break;
      case "lr":
        axis = [ "-x", "+x" ];
        size = "width";
        break;
      }

      var step = boxPosition.lineHeight,
          position = step * Math.round(linePos),
          maxPosition = containerBox[size] + step,
          initialAxis = axis[0];

      // If the specified intial position is greater then the max position then
      // clamp the box to the amount of steps it would take for the box to
      // reach the max position.
      if (Math.abs(position) > maxPosition) {
        position = position < 0 ? -1 : 1;
        position *= Math.ceil(maxPosition / step) * step;
      }

      // If computed line position returns negative then line numbers are
      // relative to the bottom of the video instead of the top. Therefore, we
      // need to increase our initial position by the length or width of the
      // video, depending on the writing direction, and reverse our axis directions.
      if (linePos < 0) {
        position += cue.vertical === "" ? containerBox.height : containerBox.width;
        axis = axis.reverse();
      }

      // Move the box to the specified position. This may not be its best
      // position.
      boxPosition.move(initialAxis, position);

    } else {
      // If we have a percentage line value for the cue.
      var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;

      switch (cue.lineAlign) {
      case "center":
        linePos -= (calculatedPercentage / 2);
        break;
      case "end":
        linePos -= calculatedPercentage;
        break;
      }

      // Apply initial line position to the cue box.
      switch (cue.vertical) {
      case "":
        styleBox.applyStyles({
          top: styleBox.formatStyle(linePos, "%")
        });
        break;
      case "rl":
        styleBox.applyStyles({
          left: styleBox.formatStyle(linePos, "%")
        });
        break;
      case "lr":
        styleBox.applyStyles({
          right: styleBox.formatStyle(linePos, "%")
        });
        break;
      }

      axis = [ "+y", "-x", "+x", "-y" ];

      // Get the box position again after we've applied the specified positioning
      // to it.
      boxPosition = new BoxPosition(styleBox);
    }

    var bestPosition = findBestPosition(boxPosition, axis);
    styleBox.move(bestPosition.toCSSCompatValues(containerBox));
  }

  function WebVTT$1() {
    // Nothing
  }

  // Helper to allow strings to be decoded instead of the default binary utf8 data.
  WebVTT$1.StringDecoder = function() {
    return {
      decode: function(data) {
        if (!data) {
          return "";
        }
        if (typeof data !== "string") {
          throw new Error("Error - expected string data.");
        }
        return decodeURIComponent(encodeURIComponent(data));
      }
    };
  };

  WebVTT$1.convertCueToDOMTree = function(window, cuetext) {
    if (!window || !cuetext) {
      return null;
    }
    return parseContent(window, cuetext);
  };

  var FONT_SIZE_PERCENT = 0.05;
  var FONT_STYLE = "sans-serif";
  var CUE_BACKGROUND_PADDING = "1.5%";

  // Runs the processing model over the cues and regions passed to it.
  // @param overlay A block level element (usually a div) that the computed cues
  //                and regions will be placed into.
  WebVTT$1.processCues = function(window, cues, overlay) {
    if (!window || !cues || !overlay) {
      return null;
    }

    // Remove all previous children.
    while (overlay.firstChild) {
      overlay.removeChild(overlay.firstChild);
    }

    var paddedOverlay = window.document.createElement("div");
    paddedOverlay.style.position = "absolute";
    paddedOverlay.style.left = "0";
    paddedOverlay.style.right = "0";
    paddedOverlay.style.top = "0";
    paddedOverlay.style.bottom = "0";
    paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
    overlay.appendChild(paddedOverlay);

    // Determine if we need to compute the display states of the cues. This could
    // be the case if a cue's state has been changed since the last computation or
    // if it has not been computed yet.
    function shouldCompute(cues) {
      for (var i = 0; i < cues.length; i++) {
        if (cues[i].hasBeenReset || !cues[i].displayState) {
          return true;
        }
      }
      return false;
    }

    // We don't need to recompute the cues' display states. Just reuse them.
    if (!shouldCompute(cues)) {
      for (var i = 0; i < cues.length; i++) {
        paddedOverlay.appendChild(cues[i].displayState);
      }
      return;
    }

    var boxPositions = [],
        containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),
        fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
    var styleOptions = {
      font: fontSize + "px " + FONT_STYLE
    };

    (function() {
      var styleBox, cue;

      for (var i = 0; i < cues.length; i++) {
        cue = cues[i];

        // Compute the intial position and styles of the cue div.
        styleBox = new CueStyleBox(window, cue, styleOptions);
        paddedOverlay.appendChild(styleBox.div);

        // Move the cue div to it's correct line position.
        moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);

        // Remember the computed div so that we don't have to recompute it later
        // if we don't have too.
        cue.displayState = styleBox.div;

        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
      }
    })();
  };

  WebVTT$1.Parser = function(window, vttjs, decoder) {
    if (!decoder) {
      decoder = vttjs;
      vttjs = {};
    }
    if (!vttjs) {
      vttjs = {};
    }

    this.window = window;
    this.vttjs = vttjs;
    this.state = "INITIAL";
    this.buffer = "";
    this.decoder = decoder || new TextDecoder("utf8");
    this.regionList = [];
  };

  WebVTT$1.Parser.prototype = {
    // If the error is a ParsingError then report it to the consumer if
    // possible. If it's not a ParsingError then throw it like normal.
    reportOrThrowError: function(e) {
      if (e instanceof ParsingError) {
        this.onparsingerror && this.onparsingerror(e);
      } else {
        throw e;
      }
    },
    parse: function (data) {
      var self = this;

      // If there is no data then we won't decode it, but will just try to parse
      // whatever is in buffer already. This may occur in circumstances, for
      // example when flush() is called.
      if (data) {
        // Try to decode the data that we received.
        self.buffer += self.decoder.decode(data, {stream: true});
      }

      function collectNextLine() {
        var buffer = self.buffer;
        var pos = 0;
        while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
          ++pos;
        }
        var line = buffer.substr(0, pos);
        // Advance the buffer early in case we fail below.
        if (buffer[pos] === '\r') {
          ++pos;
        }
        if (buffer[pos] === '\n') {
          ++pos;
        }
        self.buffer = buffer.substr(pos);
        return line;
      }

      // 3.4 WebVTT region and WebVTT region settings syntax
      function parseRegion(input) {
        var settings = new Settings();

        parseOptions(input, function (k, v) {
          switch (k) {
          case "id":
            settings.set(k, v);
            break;
          case "width":
            settings.percent(k, v);
            break;
          case "lines":
            settings.integer(k, v);
            break;
          case "regionanchor":
          case "viewportanchor":
            var xy = v.split(',');
            if (xy.length !== 2) {
              break;
            }
            // We have to make sure both x and y parse, so use a temporary
            // settings object here.
            var anchor = new Settings();
            anchor.percent("x", xy[0]);
            anchor.percent("y", xy[1]);
            if (!anchor.has("x") || !anchor.has("y")) {
              break;
            }
            settings.set(k + "X", anchor.get("x"));
            settings.set(k + "Y", anchor.get("y"));
            break;
          case "scroll":
            settings.alt(k, v, ["up"]);
            break;
          }
        }, /=/, /\s/);

        // Create the region, using default values for any values that were not
        // specified.
        if (settings.has("id")) {
          var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();
          region.width = settings.get("width", 100);
          region.lines = settings.get("lines", 3);
          region.regionAnchorX = settings.get("regionanchorX", 0);
          region.regionAnchorY = settings.get("regionanchorY", 100);
          region.viewportAnchorX = settings.get("viewportanchorX", 0);
          region.viewportAnchorY = settings.get("viewportanchorY", 100);
          region.scroll = settings.get("scroll", "");
          // Register the region.
          self.onregion && self.onregion(region);
          // Remember the VTTRegion for later in case we parse any VTTCues that
          // reference it.
          self.regionList.push({
            id: settings.get("id"),
            region: region
          });
        }
      }

      // draft-pantos-http-live-streaming-20
      // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5
      // 3.5 WebVTT
      function parseTimestampMap(input) {
        var settings = new Settings();

        parseOptions(input, function(k, v) {
          switch(k) {
          case "MPEGT":
            settings.integer(k + 'S', v);
            break;
          case "LOCA":
            settings.set(k + 'L', parseTimeStamp(v));
            break;
          }
        }, /[^\d]:/, /,/);

        self.ontimestampmap && self.ontimestampmap({
          "MPEGTS": settings.get("MPEGTS"),
          "LOCAL": settings.get("LOCAL")
        });
      }

      // 3.2 WebVTT metadata header syntax
      function parseHeader(input) {
        if (input.match(/X-TIMESTAMP-MAP/)) {
          // This line contains HLS X-TIMESTAMP-MAP metadata
          parseOptions(input, function(k, v) {
            switch(k) {
            case "X-TIMESTAMP-MAP":
              parseTimestampMap(v);
              break;
            }
          }, /=/);
        } else {
          parseOptions(input, function (k, v) {
            switch (k) {
            case "Region":
              // 3.3 WebVTT region metadata header syntax
              parseRegion(v);
              break;
            }
          }, /:/);
        }

      }

      // 5.1 WebVTT file parsing.
      try {
        var line;
        if (self.state === "INITIAL") {
          // We can't start parsing until we have the first line.
          if (!/\r\n|\n/.test(self.buffer)) {
            return this;
          }

          line = collectNextLine();

          var m = line.match(/^WEBVTT([ \t].*)?$/);
          if (!m || !m[0]) {
            throw new ParsingError(ParsingError.Errors.BadSignature);
          }

          self.state = "HEADER";
        }

        var alreadyCollectedLine = false;
        while (self.buffer) {
          // We can't parse a line until we have the full line.
          if (!/\r\n|\n/.test(self.buffer)) {
            return this;
          }

          if (!alreadyCollectedLine) {
            line = collectNextLine();
          } else {
            alreadyCollectedLine = false;
          }

          switch (self.state) {
          case "HEADER":
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = "ID";
            }
            continue;
          case "NOTE":
            // Ignore NOTE blocks.
            if (!line) {
              self.state = "ID";
            }
            continue;
          case "ID":
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = "NOTE";
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }
            self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
            // Safari still uses the old middle value and won't accept center
            try {
              self.cue.align = "center";
            } catch (e) {
              self.cue.align = "middle";
            }
            self.state = "CUE";
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf("-->") === -1) {
              self.cue.id = line;
              continue;
            }
            // Process line as start of a cue.
            /*falls through*/
          case "CUE":
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              self.reportOrThrowError(e);
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = "BADCUE";
              continue;
            }
            self.state = "CUETEXT";
            continue;
          case "CUETEXT":
            var hasSubstring = line.indexOf("-->") !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              self.oncue && self.oncue(self.cue);
              self.cue = null;
              self.state = "ID";
              continue;
            }
            if (self.cue.text) {
              self.cue.text += "\n";
            }
            self.cue.text += line.replace(/\u2028/g, '\n').replace(/u2029/g, '\n');
            continue;
          case "BADCUE": // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = "ID";
            }
            continue;
          }
        }
      } catch (e) {
        self.reportOrThrowError(e);

        // If we are currently parsing a cue, report what we have.
        if (self.state === "CUETEXT" && self.cue && self.oncue) {
          self.oncue(self.cue);
        }
        self.cue = null;
        // Enter BADWEBVTT state if header was not parsed correctly otherwise
        // another exception occurred so enter BADCUE state.
        self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
      }
      return this;
    },
    flush: function () {
      var self = this;
      try {
        // Finish decoding the stream.
        self.buffer += self.decoder.decode();
        // Synthesize the end of the current cue or region.
        if (self.cue || self.state === "HEADER") {
          self.buffer += "\n\n";
          self.parse();
        }
        // If we've flushed, parsed, and we're still on the INITIAL state then
        // that means we don't have enough of the stream to parse the first
        // line.
        if (self.state === "INITIAL") {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }
      } catch(e) {
        self.reportOrThrowError(e);
      }
      self.onflush && self.onflush();
      return this;
    }
  };

  var vtt$1 = WebVTT$1;

  /**
   * Copyright 2013 vtt.js Contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var autoKeyword = "auto";
  var directionSetting = {
    "": 1,
    "lr": 1,
    "rl": 1
  };
  var alignSetting = {
    "start": 1,
    "center": 1,
    "end": 1,
    "left": 1,
    "right": 1,
    "auto": 1,
    "line-left": 1,
    "line-right": 1
  };

  function findDirectionSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function VTTCue(startTime, endTime, text) {
    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    this.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = "";
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = "";
    var _snapToLines = true;
    var _line = "auto";
    var _lineAlign = "start";
    var _position = "auto";
    var _positionAlign = "auto";
    var _size = 100;
    var _align = "center";

    Object.defineProperties(this, {
      "id": {
        enumerable: true,
        get: function() {
          return _id;
        },
        set: function(value) {
          _id = "" + value;
        }
      },

      "pauseOnExit": {
        enumerable: true,
        get: function() {
          return _pauseOnExit;
        },
        set: function(value) {
          _pauseOnExit = !!value;
        }
      },

      "startTime": {
        enumerable: true,
        get: function() {
          return _startTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("Start time must be set to a number.");
          }
          _startTime = value;
          this.hasBeenReset = true;
        }
      },

      "endTime": {
        enumerable: true,
        get: function() {
          return _endTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("End time must be set to a number.");
          }
          _endTime = value;
          this.hasBeenReset = true;
        }
      },

      "text": {
        enumerable: true,
        get: function() {
          return _text;
        },
        set: function(value) {
          _text = "" + value;
          this.hasBeenReset = true;
        }
      },

      "region": {
        enumerable: true,
        get: function() {
          return _region;
        },
        set: function(value) {
          _region = value;
          this.hasBeenReset = true;
        }
      },

      "vertical": {
        enumerable: true,
        get: function() {
          return _vertical;
        },
        set: function(value) {
          var setting = findDirectionSetting(value);
          // Have to check for false because the setting an be an empty string.
          if (setting === false) {
            throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
          }
          _vertical = setting;
          this.hasBeenReset = true;
        }
      },

      "snapToLines": {
        enumerable: true,
        get: function() {
          return _snapToLines;
        },
        set: function(value) {
          _snapToLines = !!value;
          this.hasBeenReset = true;
        }
      },

      "line": {
        enumerable: true,
        get: function() {
          return _line;
        },
        set: function(value) {
          if (typeof value !== "number" && value !== autoKeyword) {
            throw new SyntaxError("Line: an invalid number or illegal string was specified.");
          }
          _line = value;
          this.hasBeenReset = true;
        }
      },

      "lineAlign": {
        enumerable: true,
        get: function() {
          return _lineAlign;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            console.warn("lineAlign: an invalid or illegal string was specified.");
          } else {
            _lineAlign = setting;
            this.hasBeenReset = true;
          }
        }
      },

      "position": {
        enumerable: true,
        get: function() {
          return _position;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Position must be between 0 and 100.");
          }
          _position = value;
          this.hasBeenReset = true;
        }
      },

      "positionAlign": {
        enumerable: true,
        get: function() {
          return _positionAlign;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            console.warn("positionAlign: an invalid or illegal string was specified.");
          } else {
            _positionAlign = setting;
            this.hasBeenReset = true;
          }
        }
      },

      "size": {
        enumerable: true,
        get: function() {
          return _size;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Size must be between 0 and 100.");
          }
          _size = value;
          this.hasBeenReset = true;
        }
      },

      "align": {
        enumerable: true,
        get: function() {
          return _align;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
          }
          _align = setting;
          this.hasBeenReset = true;
        }
      }
    });

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    this.displayState = undefined;
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function() {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  var vttcue = VTTCue;

  /**
   * Copyright 2013 vtt.js Contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var scrollSetting = {
    "": true,
    "up": true
  };

  function findScrollSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var scroll = scrollSetting[value.toLowerCase()];
    return scroll ? value.toLowerCase() : false;
  }

  function isValidPercentValue(value) {
    return typeof value === "number" && (value >= 0 && value <= 100);
  }

  // VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface
  function VTTRegion() {
    var _width = 100;
    var _lines = 3;
    var _regionAnchorX = 0;
    var _regionAnchorY = 100;
    var _viewportAnchorX = 0;
    var _viewportAnchorY = 100;
    var _scroll = "";

    Object.defineProperties(this, {
      "width": {
        enumerable: true,
        get: function() {
          return _width;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("Width must be between 0 and 100.");
          }
          _width = value;
        }
      },
      "lines": {
        enumerable: true,
        get: function() {
          return _lines;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("Lines must be set to a number.");
          }
          _lines = value;
        }
      },
      "regionAnchorY": {
        enumerable: true,
        get: function() {
          return _regionAnchorY;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("RegionAnchorX must be between 0 and 100.");
          }
          _regionAnchorY = value;
        }
      },
      "regionAnchorX": {
        enumerable: true,
        get: function() {
          return _regionAnchorX;
        },
        set: function(value) {
          if(!isValidPercentValue(value)) {
            throw new Error("RegionAnchorY must be between 0 and 100.");
          }
          _regionAnchorX = value;
        }
      },
      "viewportAnchorY": {
        enumerable: true,
        get: function() {
          return _viewportAnchorY;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("ViewportAnchorY must be between 0 and 100.");
          }
          _viewportAnchorY = value;
        }
      },
      "viewportAnchorX": {
        enumerable: true,
        get: function() {
          return _viewportAnchorX;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("ViewportAnchorX must be between 0 and 100.");
          }
          _viewportAnchorX = value;
        }
      },
      "scroll": {
        enumerable: true,
        get: function() {
          return _scroll;
        },
        set: function(value) {
          var setting = findScrollSetting(value);
          // Have to check for false as an empty string is a legal value.
          if (setting === false) {
            console.warn("Scroll: an invalid or illegal string was specified.");
          } else {
            _scroll = setting;
          }
        }
      }
    });
  }

  var vttregion = VTTRegion;

  /**
   * Copyright 2013 vtt.js Contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // Default exports for Node. Export the extended versions of VTTCue and
  // VTTRegion in Node since we likely want the capability to convert back and
  // forth between JSON. If we don't then it's not that big of a deal since we're
  // off browser.

  var window$2 = window_1;

  var vttjs = browserIndex.exports = {
    WebVTT: vtt$1,
    VTTCue: vttcue,
    VTTRegion: vttregion
  };

  window$2.vttjs = vttjs;
  window$2.WebVTT = vttjs.WebVTT;

  var cueShim = vttjs.VTTCue;
  var regionShim = vttjs.VTTRegion;
  var nativeVTTCue = window$2.VTTCue;
  var nativeVTTRegion = window$2.VTTRegion;

  vttjs.shim = function() {
    window$2.VTTCue = cueShim;
    window$2.VTTRegion = regionShim;
  };

  vttjs.restore = function() {
    window$2.VTTCue = nativeVTTCue;
    window$2.VTTRegion = nativeVTTRegion;
  };

  if (!window$2.VTTCue) {
    vttjs.shim();
  }

  var browserIndexExports = browserIndex.exports;

  /**
   * @license
   * Video.js 8.17.4 <http://videojs.com/>
   * Copyright Brightcove, Inc. <https://www.brightcove.com/>
   * Available under Apache License Version 2.0
   * <https://github.com/videojs/video.js/blob/main/LICENSE>
   *
   * Includes vtt.js <https://github.com/mozilla/vtt.js>
   * Available under Apache License Version 2.0
   * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
   */

  var window$1 = window_1;
  var document$1 = document_1;
  var XHR = libExports;
  var vtt = browserIndexExports;

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var window__default = /*#__PURE__*/_interopDefaultLegacy(window$1);
  var document__default = /*#__PURE__*/_interopDefaultLegacy(document$1);
  var XHR__default = /*#__PURE__*/_interopDefaultLegacy(XHR);
  var vtt__default = /*#__PURE__*/_interopDefaultLegacy(vtt);

  var version = "8.17.4";

  /**
   * An Object that contains lifecycle hooks as keys which point to an array
   * of functions that are run when a lifecycle is triggered
   *
   * @private
   */
  const hooks_ = {};

  /**
   * Get a list of hooks for a specific lifecycle
   *
   * @param  {string} type
   *         the lifecycle to get hooks from
   *
   * @param  {Function|Function[]} [fn]
   *         Optionally add a hook (or hooks) to the lifecycle that your are getting.
   *
   * @return {Array}
   *         an array of hooks, or an empty array if there are none.
   */
  const hooks = function (type, fn) {
    hooks_[type] = hooks_[type] || [];
    if (fn) {
      hooks_[type] = hooks_[type].concat(fn);
    }
    return hooks_[type];
  };

  /**
   * Add a function hook to a specific videojs lifecycle.
   *
   * @param {string} type
   *        the lifecycle to hook the function to.
   *
   * @param {Function|Function[]}
   *        The function or array of functions to attach.
   */
  const hook = function (type, fn) {
    hooks(type, fn);
  };

  /**
   * Remove a hook from a specific videojs lifecycle.
   *
   * @param  {string} type
   *         the lifecycle that the function hooked to
   *
   * @param  {Function} fn
   *         The hooked function to remove
   *
   * @return {boolean}
   *         The function that was removed or undef
   */
  const removeHook = function (type, fn) {
    const index = hooks(type).indexOf(fn);
    if (index <= -1) {
      return false;
    }
    hooks_[type] = hooks_[type].slice();
    hooks_[type].splice(index, 1);
    return true;
  };

  /**
   * Add a function hook that will only run once to a specific videojs lifecycle.
   *
   * @param {string} type
   *        the lifecycle to hook the function to.
   *
   * @param {Function|Function[]}
   *        The function or array of functions to attach.
   */
  const hookOnce = function (type, fn) {
    hooks(type, [].concat(fn).map(original => {
      const wrapper = (...args) => {
        removeHook(type, wrapper);
        return original(...args);
      };
      return wrapper;
    }));
  };

  /**
   * @file fullscreen-api.js
   * @module fullscreen-api
   */

  /**
   * Store the browser-specific methods for the fullscreen API.
   *
   * @type {Object}
   * @see [Specification]{@link https://fullscreen.spec.whatwg.org}
   * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}
   */
  const FullscreenApi = {
    prefixed: true
  };

  // browser API methods
  const apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror', 'fullscreen'],
  // WebKit
  ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror', '-webkit-full-screen']];
  const specApi = apiMap[0];
  let browserApi;

  // determine the supported set of functions
  for (let i = 0; i < apiMap.length; i++) {
    // check for exitFullscreen function
    if (apiMap[i][1] in document__default["default"]) {
      browserApi = apiMap[i];
      break;
    }
  }

  // map the browser API names to the spec API names
  if (browserApi) {
    for (let i = 0; i < browserApi.length; i++) {
      FullscreenApi[specApi[i]] = browserApi[i];
    }
    FullscreenApi.prefixed = browserApi[0] !== specApi[0];
  }

  /**
   * @file create-logger.js
   * @module create-logger
   */

  // This is the private tracking variable for the logging history.
  let history = [];

  /**
   * Log messages to the console and history based on the type of message
   *
   * @private
   * @param  {string} name
   *         The name of the console method to use.
   *
   * @param  {Object} log
   *         The arguments to be passed to the matching console method.
   *
   * @param {string} [styles]
   *        styles for name
   */
  const LogByTypeFactory = (name, log, styles) => (type, level, args) => {
    const lvl = log.levels[level];
    const lvlRegExp = new RegExp(`^(${lvl})$`);
    let resultName = name;
    if (type !== 'log') {
      // Add the type to the front of the message when it's not "log".
      args.unshift(type.toUpperCase() + ':');
    }
    if (styles) {
      resultName = `%c${name}`;
      args.unshift(styles);
    }

    // Add console prefix after adding to history.
    args.unshift(resultName + ':');

    // Add a clone of the args at this point to history.
    if (history) {
      history.push([].concat(args));

      // only store 1000 history entries
      const splice = history.length - 1000;
      history.splice(0, splice > 0 ? splice : 0);
    }

    // If there's no console then don't try to output messages, but they will
    // still be stored in history.
    if (!window__default["default"].console) {
      return;
    }

    // Was setting these once outside of this function, but containing them
    // in the function makes it easier to test cases where console doesn't exist
    // when the module is executed.
    let fn = window__default["default"].console[type];
    if (!fn && type === 'debug') {
      // Certain browsers don't have support for console.debug. For those, we
      // should default to the closest comparable log.
      fn = window__default["default"].console.info || window__default["default"].console.log;
    }

    // Bail out if there's no console or if this type is not allowed by the
    // current logging level.
    if (!fn || !lvl || !lvlRegExp.test(type)) {
      return;
    }
    fn[Array.isArray(args) ? 'apply' : 'call'](window__default["default"].console, args);
  };
  function createLogger$1(name, delimiter = ':', styles = '') {
    // This is the private tracking variable for logging level.
    let level = 'info';

    // the curried logByType bound to the specific log and history
    let logByType;

    /**
     * Logs plain debug messages. Similar to `console.log`.
     *
     * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)
     * of our JSDoc template, we cannot properly document this as both a function
     * and a namespace, so its function signature is documented here.
     *
     * #### Arguments
     * ##### *args
     * *[]
     *
     * Any combination of values that could be passed to `console.log()`.
     *
     * #### Return Value
     *
     * `undefined`
     *
     * @namespace
     * @param    {...*} args
     *           One or more messages or objects that should be logged.
     */
    function log(...args) {
      logByType('log', level, args);
    }

    // This is the logByType helper that the logging methods below use
    logByType = LogByTypeFactory(name, log, styles);

    /**
     * Create a new subLogger which chains the old name to the new name.
     *
     * For example, doing `mylogger = videojs.log.createLogger('player')` and then using that logger will log the following:
     * ```js
     *  mylogger('foo');
     *  // > VIDEOJS: player: foo
     * ```
     *
     * @param {string} subName
     *        The name to add call the new logger
     * @param {string} [subDelimiter]
     *        Optional delimiter
     * @param {string} [subStyles]
     *        Optional styles
     * @return {Object}
     */
    log.createLogger = (subName, subDelimiter, subStyles) => {
      const resultDelimiter = subDelimiter !== undefined ? subDelimiter : delimiter;
      const resultStyles = subStyles !== undefined ? subStyles : styles;
      const resultName = `${name} ${resultDelimiter} ${subName}`;
      return createLogger$1(resultName, resultDelimiter, resultStyles);
    };

    /**
     * Create a new logger.
     *
     * @param {string} newName
     *        The name for the new logger
     * @param {string} [newDelimiter]
     *        Optional delimiter
     * @param {string} [newStyles]
     *        Optional styles
     * @return {Object}
     */
    log.createNewLogger = (newName, newDelimiter, newStyles) => {
      return createLogger$1(newName, newDelimiter, newStyles);
    };

    /**
     * Enumeration of available logging levels, where the keys are the level names
     * and the values are `|`-separated strings containing logging methods allowed
     * in that logging level. These strings are used to create a regular expression
     * matching the function name being called.
     *
     * Levels provided by Video.js are:
     *
     * - `off`: Matches no calls. Any value that can be cast to `false` will have
     *   this effect. The most restrictive.
     * - `all`: Matches only Video.js-provided functions (`debug`, `log`,
     *   `log.warn`, and `log.error`).
     * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.
     * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.
     * - `warn`: Matches `log.warn` and `log.error` calls.
     * - `error`: Matches only `log.error` calls.
     *
     * @type {Object}
     */
    log.levels = {
      all: 'debug|log|warn|error',
      off: '',
      debug: 'debug|log|warn|error',
      info: 'log|warn|error',
      warn: 'warn|error',
      error: 'error',
      DEFAULT: level
    };

    /**
     * Get or set the current logging level.
     *
     * If a string matching a key from {@link module:log.levels} is provided, acts
     * as a setter.
     *
     * @param  {'all'|'debug'|'info'|'warn'|'error'|'off'} [lvl]
     *         Pass a valid level to set a new logging level.
     *
     * @return {string}
     *         The current logging level.
     */
    log.level = lvl => {
      if (typeof lvl === 'string') {
        if (!log.levels.hasOwnProperty(lvl)) {
          throw new Error(`"${lvl}" in not a valid log level`);
        }
        level = lvl;
      }
      return level;
    };

    /**
     * Returns an array containing everything that has been logged to the history.
     *
     * This array is a shallow clone of the internal history record. However, its
     * contents are _not_ cloned; so, mutating objects inside this array will
     * mutate them in history.
     *
     * @return {Array}
     */
    log.history = () => history ? [].concat(history) : [];

    /**
     * Allows you to filter the history by the given logger name
     *
     * @param {string} fname
     *        The name to filter by
     *
     * @return {Array}
     *         The filtered list to return
     */
    log.history.filter = fname => {
      return (history || []).filter(historyItem => {
        // if the first item in each historyItem includes `fname`, then it's a match
        return new RegExp(`.*${fname}.*`).test(historyItem[0]);
      });
    };

    /**
     * Clears the internal history tracking, but does not prevent further history
     * tracking.
     */
    log.history.clear = () => {
      if (history) {
        history.length = 0;
      }
    };

    /**
     * Disable history tracking if it is currently enabled.
     */
    log.history.disable = () => {
      if (history !== null) {
        history.length = 0;
        history = null;
      }
    };

    /**
     * Enable history tracking if it is currently disabled.
     */
    log.history.enable = () => {
      if (history === null) {
        history = [];
      }
    };

    /**
     * Logs error messages. Similar to `console.error`.
     *
     * @param {...*} args
     *        One or more messages or objects that should be logged as an error
     */
    log.error = (...args) => logByType('error', level, args);

    /**
     * Logs warning messages. Similar to `console.warn`.
     *
     * @param {...*} args
     *        One or more messages or objects that should be logged as a warning.
     */
    log.warn = (...args) => logByType('warn', level, args);

    /**
     * Logs debug messages. Similar to `console.debug`, but may also act as a comparable
     * log if `console.debug` is not available
     *
     * @param {...*} args
     *        One or more messages or objects that should be logged as debug.
     */
    log.debug = (...args) => logByType('debug', level, args);
    return log;
  }

  /**
   * @file log.js
   * @module log
   */
  const log = createLogger$1('VIDEOJS');
  const createLogger = log.createLogger;

  /**
   * @file obj.js
   * @module obj
   */

  /**
   * @callback obj:EachCallback
   *
   * @param {*} value
   *        The current key for the object that is being iterated over.
   *
   * @param {string} key
   *        The current key-value for object that is being iterated over
   */

  /**
   * @callback obj:ReduceCallback
   *
   * @param {*} accum
   *        The value that is accumulating over the reduce loop.
   *
   * @param {*} value
   *        The current key for the object that is being iterated over.
   *
   * @param {string} key
   *        The current key-value for object that is being iterated over
   *
   * @return {*}
   *         The new accumulated value.
   */
  const toString = Object.prototype.toString;

  /**
   * Get the keys of an Object
   *
   * @param {Object}
   *        The Object to get the keys from
   *
   * @return {string[]}
   *         An array of the keys from the object. Returns an empty array if the
   *         object passed in was invalid or had no keys.
   *
   * @private
   */
  const keys = function (object) {
    return isObject(object) ? Object.keys(object) : [];
  };

  /**
   * Array-like iteration for objects.
   *
   * @param {Object} object
   *        The object to iterate over
   *
   * @param {obj:EachCallback} fn
   *        The callback function which is called for each key in the object.
   */
  function each(object, fn) {
    keys(object).forEach(key => fn(object[key], key));
  }

  /**
   * Array-like reduce for objects.
   *
   * @param {Object} object
   *        The Object that you want to reduce.
   *
   * @param {Function} fn
   *         A callback function which is called for each key in the object. It
   *         receives the accumulated value and the per-iteration value and key
   *         as arguments.
   *
   * @param {*} [initial = 0]
   *        Starting value
   *
   * @return {*}
   *         The final accumulated value.
   */
  function reduce(object, fn, initial = 0) {
    return keys(object).reduce((accum, key) => fn(accum, object[key], key), initial);
  }

  /**
   * Returns whether a value is an object of any kind - including DOM nodes,
   * arrays, regular expressions, etc. Not functions, though.
   *
   * This avoids the gotcha where using `typeof` on a `null` value
   * results in `'object'`.
   *
   * @param  {Object} value
   * @return {boolean}
   */
  function isObject(value) {
    return !!value && typeof value === 'object';
  }

  /**
   * Returns whether an object appears to be a "plain" object - that is, a
   * direct instance of `Object`.
   *
   * @param  {Object} value
   * @return {boolean}
   */
  function isPlain(value) {
    return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;
  }

  /**
   * Merge two objects recursively.
   *
   * Performs a deep merge like
   * {@link https://lodash.com/docs/4.17.10#merge|lodash.merge}, but only merges
   * plain objects (not arrays, elements, or anything else).
   *
   * Non-plain object values will be copied directly from the right-most
   * argument.
   *
   * @param   {Object[]} sources
   *          One or more objects to merge into a new object.
   *
   * @return {Object}
   *          A new object that is the merged result of all sources.
   */
  function merge(...sources) {
    const result = {};
    sources.forEach(source => {
      if (!source) {
        return;
      }
      each(source, (value, key) => {
        if (!isPlain(value)) {
          result[key] = value;
          return;
        }
        if (!isPlain(result[key])) {
          result[key] = {};
        }
        result[key] = merge(result[key], value);
      });
    });
    return result;
  }

  /**
   * Returns an array of values for a given object
   *
   * @param  {Object} source - target object
   * @return {Array<unknown>} - object values
   */
  function values(source = {}) {
    const result = [];
    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        const value = source[key];
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Object.defineProperty but "lazy", which means that the value is only set after
   * it is retrieved the first time, rather than being set right away.
   *
   * @param {Object} obj the object to set the property on
   * @param {string} key the key for the property to set
   * @param {Function} getValue the function used to get the value when it is needed.
   * @param {boolean} setter whether a setter should be allowed or not
   */
  function defineLazyProperty(obj, key, getValue, setter = true) {
    const set = value => Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      writable: true
    });
    const options = {
      configurable: true,
      enumerable: true,
      get() {
        const value = getValue();
        set(value);
        return value;
      }
    };
    if (setter) {
      options.set = set;
    }
    return Object.defineProperty(obj, key, options);
  }

  var Obj = /*#__PURE__*/Object.freeze({
    __proto__: null,
    each: each,
    reduce: reduce,
    isObject: isObject,
    isPlain: isPlain,
    merge: merge,
    values: values,
    defineLazyProperty: defineLazyProperty
  });

  /**
   * @file browser.js
   * @module browser
   */

  /**
   * Whether or not this device is an iPod.
   *
   * @static
   * @type {Boolean}
   */
  let IS_IPOD = false;

  /**
   * The detected iOS version - or `null`.
   *
   * @static
   * @type {string|null}
   */
  let IOS_VERSION = null;

  /**
   * Whether or not this is an Android device.
   *
   * @static
   * @type {Boolean}
   */
  let IS_ANDROID = false;

  /**
   * The detected Android version - or `null` if not Android or indeterminable.
   *
   * @static
   * @type {number|string|null}
   */
  let ANDROID_VERSION;

  /**
   * Whether or not this is Mozilla Firefox.
   *
   * @static
   * @type {Boolean}
   */
  let IS_FIREFOX = false;

  /**
   * Whether or not this is Microsoft Edge.
   *
   * @static
   * @type {Boolean}
   */
  let IS_EDGE = false;

  /**
   * Whether or not this is any Chromium Browser
   *
   * @static
   * @type {Boolean}
   */
  let IS_CHROMIUM = false;

  /**
   * Whether or not this is any Chromium browser that is not Edge.
   *
   * This will also be `true` for Chrome on iOS, which will have different support
   * as it is actually Safari under the hood.
   *
   * Deprecated, as the behaviour to not match Edge was to prevent Legacy Edge's UA matching.
   * IS_CHROMIUM should be used instead.
   * "Chromium but not Edge" could be explicitly tested with IS_CHROMIUM && !IS_EDGE
   *
   * @static
   * @deprecated
   * @type {Boolean}
   */
  let IS_CHROME = false;

  /**
   * The detected Chromium version - or `null`.
   *
   * @static
   * @type {number|null}
   */
  let CHROMIUM_VERSION = null;

  /**
   * The detected Google Chrome version - or `null`.
   * This has always been the _Chromium_ version, i.e. would return on Chromium Edge.
   * Deprecated, use CHROMIUM_VERSION instead.
   *
   * @static
   * @deprecated
   * @type {number|null}
   */
  let CHROME_VERSION = null;

  /**
   * Whether or not this is a Chromecast receiver application.
   *
   * @static
   * @type {Boolean}
   */
  const IS_CHROMECAST_RECEIVER = Boolean(window__default["default"].cast && window__default["default"].cast.framework && window__default["default"].cast.framework.CastReceiverContext);

  /**
   * The detected Internet Explorer version - or `null`.
   *
   * @static
   * @deprecated
   * @type {number|null}
   */
  let IE_VERSION = null;

  /**
   * Whether or not this is desktop Safari.
   *
   * @static
   * @type {Boolean}
   */
  let IS_SAFARI = false;

  /**
   * Whether or not this is a Windows machine.
   *
   * @static
   * @type {Boolean}
   */
  let IS_WINDOWS = false;

  /**
   * Whether or not this device is an iPad.
   *
   * @static
   * @type {Boolean}
   */
  let IS_IPAD = false;

  /**
   * Whether or not this device is an iPhone.
   *
   * @static
   * @type {Boolean}
   */
  // The Facebook app's UIWebView identifies as both an iPhone and iPad, so
  // to identify iPhones, we need to exclude iPads.
  // http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/
  let IS_IPHONE = false;

  /**
   * Whether or not this is a Tizen device.
   *
   * @static
   * @type {Boolean}
   */
  let IS_TIZEN = false;

  /**
   * Whether or not this is a WebOS device.
   *
   * @static
   * @type {Boolean}
   */
  let IS_WEBOS = false;

  /**
   * Whether or not this is a Smart TV (Tizen or WebOS) device.
   *
   * @static
   * @type {Boolean}
   */
  let IS_SMART_TV = false;

  /**
   * Whether or not this device is touch-enabled.
   *
   * @static
   * @const
   * @type {Boolean}
   */
  const TOUCH_ENABLED = Boolean(isReal() && ('ontouchstart' in window__default["default"] || window__default["default"].navigator.maxTouchPoints || window__default["default"].DocumentTouch && window__default["default"].document instanceof window__default["default"].DocumentTouch));
  const UAD = window__default["default"].navigator && window__default["default"].navigator.userAgentData;
  if (UAD && UAD.platform && UAD.brands) {
    // If userAgentData is present, use it instead of userAgent to avoid warnings
    // Currently only implemented on Chromium
    // userAgentData does not expose Android version, so ANDROID_VERSION remains `null`

    IS_ANDROID = UAD.platform === 'Android';
    IS_EDGE = Boolean(UAD.brands.find(b => b.brand === 'Microsoft Edge'));
    IS_CHROMIUM = Boolean(UAD.brands.find(b => b.brand === 'Chromium'));
    IS_CHROME = !IS_EDGE && IS_CHROMIUM;
    CHROMIUM_VERSION = CHROME_VERSION = (UAD.brands.find(b => b.brand === 'Chromium') || {}).version || null;
    IS_WINDOWS = UAD.platform === 'Windows';
  }

  // If the browser is not Chromium, either userAgentData is not present which could be an old Chromium browser,
  //  or it's a browser that has added userAgentData since that we don't have tests for yet. In either case,
  // the checks need to be made agiainst the regular userAgent string.
  if (!IS_CHROMIUM) {
    const USER_AGENT = window__default["default"].navigator && window__default["default"].navigator.userAgent || '';
    IS_IPOD = /iPod/i.test(USER_AGENT);
    IOS_VERSION = function () {
      const match = USER_AGENT.match(/OS (\d+)_/i);
      if (match && match[1]) {
        return match[1];
      }
      return null;
    }();
    IS_ANDROID = /Android/i.test(USER_AGENT);
    ANDROID_VERSION = function () {
      // This matches Android Major.Minor.Patch versions
      // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
      const match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
      if (!match) {
        return null;
      }
      const major = match[1] && parseFloat(match[1]);
      const minor = match[2] && parseFloat(match[2]);
      if (major && minor) {
        return parseFloat(match[1] + '.' + match[2]);
      } else if (major) {
        return major;
      }
      return null;
    }();
    IS_FIREFOX = /Firefox/i.test(USER_AGENT);
    IS_EDGE = /Edg/i.test(USER_AGENT);
    IS_CHROMIUM = /Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT);
    IS_CHROME = !IS_EDGE && IS_CHROMIUM;
    CHROMIUM_VERSION = CHROME_VERSION = function () {
      const match = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
      if (match && match[2]) {
        return parseFloat(match[2]);
      }
      return null;
    }();
    IE_VERSION = function () {
      const result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
      let version = result && parseFloat(result[1]);
      if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
        // IE 11 has a different user agent string than other IE versions
        version = 11.0;
      }
      return version;
    }();
    IS_TIZEN = /Tizen/i.test(USER_AGENT);
    IS_WEBOS = /Web0S/i.test(USER_AGENT);
    IS_SMART_TV = IS_TIZEN || IS_WEBOS;
    IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE && !IS_SMART_TV;
    IS_WINDOWS = /Windows/i.test(USER_AGENT);
    IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);
    IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
  }

  /**
   * Whether or not this is an iOS device.
   *
   * @static
   * @const
   * @type {Boolean}
   */
  const IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;

  /**
   * Whether or not this is any flavor of Safari - including iOS.
   *
   * @static
   * @const
   * @type {Boolean}
   */
  const IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;

  var browser = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get IS_IPOD () { return IS_IPOD; },
    get IOS_VERSION () { return IOS_VERSION; },
    get IS_ANDROID () { return IS_ANDROID; },
    get ANDROID_VERSION () { return ANDROID_VERSION; },
    get IS_FIREFOX () { return IS_FIREFOX; },
    get IS_EDGE () { return IS_EDGE; },
    get IS_CHROMIUM () { return IS_CHROMIUM; },
    get IS_CHROME () { return IS_CHROME; },
    get CHROMIUM_VERSION () { return CHROMIUM_VERSION; },
    get CHROME_VERSION () { return CHROME_VERSION; },
    IS_CHROMECAST_RECEIVER: IS_CHROMECAST_RECEIVER,
    get IE_VERSION () { return IE_VERSION; },
    get IS_SAFARI () { return IS_SAFARI; },
    get IS_WINDOWS () { return IS_WINDOWS; },
    get IS_IPAD () { return IS_IPAD; },
    get IS_IPHONE () { return IS_IPHONE; },
    get IS_TIZEN () { return IS_TIZEN; },
    get IS_WEBOS () { return IS_WEBOS; },
    get IS_SMART_TV () { return IS_SMART_TV; },
    TOUCH_ENABLED: TOUCH_ENABLED,
    IS_IOS: IS_IOS,
    IS_ANY_SAFARI: IS_ANY_SAFARI
  });

  /**
   * @file dom.js
   * @module dom
   */

  /**
   * Detect if a value is a string with any non-whitespace characters.
   *
   * @private
   * @param  {string} str
   *         The string to check
   *
   * @return {boolean}
   *         Will be `true` if the string is non-blank, `false` otherwise.
   *
   */
  function isNonBlankString(str) {
    // we use str.trim as it will trim any whitespace characters
    // from the front or back of non-whitespace characters. aka
    // Any string that contains non-whitespace characters will
    // still contain them after `trim` but whitespace only strings
    // will have a length of 0, failing this check.
    return typeof str === 'string' && Boolean(str.trim());
  }

  /**
   * Throws an error if the passed string has whitespace. This is used by
   * class methods to be relatively consistent with the classList API.
   *
   * @private
   * @param  {string} str
   *         The string to check for whitespace.
   *
   * @throws {Error}
   *         Throws an error if there is whitespace in the string.
   */
  function throwIfWhitespace(str) {
    // str.indexOf instead of regex because str.indexOf is faster performance wise.
    if (str.indexOf(' ') >= 0) {
      throw new Error('class has illegal whitespace characters');
    }
  }

  /**
   * Whether the current DOM interface appears to be real (i.e. not simulated).
   *
   * @return {boolean}
   *         Will be `true` if the DOM appears to be real, `false` otherwise.
   */
  function isReal() {
    // Both document and window will never be undefined thanks to `global`.
    return document__default["default"] === window__default["default"].document;
  }

  /**
   * Determines, via duck typing, whether or not a value is a DOM element.
   *
   * @param  {*} value
   *         The value to check.
   *
   * @return {boolean}
   *         Will be `true` if the value is a DOM element, `false` otherwise.
   */
  function isEl(value) {
    return isObject(value) && value.nodeType === 1;
  }

  /**
   * Determines if the current DOM is embedded in an iframe.
   *
   * @return {boolean}
   *         Will be `true` if the DOM is embedded in an iframe, `false`
   *         otherwise.
   */
  function isInFrame() {
    // We need a try/catch here because Safari will throw errors when attempting
    // to get either `parent` or `self`
    try {
      return window__default["default"].parent !== window__default["default"].self;
    } catch (x) {
      return true;
    }
  }

  /**
   * Creates functions to query the DOM using a given method.
   *
   * @private
   * @param   {string} method
   *          The method to create the query with.
   *
   * @return  {Function}
   *          The query method
   */
  function createQuerier(method) {
    return function (selector, context) {
      if (!isNonBlankString(selector)) {
        return document__default["default"][method](null);
      }
      if (isNonBlankString(context)) {
        context = document__default["default"].querySelector(context);
      }
      const ctx = isEl(context) ? context : document__default["default"];
      return ctx[method] && ctx[method](selector);
    };
  }

  /**
   * Creates an element and applies properties, attributes, and inserts content.
   *
   * @param  {string} [tagName='div']
   *         Name of tag to be created.
   *
   * @param  {Object} [properties={}]
   *         Element properties to be applied.
   *
   * @param  {Object} [attributes={}]
   *         Element attributes to be applied.
   *
   * @param {ContentDescriptor} [content]
   *        A content descriptor object.
   *
   * @return {Element}
   *         The element that was created.
   */
  function createEl(tagName = 'div', properties = {}, attributes = {}, content) {
    const el = document__default["default"].createElement(tagName);
    Object.getOwnPropertyNames(properties).forEach(function (propName) {
      const val = properties[propName];

      // Handle textContent since it's not supported everywhere and we have a
      // method for it.
      if (propName === 'textContent') {
        textContent(el, val);
      } else if (el[propName] !== val || propName === 'tabIndex') {
        el[propName] = val;
      }
    });
    Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
      el.setAttribute(attrName, attributes[attrName]);
    });
    if (content) {
      appendContent(el, content);
    }
    return el;
  }

  /**
   * Injects text into an element, replacing any existing contents entirely.
   *
   * @param  {HTMLElement} el
   *         The element to add text content into
   *
   * @param  {string} text
   *         The text content to add.
   *
   * @return {Element}
   *         The element with added text content.
   */
  function textContent(el, text) {
    if (typeof el.textContent === 'undefined') {
      el.innerText = text;
    } else {
      el.textContent = text;
    }
    return el;
  }

  /**
   * Insert an element as the first child node of another
   *
   * @param {Element} child
   *        Element to insert
   *
   * @param {Element} parent
   *        Element to insert child into
   */
  function prependTo(child, parent) {
    if (parent.firstChild) {
      parent.insertBefore(child, parent.firstChild);
    } else {
      parent.appendChild(child);
    }
  }

  /**
   * Check if an element has a class name.
   *
   * @param  {Element} element
   *         Element to check
   *
   * @param  {string} classToCheck
   *         Class name to check for
   *
   * @return {boolean}
   *         Will be `true` if the element has a class, `false` otherwise.
   *
   * @throws {Error}
   *         Throws an error if `classToCheck` has white space.
   */
  function hasClass(element, classToCheck) {
    throwIfWhitespace(classToCheck);
    return element.classList.contains(classToCheck);
  }

  /**
   * Add a class name to an element.
   *
   * @param  {Element} element
   *         Element to add class name to.
   *
   * @param  {...string} classesToAdd
   *         One or more class name to add.
   *
   * @return {Element}
   *         The DOM element with the added class name.
   */
  function addClass(element, ...classesToAdd) {
    element.classList.add(...classesToAdd.reduce((prev, current) => prev.concat(current.split(/\s+/)), []));
    return element;
  }

  /**
   * Remove a class name from an element.
   *
   * @param  {Element} element
   *         Element to remove a class name from.
   *
   * @param  {...string} classesToRemove
   *         One or more class name to remove.
   *
   * @return {Element}
   *         The DOM element with class name removed.
   */
  function removeClass(element, ...classesToRemove) {
    // Protect in case the player gets disposed
    if (!element) {
      log.warn("removeClass was called with an element that doesn't exist");
      return null;
    }
    element.classList.remove(...classesToRemove.reduce((prev, current) => prev.concat(current.split(/\s+/)), []));
    return element;
  }

  /**
   * The callback definition for toggleClass.
   *
   * @callback PredicateCallback
   * @param    {Element} element
   *           The DOM element of the Component.
   *
   * @param    {string} classToToggle
   *           The `className` that wants to be toggled
   *
   * @return   {boolean|undefined}
   *           If `true` is returned, the `classToToggle` will be added to the
   *           `element`, but not removed. If `false`, the `classToToggle` will be removed from
   *           the `element`, but not added. If `undefined`, the callback will be ignored.
   *
   */

  /**
   * Adds or removes a class name to/from an element depending on an optional
   * condition or the presence/absence of the class name.
   *
   * @param  {Element} element
   *         The element to toggle a class name on.
   *
   * @param  {string} classToToggle
   *         The class that should be toggled.
   *
   * @param  {boolean|PredicateCallback} [predicate]
   *         See the return value for {@link module:dom~PredicateCallback}
   *
   * @return {Element}
   *         The element with a class that has been toggled.
   */
  function toggleClass(element, classToToggle, predicate) {
    if (typeof predicate === 'function') {
      predicate = predicate(element, classToToggle);
    }
    if (typeof predicate !== 'boolean') {
      predicate = undefined;
    }
    classToToggle.split(/\s+/).forEach(className => element.classList.toggle(className, predicate));
    return element;
  }

  /**
   * Apply attributes to an HTML element.
   *
   * @param {Element} el
   *        Element to add attributes to.
   *
   * @param {Object} [attributes]
   *        Attributes to be applied.
   */
  function setAttributes(el, attributes) {
    Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
      const attrValue = attributes[attrName];
      if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
        el.removeAttribute(attrName);
      } else {
        el.setAttribute(attrName, attrValue === true ? '' : attrValue);
      }
    });
  }

  /**
   * Get an element's attribute values, as defined on the HTML tag.
   *
   * Attributes are not the same as properties. They're defined on the tag
   * or with setAttribute.
   *
   * @param  {Element} tag
   *         Element from which to get tag attributes.
   *
   * @return {Object}
   *         All attributes of the element. Boolean attributes will be `true` or
   *         `false`, others will be strings.
   */
  function getAttributes(tag) {
    const obj = {};

    // known boolean attributes
    // we can check for matching boolean properties, but not all browsers
    // and not all tags know about these attributes, so, we still want to check them manually
    const knownBooleans = ['autoplay', 'controls', 'playsinline', 'loop', 'muted', 'default', 'defaultMuted'];
    if (tag && tag.attributes && tag.attributes.length > 0) {
      const attrs = tag.attributes;
      for (let i = attrs.length - 1; i >= 0; i--) {
        const attrName = attrs[i].name;
        /** @type {boolean|string} */
        let attrVal = attrs[i].value;

        // check for known booleans
        // the matching element property will return a value for typeof
        if (knownBooleans.includes(attrName)) {
          // the value of an included boolean attribute is typically an empty
          // string ('') which would equal false if we just check for a false value.
          // we also don't want support bad code like autoplay='false'
          attrVal = attrVal !== null ? true : false;
        }
        obj[attrName] = attrVal;
      }
    }
    return obj;
  }

  /**
   * Get the value of an element's attribute.
   *
   * @param {Element} el
   *        A DOM element.
   *
   * @param {string} attribute
   *        Attribute to get the value of.
   *
   * @return {string}
   *         The value of the attribute.
   */
  function getAttribute(el, attribute) {
    return el.getAttribute(attribute);
  }

  /**
   * Set the value of an element's attribute.
   *
   * @param {Element} el
   *        A DOM element.
   *
   * @param {string} attribute
   *        Attribute to set.
   *
   * @param {string} value
   *        Value to set the attribute to.
   */
  function setAttribute(el, attribute, value) {
    el.setAttribute(attribute, value);
  }

  /**
   * Remove an element's attribute.
   *
   * @param {Element} el
   *        A DOM element.
   *
   * @param {string} attribute
   *        Attribute to remove.
   */
  function removeAttribute(el, attribute) {
    el.removeAttribute(attribute);
  }

  /**
   * Attempt to block the ability to select text.
   */
  function blockTextSelection() {
    document__default["default"].body.focus();
    document__default["default"].onselectstart = function () {
      return false;
    };
  }

  /**
   * Turn off text selection blocking.
   */
  function unblockTextSelection() {
    document__default["default"].onselectstart = function () {
      return true;
    };
  }

  /**
   * Identical to the native `getBoundingClientRect` function, but ensures that
   * the method is supported at all (it is in all browsers we claim to support)
   * and that the element is in the DOM before continuing.
   *
   * This wrapper function also shims properties which are not provided by some
   * older browsers (namely, IE8).
   *
   * Additionally, some browsers do not support adding properties to a
   * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard
   * properties (except `x` and `y` which are not widely supported). This helps
   * avoid implementations where keys are non-enumerable.
   *
   * @param  {Element} el
   *         Element whose `ClientRect` we want to calculate.
   *
   * @return {Object|undefined}
   *         Always returns a plain object - or `undefined` if it cannot.
   */
  function getBoundingClientRect(el) {
    if (el && el.getBoundingClientRect && el.parentNode) {
      const rect = el.getBoundingClientRect();
      const result = {};
      ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(k => {
        if (rect[k] !== undefined) {
          result[k] = rect[k];
        }
      });
      if (!result.height) {
        result.height = parseFloat(computedStyle(el, 'height'));
      }
      if (!result.width) {
        result.width = parseFloat(computedStyle(el, 'width'));
      }
      return result;
    }
  }

  /**
   * Represents the position of a DOM element on the page.
   *
   * @typedef  {Object} module:dom~Position
   *
   * @property {number} left
   *           Pixels to the left.
   *
   * @property {number} top
   *           Pixels from the top.
   */

  /**
   * Get the position of an element in the DOM.
   *
   * Uses `getBoundingClientRect` technique from John Resig.
   *
   * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/
   *
   * @param  {Element} el
   *         Element from which to get offset.
   *
   * @return {module:dom~Position}
   *         The position of the element that was passed in.
   */
  function findPosition(el) {
    if (!el || el && !el.offsetParent) {
      return {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      };
    }
    const width = el.offsetWidth;
    const height = el.offsetHeight;
    let left = 0;
    let top = 0;
    while (el.offsetParent && el !== document__default["default"][FullscreenApi.fullscreenElement]) {
      left += el.offsetLeft;
      top += el.offsetTop;
      el = el.offsetParent;
    }
    return {
      left,
      top,
      width,
      height
    };
  }

  /**
   * Represents x and y coordinates for a DOM element or mouse pointer.
   *
   * @typedef  {Object} module:dom~Coordinates
   *
   * @property {number} x
   *           x coordinate in pixels
   *
   * @property {number} y
   *           y coordinate in pixels
   */

  /**
   * Get the pointer position within an element.
   *
   * The base on the coordinates are the bottom left of the element.
   *
   * @param  {Element} el
   *         Element on which to get the pointer position on.
   *
   * @param  {Event} event
   *         Event object.
   *
   * @return {module:dom~Coordinates}
   *         A coordinates object corresponding to the mouse position.
   *
   */
  function getPointerPosition(el, event) {
    const translated = {
      x: 0,
      y: 0
    };
    if (IS_IOS) {
      let item = el;
      while (item && item.nodeName.toLowerCase() !== 'html') {
        const transform = computedStyle(item, 'transform');
        if (/^matrix/.test(transform)) {
          const values = transform.slice(7, -1).split(/,\s/).map(Number);
          translated.x += values[4];
          translated.y += values[5];
        } else if (/^matrix3d/.test(transform)) {
          const values = transform.slice(9, -1).split(/,\s/).map(Number);
          translated.x += values[12];
          translated.y += values[13];
        }
        if (item.assignedSlot && item.assignedSlot.parentElement && window__default["default"].WebKitCSSMatrix) {
          const transformValue = window__default["default"].getComputedStyle(item.assignedSlot.parentElement).transform;
          const matrix = new window__default["default"].WebKitCSSMatrix(transformValue);
          translated.x += matrix.m41;
          translated.y += matrix.m42;
        }
        item = item.parentNode || item.host;
      }
    }
    const position = {};
    const boxTarget = findPosition(event.target);
    const box = findPosition(el);
    const boxW = box.width;
    const boxH = box.height;
    let offsetY = event.offsetY - (box.top - boxTarget.top);
    let offsetX = event.offsetX - (box.left - boxTarget.left);
    if (event.changedTouches) {
      offsetX = event.changedTouches[0].pageX - box.left;
      offsetY = event.changedTouches[0].pageY + box.top;
      if (IS_IOS) {
        offsetX -= translated.x;
        offsetY -= translated.y;
      }
    }
    position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));
    position.x = Math.max(0, Math.min(1, offsetX / boxW));
    return position;
  }

  /**
   * Determines, via duck typing, whether or not a value is a text node.
   *
   * @param  {*} value
   *         Check if this value is a text node.
   *
   * @return {boolean}
   *         Will be `true` if the value is a text node, `false` otherwise.
   */
  function isTextNode(value) {
    return isObject(value) && value.nodeType === 3;
  }

  /**
   * Empties the contents of an element.
   *
   * @param  {Element} el
   *         The element to empty children from
   *
   * @return {Element}
   *         The element with no children
   */
  function emptyEl(el) {
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
    return el;
  }

  /**
   * This is a mixed value that describes content to be injected into the DOM
   * via some method. It can be of the following types:
   *
   * Type       | Description
   * -----------|-------------
   * `string`   | The value will be normalized into a text node.
   * `Element`  | The value will be accepted as-is.
   * `Text`     | A TextNode. The value will be accepted as-is.
   * `Array`    | A one-dimensional array of strings, elements, text nodes, or functions. These functions should return a string, element, or text node (any other return value, like an array, will be ignored).
   * `Function` | A function, which is expected to return a string, element, text node, or array - any of the other possible values described above. This means that a content descriptor could be a function that returns an array of functions, but those second-level functions must return strings, elements, or text nodes.
   *
   * @typedef {string|Element|Text|Array|Function} ContentDescriptor
   */

  /**
   * Normalizes content for eventual insertion into the DOM.
   *
   * This allows a wide range of content definition methods, but helps protect
   * from falling into the trap of simply writing to `innerHTML`, which could
   * be an XSS concern.
   *
   * The content for an element can be passed in multiple types and
   * combinations, whose behavior is as follows:
   *
   * @param {ContentDescriptor} content
   *        A content descriptor value.
   *
   * @return {Array}
   *         All of the content that was passed in, normalized to an array of
   *         elements or text nodes.
   */
  function normalizeContent(content) {
    // First, invoke content if it is a function. If it produces an array,
    // that needs to happen before normalization.
    if (typeof content === 'function') {
      content = content();
    }

    // Next up, normalize to an array, so one or many items can be normalized,
    // filtered, and returned.
    return (Array.isArray(content) ? content : [content]).map(value => {
      // First, invoke value if it is a function to produce a new value,
      // which will be subsequently normalized to a Node of some kind.
      if (typeof value === 'function') {
        value = value();
      }
      if (isEl(value) || isTextNode(value)) {
        return value;
      }
      if (typeof value === 'string' && /\S/.test(value)) {
        return document__default["default"].createTextNode(value);
      }
    }).filter(value => value);
  }

  /**
   * Normalizes and appends content to an element.
   *
   * @param  {Element} el
   *         Element to append normalized content to.
   *
   * @param {ContentDescriptor} content
   *        A content descriptor value.
   *
   * @return {Element}
   *         The element with appended normalized content.
   */
  function appendContent(el, content) {
    normalizeContent(content).forEach(node => el.appendChild(node));
    return el;
  }

  /**
   * Normalizes and inserts content into an element; this is identical to
   * `appendContent()`, except it empties the element first.
   *
   * @param {Element} el
   *        Element to insert normalized content into.
   *
   * @param {ContentDescriptor} content
   *        A content descriptor value.
   *
   * @return {Element}
   *         The element with inserted normalized content.
   */
  function insertContent(el, content) {
    return appendContent(emptyEl(el), content);
  }

  /**
   * Check if an event was a single left click.
   *
   * @param  {MouseEvent} event
   *         Event object.
   *
   * @return {boolean}
   *         Will be `true` if a single left click, `false` otherwise.
   */
  function isSingleLeftClick(event) {
    // Note: if you create something draggable, be sure to
    // call it on both `mousedown` and `mousemove` event,
    // otherwise `mousedown` should be enough for a button

    if (event.button === undefined && event.buttons === undefined) {
      // Why do we need `buttons` ?
      // Because, middle mouse sometimes have this:
      // e.button === 0 and e.buttons === 4
      // Furthermore, we want to prevent combination click, something like
      // HOLD middlemouse then left click, that would be
      // e.button === 0, e.buttons === 5
      // just `button` is not gonna work

      // Alright, then what this block does ?
      // this is for chrome `simulate mobile devices`
      // I want to support this as well

      return true;
    }
    if (event.button === 0 && event.buttons === undefined) {
      // Touch screen, sometimes on some specific device, `buttons`
      // doesn't have anything (safari on ios, blackberry...)

      return true;
    }

    // `mouseup` event on a single left click has
    // `button` and `buttons` equal to 0
    if (event.type === 'mouseup' && event.button === 0 && event.buttons === 0) {
      return true;
    }

    // MacOS Sonoma trackpad when "tap to click enabled"
    if (event.type === 'mousedown' && event.button === 0 && event.buttons === 0) {
      return true;
    }
    if (event.button !== 0 || event.buttons !== 1) {
      // This is the reason we have those if else block above
      // if any special case we can catch and let it slide
      // we do it above, when get to here, this definitely
      // is-not-left-click

      return false;
    }
    return true;
  }

  /**
   * Finds a single DOM element matching `selector` within the optional
   * `context` of another DOM element (defaulting to `document`).
   *
   * @param  {string} selector
   *         A valid CSS selector, which will be passed to `querySelector`.
   *
   * @param  {Element|String} [context=document]
   *         A DOM element within which to query. Can also be a selector
   *         string in which case the first matching element will be used
   *         as context. If missing (or no element matches selector), falls
   *         back to `document`.
   *
   * @return {Element|null}
   *         The element that was found or null.
   */
  const $ = createQuerier('querySelector');

  /**
   * Finds a all DOM elements matching `selector` within the optional
   * `context` of another DOM element (defaulting to `document`).
   *
   * @param  {string} selector
   *         A valid CSS selector, which will be passed to `querySelectorAll`.
   *
   * @param  {Element|String} [context=document]
   *         A DOM element within which to query. Can also be a selector
   *         string in which case the first matching element will be used
   *         as context. If missing (or no element matches selector), falls
   *         back to `document`.
   *
   * @return {NodeList}
   *         A element list of elements that were found. Will be empty if none
   *         were found.
   *
   */
  const $$ = createQuerier('querySelectorAll');

  /**
   * A safe getComputedStyle.
   *
   * This is needed because in Firefox, if the player is loaded in an iframe with
   * `display:none`, then `getComputedStyle` returns `null`, so, we do a
   * null-check to make sure that the player doesn't break in these cases.
   *
   * @param    {Element} el
   *           The element you want the computed style of
   *
   * @param    {string} prop
   *           The property name you want
   *
   * @see      https://bugzilla.mozilla.org/show_bug.cgi?id=548397
   */
  function computedStyle(el, prop) {
    if (!el || !prop) {
      return '';
    }
    if (typeof window__default["default"].getComputedStyle === 'function') {
      let computedStyleValue;
      try {
        computedStyleValue = window__default["default"].getComputedStyle(el);
      } catch (e) {
        return '';
      }
      return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : '';
    }
    return '';
  }

  /**
   * Copy document style sheets to another window.
   *
   * @param    {Window} win
   *           The window element you want to copy the document style sheets to.
   *
   */
  function copyStyleSheetsToWindow(win) {
    [...document__default["default"].styleSheets].forEach(styleSheet => {
      try {
        const cssRules = [...styleSheet.cssRules].map(rule => rule.cssText).join('');
        const style = document__default["default"].createElement('style');
        style.textContent = cssRules;
        win.document.head.appendChild(style);
      } catch (e) {
        const link = document__default["default"].createElement('link');
        link.rel = 'stylesheet';
        link.type = styleSheet.type;
        // For older Safari this has to be the string; on other browsers setting the MediaList works
        link.media = styleSheet.media.mediaText;
        link.href = styleSheet.href;
        win.document.head.appendChild(link);
      }
    });
  }

  var Dom = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isReal: isReal,
    isEl: isEl,
    isInFrame: isInFrame,
    createEl: createEl,
    textContent: textContent,
    prependTo: prependTo,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    toggleClass: toggleClass,
    setAttributes: setAttributes,
    getAttributes: getAttributes,
    getAttribute: getAttribute,
    setAttribute: setAttribute,
    removeAttribute: removeAttribute,
    blockTextSelection: blockTextSelection,
    unblockTextSelection: unblockTextSelection,
    getBoundingClientRect: getBoundingClientRect,
    findPosition: findPosition,
    getPointerPosition: getPointerPosition,
    isTextNode: isTextNode,
    emptyEl: emptyEl,
    normalizeContent: normalizeContent,
    appendContent: appendContent,
    insertContent: insertContent,
    isSingleLeftClick: isSingleLeftClick,
    $: $,
    $$: $$,
    computedStyle: computedStyle,
    copyStyleSheetsToWindow: copyStyleSheetsToWindow
  });

  /**
   * @file setup.js - Functions for setting up a player without
   * user interaction based on the data-setup `attribute` of the video tag.
   *
   * @module setup
   */
  let _windowLoaded = false;
  let videojs$1;

  /**
   * Set up any tags that have a data-setup `attribute` when the player is started.
   */
  const autoSetup = function () {
    if (videojs$1.options.autoSetup === false) {
      return;
    }
    const vids = Array.prototype.slice.call(document__default["default"].getElementsByTagName('video'));
    const audios = Array.prototype.slice.call(document__default["default"].getElementsByTagName('audio'));
    const divs = Array.prototype.slice.call(document__default["default"].getElementsByTagName('video-js'));
    const mediaEls = vids.concat(audios, divs);

    // Check if any media elements exist
    if (mediaEls && mediaEls.length > 0) {
      for (let i = 0, e = mediaEls.length; i < e; i++) {
        const mediaEl = mediaEls[i];

        // Check if element exists, has getAttribute func.
        if (mediaEl && mediaEl.getAttribute) {
          // Make sure this player hasn't already been set up.
          if (mediaEl.player === undefined) {
            const options = mediaEl.getAttribute('data-setup');

            // Check if data-setup attr exists.
            // We only auto-setup if they've added the data-setup attr.
            if (options !== null) {
              // Create new video.js instance.
              videojs$1(mediaEl);
            }
          }

          // If getAttribute isn't defined, we need to wait for the DOM.
        } else {
          autoSetupTimeout(1);
          break;
        }
      }

      // No videos were found, so keep looping unless page is finished loading.
    } else if (!_windowLoaded) {
      autoSetupTimeout(1);
    }
  };

  /**
   * Wait until the page is loaded before running autoSetup. This will be called in
   * autoSetup if `hasLoaded` returns false.
   *
   * @param {number} wait
   *        How long to wait in ms
   *
   * @param {module:videojs} [vjs]
   *        The videojs library function
   */
  function autoSetupTimeout(wait, vjs) {
    // Protect against breakage in non-browser environments
    if (!isReal()) {
      return;
    }
    if (vjs) {
      videojs$1 = vjs;
    }
    window__default["default"].setTimeout(autoSetup, wait);
  }

  /**
   * Used to set the internal tracking of window loaded state to true.
   *
   * @private
   */
  function setWindowLoaded() {
    _windowLoaded = true;
    window__default["default"].removeEventListener('load', setWindowLoaded);
  }
  if (isReal()) {
    if (document__default["default"].readyState === 'complete') {
      setWindowLoaded();
    } else {
      /**
       * Listen for the load event on window, and set _windowLoaded to true.
       *
       * We use a standard event listener here to avoid incrementing the GUID
       * before any players are created.
       *
       * @listens load
       */
      window__default["default"].addEventListener('load', setWindowLoaded);
    }
  }

  /**
   * @file stylesheet.js
   * @module stylesheet
   */

  /**
   * Create a DOM style element given a className for it.
   *
   * @param {string} className
   *        The className to add to the created style element.
   *
   * @return {Element}
   *         The element that was created.
   */
  const createStyleElement = function (className) {
    const style = document__default["default"].createElement('style');
    style.className = className;
    return style;
  };

  /**
   * Add text to a DOM element.
   *
   * @param {Element} el
   *        The Element to add text content to.
   *
   * @param {string} content
   *        The text to add to the element.
   */
  const setTextContent = function (el, content) {
    if (el.styleSheet) {
      el.styleSheet.cssText = content;
    } else {
      el.textContent = content;
    }
  };

  /**
   * @file dom-data.js
   * @module dom-data
   */

  /**
   * Element Data Store.
   *
   * Allows for binding data to an element without putting it directly on the
   * element. Ex. Event listeners are stored here.
   * (also from jsninja.com, slightly modified and updated for closure compiler)
   *
   * @type {Object}
   * @private
   */
  var DomData = new WeakMap();

  /**
   * @file guid.js
   * @module guid
   */

  // Default value for GUIDs. This allows us to reset the GUID counter in tests.
  //
  // The initial GUID is 3 because some users have come to rely on the first
  // default player ID ending up as `vjs_video_3`.
  //
  // See: https://github.com/videojs/video.js/pull/6216
  const _initialGuid = 3;

  /**
   * Unique ID for an element or function
   *
   * @type {Number}
   */
  let _guid = _initialGuid;

  /**
   * Get a unique auto-incrementing ID by number that has not been returned before.
   *
   * @return {number}
   *         A new unique ID.
   */
  function newGUID() {
    return _guid++;
  }

  /**
   * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
   * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
   * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
   * robust as jquery's, so there's probably some differences.
   *
   * @file events.js
   * @module events
   */

  /**
   * Clean up the listener cache and dispatchers
   *
   * @param {Element|Object} elem
   *        Element to clean up
   *
   * @param {string} type
   *        Type of event to clean up
   */
  function _cleanUpEvents(elem, type) {
    if (!DomData.has(elem)) {
      return;
    }
    const data = DomData.get(elem);

    // Remove the events of a particular type if there are none left
    if (data.handlers[type].length === 0) {
      delete data.handlers[type];
      // data.handlers[type] = null;
      // Setting to null was causing an error with data.handlers

      // Remove the meta-handler from the element
      if (elem.removeEventListener) {
        elem.removeEventListener(type, data.dispatcher, false);
      } else if (elem.detachEvent) {
        elem.detachEvent('on' + type, data.dispatcher);
      }
    }

    // Remove the events object if there are no types left
    if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
      delete data.handlers;
      delete data.dispatcher;
      delete data.disabled;
    }

    // Finally remove the element data if there is no data left
    if (Object.getOwnPropertyNames(data).length === 0) {
      DomData.delete(elem);
    }
  }

  /**
   * Loops through an array of event types and calls the requested method for each type.
   *
   * @param {Function} fn
   *        The event method we want to use.
   *
   * @param {Element|Object} elem
   *        Element or object to bind listeners to
   *
   * @param {string[]} types
   *        Type of event to bind to.
   *
   * @param {Function} callback
   *        Event listener.
   */
  function _handleMultipleEvents(fn, elem, types, callback) {
    types.forEach(function (type) {
      // Call the event method for each one of the types
      fn(elem, type, callback);
    });
  }

  /**
   * Fix a native event to have standard property values
   *
   * @param {Object} event
   *        Event object to fix.
   *
   * @return {Object}
   *         Fixed event object.
   */
  function fixEvent(event) {
    if (event.fixed_) {
      return event;
    }
    function returnTrue() {
      return true;
    }
    function returnFalse() {
      return false;
    }

    // Test if fixing up is needed
    // Used to check if !event.stopPropagation instead of isPropagationStopped
    // But native events return true for stopPropagation, but don't have
    // other expected methods like isPropagationStopped. Seems to be a problem
    // with the Javascript Ninja code. So we're just overriding all events now.
    if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {
      const old = event || window__default["default"].event;
      event = {};
      // Clone the old object so that we can modify the values event = {};
      // IE8 Doesn't like when you mess with native event properties
      // Firefox returns false for event.hasOwnProperty('type') and other props
      //  which makes copying more difficult.

      // TODO: Probably best to create an allowlist of event props
      const deprecatedProps = ['layerX', 'layerY', 'keyLocation', 'path', 'webkitMovementX', 'webkitMovementY', 'mozPressure', 'mozInputSource'];
      for (const key in old) {
        // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
        // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
        // and webkitMovementX/Y
        // Lighthouse complains if Event.path is copied
        if (!deprecatedProps.includes(key)) {
          // Chrome 32+ warns if you try to copy deprecated returnValue, but
          // we still want to if preventDefault isn't supported (IE8).
          if (!(key === 'returnValue' && old.preventDefault)) {
            event[key] = old[key];
          }
        }
      }

      // The event occurred on this element
      if (!event.target) {
        event.target = event.srcElement || document__default["default"];
      }

      // Handle which other element the event is related to
      if (!event.relatedTarget) {
        event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
      }

      // Stop the default browser action
      event.preventDefault = function () {
        if (old.preventDefault) {
          old.preventDefault();
        }
        event.returnValue = false;
        old.returnValue = false;
        event.defaultPrevented = true;
      };
      event.defaultPrevented = false;

      // Stop the event from bubbling
      event.stopPropagation = function () {
        if (old.stopPropagation) {
          old.stopPropagation();
        }
        event.cancelBubble = true;
        old.cancelBubble = true;
        event.isPropagationStopped = returnTrue;
      };
      event.isPropagationStopped = returnFalse;

      // Stop the event from bubbling and executing other handlers
      event.stopImmediatePropagation = function () {
        if (old.stopImmediatePropagation) {
          old.stopImmediatePropagation();
        }
        event.isImmediatePropagationStopped = returnTrue;
        event.stopPropagation();
      };
      event.isImmediatePropagationStopped = returnFalse;

      // Handle mouse position
      if (event.clientX !== null && event.clientX !== undefined) {
        const doc = document__default["default"].documentElement;
        const body = document__default["default"].body;
        event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
      }

      // Handle key presses
      event.which = event.charCode || event.keyCode;

      // Fix button for mouse clicks:
      // 0 == left; 1 == middle; 2 == right
      if (event.button !== null && event.button !== undefined) {
        // The following is disabled because it does not pass videojs-standard
        // and... yikes.
        /* eslint-disable */
        event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
        /* eslint-enable */
      }
    }
    event.fixed_ = true;
    // Returns fixed-up instance
    return event;
  }

  /**
   * Whether passive event listeners are supported
   */
  let _supportsPassive;
  const supportsPassive = function () {
    if (typeof _supportsPassive !== 'boolean') {
      _supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, 'passive', {
          get() {
            _supportsPassive = true;
          }
        });
        window__default["default"].addEventListener('test', null, opts);
        window__default["default"].removeEventListener('test', null, opts);
      } catch (e) {
        // disregard
      }
    }
    return _supportsPassive;
  };

  /**
   * Touch events Chrome expects to be passive
   */
  const passiveEvents = ['touchstart', 'touchmove'];

  /**
   * Add an event listener to element
   * It stores the handler function in a separate cache object
   * and adds a generic handler to the element's event,
   * along with a unique id (guid) to the element.
   *
   * @param {Element|Object} elem
   *        Element or object to bind listeners to
   *
   * @param {string|string[]} type
   *        Type of event to bind to.
   *
   * @param {Function} fn
   *        Event listener.
   */
  function on(elem, type, fn) {
    if (Array.isArray(type)) {
      return _handleMultipleEvents(on, elem, type, fn);
    }
    if (!DomData.has(elem)) {
      DomData.set(elem, {});
    }
    const data = DomData.get(elem);

    // We need a place to store all our handler data
    if (!data.handlers) {
      data.handlers = {};
    }
    if (!data.handlers[type]) {
      data.handlers[type] = [];
    }
    if (!fn.guid) {
      fn.guid = newGUID();
    }
    data.handlers[type].push(fn);
    if (!data.dispatcher) {
      data.disabled = false;
      data.dispatcher = function (event, hash) {
        if (data.disabled) {
          return;
        }
        event = fixEvent(event);
        const handlers = data.handlers[event.type];
        if (handlers) {
          // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
          const handlersCopy = handlers.slice(0);
          for (let m = 0, n = handlersCopy.length; m < n; m++) {
            if (event.isImmediatePropagationStopped()) {
              break;
            } else {
              try {
                handlersCopy[m].call(elem, event, hash);
              } catch (e) {
                log.error(e);
              }
            }
          }
        }
      };
    }
    if (data.handlers[type].length === 1) {
      if (elem.addEventListener) {
        let options = false;
        if (supportsPassive() && passiveEvents.indexOf(type) > -1) {
          options = {
            passive: true
          };
        }
        elem.addEventListener(type, data.dispatcher, options);
      } else if (elem.attachEvent) {
        elem.attachEvent('on' + type, data.dispatcher);
      }
    }
  }

  /**
   * Removes event listeners from an element
   *
   * @param {Element|Object} elem
   *        Object to remove listeners from.
   *
   * @param {string|string[]} [type]
   *        Type of listener to remove. Don't include to remove all events from element.
   *
   * @param {Function} [fn]
   *        Specific listener to remove. Don't include to remove listeners for an event
   *        type.
   */
  function off(elem, type, fn) {
    // Don't want to add a cache object through getElData if not needed
    if (!DomData.has(elem)) {
      return;
    }
    const data = DomData.get(elem);

    // If no events exist, nothing to unbind
    if (!data.handlers) {
      return;
    }
    if (Array.isArray(type)) {
      return _handleMultipleEvents(off, elem, type, fn);
    }

    // Utility function
    const removeType = function (el, t) {
      data.handlers[t] = [];
      _cleanUpEvents(el, t);
    };

    // Are we removing all bound events?
    if (type === undefined) {
      for (const t in data.handlers) {
        if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {
          removeType(elem, t);
        }
      }
      return;
    }
    const handlers = data.handlers[type];

    // If no handlers exist, nothing to unbind
    if (!handlers) {
      return;
    }

    // If no listener was provided, remove all listeners for type
    if (!fn) {
      removeType(elem, type);
      return;
    }

    // We're only removing a single handler
    if (fn.guid) {
      for (let n = 0; n < handlers.length; n++) {
        if (handlers[n].guid === fn.guid) {
          handlers.splice(n--, 1);
        }
      }
    }
    _cleanUpEvents(elem, type);
  }

  /**
   * Trigger an event for an element
   *
   * @param {Element|Object} elem
   *        Element to trigger an event on
   *
   * @param {EventTarget~Event|string} event
   *        A string (the type) or an event object with a type attribute
   *
   * @param {Object} [hash]
   *        data hash to pass along with the event
   *
   * @return {boolean|undefined}
   *         Returns the opposite of `defaultPrevented` if default was
   *         prevented. Otherwise, returns `undefined`
   */
  function trigger(elem, event, hash) {
    // Fetches element data and a reference to the parent (for bubbling).
    // Don't want to add a data object to cache for every parent,
    // so checking hasElData first.
    const elemData = DomData.has(elem) ? DomData.get(elem) : {};
    const parent = elem.parentNode || elem.ownerDocument;
    // type = event.type || event,
    // handler;

    // If an event name was passed as a string, creates an event out of it
    if (typeof event === 'string') {
      event = {
        type: event,
        target: elem
      };
    } else if (!event.target) {
      event.target = elem;
    }

    // Normalizes the event properties.
    event = fixEvent(event);

    // If the passed element has a dispatcher, executes the established handlers.
    if (elemData.dispatcher) {
      elemData.dispatcher.call(elem, event, hash);
    }

    // Unless explicitly stopped or the event does not bubble (e.g. media events)
    // recursively calls this function to bubble the event up the DOM.
    if (parent && !event.isPropagationStopped() && event.bubbles === true) {
      trigger.call(null, parent, event, hash);

      // If at the top of the DOM, triggers the default action unless disabled.
    } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {
      if (!DomData.has(event.target)) {
        DomData.set(event.target, {});
      }
      const targetData = DomData.get(event.target);

      // Checks if the target has a default action for this event.
      if (event.target[event.type]) {
        // Temporarily disables event dispatching on the target as we have already executed the handler.
        targetData.disabled = true;
        // Executes the default action.
        if (typeof event.target[event.type] === 'function') {
          event.target[event.type]();
        }
        // Re-enables event dispatching.
        targetData.disabled = false;
      }
    }

    // Inform the triggerer if the default was prevented by returning false
    return !event.defaultPrevented;
  }

  /**
   * Trigger a listener only once for an event.
   *
   * @param {Element|Object} elem
   *        Element or object to bind to.
   *
   * @param {string|string[]} type
   *        Name/type of event
   *
   * @param {Event~EventListener} fn
   *        Event listener function
   */
  function one(elem, type, fn) {
    if (Array.isArray(type)) {
      return _handleMultipleEvents(one, elem, type, fn);
    }
    const func = function () {
      off(elem, type, func);
      fn.apply(this, arguments);
    };

    // copy the guid to the new function so it can removed using the original function's ID
    func.guid = fn.guid = fn.guid || newGUID();
    on(elem, type, func);
  }

  /**
   * Trigger a listener only once and then turn if off for all
   * configured events
   *
   * @param {Element|Object} elem
   *        Element or object to bind to.
   *
   * @param {string|string[]} type
   *        Name/type of event
   *
   * @param {Event~EventListener} fn
   *        Event listener function
   */
  function any(elem, type, fn) {
    const func = function () {
      off(elem, type, func);
      fn.apply(this, arguments);
    };

    // copy the guid to the new function so it can removed using the original function's ID
    func.guid = fn.guid = fn.guid || newGUID();

    // multiple ons, but one off for everything
    on(elem, type, func);
  }

  var Events = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fixEvent: fixEvent,
    on: on,
    off: off,
    trigger: trigger,
    one: one,
    any: any
  });

  /**
   * @file fn.js
   * @module fn
   */
  const UPDATE_REFRESH_INTERVAL = 30;

  /**
   * A private, internal-only function for changing the context of a function.
   *
   * It also stores a unique id on the function so it can be easily removed from
   * events.
   *
   * @private
   * @function
   * @param    {*} context
   *           The object to bind as scope.
   *
   * @param    {Function} fn
   *           The function to be bound to a scope.
   *
   * @param    {number} [uid]
   *           An optional unique ID for the function to be set
   *
   * @return   {Function}
   *           The new function that will be bound into the context given
   */
  const bind_ = function (context, fn, uid) {
    // Make sure the function has a unique ID
    if (!fn.guid) {
      fn.guid = newGUID();
    }

    // Create the new function that changes the context
    const bound = fn.bind(context);

    // Allow for the ability to individualize this function
    // Needed in the case where multiple objects might share the same prototype
    // IF both items add an event listener with the same function, then you try to remove just one
    // it will remove both because they both have the same guid.
    // when using this, you need to use the bind method when you remove the listener as well.
    // currently used in text tracks
    bound.guid = uid ? uid + '_' + fn.guid : fn.guid;
    return bound;
  };

  /**
   * Wraps the given function, `fn`, with a new function that only invokes `fn`
   * at most once per every `wait` milliseconds.
   *
   * @function
   * @param    {Function} fn
   *           The function to be throttled.
   *
   * @param    {number}   wait
   *           The number of milliseconds by which to throttle.
   *
   * @return   {Function}
   */
  const throttle = function (fn, wait) {
    let last = window__default["default"].performance.now();
    const throttled = function (...args) {
      const now = window__default["default"].performance.now();
      if (now - last >= wait) {
        fn(...args);
        last = now;
      }
    };
    return throttled;
  };

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked.
   *
   * Inspired by lodash and underscore implementations.
   *
   * @function
   * @param    {Function} func
   *           The function to wrap with debounce behavior.
   *
   * @param    {number} wait
   *           The number of milliseconds to wait after the last invocation.
   *
   * @param    {boolean} [immediate]
   *           Whether or not to invoke the function immediately upon creation.
   *
   * @param    {Object} [context=window]
   *           The "context" in which the debounced function should debounce. For
   *           example, if this function should be tied to a Video.js player,
   *           the player can be passed here. Alternatively, defaults to the
   *           global `window` object.
   *
   * @return   {Function}
   *           A debounced function.
   */
  const debounce = function (func, wait, immediate, context = window__default["default"]) {
    let timeout;
    const cancel = () => {
      context.clearTimeout(timeout);
      timeout = null;
    };

    /* eslint-disable consistent-this */
    const debounced = function () {
      const self = this;
      const args = arguments;
      let later = function () {
        timeout = null;
        later = null;
        if (!immediate) {
          func.apply(self, args);
        }
      };
      if (!timeout && immediate) {
        func.apply(self, args);
      }
      context.clearTimeout(timeout);
      timeout = context.setTimeout(later, wait);
    };
    /* eslint-enable consistent-this */

    debounced.cancel = cancel;
    return debounced;
  };

  var Fn = /*#__PURE__*/Object.freeze({
    __proto__: null,
    UPDATE_REFRESH_INTERVAL: UPDATE_REFRESH_INTERVAL,
    bind_: bind_,
    throttle: throttle,
    debounce: debounce
  });

  /**
   * @file src/js/event-target.js
   */
  let EVENT_MAP;

  /**
   * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It
   * adds shorthand functions that wrap around lengthy functions. For example:
   * the `on` function is a wrapper around `addEventListener`.
   *
   * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}
   * @class EventTarget
   */
  class EventTarget {
    /**
     * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
     * function that will get called when an event with a certain name gets triggered.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to call with `EventTarget`s
     */
    on(type, fn) {
      // Remove the addEventListener alias before calling Events.on
      // so we don't get into an infinite type loop
      const ael = this.addEventListener;
      this.addEventListener = () => {};
      on(this, type, fn);
      this.addEventListener = ael;
    }
    /**
     * Removes an `event listener` for a specific event from an instance of `EventTarget`.
     * This makes it so that the `event listener` will no longer get called when the
     * named event happens.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to remove.
     */
    off(type, fn) {
      off(this, type, fn);
    }
    /**
     * This function will add an `event listener` that gets triggered only once. After the
     * first trigger it will get removed. This is like adding an `event listener`
     * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to be called once for each event name.
     */
    one(type, fn) {
      // Remove the addEventListener aliasing Events.on
      // so we don't get into an infinite type loop
      const ael = this.addEventListener;
      this.addEventListener = () => {};
      one(this, type, fn);
      this.addEventListener = ael;
    }
    /**
     * This function will add an `event listener` that gets triggered only once and is
     * removed from all events. This is like adding an array of `event listener`s
     * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the
     * first time it is triggered.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to be called once for each event name.
     */
    any(type, fn) {
      // Remove the addEventListener aliasing Events.on
      // so we don't get into an infinite type loop
      const ael = this.addEventListener;
      this.addEventListener = () => {};
      any(this, type, fn);
      this.addEventListener = ael;
    }
    /**
     * This function causes an event to happen. This will then cause any `event listeners`
     * that are waiting for that event, to get called. If there are no `event listeners`
     * for an event then nothing will happen.
     *
     * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
     * Trigger will also call the `on` + `uppercaseEventName` function.
     *
     * Example:
     * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
     * `onClick` if it exists.
     *
     * @param {string|EventTarget~Event|Object} event
     *        The name of the event, an `Event`, or an object with a key of type set to
     *        an event name.
     */
    trigger(event) {
      const type = event.type || event;

      // deprecation
      // In a future version we should default target to `this`
      // similar to how we default the target to `elem` in
      // `Events.trigger`. Right now the default `target` will be
      // `document` due to the `Event.fixEvent` call.
      if (typeof event === 'string') {
        event = {
          type
        };
      }
      event = fixEvent(event);
      if (this.allowedEvents_[type] && this['on' + type]) {
        this['on' + type](event);
      }
      trigger(this, event);
    }
    queueTrigger(event) {
      // only set up EVENT_MAP if it'll be used
      if (!EVENT_MAP) {
        EVENT_MAP = new Map();
      }
      const type = event.type || event;
      let map = EVENT_MAP.get(this);
      if (!map) {
        map = new Map();
        EVENT_MAP.set(this, map);
      }
      const oldTimeout = map.get(type);
      map.delete(type);
      window__default["default"].clearTimeout(oldTimeout);
      const timeout = window__default["default"].setTimeout(() => {
        map.delete(type);
        // if we cleared out all timeouts for the current target, delete its map
        if (map.size === 0) {
          map = null;
          EVENT_MAP.delete(this);
        }
        this.trigger(event);
      }, 0);
      map.set(type, timeout);
    }
  }

  /**
   * A Custom DOM event.
   *
   * @typedef {CustomEvent} Event
   * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}
   */

  /**
   * All event listeners should follow the following format.
   *
   * @callback EventListener
   * @this {EventTarget}
   *
   * @param {Event} event
   *        the event that triggered this function
   *
   * @param {Object} [hash]
   *        hash of data sent during the event
   */

  /**
   * An object containing event names as keys and booleans as values.
   *
   * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}
   *         will have extra functionality. See that function for more information.
   *
   * @property EventTarget.prototype.allowedEvents_
   * @protected
   */
  EventTarget.prototype.allowedEvents_ = {};

  /**
   * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic
   * the standard DOM API.
   *
   * @function
   * @see {@link EventTarget#on}
   */
  EventTarget.prototype.addEventListener = EventTarget.prototype.on;

  /**
   * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic
   * the standard DOM API.
   *
   * @function
   * @see {@link EventTarget#off}
   */
  EventTarget.prototype.removeEventListener = EventTarget.prototype.off;

  /**
   * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic
   * the standard DOM API.
   *
   * @function
   * @see {@link EventTarget#trigger}
   */
  EventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;

  /**
   * @file mixins/evented.js
   * @module evented
   */
  const objName = obj => {
    if (typeof obj.name === 'function') {
      return obj.name();
    }
    if (typeof obj.name === 'string') {
      return obj.name;
    }
    if (obj.name_) {
      return obj.name_;
    }
    if (obj.constructor && obj.constructor.name) {
      return obj.constructor.name;
    }
    return typeof obj;
  };

  /**
   * Returns whether or not an object has had the evented mixin applied.
   *
   * @param  {Object} object
   *         An object to test.
   *
   * @return {boolean}
   *         Whether or not the object appears to be evented.
   */
  const isEvented = object => object instanceof EventTarget || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(k => typeof object[k] === 'function');

  /**
   * Adds a callback to run after the evented mixin applied.
   *
   * @param  {Object} target
   *         An object to Add
   * @param  {Function} callback
   *         The callback to run.
   */
  const addEventedCallback = (target, callback) => {
    if (isEvented(target)) {
      callback();
    } else {
      if (!target.eventedCallbacks) {
        target.eventedCallbacks = [];
      }
      target.eventedCallbacks.push(callback);
    }
  };

  /**
   * Whether a value is a valid event type - non-empty string or array.
   *
   * @private
   * @param  {string|Array} type
   *         The type value to test.
   *
   * @return {boolean}
   *         Whether or not the type is a valid event type.
   */
  const isValidEventType = type =>
  // The regex here verifies that the `type` contains at least one non-
  // whitespace character.
  typeof type === 'string' && /\S/.test(type) || Array.isArray(type) && !!type.length;

  /**
   * Validates a value to determine if it is a valid event target. Throws if not.
   *
   * @private
   * @throws {Error}
   *         If the target does not appear to be a valid event target.
   *
   * @param  {Object} target
   *         The object to test.
   *
   * @param  {Object} obj
   *         The evented object we are validating for
   *
   * @param  {string} fnName
   *         The name of the evented mixin function that called this.
   */
  const validateTarget = (target, obj, fnName) => {
    if (!target || !target.nodeName && !isEvented(target)) {
      throw new Error(`Invalid target for ${objName(obj)}#${fnName}; must be a DOM node or evented object.`);
    }
  };

  /**
   * Validates a value to determine if it is a valid event target. Throws if not.
   *
   * @private
   * @throws {Error}
   *         If the type does not appear to be a valid event type.
   *
   * @param  {string|Array} type
   *         The type to test.
   *
   * @param  {Object} obj
  *         The evented object we are validating for
   *
   * @param  {string} fnName
   *         The name of the evented mixin function that called this.
   */
  const validateEventType = (type, obj, fnName) => {
    if (!isValidEventType(type)) {
      throw new Error(`Invalid event type for ${objName(obj)}#${fnName}; must be a non-empty string or array.`);
    }
  };

  /**
   * Validates a value to determine if it is a valid listener. Throws if not.
   *
   * @private
   * @throws {Error}
   *         If the listener is not a function.
   *
   * @param  {Function} listener
   *         The listener to test.
   *
   * @param  {Object} obj
   *         The evented object we are validating for
   *
   * @param  {string} fnName
   *         The name of the evented mixin function that called this.
   */
  const validateListener = (listener, obj, fnName) => {
    if (typeof listener !== 'function') {
      throw new Error(`Invalid listener for ${objName(obj)}#${fnName}; must be a function.`);
    }
  };

  /**
   * Takes an array of arguments given to `on()` or `one()`, validates them, and
   * normalizes them into an object.
   *
   * @private
   * @param  {Object} self
   *         The evented object on which `on()` or `one()` was called. This
   *         object will be bound as the `this` value for the listener.
   *
   * @param  {Array} args
   *         An array of arguments passed to `on()` or `one()`.
   *
   * @param  {string} fnName
   *         The name of the evented mixin function that called this.
   *
   * @return {Object}
   *         An object containing useful values for `on()` or `one()` calls.
   */
  const normalizeListenArgs = (self, args, fnName) => {
    // If the number of arguments is less than 3, the target is always the
    // evented object itself.
    const isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;
    let target;
    let type;
    let listener;
    if (isTargetingSelf) {
      target = self.eventBusEl_;

      // Deal with cases where we got 3 arguments, but we are still listening to
      // the evented object itself.
      if (args.length >= 3) {
        args.shift();
      }
      [type, listener] = args;
    } else {
      // This was `[target, type, listener] = args;` but this block needs more than
      // one statement to produce minified output compatible with Chrome 53.
      // See https://github.com/videojs/video.js/pull/8810
      target = args[0];
      type = args[1];
      listener = args[2];
    }
    validateTarget(target, self, fnName);
    validateEventType(type, self, fnName);
    validateListener(listener, self, fnName);
    listener = bind_(self, listener);
    return {
      isTargetingSelf,
      target,
      type,
      listener
    };
  };

  /**
   * Adds the listener to the event type(s) on the target, normalizing for
   * the type of target.
   *
   * @private
   * @param  {Element|Object} target
   *         A DOM node or evented object.
   *
   * @param  {string} method
   *         The event binding method to use ("on" or "one").
   *
   * @param  {string|Array} type
   *         One or more event type(s).
   *
   * @param  {Function} listener
   *         A listener function.
   */
  const listen = (target, method, type, listener) => {
    validateTarget(target, target, method);
    if (target.nodeName) {
      Events[method](target, type, listener);
    } else {
      target[method](type, listener);
    }
  };

  /**
   * Contains methods that provide event capabilities to an object which is passed
   * to {@link module:evented|evented}.
   *
   * @mixin EventedMixin
   */
  const EventedMixin = {
    /**
     * Add a listener to an event (or events) on this object or another evented
     * object.
     *
     * @param  {string|Array|Element|Object} targetOrType
     *         If this is a string or array, it represents the event type(s)
     *         that will trigger the listener.
     *
     *         Another evented object can be passed here instead, which will
     *         cause the listener to listen for events on _that_ object.
     *
     *         In either case, the listener's `this` value will be bound to
     *         this object.
     *
     * @param  {string|Array|Function} typeOrListener
     *         If the first argument was a string or array, this should be the
     *         listener function. Otherwise, this is a string or array of event
     *         type(s).
     *
     * @param  {Function} [listener]
     *         If the first argument was another evented object, this will be
     *         the listener function.
     */
    on(...args) {
      const {
        isTargetingSelf,
        target,
        type,
        listener
      } = normalizeListenArgs(this, args, 'on');
      listen(target, 'on', type, listener);

      // If this object is listening to another evented object.
      if (!isTargetingSelf) {
        // If this object is disposed, remove the listener.
        const removeListenerOnDispose = () => this.off(target, type, listener);

        // Use the same function ID as the listener so we can remove it later it
        // using the ID of the original listener.
        removeListenerOnDispose.guid = listener.guid;

        // Add a listener to the target's dispose event as well. This ensures
        // that if the target is disposed BEFORE this object, we remove the
        // removal listener that was just added. Otherwise, we create a memory leak.
        const removeRemoverOnTargetDispose = () => this.off('dispose', removeListenerOnDispose);

        // Use the same function ID as the listener so we can remove it later
        // it using the ID of the original listener.
        removeRemoverOnTargetDispose.guid = listener.guid;
        listen(this, 'on', 'dispose', removeListenerOnDispose);
        listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);
      }
    },
    /**
     * Add a listener to an event (or events) on this object or another evented
     * object. The listener will be called once per event and then removed.
     *
     * @param  {string|Array|Element|Object} targetOrType
     *         If this is a string or array, it represents the event type(s)
     *         that will trigger the listener.
     *
     *         Another evented object can be passed here instead, which will
     *         cause the listener to listen for events on _that_ object.
     *
     *         In either case, the listener's `this` value will be bound to
     *         this object.
     *
     * @param  {string|Array|Function} typeOrListener
     *         If the first argument was a string or array, this should be the
     *         listener function. Otherwise, this is a string or array of event
     *         type(s).
     *
     * @param  {Function} [listener]
     *         If the first argument was another evented object, this will be
     *         the listener function.
     */
    one(...args) {
      const {
        isTargetingSelf,
        target,
        type,
        listener
      } = normalizeListenArgs(this, args, 'one');

      // Targeting this evented object.
      if (isTargetingSelf) {
        listen(target, 'one', type, listener);

        // Targeting another evented object.
      } else {
        // TODO: This wrapper is incorrect! It should only
        //       remove the wrapper for the event type that called it.
        //       Instead all listeners are removed on the first trigger!
        //       see https://github.com/videojs/video.js/issues/5962
        const wrapper = (...largs) => {
          this.off(target, type, wrapper);
          listener.apply(null, largs);
        };

        // Use the same function ID as the listener so we can remove it later
        // it using the ID of the original listener.
        wrapper.guid = listener.guid;
        listen(target, 'one', type, wrapper);
      }
    },
    /**
     * Add a listener to an event (or events) on this object or another evented
     * object. The listener will only be called once for the first event that is triggered
     * then removed.
     *
     * @param  {string|Array|Element|Object} targetOrType
     *         If this is a string or array, it represents the event type(s)
     *         that will trigger the listener.
     *
     *         Another evented object can be passed here instead, which will
     *         cause the listener to listen for events on _that_ object.
     *
     *         In either case, the listener's `this` value will be bound to
     *         this object.
     *
     * @param  {string|Array|Function} typeOrListener
     *         If the first argument was a string or array, this should be the
     *         listener function. Otherwise, this is a string or array of event
     *         type(s).
     *
     * @param  {Function} [listener]
     *         If the first argument was another evented object, this will be
     *         the listener function.
     */
    any(...args) {
      const {
        isTargetingSelf,
        target,
        type,
        listener
      } = normalizeListenArgs(this, args, 'any');

      // Targeting this evented object.
      if (isTargetingSelf) {
        listen(target, 'any', type, listener);

        // Targeting another evented object.
      } else {
        const wrapper = (...largs) => {
          this.off(target, type, wrapper);
          listener.apply(null, largs);
        };

        // Use the same function ID as the listener so we can remove it later
        // it using the ID of the original listener.
        wrapper.guid = listener.guid;
        listen(target, 'any', type, wrapper);
      }
    },
    /**
     * Removes listener(s) from event(s) on an evented object.
     *
     * @param  {string|Array|Element|Object} [targetOrType]
     *         If this is a string or array, it represents the event type(s).
     *
     *         Another evented object can be passed here instead, in which case
     *         ALL 3 arguments are _required_.
     *
     * @param  {string|Array|Function} [typeOrListener]
     *         If the first argument was a string or array, this may be the
     *         listener function. Otherwise, this is a string or array of event
     *         type(s).
     *
     * @param  {Function} [listener]
     *         If the first argument was another evented object, this will be
     *         the listener function; otherwise, _all_ listeners bound to the
     *         event type(s) will be removed.
     */
    off(targetOrType, typeOrListener, listener) {
      // Targeting this evented object.
      if (!targetOrType || isValidEventType(targetOrType)) {
        off(this.eventBusEl_, targetOrType, typeOrListener);

        // Targeting another evented object.
      } else {
        const target = targetOrType;
        const type = typeOrListener;

        // Fail fast and in a meaningful way!
        validateTarget(target, this, 'off');
        validateEventType(type, this, 'off');
        validateListener(listener, this, 'off');

        // Ensure there's at least a guid, even if the function hasn't been used
        listener = bind_(this, listener);

        // Remove the dispose listener on this evented object, which was given
        // the same guid as the event listener in on().
        this.off('dispose', listener);
        if (target.nodeName) {
          off(target, type, listener);
          off(target, 'dispose', listener);
        } else if (isEvented(target)) {
          target.off(type, listener);
          target.off('dispose', listener);
        }
      }
    },
    /**
     * Fire an event on this evented object, causing its listeners to be called.
     *
     * @param   {string|Object} event
     *          An event type or an object with a type property.
     *
     * @param   {Object} [hash]
     *          An additional object to pass along to listeners.
     *
     * @return {boolean}
     *          Whether or not the default behavior was prevented.
     */
    trigger(event, hash) {
      validateTarget(this.eventBusEl_, this, 'trigger');
      const type = event && typeof event !== 'string' ? event.type : event;
      if (!isValidEventType(type)) {
        throw new Error(`Invalid event type for ${objName(this)}#trigger; ` + 'must be a non-empty string or object with a type key that has a non-empty value.');
      }
      return trigger(this.eventBusEl_, event, hash);
    }
  };

  /**
   * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.
   *
   * @param  {Object} target
   *         The object to which to add event methods.
   *
   * @param  {Object} [options={}]
   *         Options for customizing the mixin behavior.
   *
   * @param  {string} [options.eventBusKey]
   *         By default, adds a `eventBusEl_` DOM element to the target object,
   *         which is used as an event bus. If the target object already has a
   *         DOM element that should be used, pass its key here.
   *
   * @return {Object}
   *         The target object.
   */
  function evented(target, options = {}) {
    const {
      eventBusKey
    } = options;

    // Set or create the eventBusEl_.
    if (eventBusKey) {
      if (!target[eventBusKey].nodeName) {
        throw new Error(`The eventBusKey "${eventBusKey}" does not refer to an element.`);
      }
      target.eventBusEl_ = target[eventBusKey];
    } else {
      target.eventBusEl_ = createEl('span', {
        className: 'vjs-event-bus'
      });
    }
    Object.assign(target, EventedMixin);
    if (target.eventedCallbacks) {
      target.eventedCallbacks.forEach(callback => {
        callback();
      });
    }

    // When any evented object is disposed, it removes all its listeners.
    target.on('dispose', () => {
      target.off();
      [target, target.el_, target.eventBusEl_].forEach(function (val) {
        if (val && DomData.has(val)) {
          DomData.delete(val);
        }
      });
      window__default["default"].setTimeout(() => {
        target.eventBusEl_ = null;
      }, 0);
    });
    return target;
  }

  /**
   * @file mixins/stateful.js
   * @module stateful
   */

  /**
   * Contains methods that provide statefulness to an object which is passed
   * to {@link module:stateful}.
   *
   * @mixin StatefulMixin
   */
  const StatefulMixin = {
    /**
     * A hash containing arbitrary keys and values representing the state of
     * the object.
     *
     * @type {Object}
     */
    state: {},
    /**
     * Set the state of an object by mutating its
     * {@link module:stateful~StatefulMixin.state|state} object in place.
     *
     * @fires   module:stateful~StatefulMixin#statechanged
     * @param   {Object|Function} stateUpdates
     *          A new set of properties to shallow-merge into the plugin state.
     *          Can be a plain object or a function returning a plain object.
     *
     * @return {Object|undefined}
     *          An object containing changes that occurred. If no changes
     *          occurred, returns `undefined`.
     */
    setState(stateUpdates) {
      // Support providing the `stateUpdates` state as a function.
      if (typeof stateUpdates === 'function') {
        stateUpdates = stateUpdates();
      }
      let changes;
      each(stateUpdates, (value, key) => {
        // Record the change if the value is different from what's in the
        // current state.
        if (this.state[key] !== value) {
          changes = changes || {};
          changes[key] = {
            from: this.state[key],
            to: value
          };
        }
        this.state[key] = value;
      });

      // Only trigger "statechange" if there were changes AND we have a trigger
      // function. This allows us to not require that the target object be an
      // evented object.
      if (changes && isEvented(this)) {
        /**
         * An event triggered on an object that is both
         * {@link module:stateful|stateful} and {@link module:evented|evented}
         * indicating that its state has changed.
         *
         * @event    module:stateful~StatefulMixin#statechanged
         * @type     {Object}
         * @property {Object} changes
         *           A hash containing the properties that were changed and
         *           the values they were changed `from` and `to`.
         */
        this.trigger({
          changes,
          type: 'statechanged'
        });
      }
      return changes;
    }
  };

  /**
   * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target
   * object.
   *
   * If the target object is {@link module:evented|evented} and has a
   * `handleStateChanged` method, that method will be automatically bound to the
   * `statechanged` event on itself.
   *
   * @param   {Object} target
   *          The object to be made stateful.
   *
   * @param   {Object} [defaultState]
   *          A default set of properties to populate the newly-stateful object's
   *          `state` property.
   *
   * @return {Object}
   *          Returns the `target`.
   */
  function stateful(target, defaultState) {
    Object.assign(target, StatefulMixin);

    // This happens after the mixing-in because we need to replace the `state`
    // added in that step.
    target.state = Object.assign({}, target.state, defaultState);

    // Auto-bind the `handleStateChanged` method of the target object if it exists.
    if (typeof target.handleStateChanged === 'function' && isEvented(target)) {
      target.on('statechanged', target.handleStateChanged);
    }
    return target;
  }

  /**
   * @file str.js
   * @module to-lower-case
   */

  /**
   * Lowercase the first letter of a string.
   *
   * @param {string} string
   *        String to be lowercased
   *
   * @return {string}
   *         The string with a lowercased first letter
   */
  const toLowerCase = function (string) {
    if (typeof string !== 'string') {
      return string;
    }
    return string.replace(/./, w => w.toLowerCase());
  };

  /**
   * Uppercase the first letter of a string.
   *
   * @param {string} string
   *        String to be uppercased
   *
   * @return {string}
   *         The string with an uppercased first letter
   */
  const toTitleCase = function (string) {
    if (typeof string !== 'string') {
      return string;
    }
    return string.replace(/./, w => w.toUpperCase());
  };

  /**
   * Compares the TitleCase versions of the two strings for equality.
   *
   * @param {string} str1
   *        The first string to compare
   *
   * @param {string} str2
   *        The second string to compare
   *
   * @return {boolean}
   *         Whether the TitleCase versions of the strings are equal
   */
  const titleCaseEquals = function (str1, str2) {
    return toTitleCase(str1) === toTitleCase(str2);
  };

  var Str = /*#__PURE__*/Object.freeze({
    __proto__: null,
    toLowerCase: toLowerCase,
    toTitleCase: toTitleCase,
    titleCaseEquals: titleCaseEquals
  });

  /**
   * Player Component - Base class for all UI objects
   *
   * @file component.js
   */

  /** @import Player from './player' */

  /**
   * A callback to be called if and when the component is ready.
   * `this` will be the Component instance.
   *
   * @callback ReadyCallback
   * @returns  {void}
   */

  /**
   * Base class for all UI Components.
   * Components are UI objects which represent both a javascript object and an element
   * in the DOM. They can be children of other components, and can have
   * children themselves.
   *
   * Components can also use methods from {@link EventTarget}
   */
  class Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of component options.
     *
     * @param {Object[]} [options.children]
     *        An array of children objects to initialize this component with. Children objects have
     *        a name property that will be used if more than one component of the same type needs to be
     *        added.
     *
     * @param  {string} [options.className]
     *         A class or space separated list of classes to add the component
     *
     * @param {ReadyCallback} [ready]
     *        Function that gets called when the `Component` is ready.
     */
    constructor(player, options, ready) {
      // The component might be the player itself and we can't pass `this` to super
      if (!player && this.play) {
        this.player_ = player = this; // eslint-disable-line
      } else {
        this.player_ = player;
      }
      this.isDisposed_ = false;

      // Hold the reference to the parent component via `addChild` method
      this.parentComponent_ = null;

      // Make a copy of prototype.options_ to protect against overriding defaults
      this.options_ = merge({}, this.options_);

      // Updated options with supplied options
      options = this.options_ = merge(this.options_, options);

      // Get ID from options or options element if one is supplied
      this.id_ = options.id || options.el && options.el.id;

      // If there was no ID from the options, generate one
      if (!this.id_) {
        // Don't require the player ID function in the case of mock players
        const id = player && player.id && player.id() || 'no_player';
        this.id_ = `${id}_component_${newGUID()}`;
      }
      this.name_ = options.name || null;

      // Create element if one wasn't provided in options
      if (options.el) {
        this.el_ = options.el;
      } else if (options.createEl !== false) {
        this.el_ = this.createEl();
      }
      if (options.className && this.el_) {
        options.className.split(' ').forEach(c => this.addClass(c));
      }

      // Remove the placeholder event methods. If the component is evented, the
      // real methods are added next
      ['on', 'off', 'one', 'any', 'trigger'].forEach(fn => {
        this[fn] = undefined;
      });

      // if evented is anything except false, we want to mixin in evented
      if (options.evented !== false) {
        // Make this an evented object and use `el_`, if available, as its event bus
        evented(this, {
          eventBusKey: this.el_ ? 'el_' : null
        });
        this.handleLanguagechange = this.handleLanguagechange.bind(this);
        this.on(this.player_, 'languagechange', this.handleLanguagechange);
      }
      stateful(this, this.constructor.defaultState);
      this.children_ = [];
      this.childIndex_ = {};
      this.childNameIndex_ = {};
      this.setTimeoutIds_ = new Set();
      this.setIntervalIds_ = new Set();
      this.rafIds_ = new Set();
      this.namedRafs_ = new Map();
      this.clearingTimersOnDispose_ = false;

      // Add any child components in options
      if (options.initChildren !== false) {
        this.initChildren();
      }

      // Don't want to trigger ready here or it will go before init is actually
      // finished for all children that run this constructor
      this.ready(ready);
      if (options.reportTouchActivity !== false) {
        this.enableTouchActivity();
      }
    }

    // `on`, `off`, `one`, `any` and `trigger` are here so tsc includes them in definitions.
    // They are replaced or removed in the constructor

    /**
     * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
     * function that will get called when an event with a certain name gets triggered.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to call with `EventTarget`s
     */

    /**
     * Removes an `event listener` for a specific event from an instance of `EventTarget`.
     * This makes it so that the `event listener` will no longer get called when the
     * named event happens.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} [fn]
     *        The function to remove. If not specified, all listeners managed by Video.js will be removed.
     */

    /**
     * This function will add an `event listener` that gets triggered only once. After the
     * first trigger it will get removed. This is like adding an `event listener`
     * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to be called once for each event name.
     */

    /**
     * This function will add an `event listener` that gets triggered only once and is
     * removed from all events. This is like adding an array of `event listener`s
     * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the
     * first time it is triggered.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to be called once for each event name.
     */

    /**
     * This function causes an event to happen. This will then cause any `event listeners`
     * that are waiting for that event, to get called. If there are no `event listeners`
     * for an event then nothing will happen.
     *
     * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
     * Trigger will also call the `on` + `uppercaseEventName` function.
     *
     * Example:
     * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
     * `onClick` if it exists.
     *
     * @param {string|Event|Object} event
     *        The name of the event, an `Event`, or an object with a key of type set to
     *        an event name.
     *
     * @param {Object} [hash]
     *        Optionally extra argument to pass through to an event listener
     */

    /**
     * Dispose of the `Component` and all child components.
     *
     * @fires Component#dispose
     *
     * @param {Object} options
     * @param {Element} options.originalEl element with which to replace player element
     */
    dispose(options = {}) {
      // Bail out if the component has already been disposed.
      if (this.isDisposed_) {
        return;
      }
      if (this.readyQueue_) {
        this.readyQueue_.length = 0;
      }

      /**
       * Triggered when a `Component` is disposed.
       *
       * @event Component#dispose
       * @type {Event}
       *
       * @property {boolean} [bubbles=false]
       *           set to false so that the dispose event does not
       *           bubble up
       */
      this.trigger({
        type: 'dispose',
        bubbles: false
      });
      this.isDisposed_ = true;

      // Dispose all children.
      if (this.children_) {
        for (let i = this.children_.length - 1; i >= 0; i--) {
          if (this.children_[i].dispose) {
            this.children_[i].dispose();
          }
        }
      }

      // Delete child references
      this.children_ = null;
      this.childIndex_ = null;
      this.childNameIndex_ = null;
      this.parentComponent_ = null;
      if (this.el_) {
        // Remove element from DOM
        if (this.el_.parentNode) {
          if (options.restoreEl) {
            this.el_.parentNode.replaceChild(options.restoreEl, this.el_);
          } else {
            this.el_.parentNode.removeChild(this.el_);
          }
        }
        this.el_ = null;
      }

      // remove reference to the player after disposing of the element
      this.player_ = null;
    }

    /**
     * Determine whether or not this component has been disposed.
     *
     * @return {boolean}
     *         If the component has been disposed, will be `true`. Otherwise, `false`.
     */
    isDisposed() {
      return Boolean(this.isDisposed_);
    }

    /**
     * Return the {@link Player} that the `Component` has attached to.
     *
     * @return {Player}
     *         The player that this `Component` has attached to.
     */
    player() {
      return this.player_;
    }

    /**
     * Deep merge of options objects with new options.
     * > Note: When both `obj` and `options` contain properties whose values are objects.
     *         The two properties get merged using {@link module:obj.merge}
     *
     * @param {Object} obj
     *        The object that contains new options.
     *
     * @return {Object}
     *         A new object of `this.options_` and `obj` merged together.
     */
    options(obj) {
      if (!obj) {
        return this.options_;
      }
      this.options_ = merge(this.options_, obj);
      return this.options_;
    }

    /**
     * Get the `Component`s DOM element
     *
     * @return {Element}
     *         The DOM element for this `Component`.
     */
    el() {
      return this.el_;
    }

    /**
     * Create the `Component`s DOM element.
     *
     * @param {string} [tagName]
     *        Element's DOM node type. e.g. 'div'
     *
     * @param {Object} [properties]
     *        An object of properties that should be set.
     *
     * @param {Object} [attributes]
     *        An object of attributes that should be set.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl(tagName, properties, attributes) {
      return createEl(tagName, properties, attributes);
    }

    /**
     * Localize a string given the string in english.
     *
     * If tokens are provided, it'll try and run a simple token replacement on the provided string.
     * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.
     *
     * If a `defaultValue` is provided, it'll use that over `string`,
     * if a value isn't found in provided language files.
     * This is useful if you want to have a descriptive key for token replacement
     * but have a succinct localized string and not require `en.json` to be included.
     *
     * Currently, it is used for the progress bar timing.
     * ```js
     * {
     *   "progress bar timing: currentTime={1} duration={2}": "{1} of {2}"
     * }
     * ```
     * It is then used like so:
     * ```js
     * this.localize('progress bar timing: currentTime={1} duration{2}',
     *               [this.player_.currentTime(), this.player_.duration()],
     *               '{1} of {2}');
     * ```
     *
     * Which outputs something like: `01:23 of 24:56`.
     *
     *
     * @param {string} string
     *        The string to localize and the key to lookup in the language files.
     * @param {string[]} [tokens]
     *        If the current item has token replacements, provide the tokens here.
     * @param {string} [defaultValue]
     *        Defaults to `string`. Can be a default value to use for token replacement
     *        if the lookup key is needed to be separate.
     *
     * @return {string}
     *         The localized string or if no localization exists the english string.
     */
    localize(string, tokens, defaultValue = string) {
      const code = this.player_.language && this.player_.language();
      const languages = this.player_.languages && this.player_.languages();
      const language = languages && languages[code];
      const primaryCode = code && code.split('-')[0];
      const primaryLang = languages && languages[primaryCode];
      let localizedString = defaultValue;
      if (language && language[string]) {
        localizedString = language[string];
      } else if (primaryLang && primaryLang[string]) {
        localizedString = primaryLang[string];
      }
      if (tokens) {
        localizedString = localizedString.replace(/\{(\d+)\}/g, function (match, index) {
          const value = tokens[index - 1];
          let ret = value;
          if (typeof value === 'undefined') {
            ret = match;
          }
          return ret;
        });
      }
      return localizedString;
    }

    /**
     * Handles language change for the player in components. Should be overridden by sub-components.
     *
     * @abstract
     */
    handleLanguagechange() {}

    /**
     * Return the `Component`s DOM element. This is where children get inserted.
     * This will usually be the the same as the element returned in {@link Component#el}.
     *
     * @return {Element}
     *         The content element for this `Component`.
     */
    contentEl() {
      return this.contentEl_ || this.el_;
    }

    /**
     * Get this `Component`s ID
     *
     * @return {string}
     *         The id of this `Component`
     */
    id() {
      return this.id_;
    }

    /**
     * Get the `Component`s name. The name gets used to reference the `Component`
     * and is set during registration.
     *
     * @return {string}
     *         The name of this `Component`.
     */
    name() {
      return this.name_;
    }

    /**
     * Get an array of all child components
     *
     * @return {Array}
     *         The children
     */
    children() {
      return this.children_;
    }

    /**
     * Returns the child `Component` with the given `id`.
     *
     * @param {string} id
     *        The id of the child `Component` to get.
     *
     * @return {Component|undefined}
     *         The child `Component` with the given `id` or undefined.
     */
    getChildById(id) {
      return this.childIndex_[id];
    }

    /**
     * Returns the child `Component` with the given `name`.
     *
     * @param {string} name
     *        The name of the child `Component` to get.
     *
     * @return {Component|undefined}
     *         The child `Component` with the given `name` or undefined.
     */
    getChild(name) {
      if (!name) {
        return;
      }
      return this.childNameIndex_[name];
    }

    /**
     * Returns the descendant `Component` following the givent
     * descendant `names`. For instance ['foo', 'bar', 'baz'] would
     * try to get 'foo' on the current component, 'bar' on the 'foo'
     * component and 'baz' on the 'bar' component and return undefined
     * if any of those don't exist.
     *
     * @param {...string[]|...string} names
     *        The name of the child `Component` to get.
     *
     * @return {Component|undefined}
     *         The descendant `Component` following the given descendant
     *         `names` or undefined.
     */
    getDescendant(...names) {
      // flatten array argument into the main array
      names = names.reduce((acc, n) => acc.concat(n), []);
      let currentChild = this;
      for (let i = 0; i < names.length; i++) {
        currentChild = currentChild.getChild(names[i]);
        if (!currentChild || !currentChild.getChild) {
          return;
        }
      }
      return currentChild;
    }

    /**
     * Adds an SVG icon element to another element or component.
     *
     * @param {string} iconName
     *        The name of icon. A list of all the icon names can be found at 'sandbox/svg-icons.html'
     *
     * @param {Element} [el=this.el()]
     *        Element to set the title on. Defaults to the current Component's element.
     *
     * @return {Element}
     *        The newly created icon element.
     */
    setIcon(iconName, el = this.el()) {
      // TODO: In v9 of video.js, we will want to remove font icons entirely.
      // This means this check, as well as the others throughout the code, and
      // the unecessary CSS for font icons, will need to be removed.
      // See https://github.com/videojs/video.js/pull/8260 as to which components
      // need updating.
      if (!this.player_.options_.experimentalSvgIcons) {
        return;
      }
      const xmlnsURL = 'http://www.w3.org/2000/svg';

      // The below creates an element in the format of:
      // <span><svg><use>....</use></svg></span>
      const iconContainer = createEl('span', {
        className: 'vjs-icon-placeholder vjs-svg-icon'
      }, {
        'aria-hidden': 'true'
      });
      const svgEl = document__default["default"].createElementNS(xmlnsURL, 'svg');
      svgEl.setAttributeNS(null, 'viewBox', '0 0 512 512');
      const useEl = document__default["default"].createElementNS(xmlnsURL, 'use');
      svgEl.appendChild(useEl);
      useEl.setAttributeNS(null, 'href', `#vjs-icon-${iconName}`);
      iconContainer.appendChild(svgEl);

      // Replace a pre-existing icon if one exists.
      if (this.iconIsSet_) {
        el.replaceChild(iconContainer, el.querySelector('.vjs-icon-placeholder'));
      } else {
        el.appendChild(iconContainer);
      }
      this.iconIsSet_ = true;
      return iconContainer;
    }

    /**
     * Add a child `Component` inside the current `Component`.
     *
     * @param {string|Component} child
     *        The name or instance of a child to add.
     *
     * @param {Object} [options={}]
     *        The key/value store of options that will get passed to children of
     *        the child.
     *
     * @param {number} [index=this.children_.length]
     *        The index to attempt to add a child into.
     *
     *
     * @return {Component}
     *         The `Component` that gets added as a child. When using a string the
     *         `Component` will get created by this process.
     */
    addChild(child, options = {}, index = this.children_.length) {
      let component;
      let componentName;

      // If child is a string, create component with options
      if (typeof child === 'string') {
        componentName = toTitleCase(child);
        const componentClassName = options.componentClass || componentName;

        // Set name through options
        options.name = componentName;

        // Create a new object & element for this controls set
        // If there's no .player_, this is a player
        const ComponentClass = Component.getComponent(componentClassName);
        if (!ComponentClass) {
          throw new Error(`Component ${componentClassName} does not exist`);
        }

        // data stored directly on the videojs object may be
        // misidentified as a component to retain
        // backwards-compatibility with 4.x. check to make sure the
        // component class can be instantiated.
        if (typeof ComponentClass !== 'function') {
          return null;
        }
        component = new ComponentClass(this.player_ || this, options);

        // child is a component instance
      } else {
        component = child;
      }
      if (component.parentComponent_) {
        component.parentComponent_.removeChild(component);
      }
      this.children_.splice(index, 0, component);
      component.parentComponent_ = this;
      if (typeof component.id === 'function') {
        this.childIndex_[component.id()] = component;
      }

      // If a name wasn't used to create the component, check if we can use the
      // name function of the component
      componentName = componentName || component.name && toTitleCase(component.name());
      if (componentName) {
        this.childNameIndex_[componentName] = component;
        this.childNameIndex_[toLowerCase(componentName)] = component;
      }

      // Add the UI object's element to the container div (box)
      // Having an element is not required
      if (typeof component.el === 'function' && component.el()) {
        // If inserting before a component, insert before that component's element
        let refNode = null;
        if (this.children_[index + 1]) {
          // Most children are components, but the video tech is an HTML element
          if (this.children_[index + 1].el_) {
            refNode = this.children_[index + 1].el_;
          } else if (isEl(this.children_[index + 1])) {
            refNode = this.children_[index + 1];
          }
        }
        this.contentEl().insertBefore(component.el(), refNode);
      }

      // Return so it can stored on parent object if desired.
      return component;
    }

    /**
     * Remove a child `Component` from this `Component`s list of children. Also removes
     * the child `Component`s element from this `Component`s element.
     *
     * @param {Component} component
     *        The child `Component` to remove.
     */
    removeChild(component) {
      if (typeof component === 'string') {
        component = this.getChild(component);
      }
      if (!component || !this.children_) {
        return;
      }
      let childFound = false;
      for (let i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i] === component) {
          childFound = true;
          this.children_.splice(i, 1);
          break;
        }
      }
      if (!childFound) {
        return;
      }
      component.parentComponent_ = null;
      this.childIndex_[component.id()] = null;
      this.childNameIndex_[toTitleCase(component.name())] = null;
      this.childNameIndex_[toLowerCase(component.name())] = null;
      const compEl = component.el();
      if (compEl && compEl.parentNode === this.contentEl()) {
        this.contentEl().removeChild(component.el());
      }
    }

    /**
     * Add and initialize default child `Component`s based upon options.
     */
    initChildren() {
      const children = this.options_.children;
      if (children) {
        // `this` is `parent`
        const parentOptions = this.options_;
        const handleAdd = child => {
          const name = child.name;
          let opts = child.opts;

          // Allow options for children to be set at the parent options
          // e.g. videojs(id, { controlBar: false });
          // instead of videojs(id, { children: { controlBar: false });
          if (parentOptions[name] !== undefined) {
            opts = parentOptions[name];
          }

          // Allow for disabling default components
          // e.g. options['children']['posterImage'] = false
          if (opts === false) {
            return;
          }

          // Allow options to be passed as a simple boolean if no configuration
          // is necessary.
          if (opts === true) {
            opts = {};
          }

          // We also want to pass the original player options
          // to each component as well so they don't need to
          // reach back into the player for options later.
          opts.playerOptions = this.options_.playerOptions;

          // Create and add the child component.
          // Add a direct reference to the child by name on the parent instance.
          // If two of the same component are used, different names should be supplied
          // for each
          const newChild = this.addChild(name, opts);
          if (newChild) {
            this[name] = newChild;
          }
        };

        // Allow for an array of children details to passed in the options
        let workingChildren;
        const Tech = Component.getComponent('Tech');
        if (Array.isArray(children)) {
          workingChildren = children;
        } else {
          workingChildren = Object.keys(children);
        }
        workingChildren
        // children that are in this.options_ but also in workingChildren  would
        // give us extra children we do not want. So, we want to filter them out.
        .concat(Object.keys(this.options_).filter(function (child) {
          return !workingChildren.some(function (wchild) {
            if (typeof wchild === 'string') {
              return child === wchild;
            }
            return child === wchild.name;
          });
        })).map(child => {
          let name;
          let opts;
          if (typeof child === 'string') {
            name = child;
            opts = children[name] || this.options_[name] || {};
          } else {
            name = child.name;
            opts = child;
          }
          return {
            name,
            opts
          };
        }).filter(child => {
          // we have to make sure that child.name isn't in the techOrder since
          // techs are registered as Components but can't aren't compatible
          // See https://github.com/videojs/video.js/issues/2772
          const c = Component.getComponent(child.opts.componentClass || toTitleCase(child.name));
          return c && !Tech.isTech(c);
        }).forEach(handleAdd);
      }
    }

    /**
     * Builds the default DOM class name. Should be overridden by sub-components.
     *
     * @return {string}
     *         The DOM class name for this object.
     *
     * @abstract
     */
    buildCSSClass() {
      // Child classes can include a function that does:
      // return 'CLASS NAME' + this._super();
      return '';
    }

    /**
     * Bind a listener to the component's ready state.
     * Different from event listeners in that if the ready event has already happened
     * it will trigger the function immediately.
     *
     * @param {ReadyCallback} fn
     *        Function that gets called when the `Component` is ready.
     */
    ready(fn, sync = false) {
      if (!fn) {
        return;
      }
      if (!this.isReady_) {
        this.readyQueue_ = this.readyQueue_ || [];
        this.readyQueue_.push(fn);
        return;
      }
      if (sync) {
        fn.call(this);
      } else {
        // Call the function asynchronously by default for consistency
        this.setTimeout(fn, 1);
      }
    }

    /**
     * Trigger all the ready listeners for this `Component`.
     *
     * @fires Component#ready
     */
    triggerReady() {
      this.isReady_ = true;

      // Ensure ready is triggered asynchronously
      this.setTimeout(function () {
        const readyQueue = this.readyQueue_;

        // Reset Ready Queue
        this.readyQueue_ = [];
        if (readyQueue && readyQueue.length > 0) {
          readyQueue.forEach(function (fn) {
            fn.call(this);
          }, this);
        }

        // Allow for using event listeners also
        /**
         * Triggered when a `Component` is ready.
         *
         * @event Component#ready
         * @type {Event}
         */
        this.trigger('ready');
      }, 1);
    }

    /**
     * Find a single DOM element matching a `selector`. This can be within the `Component`s
     * `contentEl()` or another custom context.
     *
     * @param {string} selector
     *        A valid CSS selector, which will be passed to `querySelector`.
     *
     * @param {Element|string} [context=this.contentEl()]
     *        A DOM element within which to query. Can also be a selector string in
     *        which case the first matching element will get used as context. If
     *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
     *        nothing it falls back to `document`.
     *
     * @return {Element|null}
     *         the dom element that was found, or null
     *
     * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
     */
    $(selector, context) {
      return $(selector, context || this.contentEl());
    }

    /**
     * Finds all DOM element matching a `selector`. This can be within the `Component`s
     * `contentEl()` or another custom context.
     *
     * @param {string} selector
     *        A valid CSS selector, which will be passed to `querySelectorAll`.
     *
     * @param {Element|string} [context=this.contentEl()]
     *        A DOM element within which to query. Can also be a selector string in
     *        which case the first matching element will get used as context. If
     *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
     *        nothing it falls back to `document`.
     *
     * @return {NodeList}
     *         a list of dom elements that were found
     *
     * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
     */
    $$(selector, context) {
      return $$(selector, context || this.contentEl());
    }

    /**
     * Check if a component's element has a CSS class name.
     *
     * @param {string} classToCheck
     *        CSS class name to check.
     *
     * @return {boolean}
     *         - True if the `Component` has the class.
     *         - False if the `Component` does not have the class`
     */
    hasClass(classToCheck) {
      return hasClass(this.el_, classToCheck);
    }

    /**
     * Add a CSS class name to the `Component`s element.
     *
     * @param {...string} classesToAdd
     *        One or more CSS class name to add.
     */
    addClass(...classesToAdd) {
      addClass(this.el_, ...classesToAdd);
    }

    /**
     * Remove a CSS class name from the `Component`s element.
     *
     * @param {...string} classesToRemove
     *        One or more CSS class name to remove.
     */
    removeClass(...classesToRemove) {
      removeClass(this.el_, ...classesToRemove);
    }

    /**
     * Add or remove a CSS class name from the component's element.
     * - `classToToggle` gets added when {@link Component#hasClass} would return false.
     * - `classToToggle` gets removed when {@link Component#hasClass} would return true.
     *
     * @param  {string} classToToggle
     *         The class to add or remove. Passed to DOMTokenList's toggle()
     *
     * @param  {boolean|Dom.PredicateCallback} [predicate]
     *         A boolean or function that returns a boolean. Passed to DOMTokenList's toggle().
     */
    toggleClass(classToToggle, predicate) {
      toggleClass(this.el_, classToToggle, predicate);
    }

    /**
     * Show the `Component`s element if it is hidden by removing the
     * 'vjs-hidden' class name from it.
     */
    show() {
      this.removeClass('vjs-hidden');
    }

    /**
     * Hide the `Component`s element if it is currently showing by adding the
     * 'vjs-hidden` class name to it.
     */
    hide() {
      this.addClass('vjs-hidden');
    }

    /**
     * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'
     * class name to it. Used during fadeIn/fadeOut.
     *
     * @private
     */
    lockShowing() {
      this.addClass('vjs-lock-showing');
    }

    /**
     * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'
     * class name from it. Used during fadeIn/fadeOut.
     *
     * @private
     */
    unlockShowing() {
      this.removeClass('vjs-lock-showing');
    }

    /**
     * Get the value of an attribute on the `Component`s element.
     *
     * @param {string} attribute
     *        Name of the attribute to get the value from.
     *
     * @return {string|null}
     *         - The value of the attribute that was asked for.
     *         - Can be an empty string on some browsers if the attribute does not exist
     *           or has no value
     *         - Most browsers will return null if the attribute does not exist or has
     *           no value.
     *
     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}
     */
    getAttribute(attribute) {
      return getAttribute(this.el_, attribute);
    }

    /**
     * Set the value of an attribute on the `Component`'s element
     *
     * @param {string} attribute
     *        Name of the attribute to set.
     *
     * @param {string} value
     *        Value to set the attribute to.
     *
     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}
     */
    setAttribute(attribute, value) {
      setAttribute(this.el_, attribute, value);
    }

    /**
     * Remove an attribute from the `Component`s element.
     *
     * @param {string} attribute
     *        Name of the attribute to remove.
     *
     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}
     */
    removeAttribute(attribute) {
      removeAttribute(this.el_, attribute);
    }

    /**
     * Get or set the width of the component based upon the CSS styles.
     * See {@link Component#dimension} for more detailed information.
     *
     * @param {number|string} [num]
     *        The width that you want to set postfixed with '%', 'px' or nothing.
     *
     * @param {boolean} [skipListeners]
     *        Skip the componentresize event trigger
     *
     * @return {number|undefined}
     *         The width when getting, zero if there is no width
     */
    width(num, skipListeners) {
      return this.dimension('width', num, skipListeners);
    }

    /**
     * Get or set the height of the component based upon the CSS styles.
     * See {@link Component#dimension} for more detailed information.
     *
     * @param {number|string} [num]
     *        The height that you want to set postfixed with '%', 'px' or nothing.
     *
     * @param {boolean} [skipListeners]
     *        Skip the componentresize event trigger
     *
     * @return {number|undefined}
     *         The height when getting, zero if there is no height
     */
    height(num, skipListeners) {
      return this.dimension('height', num, skipListeners);
    }

    /**
     * Set both the width and height of the `Component` element at the same time.
     *
     * @param  {number|string} width
     *         Width to set the `Component`s element to.
     *
     * @param  {number|string} height
     *         Height to set the `Component`s element to.
     */
    dimensions(width, height) {
      // Skip componentresize listeners on width for optimization
      this.width(width, true);
      this.height(height);
    }

    /**
     * Get or set width or height of the `Component` element. This is the shared code
     * for the {@link Component#width} and {@link Component#height}.
     *
     * Things to know:
     * - If the width or height in an number this will return the number postfixed with 'px'.
     * - If the width/height is a percent this will return the percent postfixed with '%'
     * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function
     *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.
     *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}
     *   for more information
     * - If you want the computed style of the component, use {@link Component#currentWidth}
     *   and {@link {Component#currentHeight}
     *
     * @fires Component#componentresize
     *
     * @param {string} widthOrHeight
     8        'width' or 'height'
     *
     * @param  {number|string} [num]
     8         New dimension
     *
     * @param  {boolean} [skipListeners]
     *         Skip componentresize event trigger
     *
     * @return {number|undefined}
     *         The dimension when getting or 0 if unset
     */
    dimension(widthOrHeight, num, skipListeners) {
      if (num !== undefined) {
        // Set to zero if null or literally NaN (NaN !== NaN)
        if (num === null || num !== num) {
          num = 0;
        }

        // Check if using css width/height (% or px) and adjust
        if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
          this.el_.style[widthOrHeight] = num;
        } else if (num === 'auto') {
          this.el_.style[widthOrHeight] = '';
        } else {
          this.el_.style[widthOrHeight] = num + 'px';
        }

        // skipListeners allows us to avoid triggering the resize event when setting both width and height
        if (!skipListeners) {
          /**
           * Triggered when a component is resized.
           *
           * @event Component#componentresize
           * @type {Event}
           */
          this.trigger('componentresize');
        }
        return;
      }

      // Not setting a value, so getting it
      // Make sure element exists
      if (!this.el_) {
        return 0;
      }

      // Get dimension value from style
      const val = this.el_.style[widthOrHeight];
      const pxIndex = val.indexOf('px');
      if (pxIndex !== -1) {
        // Return the pixel value with no 'px'
        return parseInt(val.slice(0, pxIndex), 10);
      }

      // No px so using % or no style was set, so falling back to offsetWidth/height
      // If component has display:none, offset will return 0
      // TODO: handle display:none and no dimension style using px
      return parseInt(this.el_['offset' + toTitleCase(widthOrHeight)], 10);
    }

    /**
     * Get the computed width or the height of the component's element.
     *
     * Uses `window.getComputedStyle`.
     *
     * @param {string} widthOrHeight
     *        A string containing 'width' or 'height'. Whichever one you want to get.
     *
     * @return {number}
     *         The dimension that gets asked for or 0 if nothing was set
     *         for that dimension.
     */
    currentDimension(widthOrHeight) {
      let computedWidthOrHeight = 0;
      if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {
        throw new Error('currentDimension only accepts width or height value');
      }
      computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);

      // remove 'px' from variable and parse as integer
      computedWidthOrHeight = parseFloat(computedWidthOrHeight);

      // if the computed value is still 0, it's possible that the browser is lying
      // and we want to check the offset values.
      // This code also runs wherever getComputedStyle doesn't exist.
      if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {
        const rule = `offset${toTitleCase(widthOrHeight)}`;
        computedWidthOrHeight = this.el_[rule];
      }
      return computedWidthOrHeight;
    }

    /**
     * An object that contains width and height values of the `Component`s
     * computed style. Uses `window.getComputedStyle`.
     *
     * @typedef {Object} Component~DimensionObject
     *
     * @property {number} width
     *           The width of the `Component`s computed style.
     *
     * @property {number} height
     *           The height of the `Component`s computed style.
     */

    /**
     * Get an object that contains computed width and height values of the
     * component's element.
     *
     * Uses `window.getComputedStyle`.
     *
     * @return {Component~DimensionObject}
     *         The computed dimensions of the component's element.
     */
    currentDimensions() {
      return {
        width: this.currentDimension('width'),
        height: this.currentDimension('height')
      };
    }

    /**
     * Get the computed width of the component's element.
     *
     * Uses `window.getComputedStyle`.
     *
     * @return {number}
     *         The computed width of the component's element.
     */
    currentWidth() {
      return this.currentDimension('width');
    }

    /**
     * Get the computed height of the component's element.
     *
     * Uses `window.getComputedStyle`.
     *
     * @return {number}
     *         The computed height of the component's element.
     */
    currentHeight() {
      return this.currentDimension('height');
    }

    /**
     * Retrieves the position and size information of the component's element.
     *
     * @return {Object} An object with `boundingClientRect` and `center` properties.
     *         - `boundingClientRect`: An object with properties `x`, `y`, `width`,
     *           `height`, `top`, `right`, `bottom`, and `left`, representing
     *           the bounding rectangle of the element.
     *         - `center`: An object with properties `x` and `y`, representing
     *           the center point of the element. `width` and `height` are set to 0.
     */
    getPositions() {
      const rect = this.el_.getBoundingClientRect();

      // Creating objects that mirror DOMRectReadOnly for boundingClientRect and center
      const boundingClientRect = {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left
      };

      // Calculating the center position
      const center = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2,
        width: 0,
        height: 0,
        top: rect.top + rect.height / 2,
        right: rect.left + rect.width / 2,
        bottom: rect.top + rect.height / 2,
        left: rect.left + rect.width / 2
      };
      return {
        boundingClientRect,
        center
      };
    }

    /**
     * Set the focus to this component
     */
    focus() {
      this.el_.focus();
    }

    /**
     * Remove the focus from this component
     */
    blur() {
      this.el_.blur();
    }

    /**
     * When this Component receives a `keydown` event which it does not process,
     *  it passes the event to the Player for handling.
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     */
    handleKeyDown(event) {
      if (this.player_) {
        // We only stop propagation here because we want unhandled events to fall
        // back to the browser. Exclude Tab for focus trapping, exclude also when spatialNavigation is enabled.
        if (event.key !== 'Tab' && !(this.player_.options_.playerOptions.spatialNavigation && this.player_.options_.playerOptions.spatialNavigation.enabled)) {
          event.stopPropagation();
        }
        this.player_.handleKeyDown(event);
      }
    }

    /**
     * Many components used to have a `handleKeyPress` method, which was poorly
     * named because it listened to a `keydown` event. This method name now
     * delegates to `handleKeyDown`. This means anyone calling `handleKeyPress`
     * will not see their method calls stop working.
     *
     * @param {KeyboardEvent} event
     *        The event that caused this function to be called.
     */
    handleKeyPress(event) {
      this.handleKeyDown(event);
    }

    /**
     * Emit a 'tap' events when touch event support gets detected. This gets used to
     * support toggling the controls through a tap on the video. They get enabled
     * because every sub-component would have extra overhead otherwise.
     *
     * @protected
     * @fires Component#tap
     * @listens Component#touchstart
     * @listens Component#touchmove
     * @listens Component#touchleave
     * @listens Component#touchcancel
     * @listens Component#touchend
      */
    emitTapEvents() {
      // Track the start time so we can determine how long the touch lasted
      let touchStart = 0;
      let firstTouch = null;

      // Maximum movement allowed during a touch event to still be considered a tap
      // Other popular libs use anywhere from 2 (hammer.js) to 15,
      // so 10 seems like a nice, round number.
      const tapMovementThreshold = 10;

      // The maximum length a touch can be while still being considered a tap
      const touchTimeThreshold = 200;
      let couldBeTap;
      this.on('touchstart', function (event) {
        // If more than one finger, don't consider treating this as a click
        if (event.touches.length === 1) {
          // Copy pageX/pageY from the object
          firstTouch = {
            pageX: event.touches[0].pageX,
            pageY: event.touches[0].pageY
          };
          // Record start time so we can detect a tap vs. "touch and hold"
          touchStart = window__default["default"].performance.now();
          // Reset couldBeTap tracking
          couldBeTap = true;
        }
      });
      this.on('touchmove', function (event) {
        // If more than one finger, don't consider treating this as a click
        if (event.touches.length > 1) {
          couldBeTap = false;
        } else if (firstTouch) {
          // Some devices will throw touchmoves for all but the slightest of taps.
          // So, if we moved only a small distance, this could still be a tap
          const xdiff = event.touches[0].pageX - firstTouch.pageX;
          const ydiff = event.touches[0].pageY - firstTouch.pageY;
          const touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
          if (touchDistance > tapMovementThreshold) {
            couldBeTap = false;
          }
        }
      });
      const noTap = function () {
        couldBeTap = false;
      };

      // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
      this.on('touchleave', noTap);
      this.on('touchcancel', noTap);

      // When the touch ends, measure how long it took and trigger the appropriate
      // event
      this.on('touchend', function (event) {
        firstTouch = null;
        // Proceed only if the touchmove/leave/cancel event didn't happen
        if (couldBeTap === true) {
          // Measure how long the touch lasted
          const touchTime = window__default["default"].performance.now() - touchStart;

          // Make sure the touch was less than the threshold to be considered a tap
          if (touchTime < touchTimeThreshold) {
            // Don't let browser turn this into a click
            event.preventDefault();
            /**
             * Triggered when a `Component` is tapped.
             *
             * @event Component#tap
             * @type {MouseEvent}
             */
            this.trigger('tap');
            // It may be good to copy the touchend event object and change the
            // type to tap, if the other event properties aren't exact after
            // Events.fixEvent runs (e.g. event.target)
          }
        }
      });
    }

    /**
     * This function reports user activity whenever touch events happen. This can get
     * turned off by any sub-components that wants touch events to act another way.
     *
     * Report user touch activity when touch events occur. User activity gets used to
     * determine when controls should show/hide. It is simple when it comes to mouse
     * events, because any mouse event should show the controls. So we capture mouse
     * events that bubble up to the player and report activity when that happens.
     * With touch events it isn't as easy as `touchstart` and `touchend` toggle player
     * controls. So touch events can't help us at the player level either.
     *
     * User activity gets checked asynchronously. So what could happen is a tap event
     * on the video turns the controls off. Then the `touchend` event bubbles up to
     * the player. Which, if it reported user activity, would turn the controls right
     * back on. We also don't want to completely block touch events from bubbling up.
     * Furthermore a `touchmove` event and anything other than a tap, should not turn
     * controls back on.
     *
     * @listens Component#touchstart
     * @listens Component#touchmove
     * @listens Component#touchend
     * @listens Component#touchcancel
     */
    enableTouchActivity() {
      // Don't continue if the root player doesn't support reporting user activity
      if (!this.player() || !this.player().reportUserActivity) {
        return;
      }

      // listener for reporting that the user is active
      const report = bind_(this.player(), this.player().reportUserActivity);
      let touchHolding;
      this.on('touchstart', function () {
        report();
        // For as long as the they are touching the device or have their mouse down,
        // we consider them active even if they're not moving their finger or mouse.
        // So we want to continue to update that they are active
        this.clearInterval(touchHolding);
        // report at the same interval as activityCheck
        touchHolding = this.setInterval(report, 250);
      });
      const touchEnd = function (event) {
        report();
        // stop the interval that maintains activity if the touch is holding
        this.clearInterval(touchHolding);
      };
      this.on('touchmove', report);
      this.on('touchend', touchEnd);
      this.on('touchcancel', touchEnd);
    }

    /**
     * A callback that has no parameters and is bound into `Component`s context.
     *
     * @callback Component~GenericCallback
     * @this Component
     */

    /**
     * Creates a function that runs after an `x` millisecond timeout. This function is a
     * wrapper around `window.setTimeout`. There are a few reasons to use this one
     * instead though:
     * 1. It gets cleared via  {@link Component#clearTimeout} when
     *    {@link Component#dispose} gets called.
     * 2. The function callback will gets turned into a {@link Component~GenericCallback}
     *
     * > Note: You can't use `window.clearTimeout` on the id returned by this function. This
     *         will cause its dispose listener not to get cleaned up! Please use
     *         {@link Component#clearTimeout} or {@link Component#dispose} instead.
     *
     * @param {Component~GenericCallback} fn
     *        The function that will be run after `timeout`.
     *
     * @param {number} timeout
     *        Timeout in milliseconds to delay before executing the specified function.
     *
     * @return {number}
     *         Returns a timeout ID that gets used to identify the timeout. It can also
     *         get used in {@link Component#clearTimeout} to clear the timeout that
     *         was set.
     *
     * @listens Component#dispose
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}
     */
    setTimeout(fn, timeout) {
      // declare as variables so they are properly available in timeout function
      // eslint-disable-next-line
      var timeoutId;
      fn = bind_(this, fn);
      this.clearTimersOnDispose_();
      timeoutId = window__default["default"].setTimeout(() => {
        if (this.setTimeoutIds_.has(timeoutId)) {
          this.setTimeoutIds_.delete(timeoutId);
        }
        fn();
      }, timeout);
      this.setTimeoutIds_.add(timeoutId);
      return timeoutId;
    }

    /**
     * Clears a timeout that gets created via `window.setTimeout` or
     * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}
     * use this function instead of `window.clearTimout`. If you don't your dispose
     * listener will not get cleaned up until {@link Component#dispose}!
     *
     * @param {number} timeoutId
     *        The id of the timeout to clear. The return value of
     *        {@link Component#setTimeout} or `window.setTimeout`.
     *
     * @return {number}
     *         Returns the timeout id that was cleared.
     *
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}
     */
    clearTimeout(timeoutId) {
      if (this.setTimeoutIds_.has(timeoutId)) {
        this.setTimeoutIds_.delete(timeoutId);
        window__default["default"].clearTimeout(timeoutId);
      }
      return timeoutId;
    }

    /**
     * Creates a function that gets run every `x` milliseconds. This function is a wrapper
     * around `window.setInterval`. There are a few reasons to use this one instead though.
     * 1. It gets cleared via  {@link Component#clearInterval} when
     *    {@link Component#dispose} gets called.
     * 2. The function callback will be a {@link Component~GenericCallback}
     *
     * @param {Component~GenericCallback} fn
     *        The function to run every `x` seconds.
     *
     * @param {number} interval
     *        Execute the specified function every `x` milliseconds.
     *
     * @return {number}
     *         Returns an id that can be used to identify the interval. It can also be be used in
     *         {@link Component#clearInterval} to clear the interval.
     *
     * @listens Component#dispose
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}
     */
    setInterval(fn, interval) {
      fn = bind_(this, fn);
      this.clearTimersOnDispose_();
      const intervalId = window__default["default"].setInterval(fn, interval);
      this.setIntervalIds_.add(intervalId);
      return intervalId;
    }

    /**
     * Clears an interval that gets created via `window.setInterval` or
     * {@link Component#setInterval}. If you set an interval via {@link Component#setInterval}
     * use this function instead of `window.clearInterval`. If you don't your dispose
     * listener will not get cleaned up until {@link Component#dispose}!
     *
     * @param {number} intervalId
     *        The id of the interval to clear. The return value of
     *        {@link Component#setInterval} or `window.setInterval`.
     *
     * @return {number}
     *         Returns the interval id that was cleared.
     *
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}
     */
    clearInterval(intervalId) {
      if (this.setIntervalIds_.has(intervalId)) {
        this.setIntervalIds_.delete(intervalId);
        window__default["default"].clearInterval(intervalId);
      }
      return intervalId;
    }

    /**
     * Queues up a callback to be passed to requestAnimationFrame (rAF), but
     * with a few extra bonuses:
     *
     * - Supports browsers that do not support rAF by falling back to
     *   {@link Component#setTimeout}.
     *
     * - The callback is turned into a {@link Component~GenericCallback} (i.e.
     *   bound to the component).
     *
     * - Automatic cancellation of the rAF callback is handled if the component
     *   is disposed before it is called.
     *
     * @param  {Component~GenericCallback} fn
     *         A function that will be bound to this component and executed just
     *         before the browser's next repaint.
     *
     * @return {number}
     *         Returns an rAF ID that gets used to identify the timeout. It can
     *         also be used in {@link Component#cancelAnimationFrame} to cancel
     *         the animation frame callback.
     *
     * @listens Component#dispose
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
     */
    requestAnimationFrame(fn) {
      this.clearTimersOnDispose_();

      // declare as variables so they are properly available in rAF function
      // eslint-disable-next-line
      var id;
      fn = bind_(this, fn);
      id = window__default["default"].requestAnimationFrame(() => {
        if (this.rafIds_.has(id)) {
          this.rafIds_.delete(id);
        }
        fn();
      });
      this.rafIds_.add(id);
      return id;
    }

    /**
     * Request an animation frame, but only one named animation
     * frame will be queued. Another will never be added until
     * the previous one finishes.
     *
     * @param {string} name
     *        The name to give this requestAnimationFrame
     *
     * @param  {Component~GenericCallback} fn
     *         A function that will be bound to this component and executed just
     *         before the browser's next repaint.
     */
    requestNamedAnimationFrame(name, fn) {
      if (this.namedRafs_.has(name)) {
        this.cancelNamedAnimationFrame(name);
      }
      this.clearTimersOnDispose_();
      fn = bind_(this, fn);
      const id = this.requestAnimationFrame(() => {
        fn();
        if (this.namedRafs_.has(name)) {
          this.namedRafs_.delete(name);
        }
      });
      this.namedRafs_.set(name, id);
      return name;
    }

    /**
     * Cancels a current named animation frame if it exists.
     *
     * @param {string} name
     *        The name of the requestAnimationFrame to cancel.
     */
    cancelNamedAnimationFrame(name) {
      if (!this.namedRafs_.has(name)) {
        return;
      }
      this.cancelAnimationFrame(this.namedRafs_.get(name));
      this.namedRafs_.delete(name);
    }

    /**
     * Cancels a queued callback passed to {@link Component#requestAnimationFrame}
     * (rAF).
     *
     * If you queue an rAF callback via {@link Component#requestAnimationFrame},
     * use this function instead of `window.cancelAnimationFrame`. If you don't,
     * your dispose listener will not get cleaned up until {@link Component#dispose}!
     *
     * @param {number} id
     *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.
     *
     * @return {number}
     *         Returns the rAF ID that was cleared.
     *
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}
     */
    cancelAnimationFrame(id) {
      if (this.rafIds_.has(id)) {
        this.rafIds_.delete(id);
        window__default["default"].cancelAnimationFrame(id);
      }
      return id;
    }

    /**
     * A function to setup `requestAnimationFrame`, `setTimeout`,
     * and `setInterval`, clearing on dispose.
     *
     * > Previously each timer added and removed dispose listeners on it's own.
     * For better performance it was decided to batch them all, and use `Set`s
     * to track outstanding timer ids.
     *
     * @private
     */
    clearTimersOnDispose_() {
      if (this.clearingTimersOnDispose_) {
        return;
      }
      this.clearingTimersOnDispose_ = true;
      this.one('dispose', () => {
        [['namedRafs_', 'cancelNamedAnimationFrame'], ['rafIds_', 'cancelAnimationFrame'], ['setTimeoutIds_', 'clearTimeout'], ['setIntervalIds_', 'clearInterval']].forEach(([idName, cancelName]) => {
          // for a `Set` key will actually be the value again
          // so forEach((val, val) =>` but for maps we want to use
          // the key.
          this[idName].forEach((val, key) => this[cancelName](key));
        });
        this.clearingTimersOnDispose_ = false;
      });
    }

    /**
      * Decide whether an element is actually disabled or not.
      *
      * @function isActuallyDisabled
      * @param element {Node}
      * @return {boolean}
      *
      * @see {@link https://html.spec.whatwg.org/multipage/semantics-other.html#concept-element-disabled}
      */
    getIsDisabled() {
      return Boolean(this.el_.disabled);
    }

    /**
      * Decide whether the element is expressly inert or not.
      *
      * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#expressly-inert}
      * @function isExpresslyInert
      * @param element {Node}
      * @return {boolean}
      */
    getIsExpresslyInert() {
      return this.el_.inert && !this.el_.ownerDocument.documentElement.inert;
    }

    /**
     * Determine whether or not this component can be considered as focusable component.
     *
     * @param {HTMLElement} el - The HTML element representing the component.
     * @return {boolean}
     *         If the component can be focused, will be `true`. Otherwise, `false`.
     */
    getIsFocusable(el) {
      const element = el || this.el_;
      return element.tabIndex >= 0 && !(this.getIsDisabled() || this.getIsExpresslyInert());
    }

    /**
     * Determine whether or not this component is currently visible/enabled/etc...
     *
     * @param {HTMLElement} el - The HTML element representing the component.
     * @return {boolean}
     *         If the component can is currently visible & enabled, will be `true`. Otherwise, `false`.
     */
    getIsAvailableToBeFocused(el) {
      /**
       * Decide the style property of this element is specified whether it's visible or not.
       *
       * @function isVisibleStyleProperty
       * @param element {CSSStyleDeclaration}
       * @return {boolean}
       */
      function isVisibleStyleProperty(element) {
        const elementStyle = window__default["default"].getComputedStyle(element, null);
        const thisVisibility = elementStyle.getPropertyValue('visibility');
        const thisDisplay = elementStyle.getPropertyValue('display');
        const invisibleStyle = ['hidden', 'collapse'];
        return thisDisplay !== 'none' && !invisibleStyle.includes(thisVisibility);
      }

      /**
       * Decide whether the element is being rendered or not.
       * 1. If an element has the style as "visibility: hidden | collapse" or "display: none", it is not being rendered.
       * 2. If an element has the style as "opacity: 0", it is not being rendered.(that is, invisible).
       * 3. If width and height of an element are explicitly set to 0, it is not being rendered.
       * 4. If a parent element is hidden, an element itself is not being rendered.
       * (CSS visibility property and display property are inherited.)
       *
       * @see {@link https://html.spec.whatwg.org/multipage/rendering.html#being-rendered}
       * @function isBeingRendered
       * @param element {Node}
       * @return {boolean}
       */
      function isBeingRendered(element) {
        if (!isVisibleStyleProperty(element.parentElement)) {
          return false;
        }
        if (!isVisibleStyleProperty(element) || element.style.opacity === '0' || window__default["default"].getComputedStyle(element).height === '0px' || window__default["default"].getComputedStyle(element).width === '0px') {
          return false;
        }
        return true;
      }

      /**
       * Determine if the element is visible for the user or not.
       * 1. If an element sum of its offsetWidth, offsetHeight, height and width is less than 1 is not visible.
       * 2. If elementCenter.x is less than is not visible.
       * 3. If elementCenter.x is more than the document's width is not visible.
       * 4. If elementCenter.y is less than 0 is not visible.
       * 5. If elementCenter.y is the document's height is not visible.
       *
       * @function isVisible
       * @param element {Node}
       * @return {boolean}
       */
      function isVisible(element) {
        if (element.offsetWidth + element.offsetHeight + element.getBoundingClientRect().height + element.getBoundingClientRect().width === 0) {
          return false;
        }

        // Define elementCenter object with props of x and y
        // x: Left position relative to the viewport plus element's width (no margin) divided between 2.
        // y: Top position relative to the viewport plus element's height (no margin) divided between 2.
        const elementCenter = {
          x: element.getBoundingClientRect().left + element.offsetWidth / 2,
          y: element.getBoundingClientRect().top + element.offsetHeight / 2
        };
        if (elementCenter.x < 0) {
          return false;
        }
        if (elementCenter.x > (document__default["default"].documentElement.clientWidth || window__default["default"].innerWidth)) {
          return false;
        }
        if (elementCenter.y < 0) {
          return false;
        }
        if (elementCenter.y > (document__default["default"].documentElement.clientHeight || window__default["default"].innerHeight)) {
          return false;
        }
        let pointContainer = document__default["default"].elementFromPoint(elementCenter.x, elementCenter.y);
        while (pointContainer) {
          if (pointContainer === element) {
            return true;
          }
          if (pointContainer.parentNode) {
            pointContainer = pointContainer.parentNode;
          } else {
            return false;
          }
        }
      }

      // If no DOM element was passed as argument use this component's element.
      if (!el) {
        el = this.el();
      }

      // If element is visible, is being rendered & either does not have a parent element or its tabIndex is not negative.
      if (isVisible(el) && isBeingRendered(el) && (!el.parentElement || el.tabIndex >= 0)) {
        return true;
      }
      return false;
    }

    /**
     * Register a `Component` with `videojs` given the name and the component.
     *
     * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s
     *         should be registered using {@link Tech.registerTech} or
     *         {@link videojs:videojs.registerTech}.
     *
     * > NOTE: This function can also be seen on videojs as
     *         {@link videojs:videojs.registerComponent}.
     *
     * @param {string} name
     *        The name of the `Component` to register.
     *
     * @param {Component} ComponentToRegister
     *        The `Component` class to register.
     *
     * @return {Component}
     *         The `Component` that was registered.
     */
    static registerComponent(name, ComponentToRegister) {
      if (typeof name !== 'string' || !name) {
        throw new Error(`Illegal component name, "${name}"; must be a non-empty string.`);
      }
      const Tech = Component.getComponent('Tech');

      // We need to make sure this check is only done if Tech has been registered.
      const isTech = Tech && Tech.isTech(ComponentToRegister);
      const isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);
      if (isTech || !isComp) {
        let reason;
        if (isTech) {
          reason = 'techs must be registered using Tech.registerTech()';
        } else {
          reason = 'must be a Component subclass';
        }
        throw new Error(`Illegal component, "${name}"; ${reason}.`);
      }
      name = toTitleCase(name);
      if (!Component.components_) {
        Component.components_ = {};
      }
      const Player = Component.getComponent('Player');
      if (name === 'Player' && Player && Player.players) {
        const players = Player.players;
        const playerNames = Object.keys(players);

        // If we have players that were disposed, then their name will still be
        // in Players.players. So, we must loop through and verify that the value
        // for each item is not null. This allows registration of the Player component
        // after all players have been disposed or before any were created.
        if (players && playerNames.length > 0 && playerNames.map(pname => players[pname]).every(Boolean)) {
          throw new Error('Can not register Player component after player has been created.');
        }
      }
      Component.components_[name] = ComponentToRegister;
      Component.components_[toLowerCase(name)] = ComponentToRegister;
      return ComponentToRegister;
    }

    /**
     * Get a `Component` based on the name it was registered with.
     *
     * @param {string} name
     *        The Name of the component to get.
     *
     * @return {typeof Component}
     *         The `Component` that got registered under the given name.
     */
    static getComponent(name) {
      if (!name || !Component.components_) {
        return;
      }
      return Component.components_[name];
    }
  }
  Component.registerComponent('Component', Component);

  /**
   * @file time.js
   * @module time
   */

  /**
   * Returns the time for the specified index at the start or end
   * of a TimeRange object.
   *
   * @typedef    {Function} TimeRangeIndex
   *
   * @param      {number} [index=0]
   *             The range number to return the time for.
   *
   * @return     {number}
   *             The time offset at the specified index.
   *
   * @deprecated The index argument must be provided.
   *             In the future, leaving it out will throw an error.
   */

  /**
   * An object that contains ranges of time, which mimics {@link TimeRanges}.
   *
   * @typedef  {Object} TimeRange
   *
   * @property {number} length
   *           The number of time ranges represented by this object.
   *
   * @property {module:time~TimeRangeIndex} start
   *           Returns the time offset at which a specified time range begins.
   *
   * @property {module:time~TimeRangeIndex} end
   *           Returns the time offset at which a specified time range ends.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges
   */

  /**
   * Check if any of the time ranges are over the maximum index.
   *
   * @private
   * @param   {string} fnName
   *          The function name to use for logging
   *
   * @param   {number} index
   *          The index to check
   *
   * @param   {number} maxIndex
   *          The maximum possible index
   *
   * @throws  {Error} if the timeRanges provided are over the maxIndex
   */
  function rangeCheck(fnName, index, maxIndex) {
    if (typeof index !== 'number' || index < 0 || index > maxIndex) {
      throw new Error(`Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${maxIndex}).`);
    }
  }

  /**
   * Get the time for the specified index at the start or end
   * of a TimeRange object.
   *
   * @private
   * @param      {string} fnName
   *             The function name to use for logging
   *
   * @param      {string} valueIndex
   *             The property that should be used to get the time. should be
   *             'start' or 'end'
   *
   * @param      {Array} ranges
   *             An array of time ranges
   *
   * @param      {Array} [rangeIndex=0]
   *             The index to start the search at
   *
   * @return     {number}
   *             The time that offset at the specified index.
   *
   * @deprecated rangeIndex must be set to a value, in the future this will throw an error.
   * @throws     {Error} if rangeIndex is more than the length of ranges
   */
  function getRange(fnName, valueIndex, ranges, rangeIndex) {
    rangeCheck(fnName, rangeIndex, ranges.length - 1);
    return ranges[rangeIndex][valueIndex];
  }

  /**
   * Create a time range object given ranges of time.
   *
   * @private
   * @param   {Array} [ranges]
   *          An array of time ranges.
   *
   * @return  {TimeRange}
   */
  function createTimeRangesObj(ranges) {
    let timeRangesObj;
    if (ranges === undefined || ranges.length === 0) {
      timeRangesObj = {
        length: 0,
        start() {
          throw new Error('This TimeRanges object is empty');
        },
        end() {
          throw new Error('This TimeRanges object is empty');
        }
      };
    } else {
      timeRangesObj = {
        length: ranges.length,
        start: getRange.bind(null, 'start', 0, ranges),
        end: getRange.bind(null, 'end', 1, ranges)
      };
    }
    if (window__default["default"].Symbol && window__default["default"].Symbol.iterator) {
      timeRangesObj[window__default["default"].Symbol.iterator] = () => (ranges || []).values();
    }
    return timeRangesObj;
  }

  /**
   * Create a `TimeRange` object which mimics an
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges|HTML5 TimeRanges instance}.
   *
   * @param {number|Array[]} start
   *        The start of a single range (a number) or an array of ranges (an
   *        array of arrays of two numbers each).
   *
   * @param {number} end
   *        The end of a single range. Cannot be used with the array form of
   *        the `start` argument.
   *
   * @return {TimeRange}
   */
  function createTimeRanges(start, end) {
    if (Array.isArray(start)) {
      return createTimeRangesObj(start);
    } else if (start === undefined || end === undefined) {
      return createTimeRangesObj();
    }
    return createTimeRangesObj([[start, end]]);
  }

  /**
   * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in
   * seconds) will force a number of leading zeros to cover the length of the
   * guide.
   *
   * @private
   * @param  {number} seconds
   *         Number of seconds to be turned into a string
   *
   * @param  {number} guide
   *         Number (in seconds) to model the string after
   *
   * @return {string}
   *         Time formatted as H:MM:SS or M:SS
   */
  const defaultImplementation = function (seconds, guide) {
    seconds = seconds < 0 ? 0 : seconds;
    let s = Math.floor(seconds % 60);
    let m = Math.floor(seconds / 60 % 60);
    let h = Math.floor(seconds / 3600);
    const gm = Math.floor(guide / 60 % 60);
    const gh = Math.floor(guide / 3600);

    // handle invalid times
    if (isNaN(seconds) || seconds === Infinity) {
      // '-' is false for all relational operators (e.g. <, >=) so this setting
      // will add the minimum number of fields specified by the guide
      h = m = s = '-';
    }

    // Check if we need to show hours
    h = h > 0 || gh > 0 ? h + ':' : '';

    // If hours are showing, we may need to add a leading zero.
    // Always show at least one digit of minutes.
    m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';

    // Check if leading zero is need for seconds
    s = s < 10 ? '0' + s : s;
    return h + m + s;
  };

  // Internal pointer to the current implementation.
  let implementation = defaultImplementation;

  /**
   * Replaces the default formatTime implementation with a custom implementation.
   *
   * @param {Function} customImplementation
   *        A function which will be used in place of the default formatTime
   *        implementation. Will receive the current time in seconds and the
   *        guide (in seconds) as arguments.
   */
  function setFormatTime(customImplementation) {
    implementation = customImplementation;
  }

  /**
   * Resets formatTime to the default implementation.
   */
  function resetFormatTime() {
    implementation = defaultImplementation;
  }

  /**
   * Delegates to either the default time formatting function or a custom
   * function supplied via `setFormatTime`.
   *
   * Formats seconds as a time string (H:MM:SS or M:SS). Supplying a
   * guide (in seconds) will force a number of leading zeros to cover the
   * length of the guide.
   *
   * @example  formatTime(125, 600) === "02:05"
   * @param    {number} seconds
   *           Number of seconds to be turned into a string
   *
   * @param    {number} guide
   *           Number (in seconds) to model the string after
   *
   * @return   {string}
   *           Time formatted as H:MM:SS or M:SS
   */
  function formatTime(seconds, guide = seconds) {
    return implementation(seconds, guide);
  }

  var Time = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createTimeRanges: createTimeRanges,
    createTimeRange: createTimeRanges,
    setFormatTime: setFormatTime,
    resetFormatTime: resetFormatTime,
    formatTime: formatTime
  });

  /**
   * @file buffer.js
   * @module buffer
   */

  /** @import { TimeRange } from './time' */

  /**
   * Compute the percentage of the media that has been buffered.
   *
   * @param {TimeRange} buffered
   *        The current `TimeRanges` object representing buffered time ranges
   *
   * @param {number} duration
   *        Total duration of the media
   *
   * @return {number}
   *         Percent buffered of the total duration in decimal form.
   */
  function bufferedPercent(buffered, duration) {
    let bufferedDuration = 0;
    let start;
    let end;
    if (!duration) {
      return 0;
    }
    if (!buffered || !buffered.length) {
      buffered = createTimeRanges(0, 0);
    }
    for (let i = 0; i < buffered.length; i++) {
      start = buffered.start(i);
      end = buffered.end(i);

      // buffered end can be bigger than duration by a very small fraction
      if (end > duration) {
        end = duration;
      }
      bufferedDuration += end - start;
    }
    return bufferedDuration / duration;
  }

  /**
   * @file media-error.js
   */

  /**
   * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.
   *
   * @param {number|string|Object|MediaError} value
   *        This can be of multiple types:
   *        - number: should be a standard error code
   *        - string: an error message (the code will be 0)
   *        - Object: arbitrary properties
   *        - `MediaError` (native): used to populate a video.js `MediaError` object
   *        - `MediaError` (video.js): will return itself if it's already a
   *          video.js `MediaError` object.
   *
   * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}
   * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}
   *
   * @class MediaError
   */
  function MediaError(value) {
    // Allow redundant calls to this constructor to avoid having `instanceof`
    // checks peppered around the code.
    if (value instanceof MediaError) {
      return value;
    }
    if (typeof value === 'number') {
      this.code = value;
    } else if (typeof value === 'string') {
      // default code is zero, so this is a custom error
      this.message = value;
    } else if (isObject(value)) {
      // We assign the `code` property manually because native `MediaError` objects
      // do not expose it as an own/enumerable property of the object.
      if (typeof value.code === 'number') {
        this.code = value.code;
      }
      Object.assign(this, value);
    }
    if (!this.message) {
      this.message = MediaError.defaultMessages[this.code] || '';
    }
  }

  /**
   * The error code that refers two one of the defined `MediaError` types
   *
   * @type {Number}
   */
  MediaError.prototype.code = 0;

  /**
   * An optional message that to show with the error. Message is not part of the HTML5
   * video spec but allows for more informative custom errors.
   *
   * @type {String}
   */
  MediaError.prototype.message = '';

  /**
   * An optional status code that can be set by plugins to allow even more detail about
   * the error. For example a plugin might provide a specific HTTP status code and an
   * error message for that code. Then when the plugin gets that error this class will
   * know how to display an error message for it. This allows a custom message to show
   * up on the `Player` error overlay.
   *
   * @type {Array}
   */
  MediaError.prototype.status = null;

  /**
   * An object containing an error type, as well as other information regarding the error.
   *
   * @typedef {{errorType: string, [key: string]: any}} ErrorMetadata
   */

  /**
   * An optional object to give more detail about the error. This can be used to give
   * a higher level of specificity to an error versus the more generic MediaError codes.
   * `metadata` expects an `errorType` string that should align with the values from videojs.Error.
   *
   * @type {ErrorMetadata}
   */
  MediaError.prototype.metadata = null;

  /**
   * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the
   * specification listed under {@link MediaError} for more information.
   *
   * @enum {array}
   * @readonly
   * @property {string} 0 - MEDIA_ERR_CUSTOM
   * @property {string} 1 - MEDIA_ERR_ABORTED
   * @property {string} 2 - MEDIA_ERR_NETWORK
   * @property {string} 3 - MEDIA_ERR_DECODE
   * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED
   * @property {string} 5 - MEDIA_ERR_ENCRYPTED
   */
  MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];

  /**
   * The default `MediaError` messages based on the {@link MediaError.errorTypes}.
   *
   * @type {Array}
   * @constant
   */
  MediaError.defaultMessages = {
    1: 'You aborted the media playback',
    2: 'A network error caused the media download to fail part-way.',
    3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',
    4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',
    5: 'The media is encrypted and we do not have the keys to decrypt it.'
  };

  /**
   * W3C error code for any custom error.
   *
   * @member MediaError#MEDIA_ERR_CUSTOM
   * @constant {number}
   * @default 0
   */
  MediaError.MEDIA_ERR_CUSTOM = 0;

  /**
   * W3C error code for any custom error.
   *
   * @member MediaError.MEDIA_ERR_CUSTOM
   * @constant {number}
   * @default 0
   */
  MediaError.prototype.MEDIA_ERR_CUSTOM = 0;

  /**
   * W3C error code for media error aborted.
   *
   * @member MediaError#MEDIA_ERR_ABORTED
   * @constant {number}
   * @default 1
   */
  MediaError.MEDIA_ERR_ABORTED = 1;

  /**
   * W3C error code for media error aborted.
   *
   * @member MediaError.MEDIA_ERR_ABORTED
   * @constant {number}
   * @default 1
   */
  MediaError.prototype.MEDIA_ERR_ABORTED = 1;

  /**
   * W3C error code for any network error.
   *
   * @member MediaError#MEDIA_ERR_NETWORK
   * @constant {number}
   * @default 2
   */
  MediaError.MEDIA_ERR_NETWORK = 2;

  /**
   * W3C error code for any network error.
   *
   * @member MediaError.MEDIA_ERR_NETWORK
   * @constant {number}
   * @default 2
   */
  MediaError.prototype.MEDIA_ERR_NETWORK = 2;

  /**
   * W3C error code for any decoding error.
   *
   * @member MediaError#MEDIA_ERR_DECODE
   * @constant {number}
   * @default 3
   */
  MediaError.MEDIA_ERR_DECODE = 3;

  /**
   * W3C error code for any decoding error.
   *
   * @member MediaError.MEDIA_ERR_DECODE
   * @constant {number}
   * @default 3
   */
  MediaError.prototype.MEDIA_ERR_DECODE = 3;

  /**
   * W3C error code for any time that a source is not supported.
   *
   * @member MediaError#MEDIA_ERR_SRC_NOT_SUPPORTED
   * @constant {number}
   * @default 4
   */
  MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

  /**
   * W3C error code for any time that a source is not supported.
   *
   * @member MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED
   * @constant {number}
   * @default 4
   */
  MediaError.prototype.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

  /**
   * W3C error code for any time that a source is encrypted.
   *
   * @member MediaError#MEDIA_ERR_ENCRYPTED
   * @constant {number}
   * @default 5
   */
  MediaError.MEDIA_ERR_ENCRYPTED = 5;

  /**
   * W3C error code for any time that a source is encrypted.
   *
   * @member MediaError.MEDIA_ERR_ENCRYPTED
   * @constant {number}
   * @default 5
   */
  MediaError.prototype.MEDIA_ERR_ENCRYPTED = 5;

  /**
   * Returns whether an object is `Promise`-like (i.e. has a `then` method).
   *
   * @param  {Object}  value
   *         An object that may or may not be `Promise`-like.
   *
   * @return {boolean}
   *         Whether or not the object is `Promise`-like.
   */
  function isPromise(value) {
    return value !== undefined && value !== null && typeof value.then === 'function';
  }

  /**
   * Silence a Promise-like object.
   *
   * This is useful for avoiding non-harmful, but potentially confusing "uncaught
   * play promise" rejection error messages.
   *
   * @param  {Object} value
   *         An object that may or may not be `Promise`-like.
   */
  function silencePromise(value) {
    if (isPromise(value)) {
      value.then(null, e => {});
    }
  }

  /**
   * @file text-track-list-converter.js Utilities for capturing text track state and
   * re-creating tracks based on a capture.
   *
   * @module text-track-list-converter
   */

  /** @import Tech from '../tech/tech' */

  /**
   * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that
   * represents the {@link TextTrack}'s state.
   *
   * @param {TextTrack} track
   *        The text track to query.
   *
   * @return {Object}
   *         A serializable javascript representation of the TextTrack.
   * @private
   */
  const trackToJson_ = function (track) {
    const ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce((acc, prop, i) => {
      if (track[prop]) {
        acc[prop] = track[prop];
      }
      return acc;
    }, {
      cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {
        return {
          startTime: cue.startTime,
          endTime: cue.endTime,
          text: cue.text,
          id: cue.id
        };
      })
    });
    return ret;
  };

  /**
   * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the
   * state of all {@link TextTrack}s currently configured. The return array is compatible with
   * {@link text-track-list-converter:jsonToTextTracks}.
   *
   * @param {Tech} tech
   *        The tech object to query
   *
   * @return {Array}
   *         A serializable javascript representation of the {@link Tech}s
   *         {@link TextTrackList}.
   */
  const textTracksToJson = function (tech) {
    const trackEls = tech.$$('track');
    const trackObjs = Array.prototype.map.call(trackEls, t => t.track);
    const tracks = Array.prototype.map.call(trackEls, function (trackEl) {
      const json = trackToJson_(trackEl.track);
      if (trackEl.src) {
        json.src = trackEl.src;
      }
      return json;
    });
    return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {
      return trackObjs.indexOf(track) === -1;
    }).map(trackToJson_));
  };

  /**
   * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript
   * object {@link TextTrack} representations.
   *
   * @param {Array} json
   *        An array of `TextTrack` representation objects, like those that would be
   *        produced by `textTracksToJson`.
   *
   * @param {Tech} tech
   *        The `Tech` to create the `TextTrack`s on.
   */
  const jsonToTextTracks = function (json, tech) {
    json.forEach(function (track) {
      const addedTrack = tech.addRemoteTextTrack(track).track;
      if (!track.src && track.cues) {
        track.cues.forEach(cue => addedTrack.addCue(cue));
      }
    });
    return tech.textTracks();
  };
  var textTrackConverter = {
    textTracksToJson,
    jsonToTextTracks,
    trackToJson_
  };

  /**
   * @file modal-dialog.js
   */

  /** @import Player from './player' */
  /** @import { ContentDescriptor } from './utils/dom' */

  const MODAL_CLASS_NAME = 'vjs-modal-dialog';

  /**
   * The `ModalDialog` displays over the video and its controls, which blocks
   * interaction with the player until it is closed.
   *
   * Modal dialogs include a "Close" button and will close when that button
   * is activated - or when ESC is pressed anywhere.
   *
   * @extends Component
   */
  class ModalDialog extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {ContentDescriptor} [options.content=undefined]
     *        Provide customized content for this modal.
     *
     * @param {string} [options.description]
     *        A text description for the modal, primarily for accessibility.
     *
     * @param {boolean} [options.fillAlways=false]
     *        Normally, modals are automatically filled only the first time
     *        they open. This tells the modal to refresh its content
     *        every time it opens.
     *
     * @param {string} [options.label]
     *        A text label for the modal, primarily for accessibility.
     *
     * @param {boolean} [options.pauseOnOpen=true]
     *        If `true`, playback will will be paused if playing when
     *        the modal opens, and resumed when it closes.
     *
     * @param {boolean} [options.temporary=true]
     *        If `true`, the modal can only be opened once; it will be
     *        disposed as soon as it's closed.
     *
     * @param {boolean} [options.uncloseable=false]
     *        If `true`, the user will not be able to close the modal
     *        through the UI in the normal ways. Programmatic closing is
     *        still possible.
     */
    constructor(player, options) {
      super(player, options);
      this.handleKeyDown_ = e => this.handleKeyDown(e);
      this.close_ = e => this.close(e);
      this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;
      this.closeable(!this.options_.uncloseable);
      this.content(this.options_.content);

      // Make sure the contentEl is defined AFTER any children are initialized
      // because we only want the contents of the modal in the contentEl
      // (not the UI elements like the close button).
      this.contentEl_ = createEl('div', {
        className: `${MODAL_CLASS_NAME}-content`
      }, {
        role: 'document'
      });
      this.descEl_ = createEl('p', {
        className: `${MODAL_CLASS_NAME}-description vjs-control-text`,
        id: this.el().getAttribute('aria-describedby')
      });
      textContent(this.descEl_, this.description());
      this.el_.appendChild(this.descEl_);
      this.el_.appendChild(this.contentEl_);
    }

    /**
     * Create the `ModalDialog`'s DOM element
     *
     * @return {Element}
     *         The DOM element that gets created.
     */
    createEl() {
      return super.createEl('div', {
        className: this.buildCSSClass(),
        tabIndex: -1
      }, {
        'aria-describedby': `${this.id()}_description`,
        'aria-hidden': 'true',
        'aria-label': this.label(),
        'role': 'dialog',
        'aria-live': 'polite'
      });
    }
    dispose() {
      this.contentEl_ = null;
      this.descEl_ = null;
      this.previouslyActiveEl_ = null;
      super.dispose();
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `${MODAL_CLASS_NAME} vjs-hidden ${super.buildCSSClass()}`;
    }

    /**
     * Returns the label string for this modal. Primarily used for accessibility.
     *
     * @return {string}
     *         the localized or raw label of this modal.
     */
    label() {
      return this.localize(this.options_.label || 'Modal Window');
    }

    /**
     * Returns the description string for this modal. Primarily used for
     * accessibility.
     *
     * @return {string}
     *         The localized or raw description of this modal.
     */
    description() {
      let desc = this.options_.description || this.localize('This is a modal window.');

      // Append a universal closeability message if the modal is closeable.
      if (this.closeable()) {
        desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');
      }
      return desc;
    }

    /**
     * Opens the modal.
     *
     * @fires ModalDialog#beforemodalopen
     * @fires ModalDialog#modalopen
     */
    open() {
      if (this.opened_) {
        if (this.options_.fillAlways) {
          this.fill();
        }
        return;
      }
      const player = this.player();

      /**
        * Fired just before a `ModalDialog` is opened.
        *
        * @event ModalDialog#beforemodalopen
        * @type {Event}
        */
      this.trigger('beforemodalopen');
      this.opened_ = true;

      // Fill content if the modal has never opened before and
      // never been filled.
      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
        this.fill();
      }

      // If the player was playing, pause it and take note of its previously
      // playing state.
      this.wasPlaying_ = !player.paused();
      if (this.options_.pauseOnOpen && this.wasPlaying_) {
        player.pause();
      }
      this.on('keydown', this.handleKeyDown_);

      // Hide controls and note if they were enabled.
      this.hadControls_ = player.controls();
      player.controls(false);
      this.show();
      this.conditionalFocus_();
      this.el().setAttribute('aria-hidden', 'false');

      /**
        * Fired just after a `ModalDialog` is opened.
        *
        * @event ModalDialog#modalopen
        * @type {Event}
        */
      this.trigger('modalopen');
      this.hasBeenOpened_ = true;
    }

    /**
     * If the `ModalDialog` is currently open or closed.
     *
     * @param  {boolean} [value]
     *         If given, it will open (`true`) or close (`false`) the modal.
     *
     * @return {boolean}
     *         the current open state of the modaldialog
     */
    opened(value) {
      if (typeof value === 'boolean') {
        this[value ? 'open' : 'close']();
      }
      return this.opened_;
    }

    /**
     * Closes the modal, does nothing if the `ModalDialog` is
     * not open.
     *
     * @fires ModalDialog#beforemodalclose
     * @fires ModalDialog#modalclose
     */
    close() {
      if (!this.opened_) {
        return;
      }
      const player = this.player();

      /**
        * Fired just before a `ModalDialog` is closed.
        *
        * @event ModalDialog#beforemodalclose
        * @type {Event}
        */
      this.trigger('beforemodalclose');
      this.opened_ = false;
      if (this.wasPlaying_ && this.options_.pauseOnOpen) {
        player.play();
      }
      this.off('keydown', this.handleKeyDown_);
      if (this.hadControls_) {
        player.controls(true);
      }
      this.hide();
      this.el().setAttribute('aria-hidden', 'true');

      /**
        * Fired just after a `ModalDialog` is closed.
        *
        * @event ModalDialog#modalclose
        * @type {Event}
        *
        * @property {boolean} [bubbles=true]
        */
      this.trigger({
        type: 'modalclose',
        bubbles: true
      });
      this.conditionalBlur_();
      if (this.options_.temporary) {
        this.dispose();
      }
    }

    /**
     * Check to see if the `ModalDialog` is closeable via the UI.
     *
     * @param  {boolean} [value]
     *         If given as a boolean, it will set the `closeable` option.
     *
     * @return {boolean}
     *         Returns the final value of the closable option.
     */
    closeable(value) {
      if (typeof value === 'boolean') {
        const closeable = this.closeable_ = !!value;
        let close = this.getChild('closeButton');

        // If this is being made closeable and has no close button, add one.
        if (closeable && !close) {
          // The close button should be a child of the modal - not its
          // content element, so temporarily change the content element.
          const temp = this.contentEl_;
          this.contentEl_ = this.el_;
          close = this.addChild('closeButton', {
            controlText: 'Close Modal Dialog'
          });
          this.contentEl_ = temp;
          this.on(close, 'close', this.close_);
        }

        // If this is being made uncloseable and has a close button, remove it.
        if (!closeable && close) {
          this.off(close, 'close', this.close_);
          this.removeChild(close);
          close.dispose();
        }
      }
      return this.closeable_;
    }

    /**
     * Fill the modal's content element with the modal's "content" option.
     * The content element will be emptied before this change takes place.
     */
    fill() {
      this.fillWith(this.content());
    }

    /**
     * Fill the modal's content element with arbitrary content.
     * The content element will be emptied before this change takes place.
     *
     * @fires ModalDialog#beforemodalfill
     * @fires ModalDialog#modalfill
     *
     * @param {ContentDescriptor} [content]
     *        The same rules apply to this as apply to the `content` option.
     */
    fillWith(content) {
      const contentEl = this.contentEl();
      const parentEl = contentEl.parentNode;
      const nextSiblingEl = contentEl.nextSibling;

      /**
        * Fired just before a `ModalDialog` is filled with content.
        *
        * @event ModalDialog#beforemodalfill
        * @type {Event}
        */
      this.trigger('beforemodalfill');
      this.hasBeenFilled_ = true;

      // Detach the content element from the DOM before performing
      // manipulation to avoid modifying the live DOM multiple times.
      parentEl.removeChild(contentEl);
      this.empty();
      insertContent(contentEl, content);
      /**
       * Fired just after a `ModalDialog` is filled with content.
       *
       * @event ModalDialog#modalfill
       * @type {Event}
       */
      this.trigger('modalfill');

      // Re-inject the re-filled content element.
      if (nextSiblingEl) {
        parentEl.insertBefore(contentEl, nextSiblingEl);
      } else {
        parentEl.appendChild(contentEl);
      }

      // make sure that the close button is last in the dialog DOM
      const closeButton = this.getChild('closeButton');
      if (closeButton) {
        parentEl.appendChild(closeButton.el_);
      }

      /**
       * Fired after `ModalDialog` is re-filled with content & close button is appended.
       *
       * @event ModalDialog#aftermodalfill
       * @type {Event}
       */
      this.trigger('aftermodalfill');
    }

    /**
     * Empties the content element. This happens anytime the modal is filled.
     *
     * @fires ModalDialog#beforemodalempty
     * @fires ModalDialog#modalempty
     */
    empty() {
      /**
      * Fired just before a `ModalDialog` is emptied.
      *
      * @event ModalDialog#beforemodalempty
      * @type {Event}
      */
      this.trigger('beforemodalempty');
      emptyEl(this.contentEl());

      /**
      * Fired just after a `ModalDialog` is emptied.
      *
      * @event ModalDialog#modalempty
      * @type {Event}
      */
      this.trigger('modalempty');
    }

    /**
     * Gets or sets the modal content, which gets normalized before being
     * rendered into the DOM.
     *
     * This does not update the DOM or fill the modal, but it is called during
     * that process.
     *
     * @param  {ContentDescriptor} [value]
     *         If defined, sets the internal content value to be used on the
     *         next call(s) to `fill`. This value is normalized before being
     *         inserted. To "clear" the internal content value, pass `null`.
     *
     * @return {ContentDescriptor}
     *         The current content of the modal dialog
     */
    content(value) {
      if (typeof value !== 'undefined') {
        this.content_ = value;
      }
      return this.content_;
    }

    /**
     * conditionally focus the modal dialog if focus was previously on the player.
     *
     * @private
     */
    conditionalFocus_() {
      const activeEl = document__default["default"].activeElement;
      const playerEl = this.player_.el_;
      this.previouslyActiveEl_ = null;
      if (playerEl.contains(activeEl) || playerEl === activeEl) {
        this.previouslyActiveEl_ = activeEl;
        this.focus();
      }
    }

    /**
     * conditionally blur the element and refocus the last focused element
     *
     * @private
     */
    conditionalBlur_() {
      if (this.previouslyActiveEl_) {
        this.previouslyActiveEl_.focus();
        this.previouslyActiveEl_ = null;
      }
    }

    /**
     * Keydown handler. Attached when modal is focused.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      /**
       * Fired a custom keyDown event that bubbles.
       *
       * @event ModalDialog#modalKeydown
       * @type {Event}
       */
      this.trigger({
        type: 'modalKeydown',
        originalEvent: event,
        target: this,
        bubbles: true
      });
      // Do not allow keydowns to reach out of the modal dialog.
      event.stopPropagation();
      if (event.key === 'Escape' && this.closeable()) {
        event.preventDefault();
        this.close();
        return;
      }

      // exit early if it isn't a tab key
      if (event.key !== 'Tab') {
        return;
      }
      const focusableEls = this.focusableEls_();
      const activeEl = this.el_.querySelector(':focus');
      let focusIndex;
      for (let i = 0; i < focusableEls.length; i++) {
        if (activeEl === focusableEls[i]) {
          focusIndex = i;
          break;
        }
      }
      if (document__default["default"].activeElement === this.el_) {
        focusIndex = 0;
      }
      if (event.shiftKey && focusIndex === 0) {
        focusableEls[focusableEls.length - 1].focus();
        event.preventDefault();
      } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
        focusableEls[0].focus();
        event.preventDefault();
      }
    }

    /**
     * get all focusable elements
     *
     * @private
     */
    focusableEls_() {
      const allChildren = this.el_.querySelectorAll('*');
      return Array.prototype.filter.call(allChildren, child => {
        return (child instanceof window__default["default"].HTMLAnchorElement || child instanceof window__default["default"].HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window__default["default"].HTMLInputElement || child instanceof window__default["default"].HTMLSelectElement || child instanceof window__default["default"].HTMLTextAreaElement || child instanceof window__default["default"].HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window__default["default"].HTMLIFrameElement || child instanceof window__default["default"].HTMLObjectElement || child instanceof window__default["default"].HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');
      });
    }
  }

  /**
   * Default options for `ModalDialog` default options.
   *
   * @type {Object}
   * @private
   */
  ModalDialog.prototype.options_ = {
    pauseOnOpen: true,
    temporary: true
  };
  Component.registerComponent('ModalDialog', ModalDialog);

  /**
   * @file track-list.js
   */

  /** @import Track from './track' */

  /**
   * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and
   * {@link VideoTrackList}
   *
   * @extends EventTarget
   */
  class TrackList extends EventTarget {
    /**
     * Create an instance of this class
     *
     * @param { Track[] } tracks
     *        A list of tracks to initialize the list with.
     *
     * @abstract
     */
    constructor(tracks = []) {
      super();
      this.tracks_ = [];

      /**
       * @memberof TrackList
       * @member {number} length
       *         The current number of `Track`s in the this Trackist.
       * @instance
       */
      Object.defineProperty(this, 'length', {
        get() {
          return this.tracks_.length;
        }
      });
      for (let i = 0; i < tracks.length; i++) {
        this.addTrack(tracks[i]);
      }
    }

    /**
     * Add a {@link Track} to the `TrackList`
     *
     * @param {Track} track
     *        The audio, video, or text track to add to the list.
     *
     * @fires TrackList#addtrack
     */
    addTrack(track) {
      const index = this.tracks_.length;
      if (!('' + index in this)) {
        Object.defineProperty(this, index, {
          get() {
            return this.tracks_[index];
          }
        });
      }

      // Do not add duplicate tracks
      if (this.tracks_.indexOf(track) === -1) {
        this.tracks_.push(track);
        /**
         * Triggered when a track is added to a track list.
         *
         * @event TrackList#addtrack
         * @type {Event}
         * @property {Track} track
         *           A reference to track that was added.
         */
        this.trigger({
          track,
          type: 'addtrack',
          target: this
        });
      }

      /**
       * Triggered when a track label is changed.
       *
       * @event TrackList#addtrack
       * @type {Event}
       * @property {Track} track
       *           A reference to track that was added.
       */
      track.labelchange_ = () => {
        this.trigger({
          track,
          type: 'labelchange',
          target: this
        });
      };
      if (isEvented(track)) {
        track.addEventListener('labelchange', track.labelchange_);
      }
    }

    /**
     * Remove a {@link Track} from the `TrackList`
     *
     * @param {Track} rtrack
     *        The audio, video, or text track to remove from the list.
     *
     * @fires TrackList#removetrack
     */
    removeTrack(rtrack) {
      let track;
      for (let i = 0, l = this.length; i < l; i++) {
        if (this[i] === rtrack) {
          track = this[i];
          if (track.off) {
            track.off();
          }
          this.tracks_.splice(i, 1);
          break;
        }
      }
      if (!track) {
        return;
      }

      /**
       * Triggered when a track is removed from track list.
       *
       * @event TrackList#removetrack
       * @type {Event}
       * @property {Track} track
       *           A reference to track that was removed.
       */
      this.trigger({
        track,
        type: 'removetrack',
        target: this
      });
    }

    /**
     * Get a Track from the TrackList by a tracks id
     *
     * @param {string} id - the id of the track to get
     * @method getTrackById
     * @return {Track}
     * @private
     */
    getTrackById(id) {
      let result = null;
      for (let i = 0, l = this.length; i < l; i++) {
        const track = this[i];
        if (track.id === id) {
          result = track;
          break;
        }
      }
      return result;
    }
  }

  /**
   * Triggered when a different track is selected/enabled.
   *
   * @event TrackList#change
   * @type {Event}
   */

  /**
   * Events that can be called with on + eventName. See {@link EventHandler}.
   *
   * @property {Object} TrackList#allowedEvents_
   * @protected
   */
  TrackList.prototype.allowedEvents_ = {
    change: 'change',
    addtrack: 'addtrack',
    removetrack: 'removetrack',
    labelchange: 'labelchange'
  };

  // emulate attribute EventHandler support to allow for feature detection
  for (const event in TrackList.prototype.allowedEvents_) {
    TrackList.prototype['on' + event] = null;
  }

  /**
   * @file audio-track-list.js
   */

  /** @import AudioTrack from './audio-track' */

  /**
   * Anywhere we call this function we diverge from the spec
   * as we only support one enabled audiotrack at a time
   *
   * @param {AudioTrackList} list
   *        list to work on
   *
   * @param {AudioTrack} track
   *        The track to skip
   *
   * @private
   */
  const disableOthers$1 = function (list, track) {
    for (let i = 0; i < list.length; i++) {
      if (!Object.keys(list[i]).length || track.id === list[i].id) {
        continue;
      }
      // another audio track is enabled, disable it
      list[i].enabled = false;
    }
  };

  /**
   * The current list of {@link AudioTrack} for a media file.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}
   * @extends TrackList
   */
  class AudioTrackList extends TrackList {
    /**
     * Create an instance of this class.
     *
     * @param {AudioTrack[]} [tracks=[]]
     *        A list of `AudioTrack` to instantiate the list with.
     */
    constructor(tracks = []) {
      // make sure only 1 track is enabled
      // sorted from last index to first index
      for (let i = tracks.length - 1; i >= 0; i--) {
        if (tracks[i].enabled) {
          disableOthers$1(tracks, tracks[i]);
          break;
        }
      }
      super(tracks);
      this.changing_ = false;
    }

    /**
     * Add an {@link AudioTrack} to the `AudioTrackList`.
     *
     * @param {AudioTrack} track
     *        The AudioTrack to add to the list
     *
     * @fires TrackList#addtrack
     */
    addTrack(track) {
      if (track.enabled) {
        disableOthers$1(this, track);
      }
      super.addTrack(track);
      // native tracks don't have this
      if (!track.addEventListener) {
        return;
      }
      track.enabledChange_ = () => {
        // when we are disabling other tracks (since we don't support
        // more than one track at a time) we will set changing_
        // to true so that we don't trigger additional change events
        if (this.changing_) {
          return;
        }
        this.changing_ = true;
        disableOthers$1(this, track);
        this.changing_ = false;
        this.trigger('change');
      };

      /**
       * @listens AudioTrack#enabledchange
       * @fires TrackList#change
       */
      track.addEventListener('enabledchange', track.enabledChange_);
    }
    removeTrack(rtrack) {
      super.removeTrack(rtrack);
      if (rtrack.removeEventListener && rtrack.enabledChange_) {
        rtrack.removeEventListener('enabledchange', rtrack.enabledChange_);
        rtrack.enabledChange_ = null;
      }
    }
  }

  /**
   * @file video-track-list.js
   */

  /** @import VideoTrack from './video-track' */

  /**
   * Un-select all other {@link VideoTrack}s that are selected.
   *
   * @param {VideoTrackList} list
   *        list to work on
   *
   * @param {VideoTrack} track
   *        The track to skip
   *
   * @private
   */
  const disableOthers = function (list, track) {
    for (let i = 0; i < list.length; i++) {
      if (!Object.keys(list[i]).length || track.id === list[i].id) {
        continue;
      }
      // another video track is enabled, disable it
      list[i].selected = false;
    }
  };

  /**
   * The current list of {@link VideoTrack} for a video.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}
   * @extends TrackList
   */
  class VideoTrackList extends TrackList {
    /**
     * Create an instance of this class.
     *
     * @param {VideoTrack[]} [tracks=[]]
     *        A list of `VideoTrack` to instantiate the list with.
     */
    constructor(tracks = []) {
      // make sure only 1 track is enabled
      // sorted from last index to first index
      for (let i = tracks.length - 1; i >= 0; i--) {
        if (tracks[i].selected) {
          disableOthers(tracks, tracks[i]);
          break;
        }
      }
      super(tracks);
      this.changing_ = false;

      /**
       * @member {number} VideoTrackList#selectedIndex
       *         The current index of the selected {@link VideoTrack`}.
       */
      Object.defineProperty(this, 'selectedIndex', {
        get() {
          for (let i = 0; i < this.length; i++) {
            if (this[i].selected) {
              return i;
            }
          }
          return -1;
        },
        set() {}
      });
    }

    /**
     * Add a {@link VideoTrack} to the `VideoTrackList`.
     *
     * @param {VideoTrack} track
     *        The VideoTrack to add to the list
     *
     * @fires TrackList#addtrack
     */
    addTrack(track) {
      if (track.selected) {
        disableOthers(this, track);
      }
      super.addTrack(track);
      // native tracks don't have this
      if (!track.addEventListener) {
        return;
      }
      track.selectedChange_ = () => {
        if (this.changing_) {
          return;
        }
        this.changing_ = true;
        disableOthers(this, track);
        this.changing_ = false;
        this.trigger('change');
      };

      /**
       * @listens VideoTrack#selectedchange
       * @fires TrackList#change
       */
      track.addEventListener('selectedchange', track.selectedChange_);
    }
    removeTrack(rtrack) {
      super.removeTrack(rtrack);
      if (rtrack.removeEventListener && rtrack.selectedChange_) {
        rtrack.removeEventListener('selectedchange', rtrack.selectedChange_);
        rtrack.selectedChange_ = null;
      }
    }
  }

  /**
   * @file text-track-list.js
   */

  /** @import TextTrack from './text-track' */

  /**
   * The current list of {@link TextTrack} for a media file.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}
   * @extends TrackList
   */
  class TextTrackList extends TrackList {
    /**
     * Add a {@link TextTrack} to the `TextTrackList`
     *
     * @param {TextTrack} track
     *        The text track to add to the list.
     *
     * @fires TrackList#addtrack
     */
    addTrack(track) {
      super.addTrack(track);
      if (!this.queueChange_) {
        this.queueChange_ = () => this.queueTrigger('change');
      }
      if (!this.triggerSelectedlanguagechange) {
        this.triggerSelectedlanguagechange_ = () => this.trigger('selectedlanguagechange');
      }

      /**
       * @listens TextTrack#modechange
       * @fires TrackList#change
       */
      track.addEventListener('modechange', this.queueChange_);
      const nonLanguageTextTrackKind = ['metadata', 'chapters'];
      if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
        track.addEventListener('modechange', this.triggerSelectedlanguagechange_);
      }
    }
    removeTrack(rtrack) {
      super.removeTrack(rtrack);

      // manually remove the event handlers we added
      if (rtrack.removeEventListener) {
        if (this.queueChange_) {
          rtrack.removeEventListener('modechange', this.queueChange_);
        }
        if (this.selectedlanguagechange_) {
          rtrack.removeEventListener('modechange', this.triggerSelectedlanguagechange_);
        }
      }
    }
  }

  /**
   * @file html-track-element-list.js
   */

  /**
   * The current list of {@link HtmlTrackElement}s.
   */
  class HtmlTrackElementList {
    /**
     * Create an instance of this class.
     *
     * @param {HtmlTrackElement[]} [tracks=[]]
     *        A list of `HtmlTrackElement` to instantiate the list with.
     */
    constructor(trackElements = []) {
      this.trackElements_ = [];

      /**
       * @memberof HtmlTrackElementList
       * @member {number} length
       *         The current number of `Track`s in the this Trackist.
       * @instance
       */
      Object.defineProperty(this, 'length', {
        get() {
          return this.trackElements_.length;
        }
      });
      for (let i = 0, length = trackElements.length; i < length; i++) {
        this.addTrackElement_(trackElements[i]);
      }
    }

    /**
     * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`
     *
     * @param {HtmlTrackElement} trackElement
     *        The track element to add to the list.
     *
     * @private
     */
    addTrackElement_(trackElement) {
      const index = this.trackElements_.length;
      if (!('' + index in this)) {
        Object.defineProperty(this, index, {
          get() {
            return this.trackElements_[index];
          }
        });
      }

      // Do not add duplicate elements
      if (this.trackElements_.indexOf(trackElement) === -1) {
        this.trackElements_.push(trackElement);
      }
    }

    /**
     * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an
     * {@link TextTrack}.
     *
     * @param {TextTrack} track
     *        The track associated with a track element.
     *
     * @return {HtmlTrackElement|undefined}
     *         The track element that was found or undefined.
     *
     * @private
     */
    getTrackElementByTrack_(track) {
      let trackElement_;
      for (let i = 0, length = this.trackElements_.length; i < length; i++) {
        if (track === this.trackElements_[i].track) {
          trackElement_ = this.trackElements_[i];
          break;
        }
      }
      return trackElement_;
    }

    /**
     * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`
     *
     * @param {HtmlTrackElement} trackElement
     *        The track element to remove from the list.
     *
     * @private
     */
    removeTrackElement_(trackElement) {
      for (let i = 0, length = this.trackElements_.length; i < length; i++) {
        if (trackElement === this.trackElements_[i]) {
          if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === 'function') {
            this.trackElements_[i].track.off();
          }
          if (typeof this.trackElements_[i].off === 'function') {
            this.trackElements_[i].off();
          }
          this.trackElements_.splice(i, 1);
          break;
        }
      }
    }
  }

  /**
   * @file text-track-cue-list.js
   */

  /**
   * @typedef {Object} TextTrackCueList~TextTrackCue
   *
   * @property {string} id
   *           The unique id for this text track cue
   *
   * @property {number} startTime
   *           The start time for this text track cue
   *
   * @property {number} endTime
   *           The end time for this text track cue
   *
   * @property {boolean} pauseOnExit
   *           Pause when the end time is reached if true.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}
   */

  /**
   * A List of TextTrackCues.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}
   */
  class TextTrackCueList {
    /**
     * Create an instance of this class..
     *
     * @param {Array} cues
     *        A list of cues to be initialized with
     */
    constructor(cues) {
      TextTrackCueList.prototype.setCues_.call(this, cues);

      /**
       * @memberof TextTrackCueList
       * @member {number} length
       *         The current number of `TextTrackCue`s in the TextTrackCueList.
       * @instance
       */
      Object.defineProperty(this, 'length', {
        get() {
          return this.length_;
        }
      });
    }

    /**
     * A setter for cues in this list. Creates getters
     * an an index for the cues.
     *
     * @param {Array} cues
     *        An array of cues to set
     *
     * @private
     */
    setCues_(cues) {
      const oldLength = this.length || 0;
      let i = 0;
      const l = cues.length;
      this.cues_ = cues;
      this.length_ = cues.length;
      const defineProp = function (index) {
        if (!('' + index in this)) {
          Object.defineProperty(this, '' + index, {
            get() {
              return this.cues_[index];
            }
          });
        }
      };
      if (oldLength < l) {
        i = oldLength;
        for (; i < l; i++) {
          defineProp.call(this, i);
        }
      }
    }

    /**
     * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.
     *
     * @param {string} id
     *        The id of the cue that should be searched for.
     *
     * @return {TextTrackCueList~TextTrackCue|null}
     *         A single cue or null if none was found.
     */
    getCueById(id) {
      let result = null;
      for (let i = 0, l = this.length; i < l; i++) {
        const cue = this[i];
        if (cue.id === id) {
          result = cue;
          break;
        }
      }
      return result;
    }
  }

  /**
   * @file track-kinds.js
   */

  /**
   * All possible `VideoTrackKind`s
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind
   * @typedef VideoTrack~Kind
   * @enum
   */
  const VideoTrackKind = {
    alternative: 'alternative',
    captions: 'captions',
    main: 'main',
    sign: 'sign',
    subtitles: 'subtitles',
    commentary: 'commentary'
  };

  /**
   * All possible `AudioTrackKind`s
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind
   * @typedef AudioTrack~Kind
   * @enum
   */
  const AudioTrackKind = {
    'alternative': 'alternative',
    'descriptions': 'descriptions',
    'main': 'main',
    'main-desc': 'main-desc',
    'translation': 'translation',
    'commentary': 'commentary'
  };

  /**
   * All possible `TextTrackKind`s
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind
   * @typedef TextTrack~Kind
   * @enum
   */
  const TextTrackKind = {
    subtitles: 'subtitles',
    captions: 'captions',
    descriptions: 'descriptions',
    chapters: 'chapters',
    metadata: 'metadata'
  };

  /**
   * All possible `TextTrackMode`s
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
   * @typedef TextTrack~Mode
   * @enum
   */
  const TextTrackMode = {
    disabled: 'disabled',
    hidden: 'hidden',
    showing: 'showing'
  };

  /**
   * @file track.js
   */

  /**
   * A Track class that contains all of the common functionality for {@link AudioTrack},
   * {@link VideoTrack}, and {@link TextTrack}.
   *
   * > Note: This class should not be used directly
   *
   * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}
   * @extends EventTarget
   * @abstract
   */
  class Track extends EventTarget {
    /**
     * Create an instance of this class.
     *
     * @param {Object} [options={}]
     *        Object of option names and values
     *
     * @param {string} [options.kind='']
     *        A valid kind for the track type you are creating.
     *
     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
     *        A unique id for this AudioTrack.
     *
     * @param {string} [options.label='']
     *        The menu label for this track.
     *
     * @param {string} [options.language='']
     *        A valid two character language code.
     *
     * @abstract
     */
    constructor(options = {}) {
      super();
      const trackProps = {
        id: options.id || 'vjs_track_' + newGUID(),
        kind: options.kind || '',
        language: options.language || ''
      };
      let label = options.label || '';

      /**
       * @memberof Track
       * @member {string} id
       *         The id of this track. Cannot be changed after creation.
       * @instance
       *
       * @readonly
       */

      /**
       * @memberof Track
       * @member {string} kind
       *         The kind of track that this is. Cannot be changed after creation.
       * @instance
       *
       * @readonly
       */

      /**
       * @memberof Track
       * @member {string} language
       *         The two letter language code for this track. Cannot be changed after
       *         creation.
       * @instance
       *
       * @readonly
       */

      for (const key in trackProps) {
        Object.defineProperty(this, key, {
          get() {
            return trackProps[key];
          },
          set() {}
        });
      }

      /**
       * @memberof Track
       * @member {string} label
       *         The label of this track. Cannot be changed after creation.
       * @instance
       *
       * @fires Track#labelchange
       */
      Object.defineProperty(this, 'label', {
        get() {
          return label;
        },
        set(newLabel) {
          if (newLabel !== label) {
            label = newLabel;

            /**
             * An event that fires when label changes on this track.
             *
             * > Note: This is not part of the spec!
             *
             * @event Track#labelchange
             * @type {Event}
             */
            this.trigger('labelchange');
          }
        }
      });
    }
  }

  /**
   * @file url.js
   * @module url
   */

  /**
   * Resolve and parse the elements of a URL.
   *
   * @function
   * @param    {string} url
   *           The url to parse
   *
   * @return   {URL}
   *           An object of url details
   */
  const parseUrl = function (url) {
    return new URL(url, document__default["default"].baseURI);
  };

  /**
   * Get absolute version of relative URL.
   *
   * @function
   * @param    {string} url
   *           URL to make absolute
   *
   * @return   {string}
   *           Absolute URL
   */
  const getAbsoluteURL = function (url) {
    return new URL(url, document__default["default"].baseURI).href;
  };

  /**
   * Returns the extension of the passed file name. It will return an empty string
   * if passed an invalid path.
   *
   * @function
   * @param    {string} path
   *           The fileName path like '/path/to/file.mp4'
   *
   * @return  {string}
   *           The extension in lower case or an empty string if no
   *           extension could be found.
   */
  const getFileExtension = function (path) {
    if (typeof path === 'string') {
      const splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
      const pathParts = splitPathRe.exec(path);
      if (pathParts) {
        return pathParts.pop().toLowerCase();
      }
    }
    return '';
  };

  /**
   * Returns whether the url passed is a cross domain request or not.
   *
   * @function
   * @param    {string} url
   *           The url to check.
   *
   * @param    {URL} [winLoc]
   *           the domain to check the url against, defaults to window.location
   *
   * @return   {boolean}
   *           Whether it is a cross domain request or not.
   */
  const isCrossOrigin = function (url, winLoc = window__default["default"].location) {
    return parseUrl(url).origin !== winLoc.origin;
  };

  var Url = /*#__PURE__*/Object.freeze({
    __proto__: null,
    parseUrl: parseUrl,
    getAbsoluteURL: getAbsoluteURL,
    getFileExtension: getFileExtension,
    isCrossOrigin: isCrossOrigin
  });

  /**
   * @file text-track.js
   */

  /** @import Tech from '../tech/tech' */

  /**
   * Takes a webvtt file contents and parses it into cues
   *
   * @param {string} srcContent
   *        webVTT file contents
   *
   * @param {TextTrack} track
   *        TextTrack to add cues to. Cues come from the srcContent.
   *
   * @private
   */
  const parseCues = function (srcContent, track) {
    const parser = new window__default["default"].WebVTT.Parser(window__default["default"], window__default["default"].vttjs, window__default["default"].WebVTT.StringDecoder());
    const errors = [];
    parser.oncue = function (cue) {
      track.addCue(cue);
    };
    parser.onparsingerror = function (error) {
      errors.push(error);
    };
    parser.onflush = function () {
      track.trigger({
        type: 'loadeddata',
        target: track
      });
    };
    parser.parse(srcContent);
    if (errors.length > 0) {
      if (window__default["default"].console && window__default["default"].console.groupCollapsed) {
        window__default["default"].console.groupCollapsed(`Text Track parsing errors for ${track.src}`);
      }
      errors.forEach(error => log.error(error));
      if (window__default["default"].console && window__default["default"].console.groupEnd) {
        window__default["default"].console.groupEnd();
      }
    }
    parser.flush();
  };

  /**
   * Load a `TextTrack` from a specified url.
   *
   * @param {string} src
   *        Url to load track from.
   *
   * @param {TextTrack} track
   *        Track to add cues to. Comes from the content at the end of `url`.
   *
   * @private
   */
  const loadTrack = function (src, track) {
    const opts = {
      uri: src
    };
    const crossOrigin = isCrossOrigin(src);
    if (crossOrigin) {
      opts.cors = crossOrigin;
    }
    const withCredentials = track.tech_.crossOrigin() === 'use-credentials';
    if (withCredentials) {
      opts.withCredentials = withCredentials;
    }
    XHR__default["default"](opts, bind_(this, function (err, response, responseBody) {
      if (err) {
        return log.error(err, response);
      }
      track.loaded_ = true;

      // Make sure that vttjs has loaded, otherwise, wait till it finished loading
      // NOTE: this is only used for the alt/video.novtt.js build
      if (typeof window__default["default"].WebVTT !== 'function') {
        if (track.tech_) {
          // to prevent use before define eslint error, we define loadHandler
          // as a let here
          track.tech_.any(['vttjsloaded', 'vttjserror'], event => {
            if (event.type === 'vttjserror') {
              log.error(`vttjs failed to load, stopping trying to process ${track.src}`);
              return;
            }
            return parseCues(responseBody, track);
          });
        }
      } else {
        parseCues(responseBody, track);
      }
    }));
  };

  /**
   * A representation of a single `TextTrack`.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}
   * @extends Track
   */
  class TextTrack extends Track {
    /**
     * Create an instance of this class.
     *
     * @param {Object} options={}
     *        Object of option names and values
     *
     * @param {Tech} options.tech
     *        A reference to the tech that owns this TextTrack.
     *
     * @param {TextTrack~Kind} [options.kind='subtitles']
     *        A valid text track kind.
     *
     * @param {TextTrack~Mode} [options.mode='disabled']
     *        A valid text track mode.
     *
     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
     *        A unique id for this TextTrack.
     *
     * @param {string} [options.label='']
     *        The menu label for this track.
     *
     * @param {string} [options.language='']
     *        A valid two character language code.
     *
     * @param {string} [options.srclang='']
     *        A valid two character language code. An alternative, but deprioritized
     *        version of `options.language`
     *
     * @param {string} [options.src]
     *        A url to TextTrack cues.
     *
     * @param {boolean} [options.default]
     *        If this track should default to on or off.
     */
    constructor(options = {}) {
      if (!options.tech) {
        throw new Error('A tech was not provided.');
      }
      const settings = merge(options, {
        kind: TextTrackKind[options.kind] || 'subtitles',
        language: options.language || options.srclang || ''
      });
      let mode = TextTrackMode[settings.mode] || 'disabled';
      const default_ = settings.default;
      if (settings.kind === 'metadata' || settings.kind === 'chapters') {
        mode = 'hidden';
      }
      super(settings);
      this.tech_ = settings.tech;
      this.cues_ = [];
      this.activeCues_ = [];
      this.preload_ = this.tech_.preloadTextTracks !== false;
      const cues = new TextTrackCueList(this.cues_);
      const activeCues = new TextTrackCueList(this.activeCues_);
      let changed = false;
      this.timeupdateHandler = bind_(this, function (event = {}) {
        if (this.tech_.isDisposed()) {
          return;
        }
        if (!this.tech_.isReady_) {
          if (event.type !== 'timeupdate') {
            this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
          }
          return;
        }

        // Accessing this.activeCues for the side-effects of updating itself
        // due to its nature as a getter function. Do not remove or cues will
        // stop updating!
        // Use the setter to prevent deletion from uglify (pure_getters rule)
        this.activeCues = this.activeCues;
        if (changed) {
          this.trigger('cuechange');
          changed = false;
        }
        if (event.type !== 'timeupdate') {
          this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
        }
      });
      const disposeHandler = () => {
        this.stopTracking();
      };
      this.tech_.one('dispose', disposeHandler);
      if (mode !== 'disabled') {
        this.startTracking();
      }
      Object.defineProperties(this, {
        /**
         * @memberof TextTrack
         * @member {boolean} default
         *         If this track was set to be on or off by default. Cannot be changed after
         *         creation.
         * @instance
         *
         * @readonly
         */
        default: {
          get() {
            return default_;
          },
          set() {}
        },
        /**
         * @memberof TextTrack
         * @member {string} mode
         *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
         *         not be set if setting to an invalid mode.
         * @instance
         *
         * @fires TextTrack#modechange
         */
        mode: {
          get() {
            return mode;
          },
          set(newMode) {
            if (!TextTrackMode[newMode]) {
              return;
            }
            if (mode === newMode) {
              return;
            }
            mode = newMode;
            if (!this.preload_ && mode !== 'disabled' && this.cues.length === 0) {
              // On-demand load.
              loadTrack(this.src, this);
            }
            this.stopTracking();
            if (mode !== 'disabled') {
              this.startTracking();
            }
            /**
             * An event that fires when mode changes on this track. This allows
             * the TextTrackList that holds this track to act accordingly.
             *
             * > Note: This is not part of the spec!
             *
             * @event TextTrack#modechange
             * @type {Event}
             */
            this.trigger('modechange');
          }
        },
        /**
         * @memberof TextTrack
         * @member {TextTrackCueList} cues
         *         The text track cue list for this TextTrack.
         * @instance
         */
        cues: {
          get() {
            if (!this.loaded_) {
              return null;
            }
            return cues;
          },
          set() {}
        },
        /**
         * @memberof TextTrack
         * @member {TextTrackCueList} activeCues
         *         The list text track cues that are currently active for this TextTrack.
         * @instance
         */
        activeCues: {
          get() {
            if (!this.loaded_) {
              return null;
            }

            // nothing to do
            if (this.cues.length === 0) {
              return activeCues;
            }
            const ct = this.tech_.currentTime();
            const active = [];
            for (let i = 0, l = this.cues.length; i < l; i++) {
              const cue = this.cues[i];
              if (cue.startTime <= ct && cue.endTime >= ct) {
                active.push(cue);
              }
            }
            changed = false;
            if (active.length !== this.activeCues_.length) {
              changed = true;
            } else {
              for (let i = 0; i < active.length; i++) {
                if (this.activeCues_.indexOf(active[i]) === -1) {
                  changed = true;
                }
              }
            }
            this.activeCues_ = active;
            activeCues.setCues_(this.activeCues_);
            return activeCues;
          },
          // /!\ Keep this setter empty (see the timeupdate handler above)
          set() {}
        }
      });
      if (settings.src) {
        this.src = settings.src;
        if (!this.preload_) {
          // Tracks will load on-demand.
          // Act like we're loaded for other purposes.
          this.loaded_ = true;
        }
        if (this.preload_ || settings.kind !== 'subtitles' && settings.kind !== 'captions') {
          loadTrack(this.src, this);
        }
      } else {
        this.loaded_ = true;
      }
    }
    startTracking() {
      // More precise cues based on requestVideoFrameCallback with a requestAnimationFram fallback
      this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
      // Also listen to timeupdate in case rVFC/rAF stops (window in background, audio in video el)
      this.tech_.on('timeupdate', this.timeupdateHandler);
    }
    stopTracking() {
      if (this.rvf_) {
        this.tech_.cancelVideoFrameCallback(this.rvf_);
        this.rvf_ = undefined;
      }
      this.tech_.off('timeupdate', this.timeupdateHandler);
    }

    /**
     * Add a cue to the internal list of cues.
     *
     * @param {TextTrack~Cue} cue
     *        The cue to add to our internal list
     */
    addCue(originalCue) {
      let cue = originalCue;

      // Testing if the cue is a VTTCue in a way that survives minification
      if (!('getCueAsHTML' in cue)) {
        cue = new window__default["default"].vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);
        for (const prop in originalCue) {
          if (!(prop in cue)) {
            cue[prop] = originalCue[prop];
          }
        }

        // make sure that `id` is copied over
        cue.id = originalCue.id;
        cue.originalCue_ = originalCue;
      }
      const tracks = this.tech_.textTracks();
      for (let i = 0; i < tracks.length; i++) {
        if (tracks[i] !== this) {
          tracks[i].removeCue(cue);
        }
      }
      this.cues_.push(cue);
      this.cues.setCues_(this.cues_);
    }

    /**
     * Remove a cue from our internal list
     *
     * @param {TextTrack~Cue} removeCue
     *        The cue to remove from our internal list
     */
    removeCue(removeCue) {
      let i = this.cues_.length;
      while (i--) {
        const cue = this.cues_[i];
        if (cue === removeCue || cue.originalCue_ && cue.originalCue_ === removeCue) {
          this.cues_.splice(i, 1);
          this.cues.setCues_(this.cues_);
          break;
        }
      }
    }
  }

  /**
   * cuechange - One or more cues in the track have become active or stopped being active.
   *
   * @protected
   */
  TextTrack.prototype.allowedEvents_ = {
    cuechange: 'cuechange'
  };

  /**
   * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}
   * only one `AudioTrack` in the list will be enabled at a time.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}
   * @extends Track
   */
  class AudioTrack extends Track {
    /**
     * Create an instance of this class.
     *
     * @param {Object} [options={}]
     *        Object of option names and values
     *
     * @param {AudioTrack~Kind} [options.kind='']
     *        A valid audio track kind
     *
     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
     *        A unique id for this AudioTrack.
     *
     * @param {string} [options.label='']
     *        The menu label for this track.
     *
     * @param {string} [options.language='']
     *        A valid two character language code.
     *
     * @param {boolean} [options.enabled]
     *        If this track is the one that is currently playing. If this track is part of
     *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.
     */
    constructor(options = {}) {
      const settings = merge(options, {
        kind: AudioTrackKind[options.kind] || ''
      });
      super(settings);
      let enabled = false;

      /**
       * @memberof AudioTrack
       * @member {boolean} enabled
       *         If this `AudioTrack` is enabled or not. When setting this will
       *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.
       * @instance
       *
       * @fires VideoTrack#selectedchange
       */
      Object.defineProperty(this, 'enabled', {
        get() {
          return enabled;
        },
        set(newEnabled) {
          // an invalid or unchanged value
          if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {
            return;
          }
          enabled = newEnabled;

          /**
           * An event that fires when enabled changes on this track. This allows
           * the AudioTrackList that holds this track to act accordingly.
           *
           * > Note: This is not part of the spec! Native tracks will do
           *         this internally without an event.
           *
           * @event AudioTrack#enabledchange
           * @type {Event}
           */
          this.trigger('enabledchange');
        }
      });

      // if the user sets this track to selected then
      // set selected to that true value otherwise
      // we keep it false
      if (settings.enabled) {
        this.enabled = settings.enabled;
      }
      this.loaded_ = true;
    }
  }

  /**
   * A representation of a single `VideoTrack`.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}
   * @extends Track
   */
  class VideoTrack extends Track {
    /**
     * Create an instance of this class.
     *
     * @param {Object} [options={}]
     *        Object of option names and values
     *
     * @param {string} [options.kind='']
     *        A valid {@link VideoTrack~Kind}
     *
     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
     *        A unique id for this AudioTrack.
     *
     * @param {string} [options.label='']
     *        The menu label for this track.
     *
     * @param {string} [options.language='']
     *        A valid two character language code.
     *
     * @param {boolean} [options.selected]
     *        If this track is the one that is currently playing.
     */
    constructor(options = {}) {
      const settings = merge(options, {
        kind: VideoTrackKind[options.kind] || ''
      });
      super(settings);
      let selected = false;

      /**
       * @memberof VideoTrack
       * @member {boolean} selected
       *         If this `VideoTrack` is selected or not. When setting this will
       *         fire {@link VideoTrack#selectedchange} if the state of selected changed.
       * @instance
       *
       * @fires VideoTrack#selectedchange
       */
      Object.defineProperty(this, 'selected', {
        get() {
          return selected;
        },
        set(newSelected) {
          // an invalid or unchanged value
          if (typeof newSelected !== 'boolean' || newSelected === selected) {
            return;
          }
          selected = newSelected;

          /**
           * An event that fires when selected changes on this track. This allows
           * the VideoTrackList that holds this track to act accordingly.
           *
           * > Note: This is not part of the spec! Native tracks will do
           *         this internally without an event.
           *
           * @event VideoTrack#selectedchange
           * @type {Event}
           */
          this.trigger('selectedchange');
        }
      });

      // if the user sets this track to selected then
      // set selected to that true value otherwise
      // we keep it false
      if (settings.selected) {
        this.selected = settings.selected;
      }
    }
  }

  /**
   * @file html-track-element.js
   */

  /** @import Tech from '../tech/tech' */

  /**
   * A single track represented in the DOM.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}
   * @extends EventTarget
   */
  class HTMLTrackElement extends EventTarget {
    /**
     * Create an instance of this class.
     *
     * @param {Object} options={}
     *        Object of option names and values
     *
     * @param {Tech} options.tech
     *        A reference to the tech that owns this HTMLTrackElement.
     *
     * @param {TextTrack~Kind} [options.kind='subtitles']
     *        A valid text track kind.
     *
     * @param {TextTrack~Mode} [options.mode='disabled']
     *        A valid text track mode.
     *
     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
     *        A unique id for this TextTrack.
     *
     * @param {string} [options.label='']
     *        The menu label for this track.
     *
     * @param {string} [options.language='']
     *        A valid two character language code.
     *
     * @param {string} [options.srclang='']
     *        A valid two character language code. An alternative, but deprioritized
     *        version of `options.language`
     *
     * @param {string} [options.src]
     *        A url to TextTrack cues.
     *
     * @param {boolean} [options.default]
     *        If this track should default to on or off.
     */
    constructor(options = {}) {
      super();
      let readyState;
      const track = new TextTrack(options);
      this.kind = track.kind;
      this.src = track.src;
      this.srclang = track.language;
      this.label = track.label;
      this.default = track.default;
      Object.defineProperties(this, {
        /**
         * @memberof HTMLTrackElement
         * @member {HTMLTrackElement~ReadyState} readyState
         *         The current ready state of the track element.
         * @instance
         */
        readyState: {
          get() {
            return readyState;
          }
        },
        /**
         * @memberof HTMLTrackElement
         * @member {TextTrack} track
         *         The underlying TextTrack object.
         * @instance
         *
         */
        track: {
          get() {
            return track;
          }
        }
      });
      readyState = HTMLTrackElement.NONE;

      /**
       * @listens TextTrack#loadeddata
       * @fires HTMLTrackElement#load
       */
      track.addEventListener('loadeddata', () => {
        readyState = HTMLTrackElement.LOADED;
        this.trigger({
          type: 'load',
          target: this
        });
      });
    }
  }

  /**
   * @protected
   */
  HTMLTrackElement.prototype.allowedEvents_ = {
    load: 'load'
  };

  /**
   * The text track not loaded state.
   *
   * @type {number}
   * @static
   */
  HTMLTrackElement.NONE = 0;

  /**
   * The text track loading state.
   *
   * @type {number}
   * @static
   */
  HTMLTrackElement.LOADING = 1;

  /**
   * The text track loaded state.
   *
   * @type {number}
   * @static
   */
  HTMLTrackElement.LOADED = 2;

  /**
   * The text track failed to load state.
   *
   * @type {number}
   * @static
   */
  HTMLTrackElement.ERROR = 3;

  /*
   * This file contains all track properties that are used in
   * player.js, tech.js, html5.js and possibly other techs in the future.
   */

  const NORMAL = {
    audio: {
      ListClass: AudioTrackList,
      TrackClass: AudioTrack,
      capitalName: 'Audio'
    },
    video: {
      ListClass: VideoTrackList,
      TrackClass: VideoTrack,
      capitalName: 'Video'
    },
    text: {
      ListClass: TextTrackList,
      TrackClass: TextTrack,
      capitalName: 'Text'
    }
  };
  Object.keys(NORMAL).forEach(function (type) {
    NORMAL[type].getterName = `${type}Tracks`;
    NORMAL[type].privateName = `${type}Tracks_`;
  });
  const REMOTE = {
    remoteText: {
      ListClass: TextTrackList,
      TrackClass: TextTrack,
      capitalName: 'RemoteText',
      getterName: 'remoteTextTracks',
      privateName: 'remoteTextTracks_'
    },
    remoteTextEl: {
      ListClass: HtmlTrackElementList,
      TrackClass: HTMLTrackElement,
      capitalName: 'RemoteTextTrackEls',
      getterName: 'remoteTextTrackEls',
      privateName: 'remoteTextTrackEls_'
    }
  };
  const ALL = Object.assign({}, NORMAL, REMOTE);
  REMOTE.names = Object.keys(REMOTE);
  NORMAL.names = Object.keys(NORMAL);
  ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);

  /**
   * @file tech.js
   */

  /** @import { TimeRange } from '../utils/time' */

  /**
   * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string
   * that just contains the src url alone.
   * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`
     * `var SourceString = 'http://example.com/some-video.mp4';`
   *
   * @typedef {Object|string} SourceObject
   *
   * @property {string} src
   *           The url to the source
   *
   * @property {string} type
   *           The mime type of the source
   */

  /**
   * A function used by {@link Tech} to create a new {@link TextTrack}.
   *
   * @private
   *
   * @param {Tech} self
   *        An instance of the Tech class.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @param {Object} [options={}]
   *        An object with additional text track options
   *
   * @return {TextTrack}
   *          The text track that was created.
   */
  function createTrackHelper(self, kind, label, language, options = {}) {
    const tracks = self.textTracks();
    options.kind = kind;
    if (label) {
      options.label = label;
    }
    if (language) {
      options.language = language;
    }
    options.tech = self;
    const track = new ALL.text.TrackClass(options);
    tracks.addTrack(track);
    return track;
  }

  /**
   * This is the base class for media playback technology controllers, such as
   * {@link HTML5}
   *
   * @extends Component
   */
  class Tech extends Component {
    /**
    * Create an instance of this Tech.
    *
    * @param {Object} [options]
    *        The key/value store of player options.
    *
    * @param {Function} [ready]
    *        Callback function to call when the `HTML5` Tech is ready.
    */
    constructor(options = {}, ready = function () {}) {
      // we don't want the tech to report user activity automatically.
      // This is done manually in addControlsListeners
      options.reportTouchActivity = false;
      super(null, options, ready);
      this.onDurationChange_ = e => this.onDurationChange(e);
      this.trackProgress_ = e => this.trackProgress(e);
      this.trackCurrentTime_ = e => this.trackCurrentTime(e);
      this.stopTrackingCurrentTime_ = e => this.stopTrackingCurrentTime(e);
      this.disposeSourceHandler_ = e => this.disposeSourceHandler(e);
      this.queuedHanders_ = new Set();

      // keep track of whether the current source has played at all to
      // implement a very limited played()
      this.hasStarted_ = false;
      this.on('playing', function () {
        this.hasStarted_ = true;
      });
      this.on('loadstart', function () {
        this.hasStarted_ = false;
      });
      ALL.names.forEach(name => {
        const props = ALL[name];
        if (options && options[props.getterName]) {
          this[props.privateName] = options[props.getterName];
        }
      });

      // Manually track progress in cases where the browser/tech doesn't report it.
      if (!this.featuresProgressEvents) {
        this.manualProgressOn();
      }

      // Manually track timeupdates in cases where the browser/tech doesn't report it.
      if (!this.featuresTimeupdateEvents) {
        this.manualTimeUpdatesOn();
      }
      ['Text', 'Audio', 'Video'].forEach(track => {
        if (options[`native${track}Tracks`] === false) {
          this[`featuresNative${track}Tracks`] = false;
        }
      });
      if (options.nativeCaptions === false || options.nativeTextTracks === false) {
        this.featuresNativeTextTracks = false;
      } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
        this.featuresNativeTextTracks = true;
      }
      if (!this.featuresNativeTextTracks) {
        this.emulateTextTracks();
      }
      this.preloadTextTracks = options.preloadTextTracks !== false;
      this.autoRemoteTextTracks_ = new ALL.text.ListClass();
      this.initTrackListeners();

      // Turn on component tap events only if not using native controls
      if (!options.nativeControlsForTouch) {
        this.emitTapEvents();
      }
      if (this.constructor) {
        this.name_ = this.constructor.name || 'Unknown Tech';
      }
    }

    /**
     * A special function to trigger source set in a way that will allow player
     * to re-trigger if the player or tech are not ready yet.
     *
     * @fires Tech#sourceset
     * @param {string} src The source string at the time of the source changing.
     */
    triggerSourceset(src) {
      if (!this.isReady_) {
        // on initial ready we have to trigger source set
        // 1ms after ready so that player can watch for it.
        this.one('ready', () => this.setTimeout(() => this.triggerSourceset(src), 1));
      }

      /**
       * Fired when the source is set on the tech causing the media element
       * to reload.
       *
       * @see {@link Player#event:sourceset}
       * @event Tech#sourceset
       * @type {Event}
       */
      this.trigger({
        src,
        type: 'sourceset'
      });
    }

    /* Fallbacks for unsupported event types
    ================================================================================ */

    /**
     * Polyfill the `progress` event for browsers that don't support it natively.
     *
     * @see {@link Tech#trackProgress}
     */
    manualProgressOn() {
      this.on('durationchange', this.onDurationChange_);
      this.manualProgress = true;

      // Trigger progress watching when a source begins loading
      this.one('ready', this.trackProgress_);
    }

    /**
     * Turn off the polyfill for `progress` events that was created in
     * {@link Tech#manualProgressOn}
     */
    manualProgressOff() {
      this.manualProgress = false;
      this.stopTrackingProgress();
      this.off('durationchange', this.onDurationChange_);
    }

    /**
     * This is used to trigger a `progress` event when the buffered percent changes. It
     * sets an interval function that will be called every 500 milliseconds to check if the
     * buffer end percent has changed.
     *
     * > This function is called by {@link Tech#manualProgressOn}
     *
     * @param {Event} event
     *        The `ready` event that caused this to run.
     *
     * @listens Tech#ready
     * @fires Tech#progress
     */
    trackProgress(event) {
      this.stopTrackingProgress();
      this.progressInterval = this.setInterval(bind_(this, function () {
        // Don't trigger unless buffered amount is greater than last time

        const numBufferedPercent = this.bufferedPercent();
        if (this.bufferedPercent_ !== numBufferedPercent) {
          /**
           * See {@link Player#progress}
           *
           * @event Tech#progress
           * @type {Event}
           */
          this.trigger('progress');
        }
        this.bufferedPercent_ = numBufferedPercent;
        if (numBufferedPercent === 1) {
          this.stopTrackingProgress();
        }
      }), 500);
    }

    /**
     * Update our internal duration on a `durationchange` event by calling
     * {@link Tech#duration}.
     *
     * @param {Event} event
     *        The `durationchange` event that caused this to run.
     *
     * @listens Tech#durationchange
     */
    onDurationChange(event) {
      this.duration_ = this.duration();
    }

    /**
     * Get and create a `TimeRange` object for buffering.
     *
     * @return {TimeRange}
     *         The time range object that was created.
     */
    buffered() {
      return createTimeRanges(0, 0);
    }

    /**
     * Get the percentage of the current video that is currently buffered.
     *
     * @return {number}
     *         A number from 0 to 1 that represents the decimal percentage of the
     *         video that is buffered.
     *
     */
    bufferedPercent() {
      return bufferedPercent(this.buffered(), this.duration_);
    }

    /**
     * Turn off the polyfill for `progress` events that was created in
     * {@link Tech#manualProgressOn}
     * Stop manually tracking progress events by clearing the interval that was set in
     * {@link Tech#trackProgress}.
     */
    stopTrackingProgress() {
      this.clearInterval(this.progressInterval);
    }

    /**
     * Polyfill the `timeupdate` event for browsers that don't support it.
     *
     * @see {@link Tech#trackCurrentTime}
     */
    manualTimeUpdatesOn() {
      this.manualTimeUpdates = true;
      this.on('play', this.trackCurrentTime_);
      this.on('pause', this.stopTrackingCurrentTime_);
    }

    /**
     * Turn off the polyfill for `timeupdate` events that was created in
     * {@link Tech#manualTimeUpdatesOn}
     */
    manualTimeUpdatesOff() {
      this.manualTimeUpdates = false;
      this.stopTrackingCurrentTime();
      this.off('play', this.trackCurrentTime_);
      this.off('pause', this.stopTrackingCurrentTime_);
    }

    /**
     * Sets up an interval function to track current time and trigger `timeupdate` every
     * 250 milliseconds.
     *
     * @listens Tech#play
     * @triggers Tech#timeupdate
     */
    trackCurrentTime() {
      if (this.currentTimeInterval) {
        this.stopTrackingCurrentTime();
      }
      this.currentTimeInterval = this.setInterval(function () {
        /**
         * Triggered at an interval of 250ms to indicated that time is passing in the video.
         *
         * @event Tech#timeupdate
         * @type {Event}
         */
        this.trigger({
          type: 'timeupdate',
          target: this,
          manuallyTriggered: true
        });

        // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
      }, 250);
    }

    /**
     * Stop the interval function created in {@link Tech#trackCurrentTime} so that the
     * `timeupdate` event is no longer triggered.
     *
     * @listens {Tech#pause}
     */
    stopTrackingCurrentTime() {
      this.clearInterval(this.currentTimeInterval);

      // #1002 - if the video ends right before the next timeupdate would happen,
      // the progress bar won't make it all the way to the end
      this.trigger({
        type: 'timeupdate',
        target: this,
        manuallyTriggered: true
      });
    }

    /**
     * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},
     * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.
     *
     * @fires Component#dispose
     */
    dispose() {
      // clear out all tracks because we can't reuse them between techs
      this.clearTracks(NORMAL.names);

      // Turn off any manual progress or timeupdate tracking
      if (this.manualProgress) {
        this.manualProgressOff();
      }
      if (this.manualTimeUpdates) {
        this.manualTimeUpdatesOff();
      }
      super.dispose();
    }

    /**
     * Clear out a single `TrackList` or an array of `TrackLists` given their names.
     *
     * > Note: Techs without source handlers should call this between sources for `video`
     *         & `audio` tracks. You don't want to use them between tracks!
     *
     * @param {string[]|string} types
     *        TrackList names to clear, valid names are `video`, `audio`, and
     *        `text`.
     */
    clearTracks(types) {
      types = [].concat(types);
      // clear out all tracks because we can't reuse them between techs
      types.forEach(type => {
        const list = this[`${type}Tracks`]() || [];
        let i = list.length;
        while (i--) {
          const track = list[i];
          if (type === 'text') {
            this.removeRemoteTextTrack(track);
          }
          list.removeTrack(track);
        }
      });
    }

    /**
     * Remove any TextTracks added via addRemoteTextTrack that are
     * flagged for automatic garbage collection
     */
    cleanupAutoTextTracks() {
      const list = this.autoRemoteTextTracks_ || [];
      let i = list.length;
      while (i--) {
        const track = list[i];
        this.removeRemoteTextTrack(track);
      }
    }

    /**
     * Reset the tech, which will removes all sources and reset the internal readyState.
     *
     * @abstract
     */
    reset() {}

    /**
     * Get the value of `crossOrigin` from the tech.
     *
     * @abstract
     *
     * @see {Html5#crossOrigin}
     */
    crossOrigin() {}

    /**
     * Set the value of `crossOrigin` on the tech.
     *
     * @abstract
     *
     * @param {string} crossOrigin the crossOrigin value
     * @see {Html5#setCrossOrigin}
     */
    setCrossOrigin() {}

    /**
     * Get or set an error on the Tech.
     *
     * @param {MediaError} [err]
     *        Error to set on the Tech
     *
     * @return {MediaError|null}
     *         The current error object on the tech, or null if there isn't one.
     */
    error(err) {
      if (err !== undefined) {
        this.error_ = new MediaError(err);
        this.trigger('error');
      }
      return this.error_;
    }

    /**
     * Returns the `TimeRange`s that have been played through for the current source.
     *
     * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.
     *         It only checks whether the source has played at all or not.
     *
     * @return {TimeRange}
     *         - A single time range if this video has played
     *         - An empty set of ranges if not.
     */
    played() {
      if (this.hasStarted_) {
        return createTimeRanges(0, 0);
      }
      return createTimeRanges();
    }

    /**
     * Start playback
     *
     * @abstract
     *
     * @see {Html5#play}
     */
    play() {}

    /**
     * Set whether we are scrubbing or not
     *
     * @abstract
     * @param {boolean} _isScrubbing
     *                  - true for we are currently scrubbing
     *                  - false for we are no longer scrubbing
     *
     * @see {Html5#setScrubbing}
     */
    setScrubbing(_isScrubbing) {}

    /**
     * Get whether we are scrubbing or not
     *
     * @abstract
     *
     * @see {Html5#scrubbing}
     */
    scrubbing() {}

    /**
     * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was
     * previously called.
     *
     * @param {number} _seconds
     *        Set the current time of the media to this.
     * @fires Tech#timeupdate
     */
    setCurrentTime(_seconds) {
      // improve the accuracy of manual timeupdates
      if (this.manualTimeUpdates) {
        /**
         * A manual `timeupdate` event.
         *
         * @event Tech#timeupdate
         * @type {Event}
         */
        this.trigger({
          type: 'timeupdate',
          target: this,
          manuallyTriggered: true
        });
      }
    }

    /**
     * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and
     * {@link TextTrackList} events.
     *
     * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.
     *
     * @fires Tech#audiotrackchange
     * @fires Tech#videotrackchange
     * @fires Tech#texttrackchange
     */
    initTrackListeners() {
      /**
        * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}
        *
        * @event Tech#audiotrackchange
        * @type {Event}
        */

      /**
        * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}
        *
        * @event Tech#videotrackchange
        * @type {Event}
        */

      /**
        * Triggered when tracks are added or removed on the Tech {@link TextTrackList}
        *
        * @event Tech#texttrackchange
        * @type {Event}
        */
      NORMAL.names.forEach(name => {
        const props = NORMAL[name];
        const trackListChanges = () => {
          this.trigger(`${name}trackchange`);
        };
        const tracks = this[props.getterName]();
        tracks.addEventListener('removetrack', trackListChanges);
        tracks.addEventListener('addtrack', trackListChanges);
        this.on('dispose', () => {
          tracks.removeEventListener('removetrack', trackListChanges);
          tracks.removeEventListener('addtrack', trackListChanges);
        });
      });
    }

    /**
     * Emulate TextTracks using vtt.js if necessary
     *
     * @fires Tech#vttjsloaded
     * @fires Tech#vttjserror
     */
    addWebVttScript_() {
      if (window__default["default"].WebVTT) {
        return;
      }

      // Initially, Tech.el_ is a child of a dummy-div wait until the Component system
      // signals that the Tech is ready at which point Tech.el_ is part of the DOM
      // before inserting the WebVTT script
      if (document__default["default"].body.contains(this.el())) {
        // load via require if available and vtt.js script location was not passed in
        // as an option. novtt builds will turn the above require call into an empty object
        // which will cause this if check to always fail.
        if (!this.options_['vtt.js'] && isPlain(vtt__default["default"]) && Object.keys(vtt__default["default"]).length > 0) {
          this.trigger('vttjsloaded');
          return;
        }

        // load vtt.js via the script location option or the cdn of no location was
        // passed in
        const script = document__default["default"].createElement('script');
        script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js';
        script.onload = () => {
          /**
           * Fired when vtt.js is loaded.
           *
           * @event Tech#vttjsloaded
           * @type {Event}
           */
          this.trigger('vttjsloaded');
        };
        script.onerror = () => {
          /**
           * Fired when vtt.js was not loaded due to an error
           *
           * @event Tech#vttjsloaded
           * @type {Event}
           */
          this.trigger('vttjserror');
        };
        this.on('dispose', () => {
          script.onload = null;
          script.onerror = null;
        });
        // but have not loaded yet and we set it to true before the inject so that
        // we don't overwrite the injected window.WebVTT if it loads right away
        window__default["default"].WebVTT = true;
        this.el().parentNode.appendChild(script);
      } else {
        this.ready(this.addWebVttScript_);
      }
    }

    /**
     * Emulate texttracks
     *
     */
    emulateTextTracks() {
      const tracks = this.textTracks();
      const remoteTracks = this.remoteTextTracks();
      const handleAddTrack = e => tracks.addTrack(e.track);
      const handleRemoveTrack = e => tracks.removeTrack(e.track);
      remoteTracks.on('addtrack', handleAddTrack);
      remoteTracks.on('removetrack', handleRemoveTrack);
      this.addWebVttScript_();
      const updateDisplay = () => this.trigger('texttrackchange');
      const textTracksChanges = () => {
        updateDisplay();
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          track.removeEventListener('cuechange', updateDisplay);
          if (track.mode === 'showing') {
            track.addEventListener('cuechange', updateDisplay);
          }
        }
      };
      textTracksChanges();
      tracks.addEventListener('change', textTracksChanges);
      tracks.addEventListener('addtrack', textTracksChanges);
      tracks.addEventListener('removetrack', textTracksChanges);
      this.on('dispose', function () {
        remoteTracks.off('addtrack', handleAddTrack);
        remoteTracks.off('removetrack', handleRemoveTrack);
        tracks.removeEventListener('change', textTracksChanges);
        tracks.removeEventListener('addtrack', textTracksChanges);
        tracks.removeEventListener('removetrack', textTracksChanges);
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          track.removeEventListener('cuechange', updateDisplay);
        }
      });
    }

    /**
     * Create and returns a remote {@link TextTrack} object.
     *
     * @param {string} kind
     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
     *
     * @param {string} [label]
     *        Label to identify the text track
     *
     * @param {string} [language]
     *        Two letter language abbreviation
     *
     * @return {TextTrack}
     *         The TextTrack that gets created.
     */
    addTextTrack(kind, label, language) {
      if (!kind) {
        throw new Error('TextTrack kind is required but was not provided');
      }
      return createTrackHelper(this, kind, label, language);
    }

    /**
     * Create an emulated TextTrack for use by addRemoteTextTrack
     *
     * This is intended to be overridden by classes that inherit from
     * Tech in order to create native or custom TextTracks.
     *
     * @param {Object} options
     *        The object should contain the options to initialize the TextTrack with.
     *
     * @param {string} [options.kind]
     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
     *
     * @param {string} [options.label].
     *        Label to identify the text track
     *
     * @param {string} [options.language]
     *        Two letter language abbreviation.
     *
     * @return {HTMLTrackElement}
     *         The track element that gets created.
     */
    createRemoteTextTrack(options) {
      const track = merge(options, {
        tech: this
      });
      return new REMOTE.remoteTextEl.TrackClass(track);
    }

    /**
     * Creates a remote text track object and returns an html track element.
     *
     * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.
     *
     * @param {Object} options
     *        See {@link Tech#createRemoteTextTrack} for more detailed properties.
     *
     * @param {boolean} [manualCleanup=false]
     *        - When false: the TextTrack will be automatically removed from the video
     *          element whenever the source changes
     *        - When True: The TextTrack will have to be cleaned up manually
     *
     * @return {HTMLTrackElement}
     *         An Html Track Element.
     *
     */
    addRemoteTextTrack(options = {}, manualCleanup) {
      const htmlTrackElement = this.createRemoteTextTrack(options);
      if (typeof manualCleanup !== 'boolean') {
        manualCleanup = false;
      }

      // store HTMLTrackElement and TextTrack to remote list
      this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
      this.remoteTextTracks().addTrack(htmlTrackElement.track);
      if (manualCleanup === false) {
        // create the TextTrackList if it doesn't exist
        this.ready(() => this.autoRemoteTextTracks_.addTrack(htmlTrackElement.track));
      }
      return htmlTrackElement;
    }

    /**
     * Remove a remote text track from the remote `TextTrackList`.
     *
     * @param {TextTrack} track
     *        `TextTrack` to remove from the `TextTrackList`
     */
    removeRemoteTextTrack(track) {
      const trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);

      // remove HTMLTrackElement and TextTrack from remote list
      this.remoteTextTrackEls().removeTrackElement_(trackElement);
      this.remoteTextTracks().removeTrack(track);
      this.autoRemoteTextTracks_.removeTrack(track);
    }

    /**
     * Gets available media playback quality metrics as specified by the W3C's Media
     * Playback Quality API.
     *
     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
     *
     * @return {Object}
     *         An object with supported media playback quality metrics
     *
     * @abstract
     */
    getVideoPlaybackQuality() {
      return {};
    }

    /**
     * Attempt to create a floating video window always on top of other windows
     * so that users may continue consuming media while they interact with other
     * content sites, or applications on their device.
     *
     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
     *
     * @return {Promise|undefined}
     *         A promise with a Picture-in-Picture window if the browser supports
     *         Promises (or one was passed in as an option). It returns undefined
     *         otherwise.
     *
     * @abstract
     */
    requestPictureInPicture() {
      return Promise.reject();
    }

    /**
     * A method to check for the value of the 'disablePictureInPicture' <video> property.
     * Defaults to true, as it should be considered disabled if the tech does not support pip
     *
     * @abstract
     */
    disablePictureInPicture() {
      return true;
    }

    /**
     * A method to set or unset the 'disablePictureInPicture' <video> property.
     *
     * @abstract
     */
    setDisablePictureInPicture() {}

    /**
     * A fallback implementation of requestVideoFrameCallback using requestAnimationFrame
     *
     * @param {function} cb
     * @return {number} request id
     */
    requestVideoFrameCallback(cb) {
      const id = newGUID();
      if (!this.isReady_ || this.paused()) {
        this.queuedHanders_.add(id);
        this.one('playing', () => {
          if (this.queuedHanders_.has(id)) {
            this.queuedHanders_.delete(id);
            cb();
          }
        });
      } else {
        this.requestNamedAnimationFrame(id, cb);
      }
      return id;
    }

    /**
     * A fallback implementation of cancelVideoFrameCallback
     *
     * @param {number} id id of callback to be cancelled
     */
    cancelVideoFrameCallback(id) {
      if (this.queuedHanders_.has(id)) {
        this.queuedHanders_.delete(id);
      } else {
        this.cancelNamedAnimationFrame(id);
      }
    }

    /**
     * A method to set a poster from a `Tech`.
     *
     * @abstract
     */
    setPoster() {}

    /**
     * A method to check for the presence of the 'playsinline' <video> attribute.
     *
     * @abstract
     */
    playsinline() {}

    /**
     * A method to set or unset the 'playsinline' <video> attribute.
     *
     * @abstract
     */
    setPlaysinline() {}

    /**
     * Attempt to force override of native audio tracks.
     *
     * @param {boolean} override - If set to true native audio will be overridden,
     * otherwise native audio will potentially be used.
     *
     * @abstract
     */
    overrideNativeAudioTracks(override) {}

    /**
     * Attempt to force override of native video tracks.
     *
     * @param {boolean} override - If set to true native video will be overridden,
     * otherwise native video will potentially be used.
     *
     * @abstract
     */
    overrideNativeVideoTracks(override) {}

    /**
     * Check if the tech can support the given mime-type.
     *
     * The base tech does not support any type, but source handlers might
     * overwrite this.
     *
     * @param  {string} _type
     *         The mimetype to check for support
     *
     * @return {string}
     *         'probably', 'maybe', or empty string
     *
     * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}
     *
     * @abstract
     */
    canPlayType(_type) {
      return '';
    }

    /**
     * Check if the type is supported by this tech.
     *
     * The base tech does not support any type, but source handlers might
     * overwrite this.
     *
     * @param {string} _type
     *        The media type to check
     * @return {string} Returns the native video element's response
     */
    static canPlayType(_type) {
      return '';
    }

    /**
     * Check if the tech can support the given source
     *
     * @param {Object} srcObj
     *        The source object
     * @param {Object} options
     *        The options passed to the tech
     * @return {string} 'probably', 'maybe', or '' (empty string)
     */
    static canPlaySource(srcObj, options) {
      return Tech.canPlayType(srcObj.type);
    }

    /*
     * Return whether the argument is a Tech or not.
     * Can be passed either a Class like `Html5` or a instance like `player.tech_`
     *
     * @param {Object} component
     *        The item to check
     *
     * @return {boolean}
     *         Whether it is a tech or not
     *         - True if it is a tech
     *         - False if it is not
     */
    static isTech(component) {
      return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
    }

    /**
     * Registers a `Tech` into a shared list for videojs.
     *
     * @param {string} name
     *        Name of the `Tech` to register.
     *
     * @param {Object} tech
     *        The `Tech` class to register.
     */
    static registerTech(name, tech) {
      if (!Tech.techs_) {
        Tech.techs_ = {};
      }
      if (!Tech.isTech(tech)) {
        throw new Error(`Tech ${name} must be a Tech`);
      }
      if (!Tech.canPlayType) {
        throw new Error('Techs must have a static canPlayType method on them');
      }
      if (!Tech.canPlaySource) {
        throw new Error('Techs must have a static canPlaySource method on them');
      }
      name = toTitleCase(name);
      Tech.techs_[name] = tech;
      Tech.techs_[toLowerCase(name)] = tech;
      if (name !== 'Tech') {
        // camel case the techName for use in techOrder
        Tech.defaultTechOrder_.push(name);
      }
      return tech;
    }

    /**
     * Get a `Tech` from the shared list by name.
     *
     * @param {string} name
     *        `camelCase` or `TitleCase` name of the Tech to get
     *
     * @return {Tech|undefined}
     *         The `Tech` or undefined if there was no tech with the name requested.
     */
    static getTech(name) {
      if (!name) {
        return;
      }
      if (Tech.techs_ && Tech.techs_[name]) {
        return Tech.techs_[name];
      }
      name = toTitleCase(name);
      if (window__default["default"] && window__default["default"].videojs && window__default["default"].videojs[name]) {
        log.warn(`The ${name} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`);
        return window__default["default"].videojs[name];
      }
    }
  }

  /**
   * Get the {@link VideoTrackList}
   *
   * @returns {VideoTrackList}
   * @method Tech.prototype.videoTracks
   */

  /**
   * Get the {@link AudioTrackList}
   *
   * @returns {AudioTrackList}
   * @method Tech.prototype.audioTracks
   */

  /**
   * Get the {@link TextTrackList}
   *
   * @returns {TextTrackList}
   * @method Tech.prototype.textTracks
   */

  /**
   * Get the remote element {@link TextTrackList}
   *
   * @returns {TextTrackList}
   * @method Tech.prototype.remoteTextTracks
   */

  /**
   * Get the remote element {@link HtmlTrackElementList}
   *
   * @returns {HtmlTrackElementList}
   * @method Tech.prototype.remoteTextTrackEls
   */

  ALL.names.forEach(function (name) {
    const props = ALL[name];
    Tech.prototype[props.getterName] = function () {
      this[props.privateName] = this[props.privateName] || new props.ListClass();
      return this[props.privateName];
    };
  });

  /**
   * List of associated text tracks
   *
   * @type {TextTrackList}
   * @private
   * @property Tech#textTracks_
   */

  /**
   * List of associated audio tracks.
   *
   * @type {AudioTrackList}
   * @private
   * @property Tech#audioTracks_
   */

  /**
   * List of associated video tracks.
   *
   * @type {VideoTrackList}
   * @private
   * @property Tech#videoTracks_
   */

  /**
   * Boolean indicating whether the `Tech` supports volume control.
   *
   * @type {boolean}
   * @default
   */
  Tech.prototype.featuresVolumeControl = true;

  /**
   * Boolean indicating whether the `Tech` supports muting volume.
   *
   * @type {boolean}
   * @default
   */
  Tech.prototype.featuresMuteControl = true;

  /**
   * Boolean indicating whether the `Tech` supports fullscreen resize control.
   * Resizing plugins using request fullscreen reloads the plugin
   *
   * @type {boolean}
   * @default
   */
  Tech.prototype.featuresFullscreenResize = false;

  /**
   * Boolean indicating whether the `Tech` supports changing the speed at which the video
   * plays. Examples:
   *   - Set player to play 2x (twice) as fast
   *   - Set player to play 0.5x (half) as fast
   *
   * @type {boolean}
   * @default
   */
  Tech.prototype.featuresPlaybackRate = false;

  /**
   * Boolean indicating whether the `Tech` supports the `progress` event.
   * This will be used to determine if {@link Tech#manualProgressOn} should be called.
   *
   * @type {boolean}
   * @default
   */
  Tech.prototype.featuresProgressEvents = false;

  /**
   * Boolean indicating whether the `Tech` supports the `sourceset` event.
   *
   * A tech should set this to `true` and then use {@link Tech#triggerSourceset}
   * to trigger a {@link Tech#event:sourceset} at the earliest time after getting
   * a new source.
   *
   * @type {boolean}
   * @default
   */
  Tech.prototype.featuresSourceset = false;

  /**
   * Boolean indicating whether the `Tech` supports the `timeupdate` event.
   * This will be used to determine if {@link Tech#manualTimeUpdates} should be called.
   *
   * @type {boolean}
   * @default
   */
  Tech.prototype.featuresTimeupdateEvents = false;

  /**
   * Boolean indicating whether the `Tech` supports the native `TextTrack`s.
   * This will help us integrate with native `TextTrack`s if the browser supports them.
   *
   * @type {boolean}
   * @default
   */
  Tech.prototype.featuresNativeTextTracks = false;

  /**
   * Boolean indicating whether the `Tech` supports `requestVideoFrameCallback`.
   *
   * @type {boolean}
   * @default
   */
  Tech.prototype.featuresVideoFrameCallback = false;

  /**
   * A functional mixin for techs that want to use the Source Handler pattern.
   * Source handlers are scripts for handling specific formats.
   * The source handler pattern is used for adaptive formats (HLS, DASH) that
   * manually load video data and feed it into a Source Buffer (Media Source Extensions)
   * Example: `Tech.withSourceHandlers.call(MyTech);`
   *
   * @param {Tech} _Tech
   *        The tech to add source handler functions to.
   *
   * @mixes Tech~SourceHandlerAdditions
   */
  Tech.withSourceHandlers = function (_Tech) {
    /**
     * Register a source handler
     *
     * @param {Function} handler
     *        The source handler class
     *
     * @param {number} [index]
     *        Register it at the following index
     */
    _Tech.registerSourceHandler = function (handler, index) {
      let handlers = _Tech.sourceHandlers;
      if (!handlers) {
        handlers = _Tech.sourceHandlers = [];
      }
      if (index === undefined) {
        // add to the end of the list
        index = handlers.length;
      }
      handlers.splice(index, 0, handler);
    };

    /**
     * Check if the tech can support the given type. Also checks the
     * Techs sourceHandlers.
     *
     * @param {string} type
     *         The mimetype to check.
     *
     * @return {string}
     *         'probably', 'maybe', or '' (empty string)
     */
    _Tech.canPlayType = function (type) {
      const handlers = _Tech.sourceHandlers || [];
      let can;
      for (let i = 0; i < handlers.length; i++) {
        can = handlers[i].canPlayType(type);
        if (can) {
          return can;
        }
      }
      return '';
    };

    /**
     * Returns the first source handler that supports the source.
     *
     * TODO: Answer question: should 'probably' be prioritized over 'maybe'
     *
     * @param {SourceObject} source
     *        The source object
     *
     * @param {Object} options
     *        The options passed to the tech
     *
     * @return {SourceHandler|null}
     *          The first source handler that supports the source or null if
     *          no SourceHandler supports the source
     */
    _Tech.selectSourceHandler = function (source, options) {
      const handlers = _Tech.sourceHandlers || [];
      let can;
      for (let i = 0; i < handlers.length; i++) {
        can = handlers[i].canHandleSource(source, options);
        if (can) {
          return handlers[i];
        }
      }
      return null;
    };

    /**
     * Check if the tech can support the given source.
     *
     * @param {SourceObject} srcObj
     *        The source object
     *
     * @param {Object} options
     *        The options passed to the tech
     *
     * @return {string}
     *         'probably', 'maybe', or '' (empty string)
     */
    _Tech.canPlaySource = function (srcObj, options) {
      const sh = _Tech.selectSourceHandler(srcObj, options);
      if (sh) {
        return sh.canHandleSource(srcObj, options);
      }
      return '';
    };

    /**
     * When using a source handler, prefer its implementation of
     * any function normally provided by the tech.
     */
    const deferrable = ['seekable', 'seeking', 'duration'];

    /**
     * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable
     * function if it exists, with a fallback to the Techs seekable function.
     *
     * @method _Tech.seekable
     */

    /**
     * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration
     * function if it exists, otherwise it will fallback to the techs duration function.
     *
     * @method _Tech.duration
     */

    deferrable.forEach(function (fnName) {
      const originalFn = this[fnName];
      if (typeof originalFn !== 'function') {
        return;
      }
      this[fnName] = function () {
        if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
          return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
        }
        return originalFn.apply(this, arguments);
      };
    }, _Tech.prototype);

    /**
     * Create a function for setting the source using a source object
     * and source handlers.
     * Should never be called unless a source handler was found.
     *
     * @param {SourceObject} source
     *        A source object with src and type keys
     */
    _Tech.prototype.setSource = function (source) {
      let sh = _Tech.selectSourceHandler(source, this.options_);
      if (!sh) {
        // Fall back to a native source handler when unsupported sources are
        // deliberately set
        if (_Tech.nativeSourceHandler) {
          sh = _Tech.nativeSourceHandler;
        } else {
          log.error('No source handler found for the current source.');
        }
      }

      // Dispose any existing source handler
      this.disposeSourceHandler();
      this.off('dispose', this.disposeSourceHandler_);
      if (sh !== _Tech.nativeSourceHandler) {
        this.currentSource_ = source;
      }
      this.sourceHandler_ = sh.handleSource(source, this, this.options_);
      this.one('dispose', this.disposeSourceHandler_);
    };

    /**
     * Clean up any existing SourceHandlers and listeners when the Tech is disposed.
     *
     * @listens Tech#dispose
     */
    _Tech.prototype.disposeSourceHandler = function () {
      // if we have a source and get another one
      // then we are loading something new
      // than clear all of our current tracks
      if (this.currentSource_) {
        this.clearTracks(['audio', 'video']);
        this.currentSource_ = null;
      }

      // always clean up auto-text tracks
      this.cleanupAutoTextTracks();
      if (this.sourceHandler_) {
        if (this.sourceHandler_.dispose) {
          this.sourceHandler_.dispose();
        }
        this.sourceHandler_ = null;
      }
    };
  };

  // The base Tech class needs to be registered as a Component. It is the only
  // Tech that can be registered as a Component.
  Component.registerComponent('Tech', Tech);
  Tech.registerTech('Tech', Tech);

  /**
   * A list of techs that should be added to techOrder on Players
   *
   * @private
   */
  Tech.defaultTechOrder_ = [];

  /**
   * @file middleware.js
   * @module middleware
   */

  /** @import Player from '../player' */
  /** @import Tech from '../tech/tech' */

  const middlewares = {};
  const middlewareInstances = {};
  const TERMINATOR = {};

  /**
   * A middleware object is a plain JavaScript object that has methods that
   * match the {@link Tech} methods found in the lists of allowed
   * {@link module:middleware.allowedGetters|getters},
   * {@link module:middleware.allowedSetters|setters}, and
   * {@link module:middleware.allowedMediators|mediators}.
   *
   * @typedef {Object} MiddlewareObject
   */

  /**
   * A middleware factory function that should return a
   * {@link module:middleware~MiddlewareObject|MiddlewareObject}.
   *
   * This factory will be called for each player when needed, with the player
   * passed in as an argument.
   *
   * @callback MiddlewareFactory
   * @param {Player} player
   *        A Video.js player.
   */

  /**
   * Define a middleware that the player should use by way of a factory function
   * that returns a middleware object.
   *
   * @param  {string} type
   *         The MIME type to match or `"*"` for all MIME types.
   *
   * @param  {MiddlewareFactory} middleware
   *         A middleware factory function that will be executed for
   *         matching types.
   */
  function use(type, middleware) {
    middlewares[type] = middlewares[type] || [];
    middlewares[type].push(middleware);
  }

  /**
   * Asynchronously sets a source using middleware by recursing through any
   * matching middlewares and calling `setSource` on each, passing along the
   * previous returned value each time.
   *
   * @param  {Player} player
   *         A {@link Player} instance.
   *
   * @param  {Tech~SourceObject} src
   *         A source object.
   *
   * @param  {Function}
   *         The next middleware to run.
   */
  function setSource(player, src, next) {
    player.setTimeout(() => setSourceHelper(src, middlewares[src.type], next, player), 1);
  }

  /**
   * When the tech is set, passes the tech to each middleware's `setTech` method.
   *
   * @param {Object[]} middleware
   *        An array of middleware instances.
   *
   * @param {Tech} tech
   *        A Video.js tech.
   */
  function setTech(middleware, tech) {
    middleware.forEach(mw => mw.setTech && mw.setTech(tech));
  }

  /**
   * Calls a getter on the tech first, through each middleware
   * from right to left to the player.
   *
   * @param  {Object[]} middleware
   *         An array of middleware instances.
   *
   * @param  {Tech} tech
   *         The current tech.
   *
   * @param  {string} method
   *         A method name.
   *
   * @return {*}
   *         The final value from the tech after middleware has intercepted it.
   */
  function get(middleware, tech, method) {
    return middleware.reduceRight(middlewareIterator(method), tech[method]());
  }

  /**
   * Takes the argument given to the player and calls the setter method on each
   * middleware from left to right to the tech.
   *
   * @param  {Object[]} middleware
   *         An array of middleware instances.
   *
   * @param  {Tech} tech
   *         The current tech.
   *
   * @param  {string} method
   *         A method name.
   *
   * @param  {*} arg
   *         The value to set on the tech.
   *
   * @return {*}
   *         The return value of the `method` of the `tech`.
   */
  function set(middleware, tech, method, arg) {
    return tech[method](middleware.reduce(middlewareIterator(method), arg));
  }

  /**
   * Takes the argument given to the player and calls the `call` version of the
   * method on each middleware from left to right.
   *
   * Then, call the passed in method on the tech and return the result unchanged
   * back to the player, through middleware, this time from right to left.
   *
   * @param  {Object[]} middleware
   *         An array of middleware instances.
   *
   * @param  {Tech} tech
   *         The current tech.
   *
   * @param  {string} method
   *         A method name.
   *
   * @param  {*} arg
   *         The value to set on the tech.
   *
   * @return {*}
   *         The return value of the `method` of the `tech`, regardless of the
   *         return values of middlewares.
   */
  function mediate(middleware, tech, method, arg = null) {
    const callMethod = 'call' + toTitleCase(method);
    const middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);
    const terminated = middlewareValue === TERMINATOR;
    // deprecated. The `null` return value should instead return TERMINATOR to
    // prevent confusion if a techs method actually returns null.
    const returnValue = terminated ? null : tech[method](middlewareValue);
    executeRight(middleware, method, returnValue, terminated);
    return returnValue;
  }

  /**
   * Enumeration of allowed getters where the keys are method names.
   *
   * @type {Object}
   */
  const allowedGetters = {
    buffered: 1,
    currentTime: 1,
    duration: 1,
    muted: 1,
    played: 1,
    paused: 1,
    seekable: 1,
    volume: 1,
    ended: 1
  };

  /**
   * Enumeration of allowed setters where the keys are method names.
   *
   * @type {Object}
   */
  const allowedSetters = {
    setCurrentTime: 1,
    setMuted: 1,
    setVolume: 1
  };

  /**
   * Enumeration of allowed mediators where the keys are method names.
   *
   * @type {Object}
   */
  const allowedMediators = {
    play: 1,
    pause: 1
  };
  function middlewareIterator(method) {
    return (value, mw) => {
      // if the previous middleware terminated, pass along the termination
      if (value === TERMINATOR) {
        return TERMINATOR;
      }
      if (mw[method]) {
        return mw[method](value);
      }
      return value;
    };
  }
  function executeRight(mws, method, value, terminated) {
    for (let i = mws.length - 1; i >= 0; i--) {
      const mw = mws[i];
      if (mw[method]) {
        mw[method](terminated, value);
      }
    }
  }

  /**
   * Clear the middleware cache for a player.
   *
   * @param  {Player} player
   *         A {@link Player} instance.
   */
  function clearCacheForPlayer(player) {
    if (middlewareInstances.hasOwnProperty(player.id())) {
      delete middlewareInstances[player.id()];
    }
  }

  /**
   * {
   *  [playerId]: [[mwFactory, mwInstance], ...]
   * }
   *
   * @private
   */
  function getOrCreateFactory(player, mwFactory) {
    const mws = middlewareInstances[player.id()];
    let mw = null;
    if (mws === undefined || mws === null) {
      mw = mwFactory(player);
      middlewareInstances[player.id()] = [[mwFactory, mw]];
      return mw;
    }
    for (let i = 0; i < mws.length; i++) {
      const [mwf, mwi] = mws[i];
      if (mwf !== mwFactory) {
        continue;
      }
      mw = mwi;
    }
    if (mw === null) {
      mw = mwFactory(player);
      mws.push([mwFactory, mw]);
    }
    return mw;
  }
  function setSourceHelper(src = {}, middleware = [], next, player, acc = [], lastRun = false) {
    const [mwFactory, ...mwrest] = middleware;

    // if mwFactory is a string, then we're at a fork in the road
    if (typeof mwFactory === 'string') {
      setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);

      // if we have an mwFactory, call it with the player to get the mw,
      // then call the mw's setSource method
    } else if (mwFactory) {
      const mw = getOrCreateFactory(player, mwFactory);

      // if setSource isn't present, implicitly select this middleware
      if (!mw.setSource) {
        acc.push(mw);
        return setSourceHelper(src, mwrest, next, player, acc, lastRun);
      }
      mw.setSource(Object.assign({}, src), function (err, _src) {
        // something happened, try the next middleware on the current level
        // make sure to use the old src
        if (err) {
          return setSourceHelper(src, mwrest, next, player, acc, lastRun);
        }

        // we've succeeded, now we need to go deeper
        acc.push(mw);

        // if it's the same type, continue down the current chain
        // otherwise, we want to go down the new chain
        setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
      });
    } else if (mwrest.length) {
      setSourceHelper(src, mwrest, next, player, acc, lastRun);
    } else if (lastRun) {
      next(src, acc);
    } else {
      setSourceHelper(src, middlewares['*'], next, player, acc, true);
    }
  }

  /** @import Player from '../player' */

  /**
   * Mimetypes
   *
   * @see https://www.iana.org/assignments/media-types/media-types.xhtml
   * @typedef Mimetypes~Kind
   * @enum
   */
  const MimetypesKind = {
    opus: 'video/ogg',
    ogv: 'video/ogg',
    mp4: 'video/mp4',
    mov: 'video/mp4',
    m4v: 'video/mp4',
    mkv: 'video/x-matroska',
    m4a: 'audio/mp4',
    mp3: 'audio/mpeg',
    aac: 'audio/aac',
    caf: 'audio/x-caf',
    flac: 'audio/flac',
    oga: 'audio/ogg',
    wav: 'audio/wav',
    m3u8: 'application/x-mpegURL',
    mpd: 'application/dash+xml',
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    gif: 'image/gif',
    png: 'image/png',
    svg: 'image/svg+xml',
    webp: 'image/webp'
  };

  /**
   * Get the mimetype of a given src url if possible
   *
   * @param {string} src
   *        The url to the src
   *
   * @return {string}
   *         return the mimetype if it was known or empty string otherwise
   */
  const getMimetype = function (src = '') {
    const ext = getFileExtension(src);
    const mimetype = MimetypesKind[ext.toLowerCase()];
    return mimetype || '';
  };

  /**
   * Find the mime type of a given source string if possible. Uses the player
   * source cache.
   *
   * @param {Player} player
   *        The player object
   *
   * @param {string} src
   *        The source string
   *
   * @return {string}
   *         The type that was found
   */
  const findMimetype = (player, src) => {
    if (!src) {
      return '';
    }

    // 1. check for the type in the `source` cache
    if (player.cache_.source.src === src && player.cache_.source.type) {
      return player.cache_.source.type;
    }

    // 2. see if we have this source in our `currentSources` cache
    const matchingSources = player.cache_.sources.filter(s => s.src === src);
    if (matchingSources.length) {
      return matchingSources[0].type;
    }

    // 3. look for the src url in source elements and use the type there
    const sources = player.$$('source');
    for (let i = 0; i < sources.length; i++) {
      const s = sources[i];
      if (s.type && s.src && s.src === src) {
        return s.type;
      }
    }

    // 4. finally fallback to our list of mime types based on src url extension
    return getMimetype(src);
  };

  /**
   * @module filter-source
   */

  /**
   * Filter out single bad source objects or multiple source objects in an
   * array. Also flattens nested source object arrays into a 1 dimensional
   * array of source objects.
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]} src
   *        The src object to filter
   *
   * @return {Tech~SourceObject[]}
   *         An array of sourceobjects containing only valid sources
   *
   * @private
   */
  const filterSource = function (src) {
    // traverse array
    if (Array.isArray(src)) {
      let newsrc = [];
      src.forEach(function (srcobj) {
        srcobj = filterSource(srcobj);
        if (Array.isArray(srcobj)) {
          newsrc = newsrc.concat(srcobj);
        } else if (isObject(srcobj)) {
          newsrc.push(srcobj);
        }
      });
      src = newsrc;
    } else if (typeof src === 'string' && src.trim()) {
      // convert string into object
      src = [fixSource({
        src
      })];
    } else if (isObject(src) && typeof src.src === 'string' && src.src && src.src.trim()) {
      // src is already valid
      src = [fixSource(src)];
    } else {
      // invalid source, turn it into an empty array
      src = [];
    }
    return src;
  };

  /**
   * Checks src mimetype, adding it when possible
   *
   * @param {Tech~SourceObject} src
   *        The src object to check
   * @return {Tech~SourceObject}
   *        src Object with known type
   */
  function fixSource(src) {
    if (!src.type) {
      const mimetype = getMimetype(src.src);
      if (mimetype) {
        src.type = mimetype;
      }
    }
    return src;
  }

  var icons = "<svg xmlns=\"http://www.w3.org/2000/svg\">\n  <defs>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-play\">\n      <path d=\"M16 10v28l22-14z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-pause\">\n      <path d=\"M12 38h8V10h-8v28zm16-28v28h8V10h-8z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-audio\">\n      <path d=\"M24 2C14.06 2 6 10.06 6 20v14c0 3.31 2.69 6 6 6h6V24h-8v-4c0-7.73 6.27-14 14-14s14 6.27 14 14v4h-8v16h6c3.31 0 6-2.69 6-6V20c0-9.94-8.06-18-18-18z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-captions\">\n      <path d=\"M38 8H10c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h28c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM22 22h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2zm14 0h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-subtitles\">\n      <path d=\"M40 8H8c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h32c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM8 24h8v4H8v-4zm20 12H8v-4h20v4zm12 0h-8v-4h8v4zm0-8H20v-4h20v4z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-fullscreen-enter\">\n      <path d=\"M14 28h-4v10h10v-4h-6v-6zm-4-8h4v-6h6v-4H10v10zm24 14h-6v4h10V28h-4v6zm-6-24v4h6v6h4V10H28z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-fullscreen-exit\">\n      <path d=\"M10 32h6v6h4V28H10v4zm6-16h-6v4h10V10h-4v6zm12 22h4v-6h6v-4H28v10zm4-22v-6h-4v10h10v-4h-6z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-play-circle\">\n      <path d=\"M20 33l12-9-12-9v18zm4-29C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-volume-mute\">\n      <path d=\"M33 24c0-3.53-2.04-6.58-5-8.05v4.42l4.91 4.91c.06-.42.09-.85.09-1.28zm5 0c0 1.88-.41 3.65-1.08 5.28l3.03 3.03C41.25 29.82 42 27 42 24c0-8.56-5.99-15.72-14-17.54v4.13c5.78 1.72 10 7.07 10 13.41zM8.55 6L6 8.55 15.45 18H6v12h8l10 10V26.55l8.51 8.51c-1.34 1.03-2.85 1.86-4.51 2.36v4.13a17.94 17.94 0 0 0 7.37-3.62L39.45 42 42 39.45l-18-18L8.55 6zM24 8l-4.18 4.18L24 16.36V8z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-volume-low\">\n      <path d=\"M14 18v12h8l10 10V8L22 18h-8z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-volume-medium\">\n      <path d=\"M37 24c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zm-27-6v12h8l10 10V8L18 18h-8z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-volume-high\">\n      <path d=\"M6 18v12h8l10 10V8L14 18H6zm27 6c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zM28 6.46v4.13c5.78 1.72 10 7.07 10 13.41s-4.22 11.69-10 13.41v4.13c8.01-1.82 14-8.97 14-17.54S36.01 8.28 28 6.46z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-spinner\">\n      <path d=\"M18.8 21l9.53-16.51C26.94 4.18 25.49 4 24 4c-4.8 0-9.19 1.69-12.64 4.51l7.33 12.69.11-.2zm24.28-3c-1.84-5.85-6.3-10.52-11.99-12.68L23.77 18h19.31zm.52 2H28.62l.58 1 9.53 16.5C41.99 33.94 44 29.21 44 24c0-1.37-.14-2.71-.4-4zm-26.53 4l-7.8-13.5C6.01 14.06 4 18.79 4 24c0 1.37.14 2.71.4 4h14.98l-2.31-4zM4.92 30c1.84 5.85 6.3 10.52 11.99 12.68L24.23 30H4.92zm22.54 0l-7.8 13.51c1.4.31 2.85.49 4.34.49 4.8 0 9.19-1.69 12.64-4.51L29.31 26.8 27.46 30z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 24 24\" id=\"vjs-icon-hd\">\n      <path d=\"M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 12H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm2-6h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1h-4V9zm1.5 4.5h2v-3h-2v3z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-chapters\">\n      <path d=\"M6 26h4v-4H6v4zm0 8h4v-4H6v4zm0-16h4v-4H6v4zm8 8h28v-4H14v4zm0 8h28v-4H14v4zm0-20v4h28v-4H14z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 40 40\" id=\"vjs-icon-downloading\">\n      <path d=\"M18.208 36.875q-3.208-.292-5.979-1.729-2.771-1.438-4.812-3.729-2.042-2.292-3.188-5.229-1.146-2.938-1.146-6.23 0-6.583 4.334-11.416 4.333-4.834 10.833-5.5v3.166q-5.167.75-8.583 4.646Q6.25 14.75 6.25 19.958q0 5.209 3.396 9.104 3.396 3.896 8.562 4.646zM20 28.417L11.542 20l2.083-2.083 4.917 4.916v-11.25h2.916v11.25l4.875-4.916L28.417 20zm1.792 8.458v-3.167q1.833-.25 3.541-.958 1.709-.708 3.167-1.875l2.333 2.292q-1.958 1.583-4.25 2.541-2.291.959-4.791 1.167zm6.791-27.792q-1.541-1.125-3.25-1.854-1.708-.729-3.541-1.021V3.042q2.5.25 4.77 1.208 2.271.958 4.271 2.5zm4.584 21.584l-2.25-2.25q1.166-1.5 1.854-3.209.687-1.708.937-3.541h3.209q-.292 2.5-1.229 4.791-.938 2.292-2.521 4.209zm.541-12.417q-.291-1.833-.958-3.562-.667-1.73-1.833-3.188l2.375-2.208q1.541 1.916 2.458 4.208.917 2.292 1.167 4.75z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-file-download\">\n      <path d=\"M10.8 40.55q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h26.35v-7.7h3.4v7.7q0 1.4-1 2.4t-2.4 1zM24 32.1L13.9 22.05l2.45-2.45 5.95 5.95V7.15h3.4v18.4l5.95-5.95 2.45 2.45z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-file-download-done\">\n      <path d=\"M9.8 40.5v-3.45h28.4v3.45zm9.2-9.05L7.4 19.85l2.45-2.35L19 26.65l19.2-19.2 2.4 2.4z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-file-download-off\">\n      <path d=\"M4.9 4.75L43.25 43.1 41 45.3l-4.75-4.75q-.05.05-.075.025-.025-.025-.075-.025H10.8q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h22.05l-7-7-1.85 1.8L13.9 21.9l1.85-1.85L2.7 7zm26.75 14.7l2.45 2.45-3.75 3.8-2.45-2.5zM25.7 7.15V21.1l-3.4-3.45V7.15z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-share\">\n      <path d=\"M36 32.17c-1.52 0-2.89.59-3.93 1.54L17.82 25.4c.11-.45.18-.92.18-1.4s-.07-.95-.18-1.4l14.1-8.23c1.07 1 2.5 1.62 4.08 1.62 3.31 0 6-2.69 6-6s-2.69-6-6-6-6 2.69-6 6c0 .48.07.95.18 1.4l-14.1 8.23c-1.07-1-2.5-1.62-4.08-1.62-3.31 0-6 2.69-6 6s2.69 6 6 6c1.58 0 3.01-.62 4.08-1.62l14.25 8.31c-.1.42-.16.86-.16 1.31A5.83 5.83 0 1 0 36 32.17z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-cog\">\n      <path d=\"M38.86 25.95c.08-.64.14-1.29.14-1.95s-.06-1.31-.14-1.95l4.23-3.31c.38-.3.49-.84.24-1.28l-4-6.93c-.25-.43-.77-.61-1.22-.43l-4.98 2.01c-1.03-.79-2.16-1.46-3.38-1.97L29 4.84c-.09-.47-.5-.84-1-.84h-8c-.5 0-.91.37-.99.84l-.75 5.3a14.8 14.8 0 0 0-3.38 1.97L9.9 10.1a1 1 0 0 0-1.22.43l-4 6.93c-.25.43-.14.97.24 1.28l4.22 3.31C9.06 22.69 9 23.34 9 24s.06 1.31.14 1.95l-4.22 3.31c-.38.3-.49.84-.24 1.28l4 6.93c.25.43.77.61 1.22.43l4.98-2.01c1.03.79 2.16 1.46 3.38 1.97l.75 5.3c.08.47.49.84.99.84h8c.5 0 .91-.37.99-.84l.75-5.3a14.8 14.8 0 0 0 3.38-1.97l4.98 2.01a1 1 0 0 0 1.22-.43l4-6.93c.25-.43.14-.97-.24-1.28l-4.22-3.31zM24 31c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-square\">\n      <path d=\"M36 8H12c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h24c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zm0 28H12V12h24v24z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-circle\">\n      <circle cx=\"24\" cy=\"24\" r=\"20\"></circle>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-circle-outline\">\n      <path d=\"M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-circle-inner-circle\">\n      <path d=\"M24 4C12.97 4 4 12.97 4 24s8.97 20 20 20 20-8.97 20-20S35.03 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16zm6-16c0 3.31-2.69 6-6 6s-6-2.69-6-6 2.69-6 6-6 6 2.69 6 6z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-cancel\">\n      <path d=\"M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm10 27.17L31.17 34 24 26.83 16.83 34 14 31.17 21.17 24 14 16.83 16.83 14 24 21.17 31.17 14 34 16.83 26.83 24 34 31.17z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-replay\">\n      <path d=\"M24 10V2L14 12l10 10v-8c6.63 0 12 5.37 12 12s-5.37 12-12 12-12-5.37-12-12H8c0 8.84 7.16 16 16 16s16-7.16 16-16-7.16-16-16-16z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-repeat\">\n      <path d=\"M14 14h20v6l8-8-8-8v6H10v12h4v-8zm20 20H14v-6l-8 8 8 8v-6h24V26h-4v8z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 96 48 48\" id=\"vjs-icon-replay-5\">\n      <path d=\"M17.689 98l-8.697 8.696 8.697 8.697 2.486-2.485-4.32-4.319h1.302c4.93 0 9.071 1.722 12.424 5.165 3.352 3.443 5.029 7.638 5.029 12.584h3.55c0-2.958-.553-5.73-1.658-8.313-1.104-2.583-2.622-4.841-4.555-6.774-1.932-1.932-4.19-3.45-6.773-4.555-2.584-1.104-5.355-1.657-8.313-1.657H15.5l4.615-4.615zm-8.08 21.659v13.861h11.357v5.008H9.609V143h12.7c.834 0 1.55-.298 2.146-.894.596-.597.895-1.31.895-2.145v-7.781c0-.835-.299-1.55-.895-2.147a2.929 2.929 0 0 0-2.147-.894h-8.227v-5.096H25.35v-4.384z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 96 48 48\" id=\"vjs-icon-replay-10\">\n      <path d=\"M42.315 125.63c0-4.997-1.694-9.235-5.08-12.713-3.388-3.479-7.571-5.218-12.552-5.218h-1.315l4.363 4.363-2.51 2.51-8.787-8.786L25.221 97l2.45 2.45-4.662 4.663h1.375c2.988 0 5.788.557 8.397 1.673 2.61 1.116 4.892 2.65 6.844 4.602 1.953 1.953 3.487 4.234 4.602 6.844 1.116 2.61 1.674 5.41 1.674 8.398zM8.183 142v-19.657H3.176V117.8h9.643V142zm13.63 0c-1.156 0-2.127-.393-2.912-1.178-.778-.778-1.168-1.746-1.168-2.902v-16.04c0-1.156.393-2.127 1.178-2.912.779-.779 1.746-1.168 2.902-1.168h7.696c1.156 0 2.126.392 2.911 1.177.779.78 1.168 1.747 1.168 2.903v16.04c0 1.156-.392 2.127-1.177 2.912-.779.779-1.746 1.168-2.902 1.168zm.556-4.636h6.583v-15.02H22.37z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 96 48 48\" id=\"vjs-icon-replay-30\">\n      <path d=\"M26.047 97l-8.733 8.732 8.733 8.733 2.496-2.494-4.336-4.338h1.307c4.95 0 9.108 1.73 12.474 5.187 3.367 3.458 5.051 7.668 5.051 12.635h3.565c0-2.97-.556-5.751-1.665-8.346-1.109-2.594-2.633-4.862-4.574-6.802-1.94-1.941-4.208-3.466-6.803-4.575-2.594-1.109-5.375-1.664-8.345-1.664H23.85l4.634-4.634zM2.555 117.531v4.688h10.297v5.25H5.873v4.687h6.979v5.156H2.555V142H13.36c1.061 0 1.95-.395 2.668-1.186.718-.79 1.076-1.772 1.076-2.94v-16.218c0-1.168-.358-2.149-1.076-2.94-.717-.79-1.607-1.185-2.668-1.185zm22.482.14c-1.149 0-2.11.39-2.885 1.165-.78.78-1.172 1.744-1.172 2.893v15.943c0 1.149.388 2.11 1.163 2.885.78.78 1.745 1.172 2.894 1.172h7.649c1.148 0 2.11-.388 2.884-1.163.78-.78 1.17-1.745 1.17-2.894v-15.943c0-1.15-.386-2.111-1.16-2.885-.78-.78-1.746-1.172-2.894-1.172zm.553 4.518h6.545v14.93H25.59z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 96 48 48\" id=\"vjs-icon-forward-5\">\n      <path d=\"M29.508 97l-2.431 2.43 4.625 4.625h-1.364c-2.965 0-5.742.554-8.332 1.66-2.589 1.107-4.851 2.629-6.788 4.566-1.937 1.937-3.458 4.2-4.565 6.788-1.107 2.59-1.66 5.367-1.66 8.331h3.557c0-4.957 1.68-9.16 5.04-12.611 3.36-3.45 7.51-5.177 12.451-5.177h1.304l-4.326 4.33 2.49 2.49 8.715-8.716zm-9.783 21.61v13.89h11.382v5.018H19.725V142h12.727a2.93 2.93 0 0 0 2.15-.896 2.93 2.93 0 0 0 .896-2.15v-7.798c0-.837-.299-1.554-.896-2.152a2.93 2.93 0 0 0-2.15-.896h-8.245V123h11.29v-4.392z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 96 48 48\" id=\"vjs-icon-forward-10\">\n      <path d=\"M23.119 97l-2.386 2.383 4.538 4.538h-1.339c-2.908 0-5.633.543-8.173 1.63-2.54 1.085-4.76 2.577-6.66 4.478-1.9 1.9-3.392 4.12-4.478 6.66-1.085 2.54-1.629 5.264-1.629 8.172h3.49c0-4.863 1.648-8.986 4.944-12.372 3.297-3.385 7.368-5.078 12.216-5.078h1.279l-4.245 4.247 2.443 2.442 8.55-8.55zm-9.52 21.45v4.42h4.871V142h4.513v-23.55zm18.136 0c-1.125 0-2.066.377-2.824 1.135-.764.764-1.148 1.709-1.148 2.834v15.612c0 1.124.38 2.066 1.139 2.824.764.764 1.708 1.145 2.833 1.145h7.489c1.125 0 2.066-.378 2.824-1.136.764-.764 1.145-1.709 1.145-2.833v-15.612c0-1.125-.378-2.067-1.136-2.825-.764-.764-1.708-1.145-2.833-1.145zm.54 4.42h6.408v14.617h-6.407z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 96 48 48\" id=\"vjs-icon-forward-30\">\n      <path d=\"M25.549 97l-2.437 2.434 4.634 4.635H26.38c-2.97 0-5.753.555-8.347 1.664-2.594 1.109-4.861 2.633-6.802 4.574-1.94 1.94-3.465 4.207-4.574 6.802-1.109 2.594-1.664 5.377-1.664 8.347h3.565c0-4.967 1.683-9.178 5.05-12.636 3.366-3.458 7.525-5.187 12.475-5.187h1.307l-4.335 4.338 2.495 2.494 8.732-8.732zm-11.553 20.53v4.689h10.297v5.249h-6.978v4.688h6.978v5.156H13.996V142h10.808c1.06 0 1.948-.395 2.666-1.186.718-.79 1.077-1.771 1.077-2.94v-16.217c0-1.169-.36-2.15-1.077-2.94-.718-.79-1.605-1.186-2.666-1.186zm21.174.168c-1.149 0-2.11.389-2.884 1.163-.78.78-1.172 1.745-1.172 2.894v15.942c0 1.15.388 2.11 1.162 2.885.78.78 1.745 1.17 2.894 1.17h7.649c1.149 0 2.11-.386 2.885-1.16.78-.78 1.17-1.746 1.17-2.895v-15.942c0-1.15-.387-2.11-1.161-2.885-.78-.78-1.745-1.172-2.894-1.172zm.552 4.516h6.542v14.931h-6.542z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 512 512\" id=\"vjs-icon-audio-description\">\n      <g fill-rule=\"evenodd\"><path d=\"M227.29 381.351V162.993c50.38-1.017 89.108-3.028 117.631 17.126 27.374 19.342 48.734 56.965 44.89 105.325-4.067 51.155-41.335 94.139-89.776 98.475-24.085 2.155-71.972 0-71.972 0s-.84-1.352-.773-2.568m48.755-54.804c31.43 1.26 53.208-16.633 56.495-45.386 4.403-38.51-21.188-63.552-58.041-60.796v103.612c-.036 1.466.575 2.22 1.546 2.57\"></path><path d=\"M383.78 381.328c13.336 3.71 17.387-11.06 23.215-21.408 12.722-22.571 22.294-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.226 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894\"></path><path d=\"M425.154 381.328c13.336 3.71 17.384-11.061 23.215-21.408 12.721-22.571 22.291-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.511c-.586 3.874 2.226 7.315 3.866 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894\"></path><path d=\"M466.26 381.328c13.337 3.71 17.385-11.061 23.216-21.408 12.722-22.571 22.292-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.225 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894M4.477 383.005H72.58l18.573-28.484 64.169-.135s.065 19.413.065 28.62h48.756V160.307h-58.816c-5.653 9.537-140.85 222.697-140.85 222.697zm152.667-145.282v71.158l-40.453-.27 40.453-70.888z\"></path></g>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-next-item\">\n      <path d=\"M12 36l17-12-17-12v24zm20-24v24h4V12h-4z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-previous-item\">\n      <path d=\"M12 12h4v24h-4zm7 12l17 12V12z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-shuffle\">\n      <path d=\"M21.17 18.34L10.83 8 8 10.83l10.34 10.34 2.83-2.83zM29 8l4.09 4.09L8 37.17 10.83 40l25.09-25.09L40 19V8H29zm.66 18.83l-2.83 2.83 6.26 6.26L29 40h11V29l-4.09 4.09-6.25-6.26z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-cast\">\n      <path d=\"M42 6H6c-2.21 0-4 1.79-4 4v6h4v-6h36v28H28v4h14c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zM2 36v6h6c0-3.31-2.69-6-6-6zm0-8v4c5.52 0 10 4.48 10 10h4c0-7.73-6.27-14-14-14zm0-8v4c9.94 0 18 8.06 18 18h4c0-12.15-9.85-22-22-22z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 48 48\" id=\"vjs-icon-picture-in-picture-enter\">\n      <path d=\"M38 22H22v11.99h16V22zm8 16V9.96C46 7.76 44.2 6 42 6H6C3.8 6 2 7.76 2 9.96V38c0 2.2 1.8 4 4 4h36c2.2 0 4-1.8 4-4zm-4 .04H6V9.94h36v28.1z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 22 18\" id=\"vjs-icon-picture-in-picture-exit\">\n      <path d=\"M18 4H4v10h14V4zm4 12V1.98C22 .88 21.1 0 20 0H2C.9 0 0 .88 0 1.98V16c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H2V1.97h18v14.05z\"></path>\n      <path fill=\"none\" d=\"M-1-3h24v24H-1z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 1792 1792\" id=\"vjs-icon-facebook\">\n      <path d=\"M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759H734V905H479V609h255V391q0-186 104-288.5T1115 0q147 0 228 12z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 1792 1792\" id=\"vjs-icon-linkedin\">\n      <path d=\"M477 625v991H147V625h330zm21-306q1 73-50.5 122T312 490h-2q-82 0-132-49t-50-122q0-74 51.5-122.5T314 148t133 48.5T498 319zm1166 729v568h-329v-530q0-105-40.5-164.5T1168 862q-63 0-105.5 34.5T999 982q-11 30-11 81v553H659q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5T1285 602q171 0 275 113.5t104 332.5z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 1200 1227\" id=\"vjs-icon-twitter\">\n      <path d=\"M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.934L144.011 79.6944H306.615L611.412 515.685L658.88 583.579L1055.08 1150.3H892.476L569.165 687.854V687.828Z\"/>\n    </symbol>\n    <symbol viewBox=\"0 0 1792 1792\" id=\"vjs-icon-tumblr\">\n      <path d=\"M1328 1329l80 237q-23 35-111 66t-177 32q-104 2-190.5-26T787 1564t-95-106-55.5-120-16.5-118V676H452V461q72-26 129-69.5t91-90 58-102 34-99T779 12q1-5 4.5-8.5T791 0h244v424h333v252h-334v518q0 30 6.5 56t22.5 52.5 49.5 41.5 81.5 14q78-2 134-29z\"></path>\n    </symbol>\n    <symbol viewBox=\"0 0 1792 1792\" id=\"vjs-icon-pinterest\">\n      <path d=\"M1664 896q0 209-103 385.5T1281.5 1561 896 1664q-111 0-218-32 59-93 78-164 9-34 54-211 20 39 73 67.5t114 28.5q121 0 216-68.5t147-188.5 52-270q0-114-59.5-214T1180 449t-255-63q-105 0-196 29t-154.5 77-109 110.5-67 129.5T377 866q0 104 40 183t117 111q30 12 38-20 2-7 8-31t8-30q6-23-11-43-51-61-51-151 0-151 104.5-259.5T904 517q151 0 235.5 82t84.5 213q0 170-68.5 289T980 1220q-61 0-98-43.5T859 1072q8-35 26.5-93.5t30-103T927 800q0-50-27-83t-77-33q-62 0-105 57t-43 142q0 73 25 122l-99 418q-17 70-13 177-206-91-333-281T128 896q0-209 103-385.5T510.5 231 896 128t385.5 103T1561 510.5 1664 896z\"></path>\n    </symbol>\n  </defs>\n</svg>";

  // /**

  // Determine the keycode for the 'back' key based on the platform
  const backKeyCode = IS_TIZEN ? 10009 : IS_WEBOS ? 461 : 8;
  const SpatialNavKeyCodes = {
    codes: {
      play: 415,
      pause: 19,
      ff: 417,
      rw: 412,
      back: backKeyCode
    },
    names: {
      415: 'play',
      19: 'pause',
      417: 'ff',
      412: 'rw',
      [backKeyCode]: 'back'
    },
    isEventKey(event, keyName) {
      keyName = keyName.toLowerCase();
      if (this.names[event.keyCode] && this.names[event.keyCode] === keyName) {
        return true;
      }
      return false;
    },
    getEventName(event) {
      if (this.names[event.keyCode]) {
        return this.names[event.keyCode];
      } else if (this.codes[event.code]) {
        const code = this.codes[event.code];
        return this.names[code];
      }
      return null;
    }
  };

  /**
   * @file spatial-navigation.js
   */

  /** @import Component from './component' */
  /** @import Player from './player' */

  // The number of seconds the `step*` functions move the timeline.
  const STEP_SECONDS$1 = 5;

  /**
   * Spatial Navigation in Video.js enhances user experience and accessibility on smartTV devices,
   * enabling seamless navigation through interactive elements within the player using remote control arrow keys.
   * This functionality allows users to effortlessly navigate through focusable components.
   *
   * @extends EventTarget
   */
  class SpatialNavigation extends EventTarget {
    /**
     * Constructs a SpatialNavigation instance with initial settings.
     * Sets up the player instance, and prepares the spatial navigation system.
     *
     * @class
     * @param {Player} player - The Video.js player instance to which the spatial navigation is attached.
     */
    constructor(player) {
      super();
      this.player_ = player;
      this.focusableComponents = [];
      this.isListening_ = false;
      this.isPaused_ = false;
      this.onKeyDown_ = this.onKeyDown_.bind(this);
      this.lastFocusedComponent_ = null;
    }

    /**
     * Starts the spatial navigation by adding a keydown event listener to the video container.
     * This method ensures that the event listener is added only once.
     */
    start() {
      // If the listener is already active, exit early.
      if (this.isListening_) {
        return;
      }

      // Add the event listener since the listener is not yet active.
      this.player_.on('keydown', this.onKeyDown_);
      this.player_.on('modalKeydown', this.onKeyDown_);
      // Listen for source change events
      this.player_.on('loadedmetadata', () => {
        this.focus(this.updateFocusableComponents()[0]);
      });
      this.player_.on('modalclose', () => {
        this.refocusComponent();
      });
      this.player_.on('focusin', this.handlePlayerFocus_.bind(this));
      this.player_.on('focusout', this.handlePlayerBlur_.bind(this));
      this.isListening_ = true;
      if (this.player_.errorDisplay) {
        this.player_.errorDisplay.on('aftermodalfill', () => {
          this.updateFocusableComponents();
          if (this.focusableComponents.length) {
            // The modal has focusable components:

            if (this.focusableComponents.length > 1) {
              // The modal has close button + some additional buttons.
              // Focusing first additional button:

              this.focusableComponents[1].focus();
            } else {
              // The modal has only close button,
              // Focusing it:

              this.focusableComponents[0].focus();
            }
          }
        });
      }
    }

    /**
     * Stops the spatial navigation by removing the keydown event listener from the video container.
     * Also sets the `isListening_` flag to false.
     */
    stop() {
      this.player_.off('keydown', this.onKeyDown_);
      this.isListening_ = false;
    }

    /**
     * Responds to keydown events for spatial navigation and media control.
     *
     * Determines if spatial navigation or media control is active and handles key inputs accordingly.
     *
     * @param {KeyboardEvent} event - The keydown event to be handled.
     */
    onKeyDown_(event) {
      // Determine if the event is a custom modalKeydown event
      const actualEvent = event.originalEvent ? event.originalEvent : event;
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(actualEvent.key)) {
        // Handle directional navigation
        if (this.isPaused_) {
          return;
        }
        actualEvent.preventDefault();

        // "ArrowLeft" => "left" etc
        const direction = actualEvent.key.substring(5).toLowerCase();
        this.move(direction);
      } else if (SpatialNavKeyCodes.isEventKey(actualEvent, 'play') || SpatialNavKeyCodes.isEventKey(actualEvent, 'pause') || SpatialNavKeyCodes.isEventKey(actualEvent, 'ff') || SpatialNavKeyCodes.isEventKey(actualEvent, 'rw')) {
        // Handle media actions
        actualEvent.preventDefault();
        const action = SpatialNavKeyCodes.getEventName(actualEvent);
        this.performMediaAction_(action);
      } else if (SpatialNavKeyCodes.isEventKey(actualEvent, 'Back') && event.target && event.target.closeable()) {
        actualEvent.preventDefault();
        event.target.close();
      }
    }

    /**
     * Performs media control actions based on the given key input.
     *
     * Controls the playback and seeking functionalities of the media player.
     *
     * @param {string} key - The key representing the media action to be performed.
     *   Accepted keys: 'play', 'pause', 'ff' (fast-forward), 'rw' (rewind).
     */
    performMediaAction_(key) {
      if (this.player_) {
        switch (key) {
          case 'play':
            if (this.player_.paused()) {
              this.player_.play();
            }
            break;
          case 'pause':
            if (!this.player_.paused()) {
              this.player_.pause();
            }
            break;
          case 'ff':
            this.userSeek_(this.player_.currentTime() + STEP_SECONDS$1);
            break;
          case 'rw':
            this.userSeek_(this.player_.currentTime() - STEP_SECONDS$1);
            break;
        }
      }
    }

    /**
     * Prevent liveThreshold from causing seeks to seem like they
     * are not happening from a user perspective.
     *
     * @param {number} ct
     *        current time to seek to
     */
    userSeek_(ct) {
      if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
        this.player_.liveTracker.nextSeekedFromUser();
      }
      this.player_.currentTime(ct);
    }

    /**
     * Pauses the spatial navigation functionality.
     * This method sets a flag that can be used to temporarily disable the navigation logic.
     */
    pause() {
      this.isPaused_ = true;
    }

    /**
     * Resumes the spatial navigation functionality if it has been paused.
     * This method resets the pause flag, re-enabling the navigation logic.
     */
    resume() {
      this.isPaused_ = false;
    }

    /**
     * Handles Player Blur.
     *
     * @param {string|Event|Object} event
     *        The name of the event, an `Event`, or an object with a key of type set to
     *        an event name.
     *
     * Calls for handling of the Player Blur if:
     * *The next focused element is not a child of current focused element &
     * The next focused element is not a child of the Player.
     * *There is no next focused element
     */
    handlePlayerBlur_(event) {
      const nextFocusedElement = event.relatedTarget;
      let isChildrenOfPlayer = null;
      const currentComponent = this.getCurrentComponent(event.target);
      if (nextFocusedElement) {
        isChildrenOfPlayer = Boolean(nextFocusedElement.closest('.video-js'));

        // If nextFocusedElement is the 'TextTrackSettings' component
        if (nextFocusedElement.classList.contains('vjs-text-track-settings') && !this.isPaused_) {
          this.searchForTrackSelect_();
        }
      }
      if (!event.currentTarget.contains(event.relatedTarget) && !isChildrenOfPlayer || !nextFocusedElement) {
        if (currentComponent && currentComponent.name() === 'CloseButton') {
          this.refocusComponent();
        } else {
          this.pause();
          if (currentComponent && currentComponent.el()) {
            // Store last focused component
            this.lastFocusedComponent_ = currentComponent;
          }
        }
      }
    }

    /**
     * Handles the Player focus event.
     *
     * Calls for handling of the Player Focus if current element is focusable.
     */
    handlePlayerFocus_() {
      if (this.getCurrentComponent() && this.getCurrentComponent().getIsFocusable()) {
        this.resume();
      }
    }

    /**
     * Gets a set of focusable components.
     *
     * @return {Array}
     *         Returns an array of focusable components.
     */
    updateFocusableComponents() {
      const player = this.player_;
      const focusableComponents = [];

      /**
       * Searches for children candidates.
       *
       * Pushes Components to array of 'focusableComponents'.
       * Calls itself if there is children elements inside iterated component.
       *
       * @param {Array} componentsArray - The array of components to search for focusable children.
       */
      function searchForChildrenCandidates(componentsArray) {
        for (const i of componentsArray) {
          if (i.hasOwnProperty('el_') && i.getIsFocusable() && i.getIsAvailableToBeFocused(i.el())) {
            focusableComponents.push(i);
          }
          if (i.hasOwnProperty('children_') && i.children_.length > 0) {
            searchForChildrenCandidates(i.children_);
          }
        }
      }

      // Iterate inside all children components of the player.
      player.children_.forEach(value => {
        if (value.hasOwnProperty('el_')) {
          // If component has required functions 'getIsFocusable' & 'getIsAvailableToBeFocused', is focusable & available to be focused.
          if (value.getIsFocusable && value.getIsAvailableToBeFocused && value.getIsFocusable() && value.getIsAvailableToBeFocused(value.el())) {
            focusableComponents.push(value);
            return;
            // If component has posible children components as candidates.
          } else if (value.hasOwnProperty('children_') && value.children_.length > 0) {
            searchForChildrenCandidates(value.children_);
            // If component has posible item components as candidates.
          } else if (value.hasOwnProperty('items') && value.items.length > 0) {
            searchForChildrenCandidates(value.items);
            // If there is a suitable child element within the component's DOM element.
          } else if (this.findSuitableDOMChild(value)) {
            focusableComponents.push(value);
          }
        }

        // TODO - Refactor the following logic after refactor of videojs-errors elements to be components is done.
        if (value.name_ === 'ErrorDisplay' && value.opened_) {
          const buttonContainer = value.el_.querySelector('.vjs-errors-ok-button-container');
          if (buttonContainer) {
            const modalButtons = buttonContainer.querySelectorAll('button');
            modalButtons.forEach((element, index) => {
              // Add elements as objects to be handled by the spatial navigation
              focusableComponents.push({
                name: () => {
                  return 'ModalButton' + (index + 1);
                },
                el: () => element,
                getPositions: () => {
                  const rect = element.getBoundingClientRect();

                  // Creating objects that mirror DOMRectReadOnly for boundingClientRect and center
                  const boundingClientRect = {
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                    top: rect.top,
                    right: rect.right,
                    bottom: rect.bottom,
                    left: rect.left
                  };

                  // Calculating the center position
                  const center = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2,
                    width: 0,
                    height: 0,
                    top: rect.top + rect.height / 2,
                    right: rect.left + rect.width / 2,
                    bottom: rect.top + rect.height / 2,
                    left: rect.left + rect.width / 2
                  };
                  return {
                    boundingClientRect,
                    center
                  };
                },
                // Asume that the following are always focusable
                getIsAvailableToBeFocused: () => true,
                getIsFocusable: el => true,
                focus: () => element.focus()
              });
            });
          }
        }
      });
      this.focusableComponents = focusableComponents;
      return this.focusableComponents;
    }

    /**
     * Finds a suitable child element within the provided component's DOM element.
     *
     * @param {Object} component - The component containing the DOM element to search within.
     * @return {HTMLElement|null} Returns the suitable child element if found, or null if not found.
     */
    findSuitableDOMChild(component) {
      /**
       * Recursively searches for a suitable child node that can be focused within a given component.
       * It first checks if the provided node itself can be focused according to the component's
       * `getIsFocusable` and `getIsAvailableToBeFocused` methods. If not, it recursively searches
       * through the node's children to find a suitable child node that meets the focusability criteria.
       *
       * @param {HTMLElement} node - The DOM node to start the search from.
       * @return {HTMLElement|null} The first child node that is focusable and available to be focused,
       * or `null` if no suitable child is found.
       */
      function searchForSuitableChild(node) {
        if (component.getIsFocusable(node) && component.getIsAvailableToBeFocused(node)) {
          return node;
        }
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          const suitableChild = searchForSuitableChild(child);
          if (suitableChild) {
            return suitableChild;
          }
        }
        return null;
      }
      if (component.el()) {
        return searchForSuitableChild(component.el());
      }
      return null;
    }

    /**
     * Gets the currently focused component from the list of focusable components.
     * If a target element is provided, it uses that element to find the corresponding
     * component. If no target is provided, it defaults to using the document's currently
     * active element.
     *
     * @param {HTMLElement} [target] - The DOM element to check against the focusable components.
     *                                 If not provided, `document.activeElement` is used.
     * @return {Component|null} - Returns the focused component if found among the focusable components,
     *                            otherwise returns null if no matching component is found.
     */
    getCurrentComponent(target) {
      this.updateFocusableComponents();
      // eslint-disable-next-line
      const curComp = target || document.activeElement;
      if (this.focusableComponents.length) {
        for (const i of this.focusableComponents) {
          // If component Node is equal to the current active element.
          if (i.el() === curComp) {
            return i;
          }
        }
      }
    }

    /**
     * Adds a component to the array of focusable components.
     *
     * @param {Component} component
     *        The `Component` to be added.
     */
    add(component) {
      const focusableComponents = [...this.focusableComponents];
      if (component.hasOwnProperty('el_') && component.getIsFocusable() && component.getIsAvailableToBeFocused(component.el())) {
        focusableComponents.push(component);
      }
      this.focusableComponents = focusableComponents;
      // Trigger the notification manually
      this.trigger({
        type: 'focusableComponentsChanged',
        focusableComponents: this.focusableComponents
      });
    }

    /**
     * Removes component from the array of focusable components.
     *
     * @param {Component} component - The component to be removed from the focusable components array.
     */
    remove(component) {
      for (let i = 0; i < this.focusableComponents.length; i++) {
        if (this.focusableComponents[i].name() === component.name()) {
          this.focusableComponents.splice(i, 1);
          // Trigger the notification manually
          this.trigger({
            type: 'focusableComponentsChanged',
            focusableComponents: this.focusableComponents
          });
          return;
        }
      }
    }

    /**
     * Clears array of focusable components.
     */
    clear() {
      // Check if the array is already empty to avoid unnecessary event triggering
      if (this.focusableComponents.length > 0) {
        // Clear the array
        this.focusableComponents = [];

        // Trigger the notification manually
        this.trigger({
          type: 'focusableComponentsChanged',
          focusableComponents: this.focusableComponents
        });
      }
    }

    /**
     * Navigates to the next focusable component based on the specified direction.
     *
     * @param {string} direction 'up', 'down', 'left', 'right'
     */
    move(direction) {
      const currentFocusedComponent = this.getCurrentComponent();
      if (!currentFocusedComponent) {
        return;
      }
      const currentPositions = currentFocusedComponent.getPositions();
      const candidates = this.focusableComponents.filter(component => component !== currentFocusedComponent && this.isInDirection_(currentPositions.boundingClientRect, component.getPositions().boundingClientRect, direction));
      const bestCandidate = this.findBestCandidate_(currentPositions.center, candidates, direction);
      if (bestCandidate) {
        this.focus(bestCandidate);
      } else {
        this.trigger({
          type: 'endOfFocusableComponents',
          direction,
          focusedComponent: currentFocusedComponent
        });
      }
    }

    /**
     * Finds the best candidate on the current center position,
     * the list of candidates, and the specified navigation direction.
     *
     * @param {Object} currentCenter The center position of the current focused component element.
     * @param {Array} candidates An array of candidate components to receive focus.
     * @param {string} direction The direction of navigation ('up', 'down', 'left', 'right').
     * @return {Object|null} The component that is the best candidate for receiving focus.
     */
    findBestCandidate_(currentCenter, candidates, direction) {
      let minDistance = Infinity;
      let bestCandidate = null;
      for (const candidate of candidates) {
        const candidateCenter = candidate.getPositions().center;
        const distance = this.calculateDistance_(currentCenter, candidateCenter, direction);
        if (distance < minDistance) {
          minDistance = distance;
          bestCandidate = candidate;
        }
      }
      return bestCandidate;
    }

    /**
     * Determines if a target rectangle is in the specified navigation direction
     * relative to a source rectangle.
     *
     * @param {Object} srcRect The bounding rectangle of the source element.
     * @param {Object} targetRect The bounding rectangle of the target element.
     * @param {string} direction The navigation direction ('up', 'down', 'left', 'right').
     * @return {boolean} True if the target is in the specified direction relative to the source.
     */
    isInDirection_(srcRect, targetRect, direction) {
      switch (direction) {
        case 'right':
          return targetRect.left >= srcRect.right;
        case 'left':
          return targetRect.right <= srcRect.left;
        case 'down':
          return targetRect.top >= srcRect.bottom;
        case 'up':
          return targetRect.bottom <= srcRect.top;
        default:
          return false;
      }
    }

    /**
     * Focus the last focused component saved before blur on player.
     */
    refocusComponent() {
      if (this.lastFocusedComponent_) {
        // If user is not active, set it to active.
        if (!this.player_.userActive()) {
          this.player_.userActive(true);
        }
        this.updateFocusableComponents();

        // Search inside array of 'focusableComponents' for a match of name of
        // the last focused component.
        for (let i = 0; i < this.focusableComponents.length; i++) {
          if (this.focusableComponents[i].name() === this.lastFocusedComponent_.name()) {
            this.focus(this.focusableComponents[i]);
            return;
          }
        }
      } else {
        this.focus(this.updateFocusableComponents()[0]);
      }
    }

    /**
     * Focuses on a given component.
     * If the component is available to be focused, it focuses on the component.
     * If not, it attempts to find a suitable DOM child within the component and focuses on it.
     *
     * @param {Component} component - The component to be focused.
     */
    focus(component) {
      if (typeof component !== 'object') {
        return;
      }
      if (component.getIsAvailableToBeFocused(component.el())) {
        component.focus();
      } else if (this.findSuitableDOMChild(component)) {
        this.findSuitableDOMChild(component).focus();
      }
    }

    /**
     * Calculates the distance between two points, adjusting the calculation based on
     * the specified navigation direction.
     *
     * @param {Object} center1 The center point of the first element.
     * @param {Object} center2 The center point of the second element.
     * @param {string} direction The direction of navigation ('up', 'down', 'left', 'right').
     * @return {number} The calculated distance between the two centers.
     */
    calculateDistance_(center1, center2, direction) {
      const dx = Math.abs(center1.x - center2.x);
      const dy = Math.abs(center1.y - center2.y);
      let distance;
      switch (direction) {
        case 'right':
        case 'left':
          // Higher weight for vertical distance in horizontal navigation.
          distance = dx + dy * 100;
          break;
        case 'up':
          // Strongly prioritize vertical proximity for UP navigation.
          // Adjust the weight to ensure that elements directly above are favored.
          distance = dy * 2 + dx * 0.5;
          break;
        case 'down':
          // More balanced weight for vertical and horizontal distances.
          // Adjust the weights here to find the best balance.
          distance = dy * 5 + dx;
          break;
        default:
          distance = dx + dy;
      }
      return distance;
    }

    /**
     * This gets called by 'handlePlayerBlur_' if 'spatialNavigation' is enabled.
     * Searches for the first 'TextTrackSelect' inside of modal to focus.
     *
     * @private
     */
    searchForTrackSelect_() {
      const spatialNavigation = this;
      for (const component of spatialNavigation.updateFocusableComponents()) {
        if (component.constructor.name === 'TextTrackSelect') {
          spatialNavigation.focus(component);
          break;
        }
      }
    }
  }

  /**
   * @file loader.js
   */

  /** @import Player from '../player' */

  /**
   * The `MediaLoader` is the `Component` that decides which playback technology to load
   * when a player is initialized.
   *
   * @extends Component
   */
  class MediaLoader extends Component {
    /**
     * Create an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should attach to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function that is run when this component is ready.
     */
    constructor(player, options, ready) {
      // MediaLoader has no element
      const options_ = merge({
        createEl: false
      }, options);
      super(player, options_, ready);

      // If there are no sources when the player is initialized,
      // load the first supported playback technology.

      if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
        for (let i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
          const techName = toTitleCase(j[i]);
          let tech = Tech.getTech(techName);

          // Support old behavior of techs being registered as components.
          // Remove once that deprecated behavior is removed.
          if (!techName) {
            tech = Component.getComponent(techName);
          }

          // Check if the browser supports this technology
          if (tech && tech.isSupported()) {
            player.loadTech_(techName);
            break;
          }
        }
      } else {
        // Loop through playback technologies (e.g. HTML5) and check for support.
        // Then load the best source.
        // A few assumptions here:
        //   All playback technologies respect preload false.
        player.src(options.playerOptions.sources);
      }
    }
  }
  Component.registerComponent('MediaLoader', MediaLoader);

  /**
   * @file clickable-component.js
   */

  /** @import Player from './player' */

  /**
   * Component which is clickable or keyboard actionable, but is not a
   * native HTML button.
   *
   * @extends Component
   */
  class ClickableComponent extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param  {Player} player
     *         The `Player` that this class should be attached to.
     *
     * @param  {Object} [options]
     *         The key/value store of component options.
     *
     * @param  {function} [options.clickHandler]
     *         The function to call when the button is clicked / activated
     *
     * @param  {string} [options.controlText]
     *         The text to set on the button
     *
     * @param  {string} [options.className]
     *         A class or space separated list of classes to add the component
     *
     */
    constructor(player, options) {
      super(player, options);
      if (this.options_.controlText) {
        this.controlText(this.options_.controlText);
      }
      this.handleMouseOver_ = e => this.handleMouseOver(e);
      this.handleMouseOut_ = e => this.handleMouseOut(e);
      this.handleClick_ = e => this.handleClick(e);
      this.handleKeyDown_ = e => this.handleKeyDown(e);
      this.emitTapEvents();
      this.enable();
    }

    /**
     * Create the `ClickableComponent`s DOM element.
     *
     * @param {string} [tag=div]
     *        The element's node type.
     *
     * @param {Object} [props={}]
     *        An object of properties that should be set on the element.
     *
     * @param {Object} [attributes={}]
     *        An object of attributes that should be set on the element.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl(tag = 'div', props = {}, attributes = {}) {
      props = Object.assign({
        className: this.buildCSSClass(),
        tabIndex: 0
      }, props);
      if (tag === 'button') {
        log.error(`Creating a ClickableComponent with an HTML element of ${tag} is not supported; use a Button instead.`);
      }

      // Add ARIA attributes for clickable element which is not a native HTML button
      attributes = Object.assign({
        role: 'button'
      }, attributes);
      this.tabIndex_ = props.tabIndex;
      const el = createEl(tag, props, attributes);
      if (!this.player_.options_.experimentalSvgIcons) {
        el.appendChild(createEl('span', {
          className: 'vjs-icon-placeholder'
        }, {
          'aria-hidden': true
        }));
      }
      this.createControlTextEl(el);
      return el;
    }
    dispose() {
      // remove controlTextEl_ on dispose
      this.controlTextEl_ = null;
      super.dispose();
    }

    /**
     * Create a control text element on this `ClickableComponent`
     *
     * @param {Element} [el]
     *        Parent element for the control text.
     *
     * @return {Element}
     *         The control text element that gets created.
     */
    createControlTextEl(el) {
      this.controlTextEl_ = createEl('span', {
        className: 'vjs-control-text'
      }, {
        // let the screen reader user know that the text of the element may change
        'aria-live': 'polite'
      });
      if (el) {
        el.appendChild(this.controlTextEl_);
      }
      this.controlText(this.controlText_, el);
      return this.controlTextEl_;
    }

    /**
     * Get or set the localize text to use for the controls on the `ClickableComponent`.
     *
     * @param {string} [text]
     *        Control text for element.
     *
     * @param {Element} [el=this.el()]
     *        Element to set the title on.
     *
     * @return {string}
     *         - The control text when getting
     */
    controlText(text, el = this.el()) {
      if (text === undefined) {
        return this.controlText_ || 'Need Text';
      }
      const localizedText = this.localize(text);

      /** @protected */
      this.controlText_ = text;
      textContent(this.controlTextEl_, localizedText);
      if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {
        // Set title attribute if only an icon is shown
        el.setAttribute('title', localizedText);
      }
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-control vjs-button ${super.buildCSSClass()}`;
    }

    /**
     * Enable this `ClickableComponent`
     */
    enable() {
      if (!this.enabled_) {
        this.enabled_ = true;
        this.removeClass('vjs-disabled');
        this.el_.setAttribute('aria-disabled', 'false');
        if (typeof this.tabIndex_ !== 'undefined') {
          this.el_.setAttribute('tabIndex', this.tabIndex_);
        }
        this.on(['tap', 'click'], this.handleClick_);
        this.on('keydown', this.handleKeyDown_);
      }
    }

    /**
     * Disable this `ClickableComponent`
     */
    disable() {
      this.enabled_ = false;
      this.addClass('vjs-disabled');
      this.el_.setAttribute('aria-disabled', 'true');
      if (typeof this.tabIndex_ !== 'undefined') {
        this.el_.removeAttribute('tabIndex');
      }
      this.off('mouseover', this.handleMouseOver_);
      this.off('mouseout', this.handleMouseOut_);
      this.off(['tap', 'click'], this.handleClick_);
      this.off('keydown', this.handleKeyDown_);
    }

    /**
     * Handles language change in ClickableComponent for the player in components
     *
     *
     */
    handleLanguagechange() {
      this.controlText(this.controlText_);
    }

    /**
     * Event handler that is called when a `ClickableComponent` receives a
     * `click` or `tap` event.
     *
     * @param {Event} event
     *        The `tap` or `click` event that caused this function to be called.
     *
     * @listens tap
     * @listens click
     * @abstract
     */
    handleClick(event) {
      if (this.options_.clickHandler) {
        this.options_.clickHandler.call(this, arguments);
      }
    }

    /**
     * Event handler that is called when a `ClickableComponent` receives a
     * `keydown` event.
     *
     * By default, if the key is Space or Enter, it will trigger a `click` event.
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      // Support Space or Enter key operation to fire a click event. Also,
      // prevent the event from propagating through the DOM and triggering
      // Player hotkeys.
      if (event.key === ' ' || event.key === 'Enter') {
        event.preventDefault();
        event.stopPropagation();
        this.trigger('click');
      } else {
        // Pass keypress handling up for unsupported keys
        super.handleKeyDown(event);
      }
    }
  }
  Component.registerComponent('ClickableComponent', ClickableComponent);

  /**
   * @file poster-image.js
   */

  /** @import Player from './player' */

  /**
   * A `ClickableComponent` that handles showing the poster image for the player.
   *
   * @extends ClickableComponent
   */
  class PosterImage extends ClickableComponent {
    /**
     * Create an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should attach to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.update();
      this.update_ = e => this.update(e);
      player.on('posterchange', this.update_);
    }

    /**
     * Clean up and dispose of the `PosterImage`.
     */
    dispose() {
      this.player().off('posterchange', this.update_);
      super.dispose();
    }

    /**
     * Create the `PosterImage`s DOM element.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl() {
      // The el is an empty div to keep position in the DOM
      // A picture and img el will be inserted when a source is set
      return createEl('div', {
        className: 'vjs-poster'
      });
    }

    /**
     * Get or set the `PosterImage`'s crossOrigin option.
     *
     * @param {string|null} [value]
     *        The value to set the crossOrigin to. If an argument is
     *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.
     *
     * @return {string|null}
     *         - The current crossOrigin value of the `Player` when getting.
     *         - undefined when setting
     */
    crossOrigin(value) {
      // `null` can be set to unset a value
      if (typeof value === 'undefined') {
        if (this.$('img')) {
          // If the poster's element exists, give its value
          return this.$('img').crossOrigin;
        } else if (this.player_.tech_ && this.player_.tech_.isReady_) {
          // If not but the tech is ready, query the tech
          return this.player_.crossOrigin();
        }
        // Otherwise check options as the  poster is usually set before the state of crossorigin
        // can be retrieved by the getter
        return this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;
      }
      if (value !== null && value !== 'anonymous' && value !== 'use-credentials') {
        this.player_.log.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${value}"`);
        return;
      }
      if (this.$('img')) {
        this.$('img').crossOrigin = value;
      }
      return;
    }

    /**
     * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.
     *
     * @listens Player#posterchange
     *
     * @param {Event} [event]
     *        The `Player#posterchange` event that triggered this function.
     */
    update(event) {
      const url = this.player().poster();
      this.setSrc(url);

      // If there's no poster source we should display:none on this component
      // so it's not still clickable or right-clickable
      if (url) {
        this.show();
      } else {
        this.hide();
      }
    }

    /**
     * Set the source of the `PosterImage` depending on the display method. (Re)creates
     * the inner picture and img elementss when needed.
     *
     * @param {string} [url]
     *        The URL to the source for the `PosterImage`. If not specified or falsy,
     *        any source and ant inner picture/img are removed.
     */
    setSrc(url) {
      if (!url) {
        this.el_.textContent = '';
        return;
      }
      if (!this.$('img')) {
        this.el_.appendChild(createEl('picture', {
          className: 'vjs-poster',
          // Don't want poster to be tabbable.
          tabIndex: -1
        }, {}, createEl('img', {
          loading: 'lazy',
          crossOrigin: this.crossOrigin()
        }, {
          alt: ''
        })));
      }
      this.$('img').src = url;
    }

    /**
     * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See
     * {@link ClickableComponent#handleClick} for instances where this will be triggered.
     *
     * @listens tap
     * @listens click
     * @listens keydown
     *
     * @param {Event} event
     +        The `click`, `tap` or `keydown` event that caused this function to be called.
     */
    handleClick(event) {
      // We don't want a click to trigger playback when controls are disabled
      if (!this.player_.controls()) {
        return;
      }
      if (this.player_.tech(true)) {
        this.player_.tech(true).focus();
      }
      if (this.player_.paused()) {
        silencePromise(this.player_.play());
      } else {
        this.player_.pause();
      }
    }
  }

  /**
   * Get or set the `PosterImage`'s crossorigin option. For the HTML5 player, this
   * sets the `crossOrigin` property on the `<img>` tag to control the CORS
   * behavior.
   *
   * @param {string|null} [value]
   *        The value to set the `PosterImages`'s crossorigin to. If an argument is
   *        given, must be one of `anonymous` or `use-credentials`.
   *
   * @return {string|null|undefined}
   *         - The current crossorigin value of the `Player` when getting.
   *         - undefined when setting
   */
  PosterImage.prototype.crossorigin = PosterImage.prototype.crossOrigin;
  Component.registerComponent('PosterImage', PosterImage);

  /**
   * @file text-track-display.js
   */

  /** @import Player from '../player' */

  const darkGray = '#222';
  const lightGray = '#ccc';
  const fontMap = {
    monospace: 'monospace',
    sansSerif: 'sans-serif',
    serif: 'serif',
    monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
    monospaceSerif: '"Courier New", monospace',
    proportionalSansSerif: 'sans-serif',
    proportionalSerif: 'serif',
    casual: '"Comic Sans MS", Impact, fantasy',
    script: '"Monotype Corsiva", cursive',
    smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
  };

  /**
   * Construct an rgba color from a given hex color code.
   *
   * @param {number} color
   *        Hex number for color, like #f0e or #f604e2.
   *
   * @param {number} opacity
   *        Value for opacity, 0.0 - 1.0.
   *
   * @return {string}
   *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.
   */
  function constructColor(color, opacity) {
    let hex;
    if (color.length === 4) {
      // color looks like "#f0e"
      hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
    } else if (color.length === 7) {
      // color looks like "#f604e2"
      hex = color.slice(1);
    } else {
      throw new Error('Invalid color code provided, ' + color + '; must be formatted as e.g. #f0e or #f604e2.');
    }
    return 'rgba(' + parseInt(hex.slice(0, 2), 16) + ',' + parseInt(hex.slice(2, 4), 16) + ',' + parseInt(hex.slice(4, 6), 16) + ',' + opacity + ')';
  }

  /**
   * Try to update the style of a DOM element. Some style changes will throw an error,
   * particularly in IE8. Those should be noops.
   *
   * @param {Element} el
   *        The DOM element to be styled.
   *
   * @param {string} style
   *        The CSS property on the element that should be styled.
   *
   * @param {string} rule
   *        The style rule that should be applied to the property.
   *
   * @private
   */
  function tryUpdateStyle(el, style, rule) {
    try {
      el.style[style] = rule;
    } catch (e) {
      // Satisfies linter.
      return;
    }
  }

  /**
   * Converts the CSS top/right/bottom/left property numeric value to string in pixels.
   *
   * @param {number} position
   *        The CSS top/right/bottom/left property value.
   *
   * @return {string}
   *          The CSS property value that was created, like '10px'.
   *
   * @private
   */
  function getCSSPositionValue(position) {
    return position ? `${position}px` : '';
  }

  /**
   * The component for displaying text track cues.
   *
   * @extends Component
   */
  class TextTrackDisplay extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when `TextTrackDisplay` is ready.
     */
    constructor(player, options, ready) {
      super(player, options, ready);
      const updateDisplayTextHandler = e => this.updateDisplay(e);
      const updateDisplayHandler = e => {
        this.updateDisplayOverlay();
        this.updateDisplay(e);
      };
      player.on('loadstart', e => this.toggleDisplay(e));
      player.on('texttrackchange', updateDisplayTextHandler);
      player.on('loadedmetadata', e => {
        this.updateDisplayOverlay();
        this.preselectTrack(e);
      });

      // This used to be called during player init, but was causing an error
      // if a track should show by default and the display hadn't loaded yet.
      // Should probably be moved to an external track loader when we support
      // tracks that don't need a display.
      player.ready(bind_(this, function () {
        if (player.tech_ && player.tech_.featuresNativeTextTracks) {
          this.hide();
          return;
        }
        player.on('fullscreenchange', updateDisplayHandler);
        player.on('playerresize', updateDisplayHandler);
        const screenOrientation = window__default["default"].screen.orientation || window__default["default"];
        const changeOrientationEvent = window__default["default"].screen.orientation ? 'change' : 'orientationchange';
        screenOrientation.addEventListener(changeOrientationEvent, updateDisplayHandler);
        player.on('dispose', () => screenOrientation.removeEventListener(changeOrientationEvent, updateDisplayHandler));
        const tracks = this.options_.playerOptions.tracks || [];
        for (let i = 0; i < tracks.length; i++) {
          this.player_.addRemoteTextTrack(tracks[i], true);
        }
        this.preselectTrack();
      }));
    }

    /**
    * Preselect a track following this precedence:
    * - matches the previously selected {@link TextTrack}'s language and kind
    * - matches the previously selected {@link TextTrack}'s language only
    * - is the first default captions track
    * - is the first default descriptions track
    *
    * @listens Player#loadstart
    */
    preselectTrack() {
      const modes = {
        captions: 1,
        subtitles: 1
      };
      const trackList = this.player_.textTracks();
      const userPref = this.player_.cache_.selectedLanguage;
      let firstDesc;
      let firstCaptions;
      let preferredTrack;
      for (let i = 0; i < trackList.length; i++) {
        const track = trackList[i];
        if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {
          // Always choose the track that matches both language and kind
          if (track.kind === userPref.kind) {
            preferredTrack = track;
            // or choose the first track that matches language
          } else if (!preferredTrack) {
            preferredTrack = track;
          }

          // clear everything if offTextTrackMenuItem was clicked
        } else if (userPref && !userPref.enabled) {
          preferredTrack = null;
          firstDesc = null;
          firstCaptions = null;
        } else if (track.default) {
          if (track.kind === 'descriptions' && !firstDesc) {
            firstDesc = track;
          } else if (track.kind in modes && !firstCaptions) {
            firstCaptions = track;
          }
        }
      }

      // The preferredTrack matches the user preference and takes
      // precedence over all the other tracks.
      // So, display the preferredTrack before the first default track
      // and the subtitles/captions track before the descriptions track
      if (preferredTrack) {
        preferredTrack.mode = 'showing';
      } else if (firstCaptions) {
        firstCaptions.mode = 'showing';
      } else if (firstDesc) {
        firstDesc.mode = 'showing';
      }
    }

    /**
     * Turn display of {@link TextTrack}'s from the current state into the other state.
     * There are only two states:
     * - 'shown'
     * - 'hidden'
     *
     * @listens Player#loadstart
     */
    toggleDisplay() {
      if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
        this.hide();
      } else {
        this.show();
      }
    }

    /**
     * Create the {@link Component}'s DOM element.
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl('div', {
        className: 'vjs-text-track-display'
      }, {
        'translate': 'yes',
        'aria-live': 'off',
        'aria-atomic': 'true'
      });
    }

    /**
     * Clear all displayed {@link TextTrack}s.
     */
    clearDisplay() {
      if (typeof window__default["default"].WebVTT === 'function') {
        window__default["default"].WebVTT.processCues(window__default["default"], [], this.el_);
      }
    }

    /**
     * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or
     * a {@link Player#fullscreenchange} is fired.
     *
     * @listens Player#texttrackchange
     * @listens Player#fullscreenchange
     */
    updateDisplay() {
      const tracks = this.player_.textTracks();
      const allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
      this.clearDisplay();
      if (allowMultipleShowingTracks) {
        const showingTracks = [];
        for (let i = 0; i < tracks.length; ++i) {
          const track = tracks[i];
          if (track.mode !== 'showing') {
            continue;
          }
          showingTracks.push(track);
        }
        this.updateForTrack(showingTracks);
        return;
      }

      //  Track display prioritization model: if multiple tracks are 'showing',
      //  display the first 'subtitles' or 'captions' track which is 'showing',
      //  otherwise display the first 'descriptions' track which is 'showing'

      let descriptionsTrack = null;
      let captionsSubtitlesTrack = null;
      let i = tracks.length;
      while (i--) {
        const track = tracks[i];
        if (track.mode === 'showing') {
          if (track.kind === 'descriptions') {
            descriptionsTrack = track;
          } else {
            captionsSubtitlesTrack = track;
          }
        }
      }
      if (captionsSubtitlesTrack) {
        if (this.getAttribute('aria-live') !== 'off') {
          this.setAttribute('aria-live', 'off');
        }
        this.updateForTrack(captionsSubtitlesTrack);
      } else if (descriptionsTrack) {
        if (this.getAttribute('aria-live') !== 'assertive') {
          this.setAttribute('aria-live', 'assertive');
        }
        this.updateForTrack(descriptionsTrack);
      }
      if (!window__default["default"].CSS.supports('inset', '10px')) {
        const textTrackDisplay = this.el_;
        const vjsTextTrackCues = textTrackDisplay.querySelectorAll('.vjs-text-track-cue');
        const controlBarHeight = this.player_.controlBar.el_.getBoundingClientRect().height;
        const playerHeight = this.player_.el_.getBoundingClientRect().height;

        // Clear inline style before getting actual height of textTrackDisplay
        textTrackDisplay.style = '';

        // textrack style updates, this styles are required to be inline
        tryUpdateStyle(textTrackDisplay, 'position', 'relative');
        tryUpdateStyle(textTrackDisplay, 'height', playerHeight - controlBarHeight + 'px');
        tryUpdateStyle(textTrackDisplay, 'top', 'unset');
        if (IS_SMART_TV) {
          tryUpdateStyle(textTrackDisplay, 'bottom', playerHeight + 'px');
        } else {
          tryUpdateStyle(textTrackDisplay, 'bottom', '0px');
        }

        // vjsTextTrackCue style updates
        if (vjsTextTrackCues.length > 0) {
          vjsTextTrackCues.forEach(vjsTextTrackCue => {
            // verify if inset styles are inline
            if (vjsTextTrackCue.style.inset) {
              const insetStyles = vjsTextTrackCue.style.inset.split(' ');

              // expected value is always 3
              if (insetStyles.length === 3) {
                Object.assign(vjsTextTrackCue.style, {
                  top: insetStyles[0],
                  right: insetStyles[1],
                  bottom: insetStyles[2],
                  left: 'unset'
                });
              }
            }
          });
        }
      }
    }

    /**
     * Updates the displayed TextTrack to be sure it overlays the video when a either
     * a {@link Player#texttrackchange} or a {@link Player#fullscreenchange} is fired.
     */
    updateDisplayOverlay() {
      // inset-inline and inset-block are not supprted on old chrome, but these are
      // only likely to be used on TV devices
      if (!this.player_.videoHeight() || !window__default["default"].CSS.supports('inset-inline: 10px')) {
        return;
      }
      const playerWidth = this.player_.currentWidth();
      const playerHeight = this.player_.currentHeight();
      const playerAspectRatio = playerWidth / playerHeight;
      const videoAspectRatio = this.player_.videoWidth() / this.player_.videoHeight();
      let insetInlineMatch = 0;
      let insetBlockMatch = 0;
      if (Math.abs(playerAspectRatio - videoAspectRatio) > 0.1) {
        if (playerAspectRatio > videoAspectRatio) {
          insetInlineMatch = Math.round((playerWidth - playerHeight * videoAspectRatio) / 2);
        } else {
          insetBlockMatch = Math.round((playerHeight - playerWidth / videoAspectRatio) / 2);
        }
      }
      tryUpdateStyle(this.el_, 'insetInline', getCSSPositionValue(insetInlineMatch));
      tryUpdateStyle(this.el_, 'insetBlock', getCSSPositionValue(insetBlockMatch));
    }

    /**
     * Style {@Link TextTrack} activeCues according to {@Link TextTrackSettings}.
     *
     * @param {TextTrack} track
     *        Text track object containing active cues to style.
     */
    updateDisplayState(track) {
      const overrides = this.player_.textTrackSettings.getValues();
      const cues = track.activeCues;
      let i = cues.length;
      while (i--) {
        const cue = cues[i];
        if (!cue) {
          continue;
        }
        const cueDiv = cue.displayState;
        if (overrides.color) {
          cueDiv.firstChild.style.color = overrides.color;
        }
        if (overrides.textOpacity) {
          tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
        }
        if (overrides.backgroundColor) {
          cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
        }
        if (overrides.backgroundOpacity) {
          tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
        }
        if (overrides.windowColor) {
          if (overrides.windowOpacity) {
            tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
          } else {
            cueDiv.style.backgroundColor = overrides.windowColor;
          }
        }
        if (overrides.edgeStyle) {
          if (overrides.edgeStyle === 'dropshadow') {
            cueDiv.firstChild.style.textShadow = `2px 2px 3px ${darkGray}, 2px 2px 4px ${darkGray}, 2px 2px 5px ${darkGray}`;
          } else if (overrides.edgeStyle === 'raised') {
            cueDiv.firstChild.style.textShadow = `1px 1px ${darkGray}, 2px 2px ${darkGray}, 3px 3px ${darkGray}`;
          } else if (overrides.edgeStyle === 'depressed') {
            cueDiv.firstChild.style.textShadow = `1px 1px ${lightGray}, 0 1px ${lightGray}, -1px -1px ${darkGray}, 0 -1px ${darkGray}`;
          } else if (overrides.edgeStyle === 'uniform') {
            cueDiv.firstChild.style.textShadow = `0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}`;
          }
        }
        if (overrides.fontPercent && overrides.fontPercent !== 1) {
          const fontSize = window__default["default"].parseFloat(cueDiv.style.fontSize);
          cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
          cueDiv.style.height = 'auto';
          cueDiv.style.top = 'auto';
        }
        if (overrides.fontFamily && overrides.fontFamily !== 'default') {
          if (overrides.fontFamily === 'small-caps') {
            cueDiv.firstChild.style.fontVariant = 'small-caps';
          } else {
            cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
          }
        }
      }
    }

    /**
     * Add an {@link TextTrack} to to the {@link Tech}s {@link TextTrackList}.
     *
     * @param {TextTrack|TextTrack[]} tracks
     *        Text track object or text track array to be added to the list.
     */
    updateForTrack(tracks) {
      if (!Array.isArray(tracks)) {
        tracks = [tracks];
      }
      if (typeof window__default["default"].WebVTT !== 'function' || tracks.every(track => {
        return !track.activeCues;
      })) {
        return;
      }
      const cues = [];

      // push all active track cues
      for (let i = 0; i < tracks.length; ++i) {
        const track = tracks[i];
        for (let j = 0; j < track.activeCues.length; ++j) {
          cues.push(track.activeCues[j]);
        }
      }

      // removes all cues before it processes new ones
      window__default["default"].WebVTT.processCues(window__default["default"], cues, this.el_);

      // add unique class to each language text track & add settings styling if necessary
      for (let i = 0; i < tracks.length; ++i) {
        const track = tracks[i];
        for (let j = 0; j < track.activeCues.length; ++j) {
          const cueEl = track.activeCues[j].displayState;
          addClass(cueEl, 'vjs-text-track-cue', 'vjs-text-track-cue-' + (track.language ? track.language : i));
          if (track.language) {
            setAttribute(cueEl, 'lang', track.language);
          }
        }
        if (this.player_.textTrackSettings) {
          this.updateDisplayState(track);
        }
      }
    }
  }
  Component.registerComponent('TextTrackDisplay', TextTrackDisplay);

  /**
   * @file loading-spinner.js
   */

  /**
   * A loading spinner for use during waiting/loading events.
   *
   * @extends Component
   */
  class LoadingSpinner extends Component {
    /**
     * Create the `LoadingSpinner`s DOM element.
     *
     * @return {Element}
     *         The dom element that gets created.
     */
    createEl() {
      const isAudio = this.player_.isAudio();
      const playerType = this.localize(isAudio ? 'Audio Player' : 'Video Player');
      const controlText = createEl('span', {
        className: 'vjs-control-text',
        textContent: this.localize('{1} is loading.', [playerType])
      });
      const el = super.createEl('div', {
        className: 'vjs-loading-spinner',
        dir: 'ltr'
      });
      el.appendChild(controlText);
      return el;
    }

    /**
     * Update control text on languagechange
     */
    handleLanguagechange() {
      this.$('.vjs-control-text').textContent = this.localize('{1} is loading.', [this.player_.isAudio() ? 'Audio Player' : 'Video Player']);
    }
  }
  Component.registerComponent('LoadingSpinner', LoadingSpinner);

  /**
   * @file button.js
   */

  /**
   * Base class for all buttons.
   *
   * @extends ClickableComponent
   */
  class Button extends ClickableComponent {
    /**
     * Create the `Button`s DOM element.
     *
     * @param {string} [tag="button"]
     *        The element's node type. This argument is IGNORED: no matter what
     *        is passed, it will always create a `button` element.
     *
     * @param {Object} [props={}]
     *        An object of properties that should be set on the element.
     *
     * @param {Object} [attributes={}]
     *        An object of attributes that should be set on the element.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl(tag, props = {}, attributes = {}) {
      tag = 'button';
      props = Object.assign({
        className: this.buildCSSClass()
      }, props);

      // Add attributes for button element
      attributes = Object.assign({
        // Necessary since the default button type is "submit"
        type: 'button'
      }, attributes);
      const el = createEl(tag, props, attributes);
      if (!this.player_.options_.experimentalSvgIcons) {
        el.appendChild(createEl('span', {
          className: 'vjs-icon-placeholder'
        }, {
          'aria-hidden': true
        }));
      }
      this.createControlTextEl(el);
      return el;
    }

    /**
     * Add a child `Component` inside of this `Button`.
     *
     * @param {string|Component} child
     *        The name or instance of a child to add.
     *
     * @param {Object} [options={}]
     *        The key/value store of options that will get passed to children of
     *        the child.
     *
     * @return {Component}
     *         The `Component` that gets added as a child. When using a string the
     *         `Component` will get created by this process.
     *
     * @deprecated since version 5
     */
    addChild(child, options = {}) {
      const className = this.constructor.name;
      log.warn(`Adding an actionable (user controllable) child to a Button (${className}) is not supported; use a ClickableComponent instead.`);

      // Avoid the error message generated by ClickableComponent's addChild method
      return Component.prototype.addChild.call(this, child, options);
    }

    /**
     * Enable the `Button` element so that it can be activated or clicked. Use this with
     * {@link Button#disable}.
     */
    enable() {
      super.enable();
      this.el_.removeAttribute('disabled');
    }

    /**
     * Disable the `Button` element so that it cannot be activated or clicked. Use this with
     * {@link Button#enable}.
     */
    disable() {
      super.disable();
      this.el_.setAttribute('disabled', 'disabled');
    }

    /**
     * This gets called when a `Button` has focus and `keydown` is triggered via a key
     * press.
     *
     * @param {KeyboardEvent} event
     *        The event that caused this function to get called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      // Ignore Space or Enter key operation, which is handled by the browser for
      // a button - though not for its super class, ClickableComponent. Also,
      // prevent the event from propagating through the DOM and triggering Player
      // hotkeys. We do not preventDefault here because we _want_ the browser to
      // handle it.
      if (event.key === ' ' || event.key === 'Enter') {
        event.stopPropagation();
        return;
      }

      // Pass keypress handling up for unsupported keys
      super.handleKeyDown(event);
    }
  }
  Component.registerComponent('Button', Button);

  /**
   * @file big-play-button.js
   */

  /**
   * The initial play button that shows before the video has played. The hiding of the
   * `BigPlayButton` get done via CSS and `Player` states.
   *
   * @extends Button
   */
  class BigPlayButton extends Button {
    constructor(player, options) {
      super(player, options);
      this.mouseused_ = false;
      this.setIcon('play');
      this.on('mousedown', e => this.handleMouseDown(e));
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.
     */
    buildCSSClass() {
      return 'vjs-big-play-button';
    }

    /**
     * This gets called when a `BigPlayButton` "clicked". See {@link ClickableComponent}
     * for more detailed information on what a click can be.
     *
     * @param {KeyboardEvent|MouseEvent|TouchEvent} event
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      const playPromise = this.player_.play();

      // exit early if clicked via the mouse
      if (this.mouseused_ && 'clientX' in event && 'clientY' in event) {
        silencePromise(playPromise);
        if (this.player_.tech(true)) {
          this.player_.tech(true).focus();
        }
        return;
      }
      const cb = this.player_.getChild('controlBar');
      const playToggle = cb && cb.getChild('playToggle');
      if (!playToggle) {
        this.player_.tech(true).focus();
        return;
      }
      const playFocus = () => playToggle.focus();
      if (isPromise(playPromise)) {
        playPromise.then(playFocus, () => {});
      } else {
        this.setTimeout(playFocus, 1);
      }
    }

    /**
     * Event handler that is called when a `BigPlayButton` receives a
     * `keydown` event.
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      this.mouseused_ = false;
      super.handleKeyDown(event);
    }

    /**
     * Handle `mousedown` events on the `BigPlayButton`.
     *
     * @param {MouseEvent} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousedown
     */
    handleMouseDown(event) {
      this.mouseused_ = true;
    }
  }

  /**
   * The text that should display over the `BigPlayButton`s controls. Added to for localization.
   *
   * @type {string}
   * @protected
   */
  BigPlayButton.prototype.controlText_ = 'Play Video';
  Component.registerComponent('BigPlayButton', BigPlayButton);

  /**
   * @file close-button.js
   */

  /** @import Player from './player' */

  /**
   * The `CloseButton` is a `{@link Button}` that fires a `close` event when
   * it gets clicked.
   *
   * @extends Button
   */
  class CloseButton extends Button {
    /**
    * Creates an instance of the this class.
    *
    * @param  {Player} player
    *         The `Player` that this class should be attached to.
    *
    * @param  {Object} [options]
    *         The key/value store of player options.
    */
    constructor(player, options) {
      super(player, options);
      this.setIcon('cancel');
      this.controlText(options && options.controlText || this.localize('Close'));
    }

    /**
    * Builds the default DOM `className`.
    *
    * @return {string}
    *         The DOM `className` for this object.
    */
    buildCSSClass() {
      return `vjs-close-button ${super.buildCSSClass()}`;
    }

    /**
     * This gets called when a `CloseButton` gets clicked. See
     * {@link ClickableComponent#handleClick} for more information on when
     * this will be triggered
     *
     * @param {Event} event
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     * @fires CloseButton#close
     */
    handleClick(event) {
      /**
       * Triggered when the a `CloseButton` is clicked.
       *
       * @event CloseButton#close
       * @type {Event}
       *
       * @property {boolean} [bubbles=false]
       *           set to false so that the close event does not
       *           bubble up to parents if there is no listener
       */
      this.trigger({
        type: 'close',
        bubbles: false
      });
    }
    /**
     * Event handler that is called when a `CloseButton` receives a
     * `keydown` event.
     *
     * By default, if the key is Esc, it will trigger a `click` event.
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      // Esc button will trigger `click` event
      if (event.key === 'Escape') {
        event.preventDefault();
        event.stopPropagation();
        this.trigger('click');
      } else {
        // Pass keypress handling up for unsupported keys
        super.handleKeyDown(event);
      }
    }
  }
  Component.registerComponent('CloseButton', CloseButton);

  /**
   * @file play-toggle.js
   */

  /** @import Player from './player' */

  /**
   * Button to toggle between play and pause.
   *
   * @extends Button
   */
  class PlayToggle extends Button {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      super(player, options);

      // show or hide replay icon
      options.replay = options.replay === undefined || options.replay;
      this.setIcon('play');
      this.on(player, 'play', e => this.handlePlay(e));
      this.on(player, 'pause', e => this.handlePause(e));
      if (options.replay) {
        this.on(player, 'ended', e => this.handleEnded(e));
      }
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-play-control ${super.buildCSSClass()}`;
    }

    /**
     * This gets called when an `PlayToggle` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      if (this.player_.paused()) {
        silencePromise(this.player_.play());
      } else {
        this.player_.pause();
      }
    }

    /**
     * This gets called once after the video has ended and the user seeks so that
     * we can change the replay button back to a play button.
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#seeked
     */
    handleSeeked(event) {
      this.removeClass('vjs-ended');
      if (this.player_.paused()) {
        this.handlePause(event);
      } else {
        this.handlePlay(event);
      }
    }

    /**
     * Add the vjs-playing class to the element so it can change appearance.
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#play
     */
    handlePlay(event) {
      this.removeClass('vjs-ended', 'vjs-paused');
      this.addClass('vjs-playing');
      // change the button text to "Pause"
      this.setIcon('pause');
      this.controlText('Pause');
    }

    /**
     * Add the vjs-paused class to the element so it can change appearance.
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#pause
     */
    handlePause(event) {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
      // change the button text to "Play"
      this.setIcon('play');
      this.controlText('Play');
    }

    /**
     * Add the vjs-ended class to the element so it can change appearance
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#ended
     */
    handleEnded(event) {
      this.removeClass('vjs-playing');
      this.addClass('vjs-ended');
      // change the button text to "Replay"
      this.setIcon('replay');
      this.controlText('Replay');

      // on the next seek remove the replay button
      this.one(this.player_, 'seeked', e => this.handleSeeked(e));
    }
  }

  /**
   * The text that should display over the `PlayToggle`s controls. Added for localization.
   *
   * @type {string}
   * @protected
   */
  PlayToggle.prototype.controlText_ = 'Play';
  Component.registerComponent('PlayToggle', PlayToggle);

  /**
   * @file time-display.js
   */

  /** @import Player from '../../player' */

  /**
   * Displays time information about the video
   *
   * @extends Component
   */
  class TimeDisplay extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.on(player, ['timeupdate', 'ended', 'seeking'], e => this.update(e));
      this.updateTextNode_();
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const className = this.buildCSSClass();
      const el = super.createEl('div', {
        className: `${className} vjs-time-control vjs-control`
      });
      const span = createEl('span', {
        className: 'vjs-control-text',
        textContent: `${this.localize(this.labelText_)}\u00a0`
      }, {
        role: 'presentation'
      });
      el.appendChild(span);
      this.contentEl_ = createEl('span', {
        className: `${className}-display`
      }, {
        // span elements have no implicit role, but some screen readers (notably VoiceOver)
        // treat them as a break between items in the DOM when using arrow keys
        // (or left-to-right swipes on iOS) to read contents of a page. Using
        // role='presentation' causes VoiceOver to NOT treat this span as a break.
        role: 'presentation'
      });
      el.appendChild(this.contentEl_);
      return el;
    }
    dispose() {
      this.contentEl_ = null;
      this.textNode_ = null;
      super.dispose();
    }

    /**
     * Updates the displayed time according to the `updateContent` function which is defined in the child class.
     *
     * @param {Event} [event]
     *          The `timeupdate`, `ended` or `seeking` (if enableSmoothSeeking is true) event that caused this function to be called.
     */
    update(event) {
      if (!this.player_.options_.enableSmoothSeeking && event.type === 'seeking') {
        return;
      }
      this.updateContent(event);
    }

    /**
     * Updates the time display text node with a new time
     *
     * @param {number} [time=0] the time to update to
     *
     * @private
     */
    updateTextNode_(time = 0) {
      time = formatTime(time);
      if (this.formattedTime_ === time) {
        return;
      }
      this.formattedTime_ = time;
      this.requestNamedAnimationFrame('TimeDisplay#updateTextNode_', () => {
        if (!this.contentEl_) {
          return;
        }
        let oldNode = this.textNode_;
        if (oldNode && this.contentEl_.firstChild !== oldNode) {
          oldNode = null;
          log.warn('TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.');
        }
        this.textNode_ = document__default["default"].createTextNode(this.formattedTime_);
        if (!this.textNode_) {
          return;
        }
        if (oldNode) {
          this.contentEl_.replaceChild(this.textNode_, oldNode);
        } else {
          this.contentEl_.appendChild(this.textNode_);
        }
      });
    }

    /**
     * To be filled out in the child class, should update the displayed time
     * in accordance with the fact that the current time has changed.
     *
     * @param {Event} [event]
     *        The `timeupdate`  event that caused this to run.
     *
     * @listens Player#timeupdate
     */
    updateContent(event) {}
  }

  /**
   * The text that is added to the `TimeDisplay` for screen reader users.
   *
   * @type {string}
   * @private
   */
  TimeDisplay.prototype.labelText_ = 'Time';

  /**
   * The text that should display over the `TimeDisplay`s controls. Added to for localization.
   *
   * @type {string}
   * @protected
   *
   * @deprecated in v7; controlText_ is not used in non-active display Components
   */
  TimeDisplay.prototype.controlText_ = 'Time';
  Component.registerComponent('TimeDisplay', TimeDisplay);

  /**
   * @file current-time-display.js
   */

  /**
   * Displays the current time
   *
   * @extends Component
   */
  class CurrentTimeDisplay extends TimeDisplay {
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return 'vjs-current-time';
    }

    /**
     * Update current time display
     *
     * @param {Event} [event]
     *        The `timeupdate` event that caused this function to run.
     *
     * @listens Player#timeupdate
     */
    updateContent(event) {
      // Allows for smooth scrubbing, when player can't keep up.
      let time;
      if (this.player_.ended()) {
        time = this.player_.duration();
      } else {
        time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      }
      this.updateTextNode_(time);
    }
  }

  /**
   * The text that is added to the `CurrentTimeDisplay` for screen reader users.
   *
   * @type {string}
   * @private
   */
  CurrentTimeDisplay.prototype.labelText_ = 'Current Time';

  /**
   * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.
   *
   * @type {string}
   * @protected
   *
   * @deprecated in v7; controlText_ is not used in non-active display Components
   */
  CurrentTimeDisplay.prototype.controlText_ = 'Current Time';
  Component.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);

  /**
   * @file duration-display.js
   */

  /** @import Player from '../../player' */

  /**
   * Displays the duration
   *
   * @extends Component
   */
  class DurationDisplay extends TimeDisplay {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      const updateContent = e => this.updateContent(e);

      // we do not want to/need to throttle duration changes,
      // as they should always display the changed duration as
      // it has changed
      this.on(player, 'durationchange', updateContent);

      // Listen to loadstart because the player duration is reset when a new media element is loaded,
      // but the durationchange on the user agent will not fire.
      // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}
      this.on(player, 'loadstart', updateContent);

      // Also listen for timeupdate (in the parent) and loadedmetadata because removing those
      // listeners could have broken dependent applications/libraries. These
      // can likely be removed for 7.0.
      this.on(player, 'loadedmetadata', updateContent);
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return 'vjs-duration';
    }

    /**
     * Update duration time display.
     *
     * @param {Event} [event]
     *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused
     *        this function to be called.
     *
     * @listens Player#durationchange
     * @listens Player#timeupdate
     * @listens Player#loadedmetadata
     */
    updateContent(event) {
      const duration = this.player_.duration();
      this.updateTextNode_(duration);
    }
  }

  /**
   * The text that is added to the `DurationDisplay` for screen reader users.
   *
   * @type {string}
   * @private
   */
  DurationDisplay.prototype.labelText_ = 'Duration';

  /**
   * The text that should display over the `DurationDisplay`s controls. Added to for localization.
   *
   * @type {string}
   * @protected
   *
   * @deprecated in v7; controlText_ is not used in non-active display Components
   */
  DurationDisplay.prototype.controlText_ = 'Duration';
  Component.registerComponent('DurationDisplay', DurationDisplay);

  /**
   * @file time-divider.js
   */

  /**
   * The separator between the current time and duration.
   * Can be hidden if it's not needed in the design.
   *
   * @extends Component
   */
  class TimeDivider extends Component {
    /**
     * Create the component's DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl('div', {
        className: 'vjs-time-control vjs-time-divider'
      }, {
        // this element and its contents can be hidden from assistive techs since
        // it is made extraneous by the announcement of the control text
        // for the current time and duration displays
        'aria-hidden': true
      });
      const div = super.createEl('div');
      const span = super.createEl('span', {
        textContent: '/'
      });
      div.appendChild(span);
      el.appendChild(div);
      return el;
    }
  }
  Component.registerComponent('TimeDivider', TimeDivider);

  /**
   * @file remaining-time-display.js
   */

  /** @import Player from '../../player' */

  /**
   * Displays the time left in the video
   *
   * @extends Component
   */
  class RemainingTimeDisplay extends TimeDisplay {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.on(player, 'durationchange', e => this.updateContent(e));
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return 'vjs-remaining-time';
    }

    /**
     * Create the `Component`'s DOM element with the "minus" character prepend to the time
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl();
      if (this.options_.displayNegative !== false) {
        el.insertBefore(createEl('span', {}, {
          'aria-hidden': true
        }, '-'), this.contentEl_);
      }
      return el;
    }

    /**
     * Update remaining time display.
     *
     * @param {Event} [event]
     *        The `timeupdate` or `durationchange` event that caused this to run.
     *
     * @listens Player#timeupdate
     * @listens Player#durationchange
     */
    updateContent(event) {
      if (typeof this.player_.duration() !== 'number') {
        return;
      }
      let time;

      // @deprecated We should only use remainingTimeDisplay
      // as of video.js 7
      if (this.player_.ended()) {
        time = 0;
      } else if (this.player_.remainingTimeDisplay) {
        time = this.player_.remainingTimeDisplay();
      } else {
        time = this.player_.remainingTime();
      }
      this.updateTextNode_(time);
    }
  }

  /**
   * The text that is added to the `RemainingTimeDisplay` for screen reader users.
   *
   * @type {string}
   * @private
   */
  RemainingTimeDisplay.prototype.labelText_ = 'Remaining Time';

  /**
   * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.
   *
   * @type {string}
   * @protected
   *
   * @deprecated in v7; controlText_ is not used in non-active display Components
   */
  RemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';
  Component.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);

  /**
   * @file live-display.js
   */

  /** @import Player from './player' */

  // TODO - Future make it click to snap to live

  /**
   * Displays the live indicator when duration is Infinity.
   *
   * @extends Component
   */
  class LiveDisplay extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.updateShowing();
      this.on(this.player(), 'durationchange', e => this.updateShowing(e));
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl('div', {
        className: 'vjs-live-control vjs-control'
      });
      this.contentEl_ = createEl('div', {
        className: 'vjs-live-display'
      }, {
        'aria-live': 'off'
      });
      this.contentEl_.appendChild(createEl('span', {
        className: 'vjs-control-text',
        textContent: `${this.localize('Stream Type')}\u00a0`
      }));
      this.contentEl_.appendChild(document__default["default"].createTextNode(this.localize('LIVE')));
      el.appendChild(this.contentEl_);
      return el;
    }
    dispose() {
      this.contentEl_ = null;
      super.dispose();
    }

    /**
     * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide
     * it accordingly
     *
     * @param {Event} [event]
     *        The {@link Player#durationchange} event that caused this function to run.
     *
     * @listens Player#durationchange
     */
    updateShowing(event) {
      if (this.player().duration() === Infinity) {
        this.show();
      } else {
        this.hide();
      }
    }
  }
  Component.registerComponent('LiveDisplay', LiveDisplay);

  /**
   * @file seek-to-live.js
   */

  /** @import Player from './player' */

  /**
   * Displays the live indicator when duration is Infinity.
   *
   * @extends Component
   */
  class SeekToLive extends Button {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.updateLiveEdgeStatus();
      if (this.player_.liveTracker) {
        this.updateLiveEdgeStatusHandler_ = e => this.updateLiveEdgeStatus(e);
        this.on(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatusHandler_);
      }
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl('button', {
        className: 'vjs-seek-to-live-control vjs-control'
      });
      this.setIcon('circle', el);
      this.textEl_ = createEl('span', {
        className: 'vjs-seek-to-live-text',
        textContent: this.localize('LIVE')
      }, {
        'aria-hidden': 'true'
      });
      el.appendChild(this.textEl_);
      return el;
    }

    /**
     * Update the state of this button if we are at the live edge
     * or not
     */
    updateLiveEdgeStatus() {
      // default to live edge
      if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {
        this.setAttribute('aria-disabled', true);
        this.addClass('vjs-at-live-edge');
        this.controlText('Seek to live, currently playing live');
      } else {
        this.setAttribute('aria-disabled', false);
        this.removeClass('vjs-at-live-edge');
        this.controlText('Seek to live, currently behind live');
      }
    }

    /**
     * On click bring us as near to the live point as possible.
     * This requires that we wait for the next `live-seekable-change`
     * event which will happen every segment length seconds.
     */
    handleClick() {
      this.player_.liveTracker.seekToLiveEdge();
    }

    /**
     * Dispose of the element and stop tracking
     */
    dispose() {
      if (this.player_.liveTracker) {
        this.off(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatusHandler_);
      }
      this.textEl_ = null;
      super.dispose();
    }
  }
  /**
   * The text that should display over the `SeekToLive`s control. Added for localization.
   *
   * @type {string}
   * @protected
   */
  SeekToLive.prototype.controlText_ = 'Seek to live, currently playing live';
  Component.registerComponent('SeekToLive', SeekToLive);

  /**
   * @file num.js
   * @module num
   */

  /**
   * Keep a number between a min and a max value
   *
   * @param {number} number
   *        The number to clamp
   *
   * @param {number} min
   *        The minimum value
   * @param {number} max
   *        The maximum value
   *
   * @return {number}
   *         the clamped number
   */
  function clamp(number, min, max) {
    number = Number(number);
    return Math.min(max, Math.max(min, isNaN(number) ? min : number));
  }

  var Num = /*#__PURE__*/Object.freeze({
    __proto__: null,
    clamp: clamp
  });

  /**
   * @file slider.js
   */

  /** @import Player from '../player' */

  /**
   * The base functionality for a slider. Can be vertical or horizontal.
   * For instance the volume bar or the seek bar on a video is a slider.
   *
   * @extends Component
   */
  class Slider extends Component {
    /**
    * Create an instance of this class
    *
    * @param {Player} player
    *        The `Player` that this class should be attached to.
    *
    * @param {Object} [options]
    *        The key/value store of player options.
    */
    constructor(player, options) {
      super(player, options);
      this.handleMouseDown_ = e => this.handleMouseDown(e);
      this.handleMouseUp_ = e => this.handleMouseUp(e);
      this.handleKeyDown_ = e => this.handleKeyDown(e);
      this.handleClick_ = e => this.handleClick(e);
      this.handleMouseMove_ = e => this.handleMouseMove(e);
      this.update_ = e => this.update(e);

      // Set property names to bar to match with the child Slider class is looking for
      this.bar = this.getChild(this.options_.barName);

      // Set a horizontal or vertical class on the slider depending on the slider type
      this.vertical(!!this.options_.vertical);
      this.enable();
    }

    /**
     * Are controls are currently enabled for this slider or not.
     *
     * @return {boolean}
     *         true if controls are enabled, false otherwise
     */
    enabled() {
      return this.enabled_;
    }

    /**
     * Enable controls for this slider if they are disabled
     */
    enable() {
      if (this.enabled()) {
        return;
      }
      this.on('mousedown', this.handleMouseDown_);
      this.on('touchstart', this.handleMouseDown_);
      this.on('keydown', this.handleKeyDown_);
      this.on('click', this.handleClick_);

      // TODO: deprecated, controlsvisible does not seem to be fired
      this.on(this.player_, 'controlsvisible', this.update);
      if (this.playerEvent) {
        this.on(this.player_, this.playerEvent, this.update);
      }
      this.removeClass('disabled');
      this.setAttribute('tabindex', 0);
      this.enabled_ = true;
    }

    /**
     * Disable controls for this slider if they are enabled
     */
    disable() {
      if (!this.enabled()) {
        return;
      }
      const doc = this.bar.el_.ownerDocument;
      this.off('mousedown', this.handleMouseDown_);
      this.off('touchstart', this.handleMouseDown_);
      this.off('keydown', this.handleKeyDown_);
      this.off('click', this.handleClick_);
      this.off(this.player_, 'controlsvisible', this.update_);
      this.off(doc, 'mousemove', this.handleMouseMove_);
      this.off(doc, 'mouseup', this.handleMouseUp_);
      this.off(doc, 'touchmove', this.handleMouseMove_);
      this.off(doc, 'touchend', this.handleMouseUp_);
      this.removeAttribute('tabindex');
      this.addClass('disabled');
      if (this.playerEvent) {
        this.off(this.player_, this.playerEvent, this.update);
      }
      this.enabled_ = false;
    }

    /**
     * Create the `Slider`s DOM element.
     *
     * @param {string} type
     *        Type of element to create.
     *
     * @param {Object} [props={}]
     *        List of properties in Object form.
     *
     * @param {Object} [attributes={}]
     *        list of attributes in Object form.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl(type, props = {}, attributes = {}) {
      // Add the slider element class to all sub classes
      props.className = props.className + ' vjs-slider';
      props = Object.assign({
        tabIndex: 0
      }, props);
      attributes = Object.assign({
        'role': 'slider',
        'aria-valuenow': 0,
        'aria-valuemin': 0,
        'aria-valuemax': 100
      }, attributes);
      return super.createEl(type, props, attributes);
    }

    /**
     * Handle `mousedown` or `touchstart` events on the `Slider`.
     *
     * @param {MouseEvent} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousedown
     * @listens touchstart
     * @fires Slider#slideractive
     */
    handleMouseDown(event) {
      const doc = this.bar.el_.ownerDocument;
      if (event.type === 'mousedown') {
        event.preventDefault();
      }
      // Do not call preventDefault() on touchstart in Chrome
      // to avoid console warnings. Use a 'touch-action: none' style
      // instead to prevent unintended scrolling.
      // https://developers.google.com/web/updates/2017/01/scrolling-intervention
      if (event.type === 'touchstart' && !IS_CHROME) {
        event.preventDefault();
      }
      blockTextSelection();
      this.addClass('vjs-sliding');
      /**
       * Triggered when the slider is in an active state
       *
       * @event Slider#slideractive
       * @type {MouseEvent}
       */
      this.trigger('slideractive');
      this.on(doc, 'mousemove', this.handleMouseMove_);
      this.on(doc, 'mouseup', this.handleMouseUp_);
      this.on(doc, 'touchmove', this.handleMouseMove_);
      this.on(doc, 'touchend', this.handleMouseUp_);
      this.handleMouseMove(event, true);
    }

    /**
     * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.
     * The `mousemove` and `touchmove` events will only only trigger this function during
     * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and
     * {@link Slider#handleMouseUp}.
     *
     * @param {MouseEvent} event
     *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered
     *        this function
     * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false.
     *
     * @listens mousemove
     * @listens touchmove
     */
    handleMouseMove(event) {}

    /**
     * Handle `mouseup` or `touchend` events on the `Slider`.
     *
     * @param {MouseEvent} event
     *        `mouseup` or `touchend` event that triggered this function.
     *
     * @listens touchend
     * @listens mouseup
     * @fires Slider#sliderinactive
     */
    handleMouseUp(event) {
      const doc = this.bar.el_.ownerDocument;
      unblockTextSelection();
      this.removeClass('vjs-sliding');
      /**
       * Triggered when the slider is no longer in an active state.
       *
       * @event Slider#sliderinactive
       * @type {Event}
       */
      this.trigger('sliderinactive');
      this.off(doc, 'mousemove', this.handleMouseMove_);
      this.off(doc, 'mouseup', this.handleMouseUp_);
      this.off(doc, 'touchmove', this.handleMouseMove_);
      this.off(doc, 'touchend', this.handleMouseUp_);
      this.update();
    }

    /**
     * Update the progress bar of the `Slider`.
     *
     * @return {number}
     *          The percentage of progress the progress bar represents as a
     *          number from 0 to 1.
     */
    update() {
      // In VolumeBar init we have a setTimeout for update that pops and update
      // to the end of the execution stack. The player is destroyed before then
      // update will cause an error
      // If there's no bar...
      if (!this.el_ || !this.bar) {
        return;
      }

      // clamp progress between 0 and 1
      // and only round to four decimal places, as we round to two below
      const progress = this.getProgress();
      if (progress === this.progress_) {
        return progress;
      }
      this.progress_ = progress;
      this.requestNamedAnimationFrame('Slider#update', () => {
        // Set the new bar width or height
        const sizeKey = this.vertical() ? 'height' : 'width';

        // Convert to a percentage for css value
        this.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + '%';
      });
      return progress;
    }

    /**
     * Get the percentage of the bar that should be filled
     * but clamped and rounded.
     *
     * @return {number}
     *         percentage filled that the slider is
     */
    getProgress() {
      return Number(clamp(this.getPercent(), 0, 1).toFixed(4));
    }

    /**
     * Calculate distance for slider
     *
     * @param {Event} event
     *        The event that caused this function to run.
     *
     * @return {number}
     *         The current position of the Slider.
     *         - position.x for vertical `Slider`s
     *         - position.y for horizontal `Slider`s
     */
    calculateDistance(event) {
      const position = getPointerPosition(this.el_, event);
      if (this.vertical()) {
        return position.y;
      }
      return position.x;
    }

    /**
     * Handle a `keydown` event on the `Slider`. Watches for left, right, up, and down
     * arrow keys. This function will only be called when the slider has focus. See
     * {@link Slider#handleFocus} and {@link Slider#handleBlur}.
     *
     * @param {KeyboardEvent} event
     *        the `keydown` event that caused this function to run.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      const spatialNavOptions = this.options_.playerOptions.spatialNavigation;
      const spatialNavEnabled = spatialNavOptions && spatialNavOptions.enabled;
      const horizontalSeek = spatialNavOptions && spatialNavOptions.horizontalSeek;
      if (spatialNavEnabled) {
        if (horizontalSeek && event.key === 'ArrowLeft' || !horizontalSeek && event.key === 'ArrowDown') {
          event.preventDefault();
          event.stopPropagation();
          this.stepBack();
        } else if (horizontalSeek && event.key === 'ArrowRight' || !horizontalSeek && event.key === 'ArrowUp') {
          event.preventDefault();
          event.stopPropagation();
          this.stepForward();
        } else {
          super.handleKeyDown(event);
        }

        // Left and Down Arrows
      } else if (event.key === 'ArrowLeft' || event.key === 'ArrowDown') {
        event.preventDefault();
        event.stopPropagation();
        this.stepBack();

        // Up and Right Arrows
      } else if (event.key === 'ArrowUp' || event.key === 'ArrowRight') {
        event.preventDefault();
        event.stopPropagation();
        this.stepForward();
      } else {
        // Pass keydown handling up for unsupported keys
        super.handleKeyDown(event);
      }
    }

    /**
     * Listener for click events on slider, used to prevent clicks
     *   from bubbling up to parent elements like button menus.
     *
     * @param {Object} event
     *        Event that caused this object to run
     */
    handleClick(event) {
      event.stopPropagation();
      event.preventDefault();
    }

    /**
     * Get/set if slider is horizontal for vertical
     *
     * @param {boolean} [bool]
     *        - true if slider is vertical,
     *        - false is horizontal
     *
     * @return {boolean}
     *         - true if slider is vertical, and getting
     *         - false if the slider is horizontal, and getting
     */
    vertical(bool) {
      if (bool === undefined) {
        return this.vertical_ || false;
      }
      this.vertical_ = !!bool;
      if (this.vertical_) {
        this.addClass('vjs-slider-vertical');
      } else {
        this.addClass('vjs-slider-horizontal');
      }
    }
  }
  Component.registerComponent('Slider', Slider);

  /**
   * @file load-progress-bar.js
   */

  /** @import Player from '../../player' */

  // get the percent width of a time compared to the total end
  const percentify = (time, end) => clamp(time / end * 100, 0, 100).toFixed(2) + '%';

  /**
   * Shows loading progress
   *
   * @extends Component
   */
  class LoadProgressBar extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.partEls_ = [];
      this.on(player, 'progress', e => this.update(e));
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl('div', {
        className: 'vjs-load-progress'
      });
      const wrapper = createEl('span', {
        className: 'vjs-control-text'
      });
      const loadedText = createEl('span', {
        textContent: this.localize('Loaded')
      });
      const separator = document__default["default"].createTextNode(': ');
      this.percentageEl_ = createEl('span', {
        className: 'vjs-control-text-loaded-percentage',
        textContent: '0%'
      });
      el.appendChild(wrapper);
      wrapper.appendChild(loadedText);
      wrapper.appendChild(separator);
      wrapper.appendChild(this.percentageEl_);
      return el;
    }
    dispose() {
      this.partEls_ = null;
      this.percentageEl_ = null;
      super.dispose();
    }

    /**
     * Update progress bar
     *
     * @param {Event} [event]
     *        The `progress` event that caused this function to run.
     *
     * @listens Player#progress
     */
    update(event) {
      this.requestNamedAnimationFrame('LoadProgressBar#update', () => {
        const liveTracker = this.player_.liveTracker;
        const buffered = this.player_.buffered();
        const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();
        const bufferedEnd = this.player_.bufferedEnd();
        const children = this.partEls_;
        const percent = percentify(bufferedEnd, duration);
        if (this.percent_ !== percent) {
          // update the width of the progress bar
          this.el_.style.width = percent;
          // update the control-text
          textContent(this.percentageEl_, percent);
          this.percent_ = percent;
        }

        // add child elements to represent the individual buffered time ranges
        for (let i = 0; i < buffered.length; i++) {
          const start = buffered.start(i);
          const end = buffered.end(i);
          let part = children[i];
          if (!part) {
            part = this.el_.appendChild(createEl());
            children[i] = part;
          }

          //  only update if changed
          if (part.dataset.start === start && part.dataset.end === end) {
            continue;
          }
          part.dataset.start = start;
          part.dataset.end = end;

          // set the percent based on the width of the progress bar (bufferedEnd)
          part.style.left = percentify(start, bufferedEnd);
          part.style.width = percentify(end - start, bufferedEnd);
        }

        // remove unused buffered range elements
        for (let i = children.length; i > buffered.length; i--) {
          this.el_.removeChild(children[i - 1]);
        }
        children.length = buffered.length;
      });
    }
  }
  Component.registerComponent('LoadProgressBar', LoadProgressBar);

  /**
   * @file time-tooltip.js
   */

  /** @import Player from '../../player' */

  /**
   * Time tooltips display a time above the progress bar.
   *
   * @extends Component
   */
  class TimeTooltip extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The {@link Player} that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
    }

    /**
     * Create the time tooltip DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl('div', {
        className: 'vjs-time-tooltip'
      }, {
        'aria-hidden': 'true'
      });
    }

    /**
     * Updates the position of the time tooltip relative to the `SeekBar`.
     *
     * @param {Object} seekBarRect
     *        The `ClientRect` for the {@link SeekBar} element.
     *
     * @param {number} seekBarPoint
     *        A number from 0 to 1, representing a horizontal reference point
     *        from the left edge of the {@link SeekBar}
     */
    update(seekBarRect, seekBarPoint, content) {
      const tooltipRect = findPosition(this.el_);
      const playerRect = getBoundingClientRect(this.player_.el());
      const seekBarPointPx = seekBarRect.width * seekBarPoint;

      // do nothing if either rect isn't available
      // for example, if the player isn't in the DOM for testing
      if (!playerRect || !tooltipRect) {
        return;
      }

      // This is the space left of the `seekBarPoint` available within the bounds
      // of the player. We calculate any gap between the left edge of the player
      // and the left edge of the `SeekBar` and add the number of pixels in the
      // `SeekBar` before hitting the `seekBarPoint`
      let spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;

      // This is the space right of the `seekBarPoint` available within the bounds
      // of the player. We calculate the number of pixels from the `seekBarPoint`
      // to the right edge of the `SeekBar` and add to that any gap between the
      // right edge of the `SeekBar` and the player.
      let spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);

      // spaceRightOfPoint is always NaN for mouse time display
      // because the seekbarRect does not have a right property. This causes
      // the mouse tool tip to be truncated when it's close to the right edge of the player.
      // In such cases, we ignore the `playerRect.right - seekBarRect.right` value when calculating.
      // For the sake of consistency, we ignore seekBarRect.left - playerRect.left for the left edge.
      if (!spaceRightOfPoint) {
        spaceRightOfPoint = seekBarRect.width - seekBarPointPx;
        spaceLeftOfPoint = seekBarPointPx;
      }
      // This is the number of pixels by which the tooltip will need to be pulled
      // further to the right to center it over the `seekBarPoint`.
      let pullTooltipBy = tooltipRect.width / 2;

      // Adjust the `pullTooltipBy` distance to the left or right depending on
      // the results of the space calculations above.
      if (spaceLeftOfPoint < pullTooltipBy) {
        pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
      } else if (spaceRightOfPoint < pullTooltipBy) {
        pullTooltipBy = spaceRightOfPoint;
      }

      // Due to the imprecision of decimal/ratio based calculations and varying
      // rounding behaviors, there are cases where the spacing adjustment is off
      // by a pixel or two. This adds insurance to these calculations.
      if (pullTooltipBy < 0) {
        pullTooltipBy = 0;
      } else if (pullTooltipBy > tooltipRect.width) {
        pullTooltipBy = tooltipRect.width;
      }

      // prevent small width fluctuations within 0.4px from
      // changing the value below.
      // This really helps for live to prevent the play
      // progress time tooltip from jittering
      pullTooltipBy = Math.round(pullTooltipBy);
      this.el_.style.right = `-${pullTooltipBy}px`;
      this.write(content);
    }

    /**
     * Write the time to the tooltip DOM element.
     *
     * @param {string} content
     *        The formatted time for the tooltip.
     */
    write(content) {
      textContent(this.el_, content);
    }

    /**
     * Updates the position of the time tooltip relative to the `SeekBar`.
     *
     * @param {Object} seekBarRect
     *        The `ClientRect` for the {@link SeekBar} element.
     *
     * @param {number} seekBarPoint
     *        A number from 0 to 1, representing a horizontal reference point
     *        from the left edge of the {@link SeekBar}
     *
     * @param {number} time
     *        The time to update the tooltip to, not used during live playback
     *
     * @param {Function} cb
     *        A function that will be called during the request animation frame
     *        for tooltips that need to do additional animations from the default
     */
    updateTime(seekBarRect, seekBarPoint, time, cb) {
      this.requestNamedAnimationFrame('TimeTooltip#updateTime', () => {
        let content;
        const duration = this.player_.duration();
        if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
          const liveWindow = this.player_.liveTracker.liveWindow();
          const secondsBehind = liveWindow - seekBarPoint * liveWindow;
          content = (secondsBehind < 1 ? '' : '-') + formatTime(secondsBehind, liveWindow);
        } else {
          content = formatTime(time, duration);
        }
        this.update(seekBarRect, seekBarPoint, content);
        if (cb) {
          cb();
        }
      });
    }
  }
  Component.registerComponent('TimeTooltip', TimeTooltip);

  /**
   * @file play-progress-bar.js
   */

  /**
   * Used by {@link SeekBar} to display media playback progress as part of the
   * {@link ProgressControl}.
   *
   * @extends Component
   */
  class PlayProgressBar extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The {@link Player} that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.setIcon('circle');
      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
    }

    /**
     * Create the the DOM element for this class.
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl('div', {
        className: 'vjs-play-progress vjs-slider-bar'
      }, {
        'aria-hidden': 'true'
      });
    }

    /**
     * Enqueues updates to its own DOM as well as the DOM of its
     * {@link TimeTooltip} child.
     *
     * @param {Object} seekBarRect
     *        The `ClientRect` for the {@link SeekBar} element.
     *
     * @param {number} seekBarPoint
     *        A number from 0 to 1, representing a horizontal reference point
     *        from the left edge of the {@link SeekBar}
     */
    update(seekBarRect, seekBarPoint) {
      const timeTooltip = this.getChild('timeTooltip');
      if (!timeTooltip) {
        return;
      }
      const time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      timeTooltip.updateTime(seekBarRect, seekBarPoint, time);
    }
  }

  /**
   * Default options for {@link PlayProgressBar}.
   *
   * @type {Object}
   * @private
   */
  PlayProgressBar.prototype.options_ = {
    children: []
  };

  // Time tooltips should not be added to a player on mobile devices
  if (!IS_IOS && !IS_ANDROID) {
    PlayProgressBar.prototype.options_.children.push('timeTooltip');
  }
  Component.registerComponent('PlayProgressBar', PlayProgressBar);

  /**
   * @file mouse-time-display.js
   */

  /**
   * The {@link MouseTimeDisplay} component tracks mouse movement over the
   * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}
   * indicating the time which is represented by a given point in the
   * {@link ProgressControl}.
   *
   * @extends Component
   */
  class MouseTimeDisplay extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The {@link Player} that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
    }

    /**
     * Create the DOM element for this class.
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl('div', {
        className: 'vjs-mouse-display'
      });
    }

    /**
     * Enqueues updates to its own DOM as well as the DOM of its
     * {@link TimeTooltip} child.
     *
     * @param {Object} seekBarRect
     *        The `ClientRect` for the {@link SeekBar} element.
     *
     * @param {number} seekBarPoint
     *        A number from 0 to 1, representing a horizontal reference point
     *        from the left edge of the {@link SeekBar}
     */
    update(seekBarRect, seekBarPoint) {
      const time = seekBarPoint * this.player_.duration();
      this.getChild('timeTooltip').updateTime(seekBarRect, seekBarPoint, time, () => {
        this.el_.style.left = `${seekBarRect.width * seekBarPoint}px`;
      });
    }
  }

  /**
   * Default options for `MouseTimeDisplay`
   *
   * @type {Object}
   * @private
   */
  MouseTimeDisplay.prototype.options_ = {
    children: ['timeTooltip']
  };
  Component.registerComponent('MouseTimeDisplay', MouseTimeDisplay);

  /**
   * @file seek-bar.js
   */

  // The number of seconds the `step*` functions move the timeline.
  const STEP_SECONDS = 5;

  // The multiplier of STEP_SECONDS that PgUp/PgDown move the timeline.
  const PAGE_KEY_MULTIPLIER = 12;

  /**
   * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}
   * as its `bar`.
   *
   * @extends Slider
   */
  class SeekBar extends Slider {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.setEventHandlers_();
    }

    /**
     * Sets the event handlers
     *
     * @private
     */
    setEventHandlers_() {
      this.update_ = bind_(this, this.update);
      this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);
      this.on(this.player_, ['durationchange', 'timeupdate'], this.update);
      this.on(this.player_, ['ended'], this.update_);
      if (this.player_.liveTracker) {
        this.on(this.player_.liveTracker, 'liveedgechange', this.update);
      }

      // when playing, let's ensure we smoothly update the play progress bar
      // via an interval
      this.updateInterval = null;
      this.enableIntervalHandler_ = e => this.enableInterval_(e);
      this.disableIntervalHandler_ = e => this.disableInterval_(e);
      this.on(this.player_, ['playing'], this.enableIntervalHandler_);
      this.on(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_);

      // we don't need to update the play progress if the document is hidden,
      // also, this causes the CPU to spike and eventually crash the page on IE11.
      if ('hidden' in document__default["default"] && 'visibilityState' in document__default["default"]) {
        this.on(document__default["default"], 'visibilitychange', this.toggleVisibility_);
      }
    }
    toggleVisibility_(e) {
      if (document__default["default"].visibilityState === 'hidden') {
        this.cancelNamedAnimationFrame('SeekBar#update');
        this.cancelNamedAnimationFrame('Slider#update');
        this.disableInterval_(e);
      } else {
        if (!this.player_.ended() && !this.player_.paused()) {
          this.enableInterval_();
        }

        // we just switched back to the page and someone may be looking, so, update ASAP
        this.update();
      }
    }
    enableInterval_() {
      if (this.updateInterval) {
        return;
      }
      this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);
    }
    disableInterval_(e) {
      if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== 'ended') {
        return;
      }
      if (!this.updateInterval) {
        return;
      }
      this.clearInterval(this.updateInterval);
      this.updateInterval = null;
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl('div', {
        className: 'vjs-progress-holder'
      }, {
        'aria-label': this.localize('Progress Bar')
      });
    }

    /**
     * This function updates the play progress bar and accessibility
     * attributes to whatever is passed in.
     *
     * @param {Event} [event]
     *        The `timeupdate` or `ended` event that caused this to run.
     *
     * @listens Player#timeupdate
     *
     * @return {number}
     *          The current percent at a number from 0-1
     */
    update(event) {
      // ignore updates while the tab is hidden
      if (document__default["default"].visibilityState === 'hidden') {
        return;
      }
      const percent = super.update();
      this.requestNamedAnimationFrame('SeekBar#update', () => {
        const currentTime = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_();
        const liveTracker = this.player_.liveTracker;
        let duration = this.player_.duration();
        if (liveTracker && liveTracker.isLive()) {
          duration = this.player_.liveTracker.liveCurrentTime();
        }
        if (this.percent_ !== percent) {
          // machine readable value of progress bar (percentage complete)
          this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));
          this.percent_ = percent;
        }
        if (this.currentTime_ !== currentTime || this.duration_ !== duration) {
          // human readable value of progress bar (time complete)
          this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));
          this.currentTime_ = currentTime;
          this.duration_ = duration;
        }

        // update the progress bar time tooltip with the current time
        if (this.bar) {
          this.bar.update(getBoundingClientRect(this.el()), this.getProgress());
        }
      });
      return percent;
    }

    /**
     * Prevent liveThreshold from causing seeks to seem like they
     * are not happening from a user perspective.
     *
     * @param {number} ct
     *        current time to seek to
     */
    userSeek_(ct) {
      if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
        this.player_.liveTracker.nextSeekedFromUser();
      }
      this.player_.currentTime(ct);
    }

    /**
     * Get the value of current time but allows for smooth scrubbing,
     * when player can't keep up.
     *
     * @return {number}
     *         The current time value to display
     *
     * @private
     */
    getCurrentTime_() {
      return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    }

    /**
     * Get the percentage of media played so far.
     *
     * @return {number}
     *         The percentage of media played so far (0 to 1).
     */
    getPercent() {
      const currentTime = this.getCurrentTime_();
      let percent;
      const liveTracker = this.player_.liveTracker;
      if (liveTracker && liveTracker.isLive()) {
        percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();

        // prevent the percent from changing at the live edge
        if (liveTracker.atLiveEdge()) {
          percent = 1;
        }
      } else {
        percent = currentTime / this.player_.duration();
      }
      return percent;
    }

    /**
     * Handle mouse down on seek bar
     *
     * @param {MouseEvent} event
     *        The `mousedown` event that caused this to run.
     *
     * @listens mousedown
     */
    handleMouseDown(event) {
      if (!isSingleLeftClick(event)) {
        return;
      }

      // Stop event propagation to prevent double fire in progress-control.js
      event.stopPropagation();
      this.videoWasPlaying = !this.player_.paused();
      this.player_.pause();
      super.handleMouseDown(event);
    }

    /**
     * Handle mouse move on seek bar
     *
     * @param {MouseEvent} event
     *        The `mousemove` event that caused this to run.
     * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false
     *
     * @listens mousemove
     */
    handleMouseMove(event, mouseDown = false) {
      if (!isSingleLeftClick(event) || isNaN(this.player_.duration())) {
        return;
      }
      if (!mouseDown && !this.player_.scrubbing()) {
        this.player_.scrubbing(true);
      }
      let newTime;
      const distance = this.calculateDistance(event);
      const liveTracker = this.player_.liveTracker;
      if (!liveTracker || !liveTracker.isLive()) {
        newTime = distance * this.player_.duration();

        // Don't let video end while scrubbing.
        if (newTime === this.player_.duration()) {
          newTime = newTime - 0.1;
        }
      } else {
        if (distance >= 0.99) {
          liveTracker.seekToLiveEdge();
          return;
        }
        const seekableStart = liveTracker.seekableStart();
        const seekableEnd = liveTracker.liveCurrentTime();
        newTime = seekableStart + distance * liveTracker.liveWindow();

        // Don't let video end while scrubbing.
        if (newTime >= seekableEnd) {
          newTime = seekableEnd;
        }

        // Compensate for precision differences so that currentTime is not less
        // than seekable start
        if (newTime <= seekableStart) {
          newTime = seekableStart + 0.1;
        }

        // On android seekableEnd can be Infinity sometimes,
        // this will cause newTime to be Infinity, which is
        // not a valid currentTime.
        if (newTime === Infinity) {
          return;
        }
      }

      // Set new time (tell player to seek to new time)
      this.userSeek_(newTime);
      if (this.player_.options_.enableSmoothSeeking) {
        this.update();
      }
    }
    enable() {
      super.enable();
      const mouseTimeDisplay = this.getChild('mouseTimeDisplay');
      if (!mouseTimeDisplay) {
        return;
      }
      mouseTimeDisplay.show();
    }
    disable() {
      super.disable();
      const mouseTimeDisplay = this.getChild('mouseTimeDisplay');
      if (!mouseTimeDisplay) {
        return;
      }
      mouseTimeDisplay.hide();
    }

    /**
     * Handle mouse up on seek bar
     *
     * @param {MouseEvent} event
     *        The `mouseup` event that caused this to run.
     *
     * @listens mouseup
     */
    handleMouseUp(event) {
      super.handleMouseUp(event);

      // Stop event propagation to prevent double fire in progress-control.js
      if (event) {
        event.stopPropagation();
      }
      this.player_.scrubbing(false);

      /**
       * Trigger timeupdate because we're done seeking and the time has changed.
       * This is particularly useful for if the player is paused to time the time displays.
       *
       * @event Tech#timeupdate
       * @type {Event}
       */
      this.player_.trigger({
        type: 'timeupdate',
        target: this,
        manuallyTriggered: true
      });
      if (this.videoWasPlaying) {
        silencePromise(this.player_.play());
      } else {
        // We're done seeking and the time has changed.
        // If the player is paused, make sure we display the correct time on the seek bar.
        this.update_();
      }
    }

    /**
     * Move more quickly fast forward for keyboard-only users
     */
    stepForward() {
      this.userSeek_(this.player_.currentTime() + STEP_SECONDS);
    }

    /**
     * Move more quickly rewind for keyboard-only users
     */
    stepBack() {
      this.userSeek_(this.player_.currentTime() - STEP_SECONDS);
    }

    /**
     * Toggles the playback state of the player
     * This gets called when enter or space is used on the seekbar
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called
     *
     */
    handleAction(event) {
      if (this.player_.paused()) {
        this.player_.play();
      } else {
        this.player_.pause();
      }
    }

    /**
     * Called when this SeekBar has focus and a key gets pressed down.
     * Supports the following keys:
     *
     *   Space or Enter key fire a click event
     *   Home key moves to start of the timeline
     *   End key moves to end of the timeline
     *   Digit "0" through "9" keys move to 0%, 10% ... 80%, 90% of the timeline
     *   PageDown key moves back a larger step than ArrowDown
     *   PageUp key moves forward a large step
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      const liveTracker = this.player_.liveTracker;
      if (event.key === ' ' || event.key === 'Enter') {
        event.preventDefault();
        event.stopPropagation();
        this.handleAction(event);
      } else if (event.key === 'Home') {
        event.preventDefault();
        event.stopPropagation();
        this.userSeek_(0);
      } else if (event.key === 'End') {
        event.preventDefault();
        event.stopPropagation();
        if (liveTracker && liveTracker.isLive()) {
          this.userSeek_(liveTracker.liveCurrentTime());
        } else {
          this.userSeek_(this.player_.duration());
        }
      } else if (/^[0-9]$/.test(event.key)) {
        event.preventDefault();
        event.stopPropagation();
        const gotoFraction = parseInt(event.key, 10) * 0.1;
        if (liveTracker && liveTracker.isLive()) {
          this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);
        } else {
          this.userSeek_(this.player_.duration() * gotoFraction);
        }
      } else if (event.key === 'PageDown') {
        event.preventDefault();
        event.stopPropagation();
        this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);
      } else if (event.key === 'PageUp') {
        event.preventDefault();
        event.stopPropagation();
        this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);
      } else {
        // Pass keydown handling up for unsupported keys
        super.handleKeyDown(event);
      }
    }
    dispose() {
      this.disableInterval_();
      this.off(this.player_, ['durationchange', 'timeupdate'], this.update);
      this.off(this.player_, ['ended'], this.update_);
      if (this.player_.liveTracker) {
        this.off(this.player_.liveTracker, 'liveedgechange', this.update);
      }
      this.off(this.player_, ['playing'], this.enableIntervalHandler_);
      this.off(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_);

      // we don't need to update the play progress if the document is hidden,
      // also, this causes the CPU to spike and eventually crash the page on IE11.
      if ('hidden' in document__default["default"] && 'visibilityState' in document__default["default"]) {
        this.off(document__default["default"], 'visibilitychange', this.toggleVisibility_);
      }
      super.dispose();
    }
  }

  /**
   * Default options for the `SeekBar`
   *
   * @type {Object}
   * @private
   */
  SeekBar.prototype.options_ = {
    children: ['loadProgressBar', 'playProgressBar'],
    barName: 'playProgressBar'
  };

  // MouseTimeDisplay tooltips should not be added to a player on mobile devices
  if (!IS_IOS && !IS_ANDROID) {
    SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');
  }
  Component.registerComponent('SeekBar', SeekBar);

  /**
   * @file progress-control.js
   */

  /**
   * The Progress Control component contains the seek bar, load progress,
   * and play progress.
   *
   * @extends Component
   */
  class ProgressControl extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.handleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
      this.throttledHandleMouseSeek = throttle(bind_(this, this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);
      this.handleMouseUpHandler_ = e => this.handleMouseUp(e);
      this.handleMouseDownHandler_ = e => this.handleMouseDown(e);
      this.enable();
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl('div', {
        className: 'vjs-progress-control vjs-control'
      });
    }

    /**
     * When the mouse moves over the `ProgressControl`, the pointer position
     * gets passed down to the `MouseTimeDisplay` component.
     *
     * @param {Event} event
     *        The `mousemove` event that caused this function to run.
     *
     * @listen mousemove
     */
    handleMouseMove(event) {
      const seekBar = this.getChild('seekBar');
      if (!seekBar) {
        return;
      }
      const playProgressBar = seekBar.getChild('playProgressBar');
      const mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');
      if (!playProgressBar && !mouseTimeDisplay) {
        return;
      }
      const seekBarEl = seekBar.el();
      const seekBarRect = findPosition(seekBarEl);
      let seekBarPoint = getPointerPosition(seekBarEl, event).x;

      // The default skin has a gap on either side of the `SeekBar`. This means
      // that it's possible to trigger this behavior outside the boundaries of
      // the `SeekBar`. This ensures we stay within it at all times.
      seekBarPoint = clamp(seekBarPoint, 0, 1);
      if (mouseTimeDisplay) {
        mouseTimeDisplay.update(seekBarRect, seekBarPoint);
      }
      if (playProgressBar) {
        playProgressBar.update(seekBarRect, seekBar.getProgress());
      }
    }

    /**
     * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.
     *
     * @method ProgressControl#throttledHandleMouseSeek
     * @param {Event} event
     *        The `mousemove` event that caused this function to run.
     *
     * @listen mousemove
     * @listen touchmove
     */

    /**
     * Handle `mousemove` or `touchmove` events on the `ProgressControl`.
     *
     * @param {Event} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousemove
     * @listens touchmove
     */
    handleMouseSeek(event) {
      const seekBar = this.getChild('seekBar');
      if (seekBar) {
        seekBar.handleMouseMove(event);
      }
    }

    /**
     * Are controls are currently enabled for this progress control.
     *
     * @return {boolean}
     *         true if controls are enabled, false otherwise
     */
    enabled() {
      return this.enabled_;
    }

    /**
     * Disable all controls on the progress control and its children
     */
    disable() {
      this.children().forEach(child => child.disable && child.disable());
      if (!this.enabled()) {
        return;
      }
      this.off(['mousedown', 'touchstart'], this.handleMouseDownHandler_);
      this.off(this.el_, 'mousemove', this.handleMouseMove);
      this.removeListenersAddedOnMousedownAndTouchstart();
      this.addClass('disabled');
      this.enabled_ = false;

      // Restore normal playback state if controls are disabled while scrubbing
      if (this.player_.scrubbing()) {
        const seekBar = this.getChild('seekBar');
        this.player_.scrubbing(false);
        if (seekBar.videoWasPlaying) {
          silencePromise(this.player_.play());
        }
      }
    }

    /**
     * Enable all controls on the progress control and its children
     */
    enable() {
      this.children().forEach(child => child.enable && child.enable());
      if (this.enabled()) {
        return;
      }
      this.on(['mousedown', 'touchstart'], this.handleMouseDownHandler_);
      this.on(this.el_, 'mousemove', this.handleMouseMove);
      this.removeClass('disabled');
      this.enabled_ = true;
    }

    /**
     * Cleanup listeners after the user finishes interacting with the progress controls
     */
    removeListenersAddedOnMousedownAndTouchstart() {
      const doc = this.el_.ownerDocument;
      this.off(doc, 'mousemove', this.throttledHandleMouseSeek);
      this.off(doc, 'touchmove', this.throttledHandleMouseSeek);
      this.off(doc, 'mouseup', this.handleMouseUpHandler_);
      this.off(doc, 'touchend', this.handleMouseUpHandler_);
    }

    /**
     * Handle `mousedown` or `touchstart` events on the `ProgressControl`.
     *
     * @param {Event} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousedown
     * @listens touchstart
     */
    handleMouseDown(event) {
      const doc = this.el_.ownerDocument;
      const seekBar = this.getChild('seekBar');
      if (seekBar) {
        seekBar.handleMouseDown(event);
      }
      this.on(doc, 'mousemove', this.throttledHandleMouseSeek);
      this.on(doc, 'touchmove', this.throttledHandleMouseSeek);
      this.on(doc, 'mouseup', this.handleMouseUpHandler_);
      this.on(doc, 'touchend', this.handleMouseUpHandler_);
    }

    /**
     * Handle `mouseup` or `touchend` events on the `ProgressControl`.
     *
     * @param {Event} event
     *        `mouseup` or `touchend` event that triggered this function.
     *
     * @listens touchend
     * @listens mouseup
     */
    handleMouseUp(event) {
      const seekBar = this.getChild('seekBar');
      if (seekBar) {
        seekBar.handleMouseUp(event);
      }
      this.removeListenersAddedOnMousedownAndTouchstart();
    }
  }

  /**
   * Default options for `ProgressControl`
   *
   * @type {Object}
   * @private
   */
  ProgressControl.prototype.options_ = {
    children: ['seekBar']
  };
  Component.registerComponent('ProgressControl', ProgressControl);

  /**
   * @file picture-in-picture-toggle.js
   */

  /** @import Player from './player' */

  /**
   * Toggle Picture-in-Picture mode
   *
   * @extends Button
   */
  class PictureInPictureToggle extends Button {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @listens Player#enterpictureinpicture
     * @listens Player#leavepictureinpicture
     */
    constructor(player, options) {
      super(player, options);
      this.setIcon('picture-in-picture-enter');
      this.on(player, ['enterpictureinpicture', 'leavepictureinpicture'], e => this.handlePictureInPictureChange(e));
      this.on(player, ['disablepictureinpicturechanged', 'loadedmetadata'], e => this.handlePictureInPictureEnabledChange(e));
      this.on(player, ['loadedmetadata', 'audioonlymodechange', 'audiopostermodechange'], () => this.handlePictureInPictureAudioModeChange());

      // TODO: Deactivate button on player emptied event.
      this.disable();
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-picture-in-picture-control vjs-hidden ${super.buildCSSClass()}`;
    }

    /**
     * Displays or hides the button depending on the audio mode detection.
     * Exits picture-in-picture if it is enabled when switching to audio mode.
     */
    handlePictureInPictureAudioModeChange() {
      // This audio detection will not detect HLS or DASH audio-only streams because there was no reliable way to detect them at the time
      const isSourceAudio = this.player_.currentType().substring(0, 5) === 'audio';
      const isAudioMode = isSourceAudio || this.player_.audioPosterMode() || this.player_.audioOnlyMode();
      if (!isAudioMode) {
        this.show();
        return;
      }
      if (this.player_.isInPictureInPicture()) {
        this.player_.exitPictureInPicture();
      }
      this.hide();
    }

    /**
     * Enables or disables button based on availability of a Picture-In-Picture mode.
     *
     * Enabled if
     * - `player.options().enableDocumentPictureInPicture` is true and
     *   window.documentPictureInPicture is available; or
     * - `player.disablePictureInPicture()` is false and
     *   element.requestPictureInPicture is available
     */
    handlePictureInPictureEnabledChange() {
      if (document__default["default"].pictureInPictureEnabled && this.player_.disablePictureInPicture() === false || this.player_.options_.enableDocumentPictureInPicture && 'documentPictureInPicture' in window__default["default"]) {
        this.enable();
      } else {
        this.disable();
      }
    }

    /**
     * Handles enterpictureinpicture and leavepictureinpicture on the player and change control text accordingly.
     *
     * @param {Event} [event]
     *        The {@link Player#enterpictureinpicture} or {@link Player#leavepictureinpicture} event that caused this function to be
     *        called.
     *
     * @listens Player#enterpictureinpicture
     * @listens Player#leavepictureinpicture
     */
    handlePictureInPictureChange(event) {
      if (this.player_.isInPictureInPicture()) {
        this.setIcon('picture-in-picture-exit');
        this.controlText('Exit Picture-in-Picture');
      } else {
        this.setIcon('picture-in-picture-enter');
        this.controlText('Picture-in-Picture');
      }
      this.handlePictureInPictureEnabledChange();
    }

    /**
     * This gets called when an `PictureInPictureToggle` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      if (!this.player_.isInPictureInPicture()) {
        this.player_.requestPictureInPicture();
      } else {
        this.player_.exitPictureInPicture();
      }
    }

    /**
     * Show the `Component`s element if it is hidden by removing the
     * 'vjs-hidden' class name from it only in browsers that support the Picture-in-Picture API.
     */
    show() {
      // Does not allow to display the pictureInPictureToggle in browsers that do not support the Picture-in-Picture API, e.g. Firefox.
      if (typeof document__default["default"].exitPictureInPicture !== 'function') {
        return;
      }
      super.show();
    }
  }

  /**
   * The text that should display over the `PictureInPictureToggle`s controls. Added for localization.
   *
   * @type {string}
   * @protected
   */
  PictureInPictureToggle.prototype.controlText_ = 'Picture-in-Picture';
  Component.registerComponent('PictureInPictureToggle', PictureInPictureToggle);

  /**
   * @file fullscreen-toggle.js
   */

  /** @import Player from './player' */

  /**
   * Toggle fullscreen video
   *
   * @extends Button
   */
  class FullscreenToggle extends Button {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.setIcon('fullscreen-enter');
      this.on(player, 'fullscreenchange', e => this.handleFullscreenChange(e));
      if (document__default["default"][player.fsApi_.fullscreenEnabled] === false) {
        this.disable();
      }
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-fullscreen-control ${super.buildCSSClass()}`;
    }

    /**
     * Handles fullscreenchange on the player and change control text accordingly.
     *
     * @param {Event} [event]
     *        The {@link Player#fullscreenchange} event that caused this function to be
     *        called.
     *
     * @listens Player#fullscreenchange
     */
    handleFullscreenChange(event) {
      if (this.player_.isFullscreen()) {
        this.controlText('Exit Fullscreen');
        this.setIcon('fullscreen-exit');
      } else {
        this.controlText('Fullscreen');
        this.setIcon('fullscreen-enter');
      }
    }

    /**
     * This gets called when an `FullscreenToggle` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      if (!this.player_.isFullscreen()) {
        this.player_.requestFullscreen();
      } else {
        this.player_.exitFullscreen();
      }
    }
  }

  /**
   * The text that should display over the `FullscreenToggle`s controls. Added for localization.
   *
   * @type {string}
   * @protected
   */
  FullscreenToggle.prototype.controlText_ = 'Fullscreen';
  Component.registerComponent('FullscreenToggle', FullscreenToggle);

  /** @import Component from '../../component' */
  /** @import Player from '../../player' */

  /**
   * Check if volume control is supported and if it isn't hide the
   * `Component` that was passed  using the `vjs-hidden` class.
   *
   * @param {Component} self
   *        The component that should be hidden if volume is unsupported
   *
   * @param {Player} player
   *        A reference to the player
   *
   * @private
   */
  const checkVolumeSupport = function (self, player) {
    // hide volume controls when they're not supported by the current tech
    if (player.tech_ && !player.tech_.featuresVolumeControl) {
      self.addClass('vjs-hidden');
    }
    self.on(player, 'loadstart', function () {
      if (!player.tech_.featuresVolumeControl) {
        self.addClass('vjs-hidden');
      } else {
        self.removeClass('vjs-hidden');
      }
    });
  };

  /**
   * @file volume-level.js
   */

  /**
   * Shows volume level
   *
   * @extends Component
   */
  class VolumeLevel extends Component {
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl('div', {
        className: 'vjs-volume-level'
      });
      this.setIcon('circle', el);
      el.appendChild(super.createEl('span', {
        className: 'vjs-control-text'
      }));
      return el;
    }
  }
  Component.registerComponent('VolumeLevel', VolumeLevel);

  /**
   * @file volume-level-tooltip.js
   */

  /** @import Player from '../../player' */

  /**
   * Volume level tooltips display a volume above or side by side the volume bar.
   *
   * @extends Component
   */
  class VolumeLevelTooltip extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The {@link Player} that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
    }

    /**
     * Create the volume tooltip DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl('div', {
        className: 'vjs-volume-tooltip'
      }, {
        'aria-hidden': 'true'
      });
    }

    /**
     * Updates the position of the tooltip relative to the `VolumeBar` and
     * its content text.
     *
     * @param {Object} rangeBarRect
     *        The `ClientRect` for the {@link VolumeBar} element.
     *
     * @param {number} rangeBarPoint
     *        A number from 0 to 1, representing a horizontal/vertical reference point
     *        from the left edge of the {@link VolumeBar}
     *
     * @param {boolean} vertical
     *        Referees to the Volume control position
     *        in the control bar{@link VolumeControl}
     *
     */
    update(rangeBarRect, rangeBarPoint, vertical, content) {
      if (!vertical) {
        const tooltipRect = getBoundingClientRect(this.el_);
        const playerRect = getBoundingClientRect(this.player_.el());
        const volumeBarPointPx = rangeBarRect.width * rangeBarPoint;
        if (!playerRect || !tooltipRect) {
          return;
        }
        const spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;
        const spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);
        let pullTooltipBy = tooltipRect.width / 2;
        if (spaceLeftOfPoint < pullTooltipBy) {
          pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
        } else if (spaceRightOfPoint < pullTooltipBy) {
          pullTooltipBy = spaceRightOfPoint;
        }
        if (pullTooltipBy < 0) {
          pullTooltipBy = 0;
        } else if (pullTooltipBy > tooltipRect.width) {
          pullTooltipBy = tooltipRect.width;
        }
        this.el_.style.right = `-${pullTooltipBy}px`;
      }
      this.write(`${content}%`);
    }

    /**
     * Write the volume to the tooltip DOM element.
     *
     * @param {string} content
     *        The formatted volume for the tooltip.
     */
    write(content) {
      textContent(this.el_, content);
    }

    /**
     * Updates the position of the volume tooltip relative to the `VolumeBar`.
     *
     * @param {Object} rangeBarRect
     *        The `ClientRect` for the {@link VolumeBar} element.
     *
     * @param {number} rangeBarPoint
     *        A number from 0 to 1, representing a horizontal/vertical reference point
     *        from the left edge of the {@link VolumeBar}
     *
     * @param {boolean} vertical
     *        Referees to the Volume control position
     *        in the control bar{@link VolumeControl}
     *
     * @param {number} volume
     *        The volume level to update the tooltip to
     *
     * @param {Function} cb
     *        A function that will be called during the request animation frame
     *        for tooltips that need to do additional animations from the default
     */
    updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {
      this.requestNamedAnimationFrame('VolumeLevelTooltip#updateVolume', () => {
        this.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));
        if (cb) {
          cb();
        }
      });
    }
  }
  Component.registerComponent('VolumeLevelTooltip', VolumeLevelTooltip);

  /**
   * @file mouse-volume-level-display.js
   */

  /**
   * The {@link MouseVolumeLevelDisplay} component tracks mouse movement over the
   * {@link VolumeControl}. It displays an indicator and a {@link VolumeLevelTooltip}
   * indicating the volume level which is represented by a given point in the
   * {@link VolumeBar}.
   *
   * @extends Component
   */
  class MouseVolumeLevelDisplay extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The {@link Player} that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
    }

    /**
     * Create the DOM element for this class.
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl('div', {
        className: 'vjs-mouse-display'
      });
    }

    /**
     * Enquires updates to its own DOM as well as the DOM of its
     * {@link VolumeLevelTooltip} child.
     *
     * @param {Object} rangeBarRect
     *        The `ClientRect` for the {@link VolumeBar} element.
     *
     * @param {number} rangeBarPoint
     *        A number from 0 to 1, representing a horizontal/vertical reference point
     *        from the left edge of the {@link VolumeBar}
     *
     * @param {boolean} vertical
     *        Referees to the Volume control position
     *        in the control bar{@link VolumeControl}
     *
     */
    update(rangeBarRect, rangeBarPoint, vertical) {
      const volume = 100 * rangeBarPoint;
      this.getChild('volumeLevelTooltip').updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, () => {
        if (vertical) {
          this.el_.style.bottom = `${rangeBarRect.height * rangeBarPoint}px`;
        } else {
          this.el_.style.left = `${rangeBarRect.width * rangeBarPoint}px`;
        }
      });
    }
  }

  /**
   * Default options for `MouseVolumeLevelDisplay`
   *
   * @type {Object}
   * @private
   */
  MouseVolumeLevelDisplay.prototype.options_ = {
    children: ['volumeLevelTooltip']
  };
  Component.registerComponent('MouseVolumeLevelDisplay', MouseVolumeLevelDisplay);

  /**
   * @file volume-bar.js
   */

  /**
   * The bar that contains the volume level and can be clicked on to adjust the level
   *
   * @extends Slider
   */
  class VolumeBar extends Slider {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.on('slideractive', e => this.updateLastVolume_(e));
      this.on(player, 'volumechange', e => this.updateARIAAttributes(e));
      player.ready(() => this.updateARIAAttributes());
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl('div', {
        className: 'vjs-volume-bar vjs-slider-bar'
      }, {
        'aria-label': this.localize('Volume Level'),
        'aria-live': 'polite'
      });
    }

    /**
     * Handle mouse down on volume bar
     *
     * @param {Event} event
     *        The `mousedown` event that caused this to run.
     *
     * @listens mousedown
     */
    handleMouseDown(event) {
      if (!isSingleLeftClick(event)) {
        return;
      }
      super.handleMouseDown(event);
    }

    /**
     * Handle movement events on the {@link VolumeMenuButton}.
     *
     * @param {Event} event
     *        The event that caused this function to run.
     *
     * @listens mousemove
     */
    handleMouseMove(event) {
      const mouseVolumeLevelDisplay = this.getChild('mouseVolumeLevelDisplay');
      if (mouseVolumeLevelDisplay) {
        const volumeBarEl = this.el();
        const volumeBarRect = getBoundingClientRect(volumeBarEl);
        const vertical = this.vertical();
        let volumeBarPoint = getPointerPosition(volumeBarEl, event);
        volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;
        // The default skin has a gap on either side of the `VolumeBar`. This means
        // that it's possible to trigger this behavior outside the boundaries of
        // the `VolumeBar`. This ensures we stay within it at all times.
        volumeBarPoint = clamp(volumeBarPoint, 0, 1);
        mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);
      }
      if (!isSingleLeftClick(event)) {
        return;
      }
      this.checkMuted();
      this.player_.volume(this.calculateDistance(event));
    }

    /**
     * If the player is muted unmute it.
     */
    checkMuted() {
      if (this.player_.muted()) {
        this.player_.muted(false);
      }
    }

    /**
     * Get percent of volume level
     *
     * @return {number}
     *         Volume level percent as a decimal number.
     */
    getPercent() {
      if (this.player_.muted()) {
        return 0;
      }
      return this.player_.volume();
    }

    /**
     * Increase volume level for keyboard users
     */
    stepForward() {
      this.checkMuted();
      this.player_.volume(this.player_.volume() + 0.1);
    }

    /**
     * Decrease volume level for keyboard users
     */
    stepBack() {
      this.checkMuted();
      this.player_.volume(this.player_.volume() - 0.1);
    }

    /**
     * Update ARIA accessibility attributes
     *
     * @param {Event} [event]
     *        The `volumechange` event that caused this function to run.
     *
     * @listens Player#volumechange
     */
    updateARIAAttributes(event) {
      const ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
      this.el_.setAttribute('aria-valuenow', ariaValue);
      this.el_.setAttribute('aria-valuetext', ariaValue + '%');
    }

    /**
     * Returns the current value of the player volume as a percentage
     *
     * @private
     */
    volumeAsPercentage_() {
      return Math.round(this.player_.volume() * 100);
    }

    /**
     * When user starts dragging the VolumeBar, store the volume and listen for
     * the end of the drag. When the drag ends, if the volume was set to zero,
     * set lastVolume to the stored volume.
     *
     * @listens slideractive
     * @private
     */
    updateLastVolume_() {
      const volumeBeforeDrag = this.player_.volume();
      this.one('sliderinactive', () => {
        if (this.player_.volume() === 0) {
          this.player_.lastVolume_(volumeBeforeDrag);
        }
      });
    }
  }

  /**
   * Default options for the `VolumeBar`
   *
   * @type {Object}
   * @private
   */
  VolumeBar.prototype.options_ = {
    children: ['volumeLevel'],
    barName: 'volumeLevel'
  };

  // MouseVolumeLevelDisplay tooltip should not be added to a player on mobile devices
  if (!IS_IOS && !IS_ANDROID) {
    VolumeBar.prototype.options_.children.splice(0, 0, 'mouseVolumeLevelDisplay');
  }

  /**
   * Call the update event for this Slider when this event happens on the player.
   *
   * @type {string}
   */
  VolumeBar.prototype.playerEvent = 'volumechange';
  Component.registerComponent('VolumeBar', VolumeBar);

  /**
   * @file volume-control.js
   */

  /**
   * The component for controlling the volume level
   *
   * @extends Component
   */
  class VolumeControl extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      options.vertical = options.vertical || false;

      // Pass the vertical option down to the VolumeBar if
      // the VolumeBar is turned on.
      if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {
        options.volumeBar = options.volumeBar || {};
        options.volumeBar.vertical = options.vertical;
      }
      super(player, options);

      // hide this control if volume support is missing
      checkVolumeSupport(this, player);
      this.throttledHandleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
      this.handleMouseUpHandler_ = e => this.handleMouseUp(e);
      this.on('mousedown', e => this.handleMouseDown(e));
      this.on('touchstart', e => this.handleMouseDown(e));
      this.on('mousemove', e => this.handleMouseMove(e));

      // while the slider is active (the mouse has been pressed down and
      // is dragging) or in focus we do not want to hide the VolumeBar
      this.on(this.volumeBar, ['focus', 'slideractive'], () => {
        this.volumeBar.addClass('vjs-slider-active');
        this.addClass('vjs-slider-active');
        this.trigger('slideractive');
      });
      this.on(this.volumeBar, ['blur', 'sliderinactive'], () => {
        this.volumeBar.removeClass('vjs-slider-active');
        this.removeClass('vjs-slider-active');
        this.trigger('sliderinactive');
      });
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      let orientationClass = 'vjs-volume-horizontal';
      if (this.options_.vertical) {
        orientationClass = 'vjs-volume-vertical';
      }
      return super.createEl('div', {
        className: `vjs-volume-control vjs-control ${orientationClass}`
      });
    }

    /**
     * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
     *
     * @param {Event} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousedown
     * @listens touchstart
     */
    handleMouseDown(event) {
      const doc = this.el_.ownerDocument;
      this.on(doc, 'mousemove', this.throttledHandleMouseMove);
      this.on(doc, 'touchmove', this.throttledHandleMouseMove);
      this.on(doc, 'mouseup', this.handleMouseUpHandler_);
      this.on(doc, 'touchend', this.handleMouseUpHandler_);
    }

    /**
     * Handle `mouseup` or `touchend` events on the `VolumeControl`.
     *
     * @param {Event} event
     *        `mouseup` or `touchend` event that triggered this function.
     *
     * @listens touchend
     * @listens mouseup
     */
    handleMouseUp(event) {
      const doc = this.el_.ownerDocument;
      this.off(doc, 'mousemove', this.throttledHandleMouseMove);
      this.off(doc, 'touchmove', this.throttledHandleMouseMove);
      this.off(doc, 'mouseup', this.handleMouseUpHandler_);
      this.off(doc, 'touchend', this.handleMouseUpHandler_);
    }

    /**
     * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
     *
     * @param {Event} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousedown
     * @listens touchstart
     */
    handleMouseMove(event) {
      this.volumeBar.handleMouseMove(event);
    }
  }

  /**
   * Default options for the `VolumeControl`
   *
   * @type {Object}
   * @private
   */
  VolumeControl.prototype.options_ = {
    children: ['volumeBar']
  };
  Component.registerComponent('VolumeControl', VolumeControl);

  /** @import Component from '../../component' */
  /** @import Player from '../../player' */

  /**
   * Check if muting volume is supported and if it isn't hide the mute toggle
   * button.
   *
   * @param {Component} self
   *        A reference to the mute toggle button
   *
   * @param {Player} player
   *        A reference to the player
   *
   * @private
   */
  const checkMuteSupport = function (self, player) {
    // hide mute toggle button if it's not supported by the current tech
    if (player.tech_ && !player.tech_.featuresMuteControl) {
      self.addClass('vjs-hidden');
    }
    self.on(player, 'loadstart', function () {
      if (!player.tech_.featuresMuteControl) {
        self.addClass('vjs-hidden');
      } else {
        self.removeClass('vjs-hidden');
      }
    });
  };

  /**
   * @file mute-toggle.js
   */

  /** @import Player from './player' */

  /**
   * A button component for muting the audio.
   *
   * @extends Button
   */
  class MuteToggle extends Button {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);

      // hide this control if volume support is missing
      checkMuteSupport(this, player);
      this.on(player, ['loadstart', 'volumechange'], e => this.update(e));
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-mute-control ${super.buildCSSClass()}`;
    }

    /**
     * This gets called when an `MuteToggle` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      const vol = this.player_.volume();
      const lastVolume = this.player_.lastVolume_();
      if (vol === 0) {
        const volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;
        this.player_.volume(volumeToSet);
        this.player_.muted(false);
      } else {
        this.player_.muted(this.player_.muted() ? false : true);
      }
    }

    /**
     * Update the `MuteToggle` button based on the state of `volume` and `muted`
     * on the player.
     *
     * @param {Event} [event]
     *        The {@link Player#loadstart} event if this function was called
     *        through an event.
     *
     * @listens Player#loadstart
     * @listens Player#volumechange
     */
    update(event) {
      this.updateIcon_();
      this.updateControlText_();
    }

    /**
     * Update the appearance of the `MuteToggle` icon.
     *
     * Possible states (given `level` variable below):
     * - 0: crossed out
     * - 1: zero bars of volume
     * - 2: one bar of volume
     * - 3: two bars of volume
     *
     * @private
     */
    updateIcon_() {
      const vol = this.player_.volume();
      let level = 3;
      this.setIcon('volume-high');

      // in iOS when a player is loaded with muted attribute
      // and volume is changed with a native mute button
      // we want to make sure muted state is updated
      if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {
        this.player_.muted(this.player_.tech_.el_.muted);
      }
      if (vol === 0 || this.player_.muted()) {
        this.setIcon('volume-mute');
        level = 0;
      } else if (vol < 0.33) {
        this.setIcon('volume-low');
        level = 1;
      } else if (vol < 0.67) {
        this.setIcon('volume-medium');
        level = 2;
      }
      removeClass(this.el_, [0, 1, 2, 3].reduce((str, i) => str + `${i ? ' ' : ''}vjs-vol-${i}`, ''));
      addClass(this.el_, `vjs-vol-${level}`);
    }

    /**
     * If `muted` has changed on the player, update the control text
     * (`title` attribute on `vjs-mute-control` element and content of
     * `vjs-control-text` element).
     *
     * @private
     */
    updateControlText_() {
      const soundOff = this.player_.muted() || this.player_.volume() === 0;
      const text = soundOff ? 'Unmute' : 'Mute';
      if (this.controlText() !== text) {
        this.controlText(text);
      }
    }
  }

  /**
   * The text that should display over the `MuteToggle`s controls. Added for localization.
   *
   * @type {string}
   * @protected
   */
  MuteToggle.prototype.controlText_ = 'Mute';
  Component.registerComponent('MuteToggle', MuteToggle);

  /**
   * @file volume-control.js
   */

  /**
   * A Component to contain the MuteToggle and VolumeControl so that
   * they can work together.
   *
   * @extends Component
   */
  class VolumePanel extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      if (typeof options.inline !== 'undefined') {
        options.inline = options.inline;
      } else {
        options.inline = true;
      }

      // pass the inline option down to the VolumeControl as vertical if
      // the VolumeControl is on.
      if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {
        options.volumeControl = options.volumeControl || {};
        options.volumeControl.vertical = !options.inline;
      }
      super(player, options);

      // this handler is used by mouse handler methods below
      this.handleKeyPressHandler_ = e => this.handleKeyPress(e);
      this.on(player, ['loadstart'], e => this.volumePanelState_(e));
      this.on(this.muteToggle, 'keyup', e => this.handleKeyPress(e));
      this.on(this.volumeControl, 'keyup', e => this.handleVolumeControlKeyUp(e));
      this.on('keydown', e => this.handleKeyPress(e));
      this.on('mouseover', e => this.handleMouseOver(e));
      this.on('mouseout', e => this.handleMouseOut(e));

      // while the slider is active (the mouse has been pressed down and
      // is dragging) we do not want to hide the VolumeBar
      this.on(this.volumeControl, ['slideractive'], this.sliderActive_);
      this.on(this.volumeControl, ['sliderinactive'], this.sliderInactive_);
    }

    /**
     * Add vjs-slider-active class to the VolumePanel
     *
     * @listens VolumeControl#slideractive
     * @private
     */
    sliderActive_() {
      this.addClass('vjs-slider-active');
    }

    /**
     * Removes vjs-slider-active class to the VolumePanel
     *
     * @listens VolumeControl#sliderinactive
     * @private
     */
    sliderInactive_() {
      this.removeClass('vjs-slider-active');
    }

    /**
     * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel
     * depending on MuteToggle and VolumeControl state
     *
     * @listens Player#loadstart
     * @private
     */
    volumePanelState_() {
      // hide volume panel if neither volume control or mute toggle
      // are displayed
      if (this.volumeControl.hasClass('vjs-hidden') && this.muteToggle.hasClass('vjs-hidden')) {
        this.addClass('vjs-hidden');
      }

      // if only mute toggle is visible we don't want
      // volume panel expanding when hovered or active
      if (this.volumeControl.hasClass('vjs-hidden') && !this.muteToggle.hasClass('vjs-hidden')) {
        this.addClass('vjs-mute-toggle-only');
      }
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      let orientationClass = 'vjs-volume-panel-horizontal';
      if (!this.options_.inline) {
        orientationClass = 'vjs-volume-panel-vertical';
      }
      return super.createEl('div', {
        className: `vjs-volume-panel vjs-control ${orientationClass}`
      });
    }

    /**
     * Dispose of the `volume-panel` and all child components.
     */
    dispose() {
      this.handleMouseOut();
      super.dispose();
    }

    /**
     * Handles `keyup` events on the `VolumeControl`, looking for ESC, which closes
     * the volume panel and sets focus on `MuteToggle`.
     *
     * @param {Event} event
     *        The `keyup` event that caused this function to be called.
     *
     * @listens keyup
     */
    handleVolumeControlKeyUp(event) {
      if (event.key === 'Escape') {
        this.muteToggle.focus();
      }
    }

    /**
     * This gets called when a `VolumePanel` gains hover via a `mouseover` event.
     * Turns on listening for `mouseover` event. When they happen it
     * calls `this.handleMouseOver`.
     *
     * @param {Event} event
     *        The `mouseover` event that caused this function to be called.
     *
     * @listens mouseover
     */
    handleMouseOver(event) {
      this.addClass('vjs-hover');
      on(document__default["default"], 'keyup', this.handleKeyPressHandler_);
    }

    /**
     * This gets called when a `VolumePanel` gains hover via a `mouseout` event.
     * Turns on listening for `mouseout` event. When they happen it
     * calls `this.handleMouseOut`.
     *
     * @param {Event} event
     *        The `mouseout` event that caused this function to be called.
     *
     * @listens mouseout
     */
    handleMouseOut(event) {
      this.removeClass('vjs-hover');
      off(document__default["default"], 'keyup', this.handleKeyPressHandler_);
    }

    /**
     * Handles `keyup` event on the document or `keydown` event on the `VolumePanel`,
     * looking for ESC, which hides the `VolumeControl`.
     *
     * @param {Event} event
     *        The keypress that triggered this event.
     *
     * @listens keydown | keyup
     */
    handleKeyPress(event) {
      if (event.key === 'Escape') {
        this.handleMouseOut();
      }
    }
  }

  /**
   * Default options for the `VolumeControl`
   *
   * @type {Object}
   * @private
   */
  VolumePanel.prototype.options_ = {
    children: ['muteToggle', 'volumeControl']
  };
  Component.registerComponent('VolumePanel', VolumePanel);

  /**
   * Button to skip forward a configurable amount of time
   * through a video. Renders in the control bar.
   *
   * e.g. options: {controlBar: {skipButtons: forward: 5}}
   *
   * @extends Button
   */
  class SkipForward extends Button {
    constructor(player, options) {
      super(player, options);
      this.validOptions = [5, 10, 30];
      this.skipTime = this.getSkipForwardTime();
      if (this.skipTime && this.validOptions.includes(this.skipTime)) {
        this.setIcon(`forward-${this.skipTime}`);
        this.controlText(this.localize('Skip forward {1} seconds', [this.skipTime.toLocaleString(player.language())]));
        this.show();
      } else {
        this.hide();
      }
    }
    getSkipForwardTime() {
      const playerOptions = this.options_.playerOptions;
      return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.forward;
    }
    buildCSSClass() {
      return `vjs-skip-forward-${this.getSkipForwardTime()} ${super.buildCSSClass()}`;
    }

    /**
     * On click, skips forward in the duration/seekable range by a configurable amount of seconds.
     * If the time left in the duration/seekable range is less than the configured 'skip forward' time,
     * skips to end of duration/seekable range.
     *
     * Handle a click on a `SkipForward` button
     *
     * @param {EventTarget~Event} event
     *        The `click` event that caused this function
     *        to be called
     */
    handleClick(event) {
      if (isNaN(this.player_.duration())) {
        return;
      }
      const currentVideoTime = this.player_.currentTime();
      const liveTracker = this.player_.liveTracker;
      const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();
      let newTime;
      if (currentVideoTime + this.skipTime <= duration) {
        newTime = currentVideoTime + this.skipTime;
      } else {
        newTime = duration;
      }
      this.player_.currentTime(newTime);
    }

    /**
     * Update control text on languagechange
     */
    handleLanguagechange() {
      this.controlText(this.localize('Skip forward {1} seconds', [this.skipTime]));
    }
  }
  SkipForward.prototype.controlText_ = 'Skip Forward';
  Component.registerComponent('SkipForward', SkipForward);

  /**
   * Button to skip backward a configurable amount of time
   * through a video. Renders in the control bar.
   *
   *  * e.g. options: {controlBar: {skipButtons: backward: 5}}
   *
   * @extends Button
   */
  class SkipBackward extends Button {
    constructor(player, options) {
      super(player, options);
      this.validOptions = [5, 10, 30];
      this.skipTime = this.getSkipBackwardTime();
      if (this.skipTime && this.validOptions.includes(this.skipTime)) {
        this.setIcon(`replay-${this.skipTime}`);
        this.controlText(this.localize('Skip backward {1} seconds', [this.skipTime.toLocaleString(player.language())]));
        this.show();
      } else {
        this.hide();
      }
    }
    getSkipBackwardTime() {
      const playerOptions = this.options_.playerOptions;
      return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.backward;
    }
    buildCSSClass() {
      return `vjs-skip-backward-${this.getSkipBackwardTime()} ${super.buildCSSClass()}`;
    }

    /**
     * On click, skips backward in the video by a configurable amount of seconds.
     * If the current time in the video is less than the configured 'skip backward' time,
     * skips to beginning of video or seekable range.
     *
     * Handle a click on a `SkipBackward` button
     *
     * @param {EventTarget~Event} event
     *        The `click` event that caused this function
     *        to be called
     */
    handleClick(event) {
      const currentVideoTime = this.player_.currentTime();
      const liveTracker = this.player_.liveTracker;
      const seekableStart = liveTracker && liveTracker.isLive() && liveTracker.seekableStart();
      let newTime;
      if (seekableStart && currentVideoTime - this.skipTime <= seekableStart) {
        newTime = seekableStart;
      } else if (currentVideoTime >= this.skipTime) {
        newTime = currentVideoTime - this.skipTime;
      } else {
        newTime = 0;
      }
      this.player_.currentTime(newTime);
    }

    /**
     * Update control text on languagechange
     */
    handleLanguagechange() {
      this.controlText(this.localize('Skip backward {1} seconds', [this.skipTime]));
    }
  }
  SkipBackward.prototype.controlText_ = 'Skip Backward';
  Component.registerComponent('SkipBackward', SkipBackward);

  /**
   * @file menu.js
   */

  /** @import Player from '../player' */

  /**
   * The Menu component is used to build popup menus, including subtitle and
   * captions selection menus.
   *
   * @extends Component
   */
  class Menu extends Component {
    /**
     * Create an instance of this class.
     *
     * @param {Player} player
     *        the player that this component should attach to
     *
     * @param {Object} [options]
     *        Object of option names and values
     *
     */
    constructor(player, options) {
      super(player, options);
      if (options) {
        this.menuButton_ = options.menuButton;
      }
      this.focusedChild_ = -1;
      this.on('keydown', e => this.handleKeyDown(e));

      // All the menu item instances share the same blur handler provided by the menu container.
      this.boundHandleBlur_ = e => this.handleBlur(e);
      this.boundHandleTapClick_ = e => this.handleTapClick(e);
    }

    /**
     * Add event listeners to the {@link MenuItem}.
     *
     * @param {Object} component
     *        The instance of the `MenuItem` to add listeners to.
     *
     */
    addEventListenerForItem(component) {
      if (!(component instanceof Component)) {
        return;
      }
      this.on(component, 'blur', this.boundHandleBlur_);
      this.on(component, ['tap', 'click'], this.boundHandleTapClick_);
    }

    /**
     * Remove event listeners from the {@link MenuItem}.
     *
     * @param {Object} component
     *        The instance of the `MenuItem` to remove listeners.
     *
     */
    removeEventListenerForItem(component) {
      if (!(component instanceof Component)) {
        return;
      }
      this.off(component, 'blur', this.boundHandleBlur_);
      this.off(component, ['tap', 'click'], this.boundHandleTapClick_);
    }

    /**
     * This method will be called indirectly when the component has been added
     * before the component adds to the new menu instance by `addItem`.
     * In this case, the original menu instance will remove the component
     * by calling `removeChild`.
     *
     * @param {Object} component
     *        The instance of the `MenuItem`
     */
    removeChild(component) {
      if (typeof component === 'string') {
        component = this.getChild(component);
      }
      this.removeEventListenerForItem(component);
      super.removeChild(component);
    }

    /**
     * Add a {@link MenuItem} to the menu.
     *
     * @param {Object|string} component
     *        The name or instance of the `MenuItem` to add.
     *
     */
    addItem(component) {
      const childComponent = this.addChild(component);
      if (childComponent) {
        this.addEventListenerForItem(childComponent);
      }
    }

    /**
     * Create the `Menu`s DOM element.
     *
     * @return {Element}
     *         the element that was created
     */
    createEl() {
      const contentElType = this.options_.contentElType || 'ul';
      this.contentEl_ = createEl(contentElType, {
        className: 'vjs-menu-content'
      });
      this.contentEl_.setAttribute('role', 'menu');
      const el = super.createEl('div', {
        append: this.contentEl_,
        className: 'vjs-menu'
      });
      el.appendChild(this.contentEl_);

      // Prevent clicks from bubbling up. Needed for Menu Buttons,
      // where a click on the parent is significant
      on(el, 'click', function (event) {
        event.preventDefault();
        event.stopImmediatePropagation();
      });
      return el;
    }
    dispose() {
      this.contentEl_ = null;
      this.boundHandleBlur_ = null;
      this.boundHandleTapClick_ = null;
      super.dispose();
    }

    /**
     * Called when a `MenuItem` loses focus.
     *
     * @param {Event} event
     *        The `blur` event that caused this function to be called.
     *
     * @listens blur
     */
    handleBlur(event) {
      const relatedTarget = event.relatedTarget || document__default["default"].activeElement;

      // Close menu popup when a user clicks outside the menu
      if (!this.children().some(element => {
        return element.el() === relatedTarget;
      })) {
        const btn = this.menuButton_;
        if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {
          btn.unpressButton();
        }
      }
    }

    /**
     * Called when a `MenuItem` gets clicked or tapped.
     *
     * @param {Event} event
     *        The `click` or `tap` event that caused this function to be called.
     *
     * @listens click,tap
     */
    handleTapClick(event) {
      // Unpress the associated MenuButton, and move focus back to it
      if (this.menuButton_) {
        this.menuButton_.unpressButton();
        const childComponents = this.children();
        if (!Array.isArray(childComponents)) {
          return;
        }
        const foundComponent = childComponents.filter(component => component.el() === event.target)[0];
        if (!foundComponent) {
          return;
        }

        // don't focus menu button if item is a caption settings item
        // because focus will move elsewhere
        if (foundComponent.name() !== 'CaptionSettingsMenuItem') {
          this.menuButton_.focus();
        }
      }
    }

    /**
     * Handle a `keydown` event on this menu. This listener is added in the constructor.
     *
     * @param {KeyboardEvent} event
     *        A `keydown` event that happened on the menu.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      // Left and Down Arrows
      if (event.key === 'ArrowLeft' || event.key === 'ArrowDown') {
        event.preventDefault();
        event.stopPropagation();
        this.stepForward();

        // Up and Right Arrows
      } else if (event.key === 'ArrowRight' || event.key === 'ArrowUp') {
        event.preventDefault();
        event.stopPropagation();
        this.stepBack();
      }
    }

    /**
     * Move to next (lower) menu item for keyboard users.
     */
    stepForward() {
      let stepChild = 0;
      if (this.focusedChild_ !== undefined) {
        stepChild = this.focusedChild_ + 1;
      }
      this.focus(stepChild);
    }

    /**
     * Move to previous (higher) menu item for keyboard users.
     */
    stepBack() {
      let stepChild = 0;
      if (this.focusedChild_ !== undefined) {
        stepChild = this.focusedChild_ - 1;
      }
      this.focus(stepChild);
    }

    /**
     * Set focus on a {@link MenuItem} in the `Menu`.
     *
     * @param {Object|string} [item=0]
     *        Index of child item set focus on.
     */
    focus(item = 0) {
      const children = this.children().slice();
      const haveTitle = children.length && children[0].hasClass('vjs-menu-title');
      if (haveTitle) {
        children.shift();
      }
      if (children.length > 0) {
        if (item < 0) {
          item = 0;
        } else if (item >= children.length) {
          item = children.length - 1;
        }
        this.focusedChild_ = item;
        children[item].el_.focus();
      }
    }
  }
  Component.registerComponent('Menu', Menu);

  /**
   * @file menu-button.js
   */

  /** @import Player from '../player' */

  /**
   * A `MenuButton` class for any popup {@link Menu}.
   *
   * @extends Component
   */
  class MenuButton extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      super(player, options);
      this.menuButton_ = new Button(player, options);
      this.menuButton_.controlText(this.controlText_);
      this.menuButton_.el_.setAttribute('aria-haspopup', 'true');

      // Add buildCSSClass values to the button, not the wrapper
      const buttonClass = Button.prototype.buildCSSClass();
      this.menuButton_.el_.className = this.buildCSSClass() + ' ' + buttonClass;
      this.menuButton_.removeClass('vjs-control');
      this.addChild(this.menuButton_);
      this.update();
      this.enabled_ = true;
      const handleClick = e => this.handleClick(e);
      this.handleMenuKeyUp_ = e => this.handleMenuKeyUp(e);
      this.on(this.menuButton_, 'tap', handleClick);
      this.on(this.menuButton_, 'click', handleClick);
      this.on(this.menuButton_, 'keydown', e => this.handleKeyDown(e));
      this.on(this.menuButton_, 'mouseenter', () => {
        this.addClass('vjs-hover');
        this.menu.show();
        on(document__default["default"], 'keyup', this.handleMenuKeyUp_);
      });
      this.on('mouseleave', e => this.handleMouseLeave(e));
      this.on('keydown', e => this.handleSubmenuKeyDown(e));
    }

    /**
     * Update the menu based on the current state of its items.
     */
    update() {
      const menu = this.createMenu();
      if (this.menu) {
        this.menu.dispose();
        this.removeChild(this.menu);
      }
      this.menu = menu;
      this.addChild(menu);

      /**
       * Track the state of the menu button
       *
       * @type {Boolean}
       * @private
       */
      this.buttonPressed_ = false;
      this.menuButton_.el_.setAttribute('aria-expanded', 'false');
      if (this.items && this.items.length <= this.hideThreshold_) {
        this.hide();
        this.menu.contentEl_.removeAttribute('role');
      } else {
        this.show();
        this.menu.contentEl_.setAttribute('role', 'menu');
      }
    }

    /**
     * Create the menu and add all items to it.
     *
     * @return {Menu}
     *         The constructed menu
     */
    createMenu() {
      const menu = new Menu(this.player_, {
        menuButton: this
      });

      /**
       * Hide the menu if the number of items is less than or equal to this threshold. This defaults
       * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list
       * it here because every time we run `createMenu` we need to reset the value.
       *
       * @protected
       * @type {Number}
       */
      this.hideThreshold_ = 0;

      // Add a title list item to the top
      if (this.options_.title) {
        const titleEl = createEl('li', {
          className: 'vjs-menu-title',
          textContent: toTitleCase(this.options_.title),
          tabIndex: -1
        });
        const titleComponent = new Component(this.player_, {
          el: titleEl
        });
        menu.addItem(titleComponent);
      }
      this.items = this.createItems();
      if (this.items) {
        // Add menu items to the menu
        for (let i = 0; i < this.items.length; i++) {
          menu.addItem(this.items[i]);
        }
      }
      return menu;
    }

    /**
     * Create the list of menu items. Specific to each subclass.
     *
     * @abstract
     */
    createItems() {}

    /**
     * Create the `MenuButtons`s DOM element.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl() {
      return super.createEl('div', {
        className: this.buildWrapperCSSClass()
      }, {});
    }

    /**
     * Overwrites the `setIcon` method from `Component`.
     * In this case, we want the icon to be appended to the menuButton.
     *
     * @param {string} name
     *         The icon name to be added.
     */
    setIcon(name) {
      super.setIcon(name, this.menuButton_.el_);
    }

    /**
     * Allow sub components to stack CSS class names for the wrapper element
     *
     * @return {string}
     *         The constructed wrapper DOM `className`
     */
    buildWrapperCSSClass() {
      let menuButtonClass = 'vjs-menu-button';

      // If the inline option is passed, we want to use different styles altogether.
      if (this.options_.inline === true) {
        menuButtonClass += '-inline';
      } else {
        menuButtonClass += '-popup';
      }

      // TODO: Fix the CSS so that this isn't necessary
      const buttonClass = Button.prototype.buildCSSClass();
      return `vjs-menu-button ${menuButtonClass} ${buttonClass} ${super.buildCSSClass()}`;
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      let menuButtonClass = 'vjs-menu-button';

      // If the inline option is passed, we want to use different styles altogether.
      if (this.options_.inline === true) {
        menuButtonClass += '-inline';
      } else {
        menuButtonClass += '-popup';
      }
      return `vjs-menu-button ${menuButtonClass} ${super.buildCSSClass()}`;
    }

    /**
     * Get or set the localized control text that will be used for accessibility.
     *
     * > NOTE: This will come from the internal `menuButton_` element.
     *
     * @param {string} [text]
     *        Control text for element.
     *
     * @param {Element} [el=this.menuButton_.el()]
     *        Element to set the title on.
     *
     * @return {string}
     *         - The control text when getting
     */
    controlText(text, el = this.menuButton_.el()) {
      return this.menuButton_.controlText(text, el);
    }

    /**
     * Dispose of the `menu-button` and all child components.
     */
    dispose() {
      this.handleMouseLeave();
      super.dispose();
    }

    /**
     * Handle a click on a `MenuButton`.
     * See {@link ClickableComponent#handleClick} for instances where this is called.
     *
     * @param {Event} event
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      if (this.buttonPressed_) {
        this.unpressButton();
      } else {
        this.pressButton();
      }
    }

    /**
     * Handle `mouseleave` for `MenuButton`.
     *
     * @param {Event} event
     *        The `mouseleave` event that caused this function to be called.
     *
     * @listens mouseleave
     */
    handleMouseLeave(event) {
      this.removeClass('vjs-hover');
      off(document__default["default"], 'keyup', this.handleMenuKeyUp_);
    }

    /**
     * Set the focus to the actual button, not to this element
     */
    focus() {
      this.menuButton_.focus();
    }

    /**
     * Remove the focus from the actual button, not this element
     */
    blur() {
      this.menuButton_.blur();
    }

    /**
     * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See
     * {@link ClickableComponent#handleKeyDown} for instances where this is called.
     *
     * @param {Event} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      // Escape or Tab unpress the 'button'
      if (event.key === 'Esc' || event.key === 'Tab') {
        if (this.buttonPressed_) {
          this.unpressButton();
        }

        // Don't preventDefault for Tab key - we still want to lose focus
        if (!event.key === 'Tab') {
          event.preventDefault();
          // Set focus back to the menu button's button
          this.menuButton_.focus();
        }
        // Up Arrow or Down Arrow also 'press' the button to open the menu
      } else if (event.key === 'Up' || event.key === 'Down' && !(this.player_.options_.playerOptions.spatialNavigation && this.player_.options_.playerOptions.spatialNavigation.enabled)) {
        if (!this.buttonPressed_) {
          event.preventDefault();
          this.pressButton();
        }
      }
    }

    /**
     * Handle a `keyup` event on a `MenuButton`. The listener for this is added in
     * the constructor.
     *
     * @param {Event} event
     *        Key press event
     *
     * @listens keyup
     */
    handleMenuKeyUp(event) {
      // Escape hides popup menu
      if (event.key === 'Esc' || event.key === 'Tab') {
        this.removeClass('vjs-hover');
      }
    }

    /**
     * This method name now delegates to `handleSubmenuKeyDown`. This means
     * anyone calling `handleSubmenuKeyPress` will not see their method calls
     * stop working.
     *
     * @param {Event} event
     *        The event that caused this function to be called.
     */
    handleSubmenuKeyPress(event) {
      this.handleSubmenuKeyDown(event);
    }

    /**
     * Handle a `keydown` event on a sub-menu. The listener for this is added in
     * the constructor.
     *
     * @param {Event} event
     *        Key press event
     *
     * @listens keydown
     */
    handleSubmenuKeyDown(event) {
      // Escape or Tab unpress the 'button'
      if (event.key === 'Esc' || event.key === 'Tab') {
        if (this.buttonPressed_) {
          this.unpressButton();
        }
        // Don't preventDefault for Tab key - we still want to lose focus
        if (!event.key === 'Tab') {
          event.preventDefault();
          // Set focus back to the menu button's button
          this.menuButton_.focus();
        }
      }
    }

    /**
     * Put the current `MenuButton` into a pressed state.
     */
    pressButton() {
      if (this.enabled_) {
        this.buttonPressed_ = true;
        this.menu.show();
        this.menu.lockShowing();
        this.menuButton_.el_.setAttribute('aria-expanded', 'true');

        // set the focus into the submenu, except on iOS where it is resulting in
        // undesired scrolling behavior when the player is in an iframe
        if (IS_IOS && isInFrame()) {
          // Return early so that the menu isn't focused
          return;
        }
        this.menu.focus();
      }
    }

    /**
     * Take the current `MenuButton` out of a pressed state.
     */
    unpressButton() {
      if (this.enabled_) {
        this.buttonPressed_ = false;
        this.menu.unlockShowing();
        this.menu.hide();
        this.menuButton_.el_.setAttribute('aria-expanded', 'false');
      }
    }

    /**
     * Disable the `MenuButton`. Don't allow it to be clicked.
     */
    disable() {
      this.unpressButton();
      this.enabled_ = false;
      this.addClass('vjs-disabled');
      this.menuButton_.disable();
    }

    /**
     * Enable the `MenuButton`. Allow it to be clicked.
     */
    enable() {
      this.enabled_ = true;
      this.removeClass('vjs-disabled');
      this.menuButton_.enable();
    }
  }
  Component.registerComponent('MenuButton', MenuButton);

  /**
   * @file track-button.js
   */

  /** @import Player from './player' */

  /**
   * The base class for buttons that toggle specific  track types (e.g. subtitles).
   *
   * @extends MenuButton
   */
  class TrackButton extends MenuButton {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      const tracks = options.tracks;
      super(player, options);
      if (this.items.length <= 1) {
        this.hide();
      }
      if (!tracks) {
        return;
      }
      const updateHandler = bind_(this, this.update);
      tracks.addEventListener('removetrack', updateHandler);
      tracks.addEventListener('addtrack', updateHandler);
      tracks.addEventListener('labelchange', updateHandler);
      this.player_.on('ready', updateHandler);
      this.player_.on('dispose', function () {
        tracks.removeEventListener('removetrack', updateHandler);
        tracks.removeEventListener('addtrack', updateHandler);
        tracks.removeEventListener('labelchange', updateHandler);
      });
    }
  }
  Component.registerComponent('TrackButton', TrackButton);

  /**
   * @file menu-item.js
   */

  /** @import Player from '../player' */

  /**
   * The component for a menu item. `<li>`
   *
   * @extends ClickableComponent
   */
  class MenuItem extends ClickableComponent {
    /**
     * Creates an instance of the this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     *
     */
    constructor(player, options) {
      super(player, options);
      this.selectable = options.selectable;
      this.isSelected_ = options.selected || false;
      this.multiSelectable = options.multiSelectable;
      this.selected(this.isSelected_);
      if (this.selectable) {
        if (this.multiSelectable) {
          this.el_.setAttribute('role', 'menuitemcheckbox');
        } else {
          this.el_.setAttribute('role', 'menuitemradio');
        }
      } else {
        this.el_.setAttribute('role', 'menuitem');
      }
    }

    /**
     * Create the `MenuItem's DOM element
     *
     * @param {string} [type=li]
     *        Element's node type, not actually used, always set to `li`.
     *
     * @param {Object} [props={}]
     *        An object of properties that should be set on the element
     *
     * @param {Object} [attrs={}]
     *        An object of attributes that should be set on the element
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl(type, props, attrs) {
      // The control is textual, not just an icon
      this.nonIconControl = true;
      const el = super.createEl('li', Object.assign({
        className: 'vjs-menu-item',
        tabIndex: -1
      }, props), attrs);

      // swap icon with menu item text.
      const menuItemEl = createEl('span', {
        className: 'vjs-menu-item-text',
        textContent: this.localize(this.options_.label)
      });

      // If using SVG icons, the element with vjs-icon-placeholder will be added separately.
      if (this.player_.options_.experimentalSvgIcons) {
        el.appendChild(menuItemEl);
      } else {
        el.replaceChild(menuItemEl, el.querySelector('.vjs-icon-placeholder'));
      }
      return el;
    }

    /**
     * Ignore keys which are used by the menu, but pass any other ones up. See
     * {@link ClickableComponent#handleKeyDown} for instances where this is called.
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      if (!['Tab', 'Escape', 'ArrowUp', 'ArrowLeft', 'ArrowRight', 'ArrowDown'].includes(event.key)) {
        // Pass keydown handling up for unused keys
        super.handleKeyDown(event);
      }
    }

    /**
     * Any click on a `MenuItem` puts it into the selected state.
     * See {@link ClickableComponent#handleClick} for instances where this is called.
     *
     * @param {Event} event
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      this.selected(true);
    }

    /**
     * Set the state for this menu item as selected or not.
     *
     * @param {boolean} selected
     *        if the menu item is selected or not
     */
    selected(selected) {
      if (this.selectable) {
        if (selected) {
          this.addClass('vjs-selected');
          this.el_.setAttribute('aria-checked', 'true');
          // aria-checked isn't fully supported by browsers/screen readers,
          // so indicate selected state to screen reader in the control text.
          this.controlText(', selected');
          this.isSelected_ = true;
        } else {
          this.removeClass('vjs-selected');
          this.el_.setAttribute('aria-checked', 'false');
          // Indicate un-selected state to screen reader
          this.controlText('');
          this.isSelected_ = false;
        }
      }
    }
  }
  Component.registerComponent('MenuItem', MenuItem);

  /**
   * @file text-track-menu-item.js
   */

  /** @import Player from '../../player' */

  /**
   * The specific menu item type for selecting a language within a text track kind
   *
   * @extends MenuItem
   */
  class TextTrackMenuItem extends MenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      const track = options.track;
      const tracks = player.textTracks();

      // Modify options for parent MenuItem class's init.
      options.label = track.label || track.language || 'Unknown';
      options.selected = track.mode === 'showing';
      super(player, options);
      this.track = track;
      // Determine the relevant kind(s) of tracks for this component and filter
      // out empty kinds.
      this.kinds = (options.kinds || [options.kind || this.track.kind]).filter(Boolean);
      const changeHandler = (...args) => {
        this.handleTracksChange.apply(this, args);
      };
      const selectedLanguageChangeHandler = (...args) => {
        this.handleSelectedLanguageChange.apply(this, args);
      };
      player.on(['loadstart', 'texttrackchange'], changeHandler);
      tracks.addEventListener('change', changeHandler);
      tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
      this.on('dispose', function () {
        player.off(['loadstart', 'texttrackchange'], changeHandler);
        tracks.removeEventListener('change', changeHandler);
        tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
      });

      // iOS7 doesn't dispatch change events to TextTrackLists when an
      // associated track's mode changes. Without something like
      // Object.observe() (also not present on iOS7), it's not
      // possible to detect changes to the mode attribute and polyfill
      // the change event. As a poor substitute, we manually dispatch
      // change events whenever the controls modify the mode.
      if (tracks.onchange === undefined) {
        let event;
        this.on(['tap', 'click'], function () {
          if (typeof window__default["default"].Event !== 'object') {
            // Android 2.3 throws an Illegal Constructor error for window.Event
            try {
              event = new window__default["default"].Event('change');
            } catch (err) {
              // continue regardless of error
            }
          }
          if (!event) {
            event = document__default["default"].createEvent('Event');
            event.initEvent('change', true, true);
          }
          tracks.dispatchEvent(event);
        });
      }

      // set the default state based on current tracks
      this.handleTracksChange();
    }

    /**
     * This gets called when an `TextTrackMenuItem` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} event
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      const referenceTrack = this.track;
      const tracks = this.player_.textTracks();
      super.handleClick(event);
      if (!tracks) {
        return;
      }
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];

        // If the track from the text tracks list is not of the right kind,
        // skip it. We do not want to affect tracks of incompatible kind(s).
        if (this.kinds.indexOf(track.kind) === -1) {
          continue;
        }

        // If this text track is the component's track and it is not showing,
        // set it to showing.
        if (track === referenceTrack) {
          if (track.mode !== 'showing') {
            track.mode = 'showing';
          }

          // If this text track is not the component's track and it is not
          // disabled, set it to disabled.
        } else if (track.mode !== 'disabled') {
          track.mode = 'disabled';
        }
      }
    }

    /**
     * Handle text track list change
     *
     * @param {Event} event
     *        The `change` event that caused this function to be called.
     *
     * @listens TextTrackList#change
     */
    handleTracksChange(event) {
      const shouldBeSelected = this.track.mode === 'showing';

      // Prevent redundant selected() calls because they may cause
      // screen readers to read the appended control text unnecessarily
      if (shouldBeSelected !== this.isSelected_) {
        this.selected(shouldBeSelected);
      }
    }
    handleSelectedLanguageChange(event) {
      if (this.track.mode === 'showing') {
        const selectedLanguage = this.player_.cache_.selectedLanguage;

        // Don't replace the kind of track across the same language
        if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
          return;
        }
        this.player_.cache_.selectedLanguage = {
          enabled: true,
          language: this.track.language,
          kind: this.track.kind
        };
      }
    }
    dispose() {
      // remove reference to track object on dispose
      this.track = null;
      super.dispose();
    }
  }
  Component.registerComponent('TextTrackMenuItem', TextTrackMenuItem);

  /**
   * @file off-text-track-menu-item.js
   */

  /** @import Player from '../../player' */

  /**
   * A special menu item for turning off a specific type of text track
   *
   * @extends TextTrackMenuItem
   */
  class OffTextTrackMenuItem extends TextTrackMenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      // Create pseudo track info
      // Requires options['kind']
      options.track = {
        player,
        // it is no longer necessary to store `kind` or `kinds` on the track itself
        // since they are now stored in the `kinds` property of all instances of
        // TextTrackMenuItem, but this will remain for backwards compatibility
        kind: options.kind,
        kinds: options.kinds,
        default: false,
        mode: 'disabled'
      };
      if (!options.kinds) {
        options.kinds = [options.kind];
      }
      if (options.label) {
        options.track.label = options.label;
      } else {
        options.track.label = options.kinds.join(' and ') + ' off';
      }

      // MenuItem is selectable
      options.selectable = true;
      // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
      options.multiSelectable = false;
      super(player, options);
    }

    /**
     * Handle text track change
     *
     * @param {Event} event
     *        The event that caused this function to run
     */
    handleTracksChange(event) {
      const tracks = this.player().textTracks();
      let shouldBeSelected = true;
      for (let i = 0, l = tracks.length; i < l; i++) {
        const track = tracks[i];
        if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {
          shouldBeSelected = false;
          break;
        }
      }

      // Prevent redundant selected() calls because they may cause
      // screen readers to read the appended control text unnecessarily
      if (shouldBeSelected !== this.isSelected_) {
        this.selected(shouldBeSelected);
      }
    }
    handleSelectedLanguageChange(event) {
      const tracks = this.player().textTracks();
      let allHidden = true;
      for (let i = 0, l = tracks.length; i < l; i++) {
        const track = tracks[i];
        if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {
          allHidden = false;
          break;
        }
      }
      if (allHidden) {
        this.player_.cache_.selectedLanguage = {
          enabled: false
        };
      }
    }

    /**
     * Update control text and label on languagechange
     */
    handleLanguagechange() {
      this.$('.vjs-menu-item-text').textContent = this.player_.localize(this.options_.label);
      super.handleLanguagechange();
    }
  }
  Component.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);

  /**
   * @file text-track-button.js
   */

  /** @import Player from '../../player' */

  /**
   * The base class for buttons that toggle specific text track types (e.g. subtitles)
   *
   * @extends MenuButton
   */
  class TextTrackButton extends TrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      options.tracks = player.textTracks();
      super(player, options);
    }

    /**
     * Create a menu item for each text track
     *
     * @param {TextTrackMenuItem[]} [items=[]]
     *        Existing array of items to use during creation
     *
     * @return {TextTrackMenuItem[]}
     *         Array of menu items that were created
     */
    createItems(items = [], TrackMenuItem = TextTrackMenuItem) {
      // Label is an override for the [track] off label
      // USed to localise captions/subtitles
      let label;
      if (this.label_) {
        label = `${this.label_} off`;
      }
      // Add an OFF menu item to turn all tracks off
      items.push(new OffTextTrackMenuItem(this.player_, {
        kinds: this.kinds_,
        kind: this.kind_,
        label
      }));
      this.hideThreshold_ += 1;
      const tracks = this.player_.textTracks();
      if (!Array.isArray(this.kinds_)) {
        this.kinds_ = [this.kind_];
      }
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];

        // only add tracks that are of an appropriate kind and have a label
        if (this.kinds_.indexOf(track.kind) > -1) {
          const item = new TrackMenuItem(this.player_, {
            track,
            kinds: this.kinds_,
            kind: this.kind_,
            // MenuItem is selectable
            selectable: true,
            // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
            multiSelectable: false
          });
          item.addClass(`vjs-${track.kind}-menu-item`);
          items.push(item);
        }
      }
      return items;
    }
  }
  Component.registerComponent('TextTrackButton', TextTrackButton);

  /**
   * @file chapters-track-menu-item.js
   */

  /** @import Player from '../../player' */

  /**
   * The chapter track menu item
   *
   * @extends MenuItem
   */
  class ChaptersTrackMenuItem extends MenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      const track = options.track;
      const cue = options.cue;
      const currentTime = player.currentTime();

      // Modify options for parent MenuItem class's init.
      options.selectable = true;
      options.multiSelectable = false;
      options.label = cue.text;
      options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
      super(player, options);
      this.track = track;
      this.cue = cue;
    }

    /**
     * This gets called when an `ChaptersTrackMenuItem` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      super.handleClick();
      this.player_.currentTime(this.cue.startTime);
    }
  }
  Component.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);

  /**
   * @file chapters-button.js
   */

  /** @import Player from '../../player' */
  /** @import Menu from '../../menu/menu' */
  /** @import TextTrack from '../../tracks/text-track' */
  /** @import TextTrackMenuItem from '../text-track-controls/text-track-menu-item' */

  /**
   * The button component for toggling and selecting chapters
   * Chapters act much differently than other text tracks
   * Cues are navigation vs. other tracks of alternative languages
   *
   * @extends TextTrackButton
   */
  class ChaptersButton extends TextTrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when this function is ready.
     */
    constructor(player, options, ready) {
      super(player, options, ready);
      this.setIcon('chapters');
      this.selectCurrentItem_ = () => {
        this.items.forEach(item => {
          item.selected(this.track_.activeCues[0] === item.cue);
        });
      };
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-chapters-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-chapters-button ${super.buildWrapperCSSClass()}`;
    }

    /**
     * Update the menu based on the current state of its items.
     *
     * @param {Event} [event]
     *        An event that triggered this function to run.
     *
     * @listens TextTrackList#addtrack
     * @listens TextTrackList#removetrack
     * @listens TextTrackList#change
     */
    update(event) {
      if (event && event.track && event.track.kind !== 'chapters') {
        return;
      }
      const track = this.findChaptersTrack();
      if (track !== this.track_) {
        this.setTrack(track);
        super.update();
      } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) {
        // Update the menu initially or if the number of cues has changed since set
        super.update();
      }
    }

    /**
     * Set the currently selected track for the chapters button.
     *
     * @param {TextTrack} track
     *        The new track to select. Nothing will change if this is the currently selected
     *        track.
     */
    setTrack(track) {
      if (this.track_ === track) {
        return;
      }
      if (!this.updateHandler_) {
        this.updateHandler_ = this.update.bind(this);
      }

      // here this.track_ refers to the old track instance
      if (this.track_) {
        const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        if (remoteTextTrackEl) {
          remoteTextTrackEl.removeEventListener('load', this.updateHandler_);
        }
        this.track_.removeEventListener('cuechange', this.selectCurrentItem_);
        this.track_ = null;
      }
      this.track_ = track;

      // here this.track_ refers to the new track instance
      if (this.track_) {
        this.track_.mode = 'hidden';
        const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        if (remoteTextTrackEl) {
          remoteTextTrackEl.addEventListener('load', this.updateHandler_);
        }
        this.track_.addEventListener('cuechange', this.selectCurrentItem_);
      }
    }

    /**
     * Find the track object that is currently in use by this ChaptersButton
     *
     * @return {TextTrack|undefined}
     *         The current track or undefined if none was found.
     */
    findChaptersTrack() {
      const tracks = this.player_.textTracks() || [];
      for (let i = tracks.length - 1; i >= 0; i--) {
        // We will always choose the last track as our chaptersTrack
        const track = tracks[i];
        if (track.kind === this.kind_) {
          return track;
        }
      }
    }

    /**
     * Get the caption for the ChaptersButton based on the track label. This will also
     * use the current tracks localized kind as a fallback if a label does not exist.
     *
     * @return {string}
     *         The tracks current label or the localized track kind.
     */
    getMenuCaption() {
      if (this.track_ && this.track_.label) {
        return this.track_.label;
      }
      return this.localize(toTitleCase(this.kind_));
    }

    /**
     * Create menu from chapter track
     *
     * @return {Menu}
     *         New menu for the chapter buttons
     */
    createMenu() {
      this.options_.title = this.getMenuCaption();
      return super.createMenu();
    }

    /**
     * Create a menu item for each text track
     *
     * @return  {TextTrackMenuItem[]}
     *         Array of menu items
     */
    createItems() {
      const items = [];
      if (!this.track_) {
        return items;
      }
      const cues = this.track_.cues;
      if (!cues) {
        return items;
      }
      for (let i = 0, l = cues.length; i < l; i++) {
        const cue = cues[i];
        const mi = new ChaptersTrackMenuItem(this.player_, {
          track: this.track_,
          cue
        });
        items.push(mi);
      }
      return items;
    }
  }

  /**
   * `kind` of TextTrack to look for to associate it with this menu.
   *
   * @type {string}
   * @private
   */
  ChaptersButton.prototype.kind_ = 'chapters';

  /**
   * The text that should display over the `ChaptersButton`s controls. Added for localization.
   *
   * @type {string}
   * @protected
   */
  ChaptersButton.prototype.controlText_ = 'Chapters';
  Component.registerComponent('ChaptersButton', ChaptersButton);

  /**
   * @file descriptions-button.js
   */

  /** @import Player from '../../player' */

  /**
   * The button component for toggling and selecting descriptions
   *
   * @extends TextTrackButton
   */
  class DescriptionsButton extends TextTrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when this component is ready.
     */
    constructor(player, options, ready) {
      super(player, options, ready);
      this.setIcon('audio-description');
      const tracks = player.textTracks();
      const changeHandler = bind_(this, this.handleTracksChange);
      tracks.addEventListener('change', changeHandler);
      this.on('dispose', function () {
        tracks.removeEventListener('change', changeHandler);
      });
    }

    /**
     * Handle text track change
     *
     * @param {Event} event
     *        The event that caused this function to run
     *
     * @listens TextTrackList#change
     */
    handleTracksChange(event) {
      const tracks = this.player().textTracks();
      let disabled = false;

      // Check whether a track of a different kind is showing
      for (let i = 0, l = tracks.length; i < l; i++) {
        const track = tracks[i];
        if (track.kind !== this.kind_ && track.mode === 'showing') {
          disabled = true;
          break;
        }
      }

      // If another track is showing, disable this menu button
      if (disabled) {
        this.disable();
      } else {
        this.enable();
      }
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-descriptions-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`;
    }
  }

  /**
   * `kind` of TextTrack to look for to associate it with this menu.
   *
   * @type {string}
   * @private
   */
  DescriptionsButton.prototype.kind_ = 'descriptions';

  /**
   * The text that should display over the `DescriptionsButton`s controls. Added for localization.
   *
   * @type {string}
   * @protected
   */
  DescriptionsButton.prototype.controlText_ = 'Descriptions';
  Component.registerComponent('DescriptionsButton', DescriptionsButton);

  /**
   * @file subtitles-button.js
   */

  /** @import Player from '../../player' */

  /**
   * The button component for toggling and selecting subtitles
   *
   * @extends TextTrackButton
   */
  class SubtitlesButton extends TextTrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when this component is ready.
     */
    constructor(player, options, ready) {
      super(player, options, ready);
      this.setIcon('subtitles');
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-subtitles-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`;
    }
  }

  /**
   * `kind` of TextTrack to look for to associate it with this menu.
   *
   * @type {string}
   * @private
   */
  SubtitlesButton.prototype.kind_ = 'subtitles';

  /**
   * The text that should display over the `SubtitlesButton`s controls. Added for localization.
   *
   * @type {string}
   * @protected
   */
  SubtitlesButton.prototype.controlText_ = 'Subtitles';
  Component.registerComponent('SubtitlesButton', SubtitlesButton);

  /**
   * @file caption-settings-menu-item.js
   */

  /** @import Player from '../../player' */

  /**
   * The menu item for caption track settings menu
   *
   * @extends TextTrackMenuItem
   */
  class CaptionSettingsMenuItem extends TextTrackMenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      options.track = {
        player,
        kind: options.kind,
        label: options.kind + ' settings',
        selectable: false,
        default: false,
        mode: 'disabled'
      };

      // CaptionSettingsMenuItem has no concept of 'selected'
      options.selectable = false;
      options.name = 'CaptionSettingsMenuItem';
      super(player, options);
      this.addClass('vjs-texttrack-settings');
      this.controlText(', opens ' + options.kind + ' settings dialog');
    }

    /**
     * This gets called when an `CaptionSettingsMenuItem` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      this.player().getChild('textTrackSettings').open();
    }

    /**
     * Update control text and label on languagechange
     */
    handleLanguagechange() {
      this.$('.vjs-menu-item-text').textContent = this.player_.localize(this.options_.kind + ' settings');
      super.handleLanguagechange();
    }
  }
  Component.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);

  /**
   * @file captions-button.js
   */

  /** @import Player from '../../player' */

  /**
   * The button component for toggling and selecting captions
   *
   * @extends TextTrackButton
   */
  class CaptionsButton extends TextTrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when this component is ready.
     */
    constructor(player, options, ready) {
      super(player, options, ready);
      this.setIcon('captions');
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-captions-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-captions-button ${super.buildWrapperCSSClass()}`;
    }

    /**
     * Create caption menu items
     *
     * @return {CaptionSettingsMenuItem[]}
     *         The array of current menu items.
     */
    createItems() {
      const items = [];
      if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {
        items.push(new CaptionSettingsMenuItem(this.player_, {
          kind: this.kind_
        }));
        this.hideThreshold_ += 1;
      }
      return super.createItems(items);
    }
  }

  /**
   * `kind` of TextTrack to look for to associate it with this menu.
   *
   * @type {string}
   * @private
   */
  CaptionsButton.prototype.kind_ = 'captions';

  /**
   * The text that should display over the `CaptionsButton`s controls. Added for localization.
   *
   * @type {string}
   * @protected
   */
  CaptionsButton.prototype.controlText_ = 'Captions';
  Component.registerComponent('CaptionsButton', CaptionsButton);

  /**
   * @file subs-caps-menu-item.js
   */

  /**
   * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles
   * in the SubsCapsMenu.
   *
   * @extends TextTrackMenuItem
   */
  class SubsCapsMenuItem extends TextTrackMenuItem {
    createEl(type, props, attrs) {
      const el = super.createEl(type, props, attrs);
      const parentSpan = el.querySelector('.vjs-menu-item-text');
      if (this.options_.track.kind === 'captions') {
        if (this.player_.options_.experimentalSvgIcons) {
          this.setIcon('captions', el);
        } else {
          parentSpan.appendChild(createEl('span', {
            className: 'vjs-icon-placeholder'
          }, {
            'aria-hidden': true
          }));
        }
        parentSpan.appendChild(createEl('span', {
          className: 'vjs-control-text',
          // space added as the text will visually flow with the
          // label
          textContent: ` ${this.localize('Captions')}`
        }));
      }
      return el;
    }
  }
  Component.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);

  /**
   * @file sub-caps-button.js
   */

  /** @import Player from '../../player' */

  /**
   * The button component for toggling and selecting captions and/or subtitles
   *
   * @extends TextTrackButton
   */
  class SubsCapsButton extends TextTrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when this component is ready.
     */
    constructor(player, options = {}) {
      super(player, options);

      // Although North America uses "captions" in most cases for
      // "captions and subtitles" other locales use "subtitles"
      this.label_ = 'subtitles';
      this.setIcon('subtitles');
      if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(this.player_.language_) > -1) {
        this.label_ = 'captions';
        this.setIcon('captions');
      }
      this.menuButton_.controlText(toTitleCase(this.label_));
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-subs-caps-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`;
    }

    /**
     * Create caption/subtitles menu items
     *
     * @return {CaptionSettingsMenuItem[]}
     *         The array of current menu items.
     */
    createItems() {
      let items = [];
      if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {
        items.push(new CaptionSettingsMenuItem(this.player_, {
          kind: this.label_
        }));
        this.hideThreshold_ += 1;
      }
      items = super.createItems(items, SubsCapsMenuItem);
      return items;
    }
  }

  /**
   * `kind`s of TextTrack to look for to associate it with this menu.
   *
   * @type {array}
   * @private
   */
  SubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];

  /**
   * The text that should display over the `SubsCapsButton`s controls.
   *
   *
   * @type {string}
   * @protected
   */
  SubsCapsButton.prototype.controlText_ = 'Subtitles';
  Component.registerComponent('SubsCapsButton', SubsCapsButton);

  /**
   * @file audio-track-menu-item.js
   */

  /** @import Player from '../../player' */

  /**
   * An {@link AudioTrack} {@link MenuItem}
   *
   * @extends MenuItem
   */
  class AudioTrackMenuItem extends MenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      const track = options.track;
      const tracks = player.audioTracks();

      // Modify options for parent MenuItem class's init.
      options.label = track.label || track.language || 'Unknown';
      options.selected = track.enabled;
      super(player, options);
      this.track = track;
      this.addClass(`vjs-${track.kind}-menu-item`);
      const changeHandler = (...args) => {
        this.handleTracksChange.apply(this, args);
      };
      tracks.addEventListener('change', changeHandler);
      this.on('dispose', () => {
        tracks.removeEventListener('change', changeHandler);
      });
    }
    createEl(type, props, attrs) {
      const el = super.createEl(type, props, attrs);
      const parentSpan = el.querySelector('.vjs-menu-item-text');
      if (['main-desc', 'descriptions'].indexOf(this.options_.track.kind) >= 0) {
        parentSpan.appendChild(createEl('span', {
          className: 'vjs-icon-placeholder'
        }, {
          'aria-hidden': true
        }));
        parentSpan.appendChild(createEl('span', {
          className: 'vjs-control-text',
          textContent: ' ' + this.localize('Descriptions')
        }));
      }
      return el;
    }

    /**
     * This gets called when an `AudioTrackMenuItem is "clicked". See {@link ClickableComponent}
     * for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      super.handleClick(event);

      // the audio track list will automatically toggle other tracks
      // off for us.
      this.track.enabled = true;

      // when native audio tracks are used, we want to make sure that other tracks are turned off
      if (this.player_.tech_.featuresNativeAudioTracks) {
        const tracks = this.player_.audioTracks();
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];

          // skip the current track since we enabled it above
          if (track === this.track) {
            continue;
          }
          track.enabled = track === this.track;
        }
      }
    }

    /**
     * Handle any {@link AudioTrack} change.
     *
     * @param {Event} [event]
     *        The {@link AudioTrackList#change} event that caused this to run.
     *
     * @listens AudioTrackList#change
     */
    handleTracksChange(event) {
      this.selected(this.track.enabled);
    }
  }
  Component.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);

  /**
   * @file audio-track-button.js
   */

  /**
   * The base class for buttons that toggle specific {@link AudioTrack} types.
   *
   * @extends TrackButton
   */
  class AudioTrackButton extends TrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      options.tracks = player.audioTracks();
      super(player, options);
      this.setIcon('audio');
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-audio-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-audio-button ${super.buildWrapperCSSClass()}`;
    }

    /**
     * Create a menu item for each audio track
     *
     * @param {AudioTrackMenuItem[]} [items=[]]
     *        An array of existing menu items to use.
     *
     * @return {AudioTrackMenuItem[]}
     *         An array of menu items
     */
    createItems(items = []) {
      // if there's only one audio track, there no point in showing it
      this.hideThreshold_ = 1;
      const tracks = this.player_.audioTracks();
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];
        items.push(new AudioTrackMenuItem(this.player_, {
          track,
          // MenuItem is selectable
          selectable: true,
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: false
        }));
      }
      return items;
    }
  }

  /**
   * The text that should display over the `AudioTrackButton`s controls. Added for localization.
   *
   * @type {string}
   * @protected
   */
  AudioTrackButton.prototype.controlText_ = 'Audio Track';
  Component.registerComponent('AudioTrackButton', AudioTrackButton);

  /**
   * @file playback-rate-menu-item.js
   */

  /** @import Player from '../../player' */

  /**
   * The specific menu item type for selecting a playback rate.
   *
   * @extends MenuItem
   */
  class PlaybackRateMenuItem extends MenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      const label = options.rate;
      const rate = parseFloat(label, 10);

      // Modify options for parent MenuItem class's init.
      options.label = label;
      options.selected = rate === player.playbackRate();
      options.selectable = true;
      options.multiSelectable = false;
      super(player, options);
      this.label = label;
      this.rate = rate;
      this.on(player, 'ratechange', e => this.update(e));
    }

    /**
     * This gets called when an `PlaybackRateMenuItem` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      super.handleClick();
      this.player().playbackRate(this.rate);
    }

    /**
     * Update the PlaybackRateMenuItem when the playbackrate changes.
     *
     * @param {Event} [event]
     *        The `ratechange` event that caused this function to run.
     *
     * @listens Player#ratechange
     */
    update(event) {
      this.selected(this.player().playbackRate() === this.rate);
    }
  }

  /**
   * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.
   *
   * @type {string}
   * @private
   */
  PlaybackRateMenuItem.prototype.contentElType = 'button';
  Component.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);

  /**
   * @file playback-rate-menu-button.js
   */

  /** @import Player from '../../player' */

  /**
   * The component for controlling the playback rate.
   *
   * @extends MenuButton
   */
  class PlaybackRateMenuButton extends MenuButton {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.menuButton_.el_.setAttribute('aria-describedby', this.labelElId_);
      this.updateVisibility();
      this.updateLabel();
      this.on(player, 'loadstart', e => this.updateVisibility(e));
      this.on(player, 'ratechange', e => this.updateLabel(e));
      this.on(player, 'playbackrateschange', e => this.handlePlaybackRateschange(e));
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl();
      this.labelElId_ = 'vjs-playback-rate-value-label-' + this.id_;
      this.labelEl_ = createEl('div', {
        className: 'vjs-playback-rate-value',
        id: this.labelElId_,
        textContent: '1x'
      });
      el.appendChild(this.labelEl_);
      return el;
    }
    dispose() {
      this.labelEl_ = null;
      super.dispose();
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-playback-rate ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-playback-rate ${super.buildWrapperCSSClass()}`;
    }

    /**
     * Create the list of menu items. Specific to each subclass.
     *
     */
    createItems() {
      const rates = this.playbackRates();
      const items = [];
      for (let i = rates.length - 1; i >= 0; i--) {
        items.push(new PlaybackRateMenuItem(this.player(), {
          rate: rates[i] + 'x'
        }));
      }
      return items;
    }

    /**
     * On playbackrateschange, update the menu to account for the new items.
     *
     * @listens Player#playbackrateschange
     */
    handlePlaybackRateschange(event) {
      this.update();
    }

    /**
     * Get possible playback rates
     *
     * @return {Array}
     *         All possible playback rates
     */
    playbackRates() {
      const player = this.player();
      return player.playbackRates && player.playbackRates() || [];
    }

    /**
     * Get whether playback rates is supported by the tech
     * and an array of playback rates exists
     *
     * @return {boolean}
     *         Whether changing playback rate is supported
     */
    playbackRateSupported() {
      return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
    }

    /**
     * Hide playback rate controls when they're no playback rate options to select
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#loadstart
     */
    updateVisibility(event) {
      if (this.playbackRateSupported()) {
        this.removeClass('vjs-hidden');
      } else {
        this.addClass('vjs-hidden');
      }
    }

    /**
     * Update button label when rate changed
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#ratechange
     */
    updateLabel(event) {
      if (this.playbackRateSupported()) {
        this.labelEl_.textContent = this.player().playbackRate() + 'x';
      }
    }
  }

  /**
   * The text that should display over the `PlaybackRateMenuButton`s controls.
   *
   * Added for localization.
   *
   * @type {string}
   * @protected
   */
  PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';
  Component.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);

  /**
   * @file spacer.js
   */

  /**
   * Just an empty spacer element that can be used as an append point for plugins, etc.
   * Also can be used to create space between elements when necessary.
   *
   * @extends Component
   */
  class Spacer extends Component {
    /**
    * Builds the default DOM `className`.
    *
    * @return {string}
    *         The DOM `className` for this object.
    */
    buildCSSClass() {
      return `vjs-spacer ${super.buildCSSClass()}`;
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl(tag = 'div', props = {}, attributes = {}) {
      if (!props.className) {
        props.className = this.buildCSSClass();
      }
      return super.createEl(tag, props, attributes);
    }
  }
  Component.registerComponent('Spacer', Spacer);

  /**
   * @file custom-control-spacer.js
   */

  /**
   * Spacer specifically meant to be used as an insertion point for new plugins, etc.
   *
   * @extends Spacer
   */
  class CustomControlSpacer extends Spacer {
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-custom-control-spacer ${super.buildCSSClass()}`;
    }

    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl('div', {
        className: this.buildCSSClass(),
        // No-flex/table-cell mode requires there be some content
        // in the cell to fill the remaining space of the table.
        textContent: '\u00a0'
      });
    }
  }
  Component.registerComponent('CustomControlSpacer', CustomControlSpacer);

  /**
   * @file control-bar.js
   */

  /**
   * Container of main controls.
   *
   * @extends Component
   */
  class ControlBar extends Component {
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl('div', {
        className: 'vjs-control-bar',
        dir: 'ltr'
      });
    }
  }

  /**
   * Default options for `ControlBar`
   *
   * @type {Object}
   * @private
   */
  ControlBar.prototype.options_ = {
    children: ['playToggle', 'skipBackward', 'skipForward', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'seekToLive', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'pictureInPictureToggle', 'fullscreenToggle']
  };
  Component.registerComponent('ControlBar', ControlBar);

  /**
   * @file error-display.js
   */

  /** @import Player from './player' */

  /**
   * A display that indicates an error has occurred. This means that the video
   * is unplayable.
   *
   * @extends ModalDialog
   */
  class ErrorDisplay extends ModalDialog {
    /**
     * Creates an instance of this class.
     *
     * @param  {Player} player
     *         The `Player` that this class should be attached to.
     *
     * @param  {Object} [options]
     *         The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.on(player, 'error', e => {
        this.open(e);
      });
    }

    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     *
     * @deprecated Since version 5.
     */
    buildCSSClass() {
      return `vjs-error-display ${super.buildCSSClass()}`;
    }

    /**
     * Gets the localized error message based on the `Player`s error.
     *
     * @return {string}
     *         The `Player`s error message localized or an empty string.
     */
    content() {
      const error = this.player().error();
      return error ? this.localize(error.message) : '';
    }
  }

  /**
   * The default options for an `ErrorDisplay`.
   *
   * @private
   */
  ErrorDisplay.prototype.options_ = Object.assign({}, ModalDialog.prototype.options_, {
    pauseOnOpen: false,
    fillAlways: true,
    temporary: false,
    uncloseable: true
  });
  Component.registerComponent('ErrorDisplay', ErrorDisplay);

  /** @import Player from './player' */
  /** @import { ContentDescriptor } from  '../utils/dom' */

  /**
   * Creates DOM element of 'select' & its options.
   *
   * @extends Component
   */
  class TextTrackSelect extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {ContentDescriptor} [options.content=undefined]
     *        Provide customized content for this modal.
     *
     * @param {string} [options.legendId]
     *        A text with part of an string to create atribute of aria-labelledby.
     *
     * @param {string} [options.id]
     *        A text with part of an string to create atribute of aria-labelledby.
     *
     * @param {Array} [options.SelectOptions]
     *        Array that contains the value & textContent of for each of the
     *        options elements.
     */
    constructor(player, options = {}) {
      super(player, options);
      this.el_.setAttribute('aria-labelledby', this.selectLabelledbyIds);
    }

    /**
     * Create the `TextTrackSelect`'s DOM element
     *
     * @return {Element}
     *         The DOM element that gets created.
     */
    createEl() {
      this.selectLabelledbyIds = [this.options_.legendId, this.options_.labelId].join(' ').trim();

      // Create select & inner options
      const selectoptions = createEl('select', {
        id: this.options_.id
      }, {}, this.options_.SelectOptions.map(optionText => {
        // Constructs an id for the <option>.
        // For the colour settings that have two <selects> with a <label> each, generates an id based off the label value
        // For font size/family and edge style with one <select> and no <label>, generates an id with a guid
        const optionId = (this.options_.labelId ? this.options_.labelId : `vjs-track-option-${newGUID()}`) + '-' + optionText[1].replace(/\W+/g, '');
        const option = createEl('option', {
          id: optionId,
          value: this.localize(optionText[0]),
          textContent: optionText[1]
        });
        option.setAttribute('aria-labelledby', `${this.selectLabelledbyIds} ${optionId}`);
        return option;
      }));
      return selectoptions;
    }
  }
  Component.registerComponent('TextTrackSelect', TextTrackSelect);

  /** @import Player from './player' */
  /** @import { ContentDescriptor } from '../utils/dom' */

  /**
   * Creates fieldset section of 'TextTrackSettings'.
   * Manganes two versions of fieldsets, one for type of 'colors'
   * & the other for 'font', Component adds diferent DOM elements
   * to that fieldset  depending on the type.
   *
   * @extends Component
   */
  class TextTrackFieldset extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {ContentDescriptor} [options.content=undefined]
     *        Provide customized content for this modal.
     *
     * @param {string} [options.legendId]
     *        A text with part of an string to create atribute of aria-labelledby.
     *        It passes to 'TextTrackSelect'.
     *
     * @param {string} [options.id]
     *        A text with part of an string to create atribute of aria-labelledby.
     *        It passes to 'TextTrackSelect'.
     *
     * @param {string} [options.legendText]
     *        A text to use as the text content of the legend element.
     *
     * @param {Array} [options.selects]
     *        Array that contains the selects that are use to create 'selects'
     *        components.
     *
     * @param {Array} [options.SelectOptions]
     *        Array that contains the value & textContent of for each of the
     *        options elements, it passes to 'TextTrackSelect'.
     *
     * @param {string} [options.type]
     *        Conditions if some DOM elements will be added to the fieldset
     *        component.
     *
     * @param {Object} [options.selectConfigs]
     *        Object with the following properties that are the selects configurations:
     *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
     *        fontPercent, textOpacity, windowColor, windowOpacity.
     *        These properties are use to configure the 'TextTrackSelect' Component.
     */
    constructor(player, options = {}) {
      super(player, options);

      // Add Components & DOM Elements
      const legendElement = createEl('legend', {
        textContent: this.localize(this.options_.legendText),
        id: this.options_.legendId
      });
      this.el().appendChild(legendElement);
      const selects = this.options_.selects;

      // Iterate array of selects to create 'selects' components
      for (const i of selects) {
        const selectConfig = this.options_.selectConfigs[i];
        const selectClassName = selectConfig.className;
        const id = selectConfig.id.replace('%s', this.options_.id_);
        let span = null;
        const guid = `vjs_select_${newGUID()}`;

        // Conditionally create span to add on the component
        if (this.options_.type === 'colors') {
          span = createEl('span', {
            className: selectClassName
          });
          const label = createEl('label', {
            id,
            className: 'vjs-label',
            textContent: selectConfig.label
          });
          label.setAttribute('for', guid);
          span.appendChild(label);
        }
        const textTrackSelect = new TextTrackSelect(player, {
          SelectOptions: selectConfig.options,
          legendId: this.options_.legendId,
          id: guid,
          labelId: id
        });
        this.addChild(textTrackSelect);

        // Conditionally append to 'select' component to conditionally created span
        if (this.options_.type === 'colors') {
          span.appendChild(textTrackSelect.el());
          this.el().appendChild(span);
        }
      }
    }

    /**
     * Create the `TextTrackFieldset`'s DOM element
     *
     * @return {Element}
     *         The DOM element that gets created.
     */
    createEl() {
      const el = createEl('fieldset', {
        // Prefixing classes of elements within a player with "vjs-"
        // is a convention used in Video.js.
        className: this.options_.className
      });
      return el;
    }
  }
  Component.registerComponent('TextTrackFieldset', TextTrackFieldset);

  /** @import Player from './player' */
  /** @import { ContentDescriptor } from  '../utils/dom' */

  /**
   * The component 'TextTrackSettingsColors' displays a set of 'fieldsets'
   * using the component 'TextTrackFieldset'.
   *
   * @extends Component
   */
  class TextTrackSettingsColors extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {ContentDescriptor} [options.content=undefined]
     *        Provide customized content for this modal.
     *
     * @param {Array} [options.fieldSets]
     *        Array that contains the configurations for the selects.
     *
     * @param {Object} [options.selectConfigs]
     *        Object with the following properties that are the select confugations:
     *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
     *        fontPercent, textOpacity, windowColor, windowOpacity.
     *        it passes to 'TextTrackFieldset'.
     */
    constructor(player, options = {}) {
      super(player, options);
      const id_ = this.options_.textTrackComponentid;

      // createElFgColor_
      const ElFgColorFieldset = new TextTrackFieldset(player, {
        id_,
        legendId: `captions-text-legend-${id_}`,
        legendText: this.localize('Text'),
        className: 'vjs-fg vjs-track-setting',
        selects: this.options_.fieldSets[0],
        selectConfigs: this.options_.selectConfigs,
        type: 'colors'
      });
      this.addChild(ElFgColorFieldset);

      // createElBgColor_
      const ElBgColorFieldset = new TextTrackFieldset(player, {
        id_,
        legendId: `captions-background-${id_}`,
        legendText: this.localize('Text Background'),
        className: 'vjs-bg vjs-track-setting',
        selects: this.options_.fieldSets[1],
        selectConfigs: this.options_.selectConfigs,
        type: 'colors'
      });
      this.addChild(ElBgColorFieldset);

      // createElWinColor_
      const ElWinColorFieldset = new TextTrackFieldset(player, {
        id_,
        legendId: `captions-window-${id_}`,
        legendText: this.localize('Caption Area Background'),
        className: 'vjs-window vjs-track-setting',
        selects: this.options_.fieldSets[2],
        selectConfigs: this.options_.selectConfigs,
        type: 'colors'
      });
      this.addChild(ElWinColorFieldset);
    }

    /**
     * Create the `TextTrackSettingsColors`'s DOM element
     *
     * @return {Element}
     *         The DOM element that gets created.
     */
    createEl() {
      const el = createEl('div', {
        className: 'vjs-track-settings-colors'
      });
      return el;
    }
  }
  Component.registerComponent('TextTrackSettingsColors', TextTrackSettingsColors);

  /** @import Player from './player' */
  /** @import { ContentDescriptor } from  '../utils/dom' */

  /**
   * The component 'TextTrackSettingsFont' displays a set of 'fieldsets'
   * using the component 'TextTrackFieldset'.
   *
   * @extends Component
   */
  class TextTrackSettingsFont extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {ContentDescriptor} [options.content=undefined]
     *        Provide customized content for this modal.
     *
     * @param {Array} [options.fieldSets]
     *        Array that contains the configurations for the selects.
     *
     * @param {Object} [options.selectConfigs]
     *        Object with the following properties that are the select confugations:
     *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
     *        fontPercent, textOpacity, windowColor, windowOpacity.
     *        it passes to 'TextTrackFieldset'.
     */
    constructor(player, options = {}) {
      super(player, options);
      const id_ = this.options_.textTrackComponentid;
      const ElFgColorFieldset = new TextTrackFieldset(player, {
        id_,
        legendId: `captions-font-size-${id_}`,
        legendText: 'Font Size',
        className: 'vjs-font-percent vjs-track-setting',
        selects: this.options_.fieldSets[0],
        selectConfigs: this.options_.selectConfigs,
        type: 'font'
      });
      this.addChild(ElFgColorFieldset);
      const ElBgColorFieldset = new TextTrackFieldset(player, {
        id_,
        legendId: `captions-edge-style-${id_}`,
        legendText: this.localize('Text Edge Style'),
        className: 'vjs-edge-style vjs-track-setting',
        selects: this.options_.fieldSets[1],
        selectConfigs: this.options_.selectConfigs,
        type: 'font'
      });
      this.addChild(ElBgColorFieldset);
      const ElWinColorFieldset = new TextTrackFieldset(player, {
        id_,
        legendId: `captions-font-family-${id_}`,
        legendText: this.localize('Font Family'),
        className: 'vjs-font-family vjs-track-setting',
        selects: this.options_.fieldSets[2],
        selectConfigs: this.options_.selectConfigs,
        type: 'font'
      });
      this.addChild(ElWinColorFieldset);
    }

    /**
     * Create the `TextTrackSettingsFont`'s DOM element
     *
     * @return {Element}
     *         The DOM element that gets created.
     */
    createEl() {
      const el = createEl('div', {
        className: 'vjs-track-settings-font'
      });
      return el;
    }
  }
  Component.registerComponent('TextTrackSettingsFont', TextTrackSettingsFont);

  /**
   * Buttons of reset & done that modal 'TextTrackSettings'
   * uses as part of its content.
   *
   * 'Reset': Resets all settings on 'TextTrackSettings'.
   * 'Done': Closes 'TextTrackSettings' modal.
   *
   * @extends Component
   */
  class TrackSettingsControls extends Component {
    constructor(player, options = {}) {
      super(player, options);

      // Create DOM elements
      const defaultsDescription = this.localize('restore all settings to the default values');
      const resetButton = new Button(player, {
        controlText: defaultsDescription,
        className: 'vjs-default-button'
      });
      resetButton.el().classList.remove('vjs-control', 'vjs-button');
      resetButton.el().textContent = this.localize('Reset');
      this.addChild(resetButton);
      const doneButton = new Button(player, {
        controlText: defaultsDescription,
        className: 'vjs-done-button'
      });

      // Remove unrequired style classes
      doneButton.el().classList.remove('vjs-control', 'vjs-button');
      doneButton.el().textContent = this.localize('Done');
      this.addChild(doneButton);
    }

    /**
     * Create the `TrackSettingsControls`'s DOM element
     *
     * @return {Element}
     *         The DOM element that gets created.
     */
    createEl() {
      const el = createEl('div', {
        className: 'vjs-track-settings-controls'
      });
      return el;
    }
  }
  Component.registerComponent('TrackSettingsControls', TrackSettingsControls);

  /**
   * @file text-track-settings.js
   */

  /** @import Player from '../player' */

  const LOCAL_STORAGE_KEY = 'vjs-text-track-settings';
  const COLOR_BLACK = ['#000', 'Black'];
  const COLOR_BLUE = ['#00F', 'Blue'];
  const COLOR_CYAN = ['#0FF', 'Cyan'];
  const COLOR_GREEN = ['#0F0', 'Green'];
  const COLOR_MAGENTA = ['#F0F', 'Magenta'];
  const COLOR_RED = ['#F00', 'Red'];
  const COLOR_WHITE = ['#FFF', 'White'];
  const COLOR_YELLOW = ['#FF0', 'Yellow'];
  const OPACITY_OPAQUE = ['1', 'Opaque'];
  const OPACITY_SEMI = ['0.5', 'Semi-Transparent'];
  const OPACITY_TRANS = ['0', 'Transparent'];

  // Configuration for the various <select> elements in the DOM of this component.
  //
  // Possible keys include:
  //
  // `default`:
  //   The default option index. Only needs to be provided if not zero.
  // `parser`:
  //   A function which is used to parse the value from the selected option in
  //   a customized way.
  // `selector`:
  //   The selector used to find the associated <select> element.
  const selectConfigs = {
    backgroundColor: {
      selector: '.vjs-bg-color > select',
      id: 'captions-background-color-%s',
      label: 'Color',
      options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN],
      className: 'vjs-bg-color'
    },
    backgroundOpacity: {
      selector: '.vjs-bg-opacity > select',
      id: 'captions-background-opacity-%s',
      label: 'Opacity',
      options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS],
      className: 'vjs-bg-opacity vjs-opacity'
    },
    color: {
      selector: '.vjs-text-color > select',
      id: 'captions-foreground-color-%s',
      label: 'Color',
      options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN],
      className: 'vjs-text-color'
    },
    edgeStyle: {
      selector: '.vjs-edge-style > select',
      id: '',
      label: 'Text Edge Style',
      options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Drop shadow']]
    },
    fontFamily: {
      selector: '.vjs-font-family > select',
      id: '',
      label: 'Font Family',
      options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]
    },
    fontPercent: {
      selector: '.vjs-font-percent > select',
      id: '',
      label: 'Font Size',
      options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],
      default: 2,
      parser: v => v === '1.00' ? null : Number(v)
    },
    textOpacity: {
      selector: '.vjs-text-opacity > select',
      id: 'captions-foreground-opacity-%s',
      label: 'Opacity',
      options: [OPACITY_OPAQUE, OPACITY_SEMI],
      className: 'vjs-text-opacity vjs-opacity'
    },
    // Options for this object are defined below.
    windowColor: {
      selector: '.vjs-window-color > select',
      id: 'captions-window-color-%s',
      label: 'Color',
      className: 'vjs-window-color'
    },
    // Options for this object are defined below.
    windowOpacity: {
      selector: '.vjs-window-opacity > select',
      id: 'captions-window-opacity-%s',
      label: 'Opacity',
      options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE],
      className: 'vjs-window-opacity vjs-opacity'
    }
  };
  selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;

  /**
   * Get the actual value of an option.
   *
   * @param  {string} value
   *         The value to get
   *
   * @param  {Function} [parser]
   *         Optional function to adjust the value.
   *
   * @return {*}
   *         - Will be `undefined` if no value exists
   *         - Will be `undefined` if the given value is "none".
   *         - Will be the actual value otherwise.
   *
   * @private
   */
  function parseOptionValue(value, parser) {
    if (parser) {
      value = parser(value);
    }
    if (value && value !== 'none') {
      return value;
    }
  }

  /**
   * Gets the value of the selected <option> element within a <select> element.
   *
   * @param  {Element} el
   *         the element to look in
   *
   * @param  {Function} [parser]
   *         Optional function to adjust the value.
   *
   * @return {*}
   *         - Will be `undefined` if no value exists
   *         - Will be `undefined` if the given value is "none".
   *         - Will be the actual value otherwise.
   *
   * @private
   */
  function getSelectedOptionValue(el, parser) {
    const value = el.options[el.options.selectedIndex].value;
    return parseOptionValue(value, parser);
  }

  /**
   * Sets the selected <option> element within a <select> element based on a
   * given value.
   *
   * @param {Element} el
   *        The element to look in.
   *
   * @param {string} value
   *        the property to look on.
   *
   * @param {Function} [parser]
   *        Optional function to adjust the value before comparing.
   *
   * @private
   */
  function setSelectedOption(el, value, parser) {
    if (!value) {
      return;
    }
    for (let i = 0; i < el.options.length; i++) {
      if (parseOptionValue(el.options[i].value, parser) === value) {
        el.selectedIndex = i;
        break;
      }
    }
  }

  /**
   * Manipulate Text Tracks settings.
   *
   * @extends ModalDialog
   */
  class TextTrackSettings extends ModalDialog {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *         The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *         The key/value store of player options.
     */
    constructor(player, options) {
      options.temporary = false;
      super(player, options);
      this.updateDisplay = this.updateDisplay.bind(this);

      // fill the modal and pretend we have opened it
      this.fill();
      this.hasBeenOpened_ = this.hasBeenFilled_ = true;
      this.renderModalComponents(player);
      this.endDialog = createEl('p', {
        className: 'vjs-control-text',
        textContent: this.localize('End of dialog window.')
      });
      this.el().appendChild(this.endDialog);
      this.setDefaults();

      // Grab `persistTextTrackSettings` from the player options if not passed in child options
      if (options.persistTextTrackSettings === undefined) {
        this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;
      }
      this.bindFunctionsToSelectsAndButtons();
      if (this.options_.persistTextTrackSettings) {
        this.restoreSettings();
      }
    }
    renderModalComponents(player) {
      const textTrackSettingsColors = new TextTrackSettingsColors(player, {
        textTrackComponentid: this.id_,
        selectConfigs,
        fieldSets: [['color', 'textOpacity'], ['backgroundColor', 'backgroundOpacity'], ['windowColor', 'windowOpacity']]
      });
      this.addChild(textTrackSettingsColors);
      const textTrackSettingsFont = new TextTrackSettingsFont(player, {
        textTrackComponentid: this.id_,
        selectConfigs,
        fieldSets: [['fontPercent'], ['edgeStyle'], ['fontFamily']]
      });
      this.addChild(textTrackSettingsFont);
      const trackSettingsControls = new TrackSettingsControls(player);
      this.addChild(trackSettingsControls);
    }
    bindFunctionsToSelectsAndButtons() {
      this.on(this.$('.vjs-done-button'), ['click', 'tap'], () => {
        this.saveSettings();
        this.close();
      });
      this.on(this.$('.vjs-default-button'), ['click', 'tap'], () => {
        this.setDefaults();
        this.updateDisplay();
      });
      each(selectConfigs, config => {
        this.on(this.$(config.selector), 'change', this.updateDisplay);
      });
    }
    dispose() {
      this.endDialog = null;
      super.dispose();
    }
    label() {
      return this.localize('Caption Settings Dialog');
    }
    description() {
      return this.localize('Beginning of dialog window. Escape will cancel and close the window.');
    }
    buildCSSClass() {
      return super.buildCSSClass() + ' vjs-text-track-settings';
    }

    /**
     * Gets an object of text track settings (or null).
     *
     * @return {Object}
     *         An object with config values parsed from the DOM or localStorage.
     */
    getValues() {
      return reduce(selectConfigs, (accum, config, key) => {
        const value = getSelectedOptionValue(this.$(config.selector), config.parser);
        if (value !== undefined) {
          accum[key] = value;
        }
        return accum;
      }, {});
    }

    /**
     * Sets text track settings from an object of values.
     *
     * @param {Object} values
     *        An object with config values parsed from the DOM or localStorage.
     */
    setValues(values) {
      each(selectConfigs, (config, key) => {
        setSelectedOption(this.$(config.selector), values[key], config.parser);
      });
    }

    /**
     * Sets all `<select>` elements to their default values.
     */
    setDefaults() {
      each(selectConfigs, config => {
        const index = config.hasOwnProperty('default') ? config.default : 0;
        this.$(config.selector).selectedIndex = index;
      });
    }

    /**
     * Restore texttrack settings from localStorage
     */
    restoreSettings() {
      let values;
      try {
        values = JSON.parse(window__default["default"].localStorage.getItem(LOCAL_STORAGE_KEY));
      } catch (err) {
        log.warn(err);
      }
      if (values) {
        this.setValues(values);
      }
    }

    /**
     * Save text track settings to localStorage
     */
    saveSettings() {
      if (!this.options_.persistTextTrackSettings) {
        return;
      }
      const values = this.getValues();
      try {
        if (Object.keys(values).length) {
          window__default["default"].localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));
        } else {
          window__default["default"].localStorage.removeItem(LOCAL_STORAGE_KEY);
        }
      } catch (err) {
        log.warn(err);
      }
    }

    /**
     * Update display of text track settings
     */
    updateDisplay() {
      const ttDisplay = this.player_.getChild('textTrackDisplay');
      if (ttDisplay) {
        ttDisplay.updateDisplay();
      }
    }

    /**
     * Repopulate dialog with new localizations on languagechange
     */
    handleLanguagechange() {
      this.fill();
      this.renderModalComponents(this.player_);
      this.bindFunctionsToSelectsAndButtons();
    }
  }
  Component.registerComponent('TextTrackSettings', TextTrackSettings);

  /**
   * @file resize-manager.js
   */

  /**
   * A Resize Manager. It is in charge of triggering `playerresize` on the player in the right conditions.
   *
   * It'll either create an iframe and use a debounced resize handler on it or use the new {@link https://wicg.github.io/ResizeObserver/|ResizeObserver}.
   *
   * If the ResizeObserver is available natively, it will be used. A polyfill can be passed in as an option.
   * If a `playerresize` event is not needed, the ResizeManager component can be removed from the player, see the example below.
   *
   * @example <caption>How to disable the resize manager</caption>
   * const player = videojs('#vid', {
   *   resizeManager: false
   * });
   *
   * @see {@link https://wicg.github.io/ResizeObserver/|ResizeObserver specification}
   *
   * @extends Component
   */
  class ResizeManager extends Component {
    /**
     * Create the ResizeManager.
     *
     * @param {Object} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of ResizeManager options.
     *
     * @param {Object} [options.ResizeObserver]
     *        A polyfill for ResizeObserver can be passed in here.
     *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.
     */
    constructor(player, options) {
      let RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window__default["default"].ResizeObserver;

      // if `null` was passed, we want to disable the ResizeObserver
      if (options.ResizeObserver === null) {
        RESIZE_OBSERVER_AVAILABLE = false;
      }

      // Only create an element when ResizeObserver isn't available
      const options_ = merge({
        createEl: !RESIZE_OBSERVER_AVAILABLE,
        reportTouchActivity: false
      }, options);
      super(player, options_);
      this.ResizeObserver = options.ResizeObserver || window__default["default"].ResizeObserver;
      this.loadListener_ = null;
      this.resizeObserver_ = null;
      this.debouncedHandler_ = debounce(() => {
        this.resizeHandler();
      }, 100, false, this);
      if (RESIZE_OBSERVER_AVAILABLE) {
        this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_);
        this.resizeObserver_.observe(player.el());
      } else {
        this.loadListener_ = () => {
          if (!this.el_ || !this.el_.contentWindow) {
            return;
          }
          const debouncedHandler_ = this.debouncedHandler_;
          let unloadListener_ = this.unloadListener_ = function () {
            off(this, 'resize', debouncedHandler_);
            off(this, 'unload', unloadListener_);
            unloadListener_ = null;
          };

          // safari and edge can unload the iframe before resizemanager dispose
          // we have to dispose of event handlers correctly before that happens
          on(this.el_.contentWindow, 'unload', unloadListener_);
          on(this.el_.contentWindow, 'resize', debouncedHandler_);
        };
        this.one('load', this.loadListener_);
      }
    }
    createEl() {
      return super.createEl('iframe', {
        className: 'vjs-resize-manager',
        tabIndex: -1,
        title: this.localize('No content')
      }, {
        'aria-hidden': 'true'
      });
    }

    /**
     * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver
     *
     * @fires Player#playerresize
     */
    resizeHandler() {
      /**
       * Called when the player size has changed
       *
       * @event Player#playerresize
       * @type {Event}
       */
      // make sure player is still around to trigger
      // prevents this from causing an error after dispose
      if (!this.player_ || !this.player_.trigger) {
        return;
      }
      this.player_.trigger('playerresize');
    }
    dispose() {
      if (this.debouncedHandler_) {
        this.debouncedHandler_.cancel();
      }
      if (this.resizeObserver_) {
        if (this.player_.el()) {
          this.resizeObserver_.unobserve(this.player_.el());
        }
        this.resizeObserver_.disconnect();
      }
      if (this.loadListener_) {
        this.off('load', this.loadListener_);
      }
      if (this.el_ && this.el_.contentWindow && this.unloadListener_) {
        this.unloadListener_.call(this.el_.contentWindow);
      }
      this.ResizeObserver = null;
      this.resizeObserver = null;
      this.debouncedHandler_ = null;
      this.loadListener_ = null;
      super.dispose();
    }
  }
  Component.registerComponent('ResizeManager', ResizeManager);

  /** @import Player from './player' */

  const defaults$1 = {
    trackingThreshold: 20,
    liveTolerance: 15
  };

  /*
    track when we are at the live edge, and other helpers for live playback */

  /**
   * A class for checking live current time and determining when the player
   * is at or behind the live edge.
   */
  class LiveTracker extends Component {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {number} [options.trackingThreshold=20]
     *        Number of seconds of live window (seekableEnd - seekableStart) that
     *        media needs to have before the liveui will be shown.
     *
     * @param {number} [options.liveTolerance=15]
     *        Number of seconds behind live that we have to be
     *        before we will be considered non-live. Note that this will only
     *        be used when playing at the live edge. This allows large seekable end
     *        changes to not effect whether we are live or not.
     */
    constructor(player, options) {
      // LiveTracker does not need an element
      const options_ = merge(defaults$1, options, {
        createEl: false
      });
      super(player, options_);
      this.trackLiveHandler_ = () => this.trackLive_();
      this.handlePlay_ = e => this.handlePlay(e);
      this.handleFirstTimeupdate_ = e => this.handleFirstTimeupdate(e);
      this.handleSeeked_ = e => this.handleSeeked(e);
      this.seekToLiveEdge_ = e => this.seekToLiveEdge(e);
      this.reset_();
      this.on(this.player_, 'durationchange', e => this.handleDurationchange(e));
      // we should try to toggle tracking on canplay as native playback engines, like Safari
      // may not have the proper values for things like seekableEnd until then
      this.on(this.player_, 'canplay', () => this.toggleTracking());
    }

    /**
     * all the functionality for tracking when seek end changes
     * and for tracking how far past seek end we should be
     */
    trackLive_() {
      const seekable = this.player_.seekable();

      // skip undefined seekable
      if (!seekable || !seekable.length) {
        return;
      }
      const newTime = Number(window__default["default"].performance.now().toFixed(4));
      const deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1000;
      this.lastTime_ = newTime;
      this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
      const liveCurrentTime = this.liveCurrentTime();
      const currentTime = this.player_.currentTime();

      // we are behind live if any are true
      // 1. the player is paused
      // 2. the user seeked to a location 2 seconds away from live
      // 3. the difference between live and current time is greater
      //    liveTolerance which defaults to 15s
      let isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;

      // we cannot be behind if
      // 1. until we have not seen a timeupdate yet
      // 2. liveCurrentTime is Infinity, which happens on Android and Native Safari
      if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {
        isBehind = false;
      }
      if (isBehind !== this.behindLiveEdge_) {
        this.behindLiveEdge_ = isBehind;
        this.trigger('liveedgechange');
      }
    }

    /**
     * handle a durationchange event on the player
     * and start/stop tracking accordingly.
     */
    handleDurationchange() {
      this.toggleTracking();
    }

    /**
     * start/stop tracking
     */
    toggleTracking() {
      if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {
        if (this.player_.options_.liveui) {
          this.player_.addClass('vjs-liveui');
        }
        this.startTracking();
      } else {
        this.player_.removeClass('vjs-liveui');
        this.stopTracking();
      }
    }

    /**
     * start tracking live playback
     */
    startTracking() {
      if (this.isTracking()) {
        return;
      }

      // If we haven't seen a timeupdate, we need to check whether playback
      // began before this component started tracking. This can happen commonly
      // when using autoplay.
      if (!this.timeupdateSeen_) {
        this.timeupdateSeen_ = this.player_.hasStarted();
      }
      this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);
      this.trackLive_();
      this.on(this.player_, ['play', 'pause'], this.trackLiveHandler_);
      if (!this.timeupdateSeen_) {
        this.one(this.player_, 'play', this.handlePlay_);
        this.one(this.player_, 'timeupdate', this.handleFirstTimeupdate_);
      } else {
        this.on(this.player_, 'seeked', this.handleSeeked_);
      }
    }

    /**
     * handle the first timeupdate on the player if it wasn't already playing
     * when live tracker started tracking.
     */
    handleFirstTimeupdate() {
      this.timeupdateSeen_ = true;
      this.on(this.player_, 'seeked', this.handleSeeked_);
    }

    /**
     * Keep track of what time a seek starts, and listen for seeked
     * to find where a seek ends.
     */
    handleSeeked() {
      const timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
      this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;
      this.nextSeekedFromUser_ = false;
      this.trackLive_();
    }

    /**
     * handle the first play on the player, and make sure that we seek
     * right to the live edge.
     */
    handlePlay() {
      this.one(this.player_, 'timeupdate', this.seekToLiveEdge_);
    }

    /**
     * Stop tracking, and set all internal variables to
     * their initial value.
     */
    reset_() {
      this.lastTime_ = -1;
      this.pastSeekEnd_ = 0;
      this.lastSeekEnd_ = -1;
      this.behindLiveEdge_ = true;
      this.timeupdateSeen_ = false;
      this.seekedBehindLive_ = false;
      this.nextSeekedFromUser_ = false;
      this.clearInterval(this.trackingInterval_);
      this.trackingInterval_ = null;
      this.off(this.player_, ['play', 'pause'], this.trackLiveHandler_);
      this.off(this.player_, 'seeked', this.handleSeeked_);
      this.off(this.player_, 'play', this.handlePlay_);
      this.off(this.player_, 'timeupdate', this.handleFirstTimeupdate_);
      this.off(this.player_, 'timeupdate', this.seekToLiveEdge_);
    }

    /**
     * The next seeked event is from the user. Meaning that any seek
     * > 2s behind live will be considered behind live for real and
     * liveTolerance will be ignored.
     */
    nextSeekedFromUser() {
      this.nextSeekedFromUser_ = true;
    }

    /**
     * stop tracking live playback
     */
    stopTracking() {
      if (!this.isTracking()) {
        return;
      }
      this.reset_();
      this.trigger('liveedgechange');
    }

    /**
     * A helper to get the player seekable end
     * so that we don't have to null check everywhere
     *
     * @return {number}
     *         The furthest seekable end or Infinity.
     */
    seekableEnd() {
      const seekable = this.player_.seekable();
      const seekableEnds = [];
      let i = seekable ? seekable.length : 0;
      while (i--) {
        seekableEnds.push(seekable.end(i));
      }

      // grab the furthest seekable end after sorting, or if there are none
      // default to Infinity
      return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;
    }

    /**
     * A helper to get the player seekable start
     * so that we don't have to null check everywhere
     *
     * @return {number}
     *         The earliest seekable start or 0.
     */
    seekableStart() {
      const seekable = this.player_.seekable();
      const seekableStarts = [];
      let i = seekable ? seekable.length : 0;
      while (i--) {
        seekableStarts.push(seekable.start(i));
      }

      // grab the first seekable start after sorting, or if there are none
      // default to 0
      return seekableStarts.length ? seekableStarts.sort()[0] : 0;
    }

    /**
     * Get the live time window aka
     * the amount of time between seekable start and
     * live current time.
     *
     * @return {number}
     *         The amount of seconds that are seekable in
     *         the live video.
     */
    liveWindow() {
      const liveCurrentTime = this.liveCurrentTime();

      // if liveCurrenTime is Infinity then we don't have a liveWindow at all
      if (liveCurrentTime === Infinity) {
        return 0;
      }
      return liveCurrentTime - this.seekableStart();
    }

    /**
     * Determines if the player is live, only checks if this component
     * is tracking live playback or not
     *
     * @return {boolean}
     *         Whether liveTracker is tracking
     */
    isLive() {
      return this.isTracking();
    }

    /**
     * Determines if currentTime is at the live edge and won't fall behind
     * on each seekableendchange
     *
     * @return {boolean}
     *         Whether playback is at the live edge
     */
    atLiveEdge() {
      return !this.behindLiveEdge();
    }

    /**
     * get what we expect the live current time to be
     *
     * @return {number}
     *         The expected live current time
     */
    liveCurrentTime() {
      return this.pastSeekEnd() + this.seekableEnd();
    }

    /**
     * The number of seconds that have occurred after seekable end
     * changed. This will be reset to 0 once seekable end changes.
     *
     * @return {number}
     *         Seconds past the current seekable end
     */
    pastSeekEnd() {
      const seekableEnd = this.seekableEnd();
      if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {
        this.pastSeekEnd_ = 0;
      }
      this.lastSeekEnd_ = seekableEnd;
      return this.pastSeekEnd_;
    }

    /**
     * If we are currently behind the live edge, aka currentTime will be
     * behind on a seekableendchange
     *
     * @return {boolean}
     *         If we are behind the live edge
     */
    behindLiveEdge() {
      return this.behindLiveEdge_;
    }

    /**
     * Whether live tracker is currently tracking or not.
     */
    isTracking() {
      return typeof this.trackingInterval_ === 'number';
    }

    /**
     * Seek to the live edge if we are behind the live edge
     */
    seekToLiveEdge() {
      this.seekedBehindLive_ = false;
      if (this.atLiveEdge()) {
        return;
      }
      this.nextSeekedFromUser_ = false;
      this.player_.currentTime(this.liveCurrentTime());
    }

    /**
     * Dispose of liveTracker
     */
    dispose() {
      this.stopTracking();
      super.dispose();
    }
  }
  Component.registerComponent('LiveTracker', LiveTracker);

  /**
   * Displays an element over the player which contains an optional title and
   * description for the current content.
   *
   * Much of the code for this component originated in the now obsolete
   * videojs-dock plugin: https://github.com/brightcove/videojs-dock/
   *
   * @extends Component
   */
  class TitleBar extends Component {
    constructor(player, options) {
      super(player, options);
      this.on('statechanged', e => this.updateDom_());
      this.updateDom_();
    }

    /**
     * Create the `TitleBar`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      this.els = {
        title: createEl('div', {
          className: 'vjs-title-bar-title',
          id: `vjs-title-bar-title-${newGUID()}`
        }),
        description: createEl('div', {
          className: 'vjs-title-bar-description',
          id: `vjs-title-bar-description-${newGUID()}`
        })
      };
      return createEl('div', {
        className: 'vjs-title-bar'
      }, {}, values(this.els));
    }

    /**
     * Updates the DOM based on the component's state object.
     */
    updateDom_() {
      const tech = this.player_.tech_;
      const techEl = tech && tech.el_;
      const techAriaAttrs = {
        title: 'aria-labelledby',
        description: 'aria-describedby'
      };
      ['title', 'description'].forEach(k => {
        const value = this.state[k];
        const el = this.els[k];
        const techAriaAttr = techAriaAttrs[k];
        emptyEl(el);
        if (value) {
          textContent(el, value);
        }

        // If there is a tech element available, update its ARIA attributes
        // according to whether a title and/or description have been provided.
        if (techEl) {
          techEl.removeAttribute(techAriaAttr);
          if (value) {
            techEl.setAttribute(techAriaAttr, el.id);
          }
        }
      });
      if (this.state.title || this.state.description) {
        this.show();
      } else {
        this.hide();
      }
    }

    /**
     * Update the contents of the title bar component with new title and
     * description text.
     *
     * If both title and description are missing, the title bar will be hidden.
     *
     * If either title or description are present, the title bar will be visible.
     *
     * NOTE: Any previously set value will be preserved. To unset a previously
     * set value, you must pass an empty string or null.
     *
     * For example:
     *
     * ```
     * update({title: 'foo', description: 'bar'}) // title: 'foo', description: 'bar'
     * update({description: 'bar2'}) // title: 'foo', description: 'bar2'
     * update({title: ''}) // title: '', description: 'bar2'
     * update({title: 'foo', description: null}) // title: 'foo', description: null
     * ```
     *
     * @param  {Object} [options={}]
     *         An options object. When empty, the title bar will be hidden.
     *
     * @param  {string} [options.title]
     *         A title to display in the title bar.
     *
     * @param  {string} [options.description]
     *         A description to display in the title bar.
     */
    update(options) {
      this.setState(options);
    }

    /**
     * Dispose the component.
     */
    dispose() {
      const tech = this.player_.tech_;
      const techEl = tech && tech.el_;
      if (techEl) {
        techEl.removeAttribute('aria-labelledby');
        techEl.removeAttribute('aria-describedby');
      }
      super.dispose();
      this.els = null;
    }
  }
  Component.registerComponent('TitleBar', TitleBar);

  /** @import Player from './player' */

  /**
   * @typedef {object} TransientButtonOptions
   * @property {string} [controlText] Control text, usually visible for these buttons
   * @property {number} [initialDisplay=4000] Time in ms that button should initially remain visible
   * @property {Array<'top'|'neartop'|'bottom'|'left'|'right'>} [position] Array of position strings to add basic styles for positioning
   * @property {string} [className] Class(es) to add
   * @property {boolean} [takeFocus=false] Whether element sohuld take focus when shown
   * @property {Function} [clickHandler] Function called on button activation
   */

  /** @type {TransientButtonOptions} */
  const defaults = {
    initialDisplay: 4000,
    position: [],
    takeFocus: false
  };

  /**
   * A floating transient button.
   * It's recommended to insert these buttons _before_ the control bar with the this argument to `addChild`
   * for a logical tab order.
   *
   * @example
   * ```
   * player.addChild(
   *   'TransientButton',
   *   options,
   *   player.children().indexOf(player.getChild("ControlBar"))
   * )
   * ```
   *
   * @extends Button
   */
  class TransientButton extends Button {
    /**
     * TransientButton constructor
     *
     * @param {Player} player The button's player
     * @param {TransientButtonOptions} options Options for the transient button
     */
    constructor(player, options) {
      options = merge(defaults, options);
      super(player, options);
      this.controlText(options.controlText);
      this.hide();

      // When shown, the float button will be visible even if the user is inactive.
      // Clear this if there is any interaction.
      this.on(this.player_, ['useractive', 'userinactive'], e => {
        this.removeClass('force-display');
      });
    }

    /**
     * Return CSS class including position classes
     *
     * @return {string} CSS class list
     */
    buildCSSClass() {
      return `vjs-transient-button focus-visible ${this.options_.position.map(c => `vjs-${c}`).join(' ')}`;
    }

    /**
     * Create the button element
     *
     * @return {HTMLButtonElement} The button element
     */
    createEl() {
      /** @type HTMLButtonElement */
      const el = createEl('button', {}, {
        type: 'button',
        class: this.buildCSSClass()
      }, createEl('span'));
      this.controlTextEl_ = el.querySelector('span');
      return el;
    }

    /**
     * Show the button. The button will remain visible for the `initialDisplay` time, default 4s,
     * and when there is user activity.
     */
    show() {
      super.show();
      this.addClass('force-display');
      if (this.options_.takeFocus) {
        this.el().focus({
          preventScroll: true
        });
      }
      this.forceDisplayTimeout = this.player_.setTimeout(() => {
        this.removeClass('force-display');
      }, this.options_.initialDisplay);
    }

    /**
     * Hide the display, even if during the `initialDisplay` time.
     */
    hide() {
      this.removeClass('force-display');
      super.hide();
    }

    /**
     * Dispose the component
     */
    dispose() {
      this.player_.clearTimeout(this.forceDisplayTimeout);
      super.dispose();
    }
  }
  Component.registerComponent('TransientButton', TransientButton);

  /** @import Html5 from './html5' */

  /**
   * This function is used to fire a sourceset when there is something
   * similar to `mediaEl.load()` being called. It will try to find the source via
   * the `src` attribute and then the `<source>` elements. It will then fire `sourceset`
   * with the source that was found or empty string if we cannot know. If it cannot
   * find a source then `sourceset` will not be fired.
   *
   * @param {Html5} tech
   *        The tech object that sourceset was setup on
   *
   * @return {boolean}
   *         returns false if the sourceset was not fired and true otherwise.
   */
  const sourcesetLoad = tech => {
    const el = tech.el();

    // if `el.src` is set, that source will be loaded.
    if (el.hasAttribute('src')) {
      tech.triggerSourceset(el.src);
      return true;
    }

    /**
     * Since there isn't a src property on the media element, source elements will be used for
     * implementing the source selection algorithm. This happens asynchronously and
     * for most cases were there is more than one source we cannot tell what source will
     * be loaded, without re-implementing the source selection algorithm. At this time we are not
     * going to do that. There are three special cases that we do handle here though:
     *
     * 1. If there are no sources, do not fire `sourceset`.
     * 2. If there is only one `<source>` with a `src` property/attribute that is our `src`
     * 3. If there is more than one `<source>` but all of them have the same `src` url.
     *    That will be our src.
     */
    const sources = tech.$$('source');
    const srcUrls = [];
    let src = '';

    // if there are no sources, do not fire sourceset
    if (!sources.length) {
      return false;
    }

    // only count valid/non-duplicate source elements
    for (let i = 0; i < sources.length; i++) {
      const url = sources[i].src;
      if (url && srcUrls.indexOf(url) === -1) {
        srcUrls.push(url);
      }
    }

    // there were no valid sources
    if (!srcUrls.length) {
      return false;
    }

    // there is only one valid source element url
    // use that
    if (srcUrls.length === 1) {
      src = srcUrls[0];
    }
    tech.triggerSourceset(src);
    return true;
  };

  /**
   * our implementation of an `innerHTML` descriptor for browsers
   * that do not have one.
   */
  const innerHTMLDescriptorPolyfill = Object.defineProperty({}, 'innerHTML', {
    get() {
      return this.cloneNode(true).innerHTML;
    },
    set(v) {
      // make a dummy node to use innerHTML on
      const dummy = document__default["default"].createElement(this.nodeName.toLowerCase());

      // set innerHTML to the value provided
      dummy.innerHTML = v;

      // make a document fragment to hold the nodes from dummy
      const docFrag = document__default["default"].createDocumentFragment();

      // copy all of the nodes created by the innerHTML on dummy
      // to the document fragment
      while (dummy.childNodes.length) {
        docFrag.appendChild(dummy.childNodes[0]);
      }

      // remove content
      this.innerText = '';

      // now we add all of that html in one by appending the
      // document fragment. This is how innerHTML does it.
      window__default["default"].Element.prototype.appendChild.call(this, docFrag);

      // then return the result that innerHTML's setter would
      return this.innerHTML;
    }
  });

  /**
   * Get a property descriptor given a list of priorities and the
   * property to get.
   */
  const getDescriptor = (priority, prop) => {
    let descriptor = {};
    for (let i = 0; i < priority.length; i++) {
      descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);
      if (descriptor && descriptor.set && descriptor.get) {
        break;
      }
    }
    descriptor.enumerable = true;
    descriptor.configurable = true;
    return descriptor;
  };
  const getInnerHTMLDescriptor = tech => getDescriptor([tech.el(), window__default["default"].HTMLMediaElement.prototype, window__default["default"].Element.prototype, innerHTMLDescriptorPolyfill], 'innerHTML');

  /**
   * Patches browser internal functions so that we can tell synchronously
   * if a `<source>` was appended to the media element. For some reason this
   * causes a `sourceset` if the the media element is ready and has no source.
   * This happens when:
   * - The page has just loaded and the media element does not have a source.
   * - The media element was emptied of all sources, then `load()` was called.
   *
   * It does this by patching the following functions/properties when they are supported:
   *
   * - `append()` - can be used to add a `<source>` element to the media element
   * - `appendChild()` - can be used to add a `<source>` element to the media element
   * - `insertAdjacentHTML()` -  can be used to add a `<source>` element to the media element
   * - `innerHTML` -  can be used to add a `<source>` element to the media element
   *
   * @param {Html5} tech
   *        The tech object that sourceset is being setup on.
   */
  const firstSourceWatch = function (tech) {
    const el = tech.el();

    // make sure firstSourceWatch isn't setup twice.
    if (el.resetSourceWatch_) {
      return;
    }
    const old = {};
    const innerDescriptor = getInnerHTMLDescriptor(tech);
    const appendWrapper = appendFn => (...args) => {
      const retval = appendFn.apply(el, args);
      sourcesetLoad(tech);
      return retval;
    };
    ['append', 'appendChild', 'insertAdjacentHTML'].forEach(k => {
      if (!el[k]) {
        return;
      }

      // store the old function
      old[k] = el[k];

      // call the old function with a sourceset if a source
      // was loaded
      el[k] = appendWrapper(old[k]);
    });
    Object.defineProperty(el, 'innerHTML', merge(innerDescriptor, {
      set: appendWrapper(innerDescriptor.set)
    }));
    el.resetSourceWatch_ = () => {
      el.resetSourceWatch_ = null;
      Object.keys(old).forEach(k => {
        el[k] = old[k];
      });
      Object.defineProperty(el, 'innerHTML', innerDescriptor);
    };

    // on the first sourceset, we need to revert our changes
    tech.one('sourceset', el.resetSourceWatch_);
  };

  /**
   * our implementation of a `src` descriptor for browsers
   * that do not have one
   */
  const srcDescriptorPolyfill = Object.defineProperty({}, 'src', {
    get() {
      if (this.hasAttribute('src')) {
        return getAbsoluteURL(window__default["default"].Element.prototype.getAttribute.call(this, 'src'));
      }
      return '';
    },
    set(v) {
      window__default["default"].Element.prototype.setAttribute.call(this, 'src', v);
      return v;
    }
  });
  const getSrcDescriptor = tech => getDescriptor([tech.el(), window__default["default"].HTMLMediaElement.prototype, srcDescriptorPolyfill], 'src');

  /**
   * setup `sourceset` handling on the `Html5` tech. This function
   * patches the following element properties/functions:
   *
   * - `src` - to determine when `src` is set
   * - `setAttribute()` - to determine when `src` is set
   * - `load()` - this re-triggers the source selection algorithm, and can
   *              cause a sourceset.
   *
   * If there is no source when we are adding `sourceset` support or during a `load()`
   * we also patch the functions listed in `firstSourceWatch`.
   *
   * @param {Html5} tech
   *        The tech to patch
   */
  const setupSourceset = function (tech) {
    if (!tech.featuresSourceset) {
      return;
    }
    const el = tech.el();

    // make sure sourceset isn't setup twice.
    if (el.resetSourceset_) {
      return;
    }
    const srcDescriptor = getSrcDescriptor(tech);
    const oldSetAttribute = el.setAttribute;
    const oldLoad = el.load;
    Object.defineProperty(el, 'src', merge(srcDescriptor, {
      set: v => {
        const retval = srcDescriptor.set.call(el, v);

        // we use the getter here to get the actual value set on src
        tech.triggerSourceset(el.src);
        return retval;
      }
    }));
    el.setAttribute = (n, v) => {
      const retval = oldSetAttribute.call(el, n, v);
      if (/src/i.test(n)) {
        tech.triggerSourceset(el.src);
      }
      return retval;
    };
    el.load = () => {
      const retval = oldLoad.call(el);

      // if load was called, but there was no source to fire
      // sourceset on. We have to watch for a source append
      // as that can trigger a `sourceset` when the media element
      // has no source
      if (!sourcesetLoad(tech)) {
        tech.triggerSourceset('');
        firstSourceWatch(tech);
      }
      return retval;
    };
    if (el.currentSrc) {
      tech.triggerSourceset(el.currentSrc);
    } else if (!sourcesetLoad(tech)) {
      firstSourceWatch(tech);
    }
    el.resetSourceset_ = () => {
      el.resetSourceset_ = null;
      el.load = oldLoad;
      el.setAttribute = oldSetAttribute;
      Object.defineProperty(el, 'src', srcDescriptor);
      if (el.resetSourceWatch_) {
        el.resetSourceWatch_();
      }
    };
  };

  /**
   * @file html5.js
   */

  /**
   * HTML5 Media Controller - Wrapper for HTML5 Media API
   *
   * @mixes Tech~SourceHandlerAdditions
   * @extends Tech
   */
  class Html5 extends Tech {
    /**
    * Create an instance of this Tech.
    *
    * @param {Object} [options]
    *        The key/value store of player options.
    *
    * @param {Function} [ready]
    *        Callback function to call when the `HTML5` Tech is ready.
    */
    constructor(options, ready) {
      super(options, ready);
      const source = options.source;
      let crossoriginTracks = false;
      this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && this.el_.tagName === 'VIDEO';

      // Set the source if one is provided
      // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
      // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
      // anyway so the error gets fired.
      if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
        this.setSource(source);
      } else {
        this.handleLateInit_(this.el_);
      }

      // setup sourceset after late sourceset/init
      if (options.enableSourceset) {
        this.setupSourcesetHandling_();
      }
      this.isScrubbing_ = false;
      if (this.el_.hasChildNodes()) {
        const nodes = this.el_.childNodes;
        let nodesLength = nodes.length;
        const removeNodes = [];
        while (nodesLength--) {
          const node = nodes[nodesLength];
          const nodeName = node.nodeName.toLowerCase();
          if (nodeName === 'track') {
            if (!this.featuresNativeTextTracks) {
              // Empty video tag tracks so the built-in player doesn't use them also.
              // This may not be fast enough to stop HTML5 browsers from reading the tags
              // so we'll need to turn off any default tracks if we're manually doing
              // captions and subtitles. videoElement.textTracks
              removeNodes.push(node);
            } else {
              // store HTMLTrackElement and TextTrack to remote list
              this.remoteTextTrackEls().addTrackElement_(node);
              this.remoteTextTracks().addTrack(node.track);
              this.textTracks().addTrack(node.track);
              if (!crossoriginTracks && !this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {
                crossoriginTracks = true;
              }
            }
          }
        }
        for (let i = 0; i < removeNodes.length; i++) {
          this.el_.removeChild(removeNodes[i]);
        }
      }
      this.proxyNativeTracks_();
      if (this.featuresNativeTextTracks && crossoriginTracks) {
        log.warn('Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n' + 'This may prevent text tracks from loading.');
      }

      // prevent iOS Safari from disabling metadata text tracks during native playback
      this.restoreMetadataTracksInIOSNativePlayer_();

      // Determine if native controls should be used
      // Our goal should be to get the custom controls on mobile solid everywhere
      // so we can remove this all together. Right now this will block custom
      // controls on touch enabled laptops like the Chrome Pixel
      if ((TOUCH_ENABLED || IS_IPHONE) && options.nativeControlsForTouch === true) {
        this.setControls(true);
      }

      // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`
      // into a `fullscreenchange` event
      this.proxyWebkitFullscreen_();
      this.triggerReady();
    }

    /**
     * Dispose of `HTML5` media element and remove all tracks.
     */
    dispose() {
      if (this.el_ && this.el_.resetSourceset_) {
        this.el_.resetSourceset_();
      }
      Html5.disposeMediaElement(this.el_);
      this.options_ = null;

      // tech will handle clearing of the emulated track list
      super.dispose();
    }

    /**
     * Modify the media element so that we can detect when
     * the source is changed. Fires `sourceset` just after the source has changed
     */
    setupSourcesetHandling_() {
      setupSourceset(this);
    }

    /**
     * When a captions track is enabled in the iOS Safari native player, all other
     * tracks are disabled (including metadata tracks), which nulls all of their
     * associated cue points. This will restore metadata tracks to their pre-fullscreen
     * state in those cases so that cue points are not needlessly lost.
     *
     * @private
     */
    restoreMetadataTracksInIOSNativePlayer_() {
      const textTracks = this.textTracks();
      let metadataTracksPreFullscreenState;

      // captures a snapshot of every metadata track's current state
      const takeMetadataTrackSnapshot = () => {
        metadataTracksPreFullscreenState = [];
        for (let i = 0; i < textTracks.length; i++) {
          const track = textTracks[i];
          if (track.kind === 'metadata') {
            metadataTracksPreFullscreenState.push({
              track,
              storedMode: track.mode
            });
          }
        }
      };

      // snapshot each metadata track's initial state, and update the snapshot
      // each time there is a track 'change' event
      takeMetadataTrackSnapshot();
      textTracks.addEventListener('change', takeMetadataTrackSnapshot);
      this.on('dispose', () => textTracks.removeEventListener('change', takeMetadataTrackSnapshot));
      const restoreTrackMode = () => {
        for (let i = 0; i < metadataTracksPreFullscreenState.length; i++) {
          const storedTrack = metadataTracksPreFullscreenState[i];
          if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {
            storedTrack.track.mode = storedTrack.storedMode;
          }
        }
        // we only want this handler to be executed on the first 'change' event
        textTracks.removeEventListener('change', restoreTrackMode);
      };

      // when we enter fullscreen playback, stop updating the snapshot and
      // restore all track modes to their pre-fullscreen state
      this.on('webkitbeginfullscreen', () => {
        textTracks.removeEventListener('change', takeMetadataTrackSnapshot);

        // remove the listener before adding it just in case it wasn't previously removed
        textTracks.removeEventListener('change', restoreTrackMode);
        textTracks.addEventListener('change', restoreTrackMode);
      });

      // start updating the snapshot again after leaving fullscreen
      this.on('webkitendfullscreen', () => {
        // remove the listener before adding it just in case it wasn't previously removed
        textTracks.removeEventListener('change', takeMetadataTrackSnapshot);
        textTracks.addEventListener('change', takeMetadataTrackSnapshot);

        // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback
        textTracks.removeEventListener('change', restoreTrackMode);
      });
    }

    /**
     * Attempt to force override of tracks for the given type
     *
     * @param {string} type - Track type to override, possible values include 'Audio',
     * 'Video', and 'Text'.
     * @param {boolean} override - If set to true native audio/video will be overridden,
     * otherwise native audio/video will potentially be used.
     * @private
     */
    overrideNative_(type, override) {
      // If there is no behavioral change don't add/remove listeners
      if (override !== this[`featuresNative${type}Tracks`]) {
        return;
      }
      const lowerCaseType = type.toLowerCase();
      if (this[`${lowerCaseType}TracksListeners_`]) {
        Object.keys(this[`${lowerCaseType}TracksListeners_`]).forEach(eventName => {
          const elTracks = this.el()[`${lowerCaseType}Tracks`];
          elTracks.removeEventListener(eventName, this[`${lowerCaseType}TracksListeners_`][eventName]);
        });
      }
      this[`featuresNative${type}Tracks`] = !override;
      this[`${lowerCaseType}TracksListeners_`] = null;
      this.proxyNativeTracksForType_(lowerCaseType);
    }

    /**
     * Attempt to force override of native audio tracks.
     *
     * @param {boolean} override - If set to true native audio will be overridden,
     * otherwise native audio will potentially be used.
     */
    overrideNativeAudioTracks(override) {
      this.overrideNative_('Audio', override);
    }

    /**
     * Attempt to force override of native video tracks.
     *
     * @param {boolean} override - If set to true native video will be overridden,
     * otherwise native video will potentially be used.
     */
    overrideNativeVideoTracks(override) {
      this.overrideNative_('Video', override);
    }

    /**
     * Proxy native track list events for the given type to our track
     * lists if the browser we are playing in supports that type of track list.
     *
     * @param {string} name - Track type; values include 'audio', 'video', and 'text'
     * @private
     */
    proxyNativeTracksForType_(name) {
      const props = NORMAL[name];
      const elTracks = this.el()[props.getterName];
      const techTracks = this[props.getterName]();
      if (!this[`featuresNative${props.capitalName}Tracks`] || !elTracks || !elTracks.addEventListener) {
        return;
      }
      const listeners = {
        change: e => {
          const event = {
            type: 'change',
            target: techTracks,
            currentTarget: techTracks,
            srcElement: techTracks
          };
          techTracks.trigger(event);

          // if we are a text track change event, we should also notify the
          // remote text track list. This can potentially cause a false positive
          // if we were to get a change event on a non-remote track and
          // we triggered the event on the remote text track list which doesn't
          // contain that track. However, best practices mean looping through the
          // list of tracks and searching for the appropriate mode value, so,
          // this shouldn't pose an issue
          if (name === 'text') {
            this[REMOTE.remoteText.getterName]().trigger(event);
          }
        },
        addtrack(e) {
          techTracks.addTrack(e.track);
        },
        removetrack(e) {
          techTracks.removeTrack(e.track);
        }
      };
      const removeOldTracks = function () {
        const removeTracks = [];
        for (let i = 0; i < techTracks.length; i++) {
          let found = false;
          for (let j = 0; j < elTracks.length; j++) {
            if (elTracks[j] === techTracks[i]) {
              found = true;
              break;
            }
          }
          if (!found) {
            removeTracks.push(techTracks[i]);
          }
        }
        while (removeTracks.length) {
          techTracks.removeTrack(removeTracks.shift());
        }
      };
      this[props.getterName + 'Listeners_'] = listeners;
      Object.keys(listeners).forEach(eventName => {
        const listener = listeners[eventName];
        elTracks.addEventListener(eventName, listener);
        this.on('dispose', e => elTracks.removeEventListener(eventName, listener));
      });

      // Remove (native) tracks that are not used anymore
      this.on('loadstart', removeOldTracks);
      this.on('dispose', e => this.off('loadstart', removeOldTracks));
    }

    /**
     * Proxy all native track list events to our track lists if the browser we are playing
     * in supports that type of track list.
     *
     * @private
     */
    proxyNativeTracks_() {
      NORMAL.names.forEach(name => {
        this.proxyNativeTracksForType_(name);
      });
    }

    /**
     * Create the `Html5` Tech's DOM element.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl() {
      let el = this.options_.tag;

      // Check if this browser supports moving the element into the box.
      // On the iPhone video will break if you move the element,
      // So we have to create a brand new element.
      // If we ingested the player div, we do not need to move the media element.
      if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
        // If the original tag is still there, clone and remove it.
        if (el) {
          const clone = el.cloneNode(true);
          if (el.parentNode) {
            el.parentNode.insertBefore(clone, el);
          }
          Html5.disposeMediaElement(el);
          el = clone;
        } else {
          el = document__default["default"].createElement('video');

          // determine if native controls should be used
          const tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
          const attributes = merge({}, tagAttributes);
          if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
            delete attributes.controls;
          }
          setAttributes(el, Object.assign(attributes, {
            id: this.options_.techId,
            class: 'vjs-tech'
          }));
        }
        el.playerId = this.options_.playerId;
      }
      if (typeof this.options_.preload !== 'undefined') {
        setAttribute(el, 'preload', this.options_.preload);
      }
      if (this.options_.disablePictureInPicture !== undefined) {
        el.disablePictureInPicture = this.options_.disablePictureInPicture;
      }

      // Update specific tag settings, in case they were overridden
      // `autoplay` has to be *last* so that `muted` and `playsinline` are present
      // when iOS/Safari or other browsers attempt to autoplay.
      const settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];
      for (let i = 0; i < settingsAttrs.length; i++) {
        const attr = settingsAttrs[i];
        const value = this.options_[attr];
        if (typeof value !== 'undefined') {
          if (value) {
            setAttribute(el, attr, attr);
          } else {
            removeAttribute(el, attr);
          }
          el[attr] = value;
        }
      }
      return el;
    }

    /**
     * This will be triggered if the loadstart event has already fired, before videojs was
     * ready. Two known examples of when this can happen are:
     * 1. If we're loading the playback object after it has started loading
     * 2. The media is already playing the (often with autoplay on) then
     *
     * This function will fire another loadstart so that videojs can catchup.
     *
     * @fires Tech#loadstart
     *
     * @return {undefined}
     *         returns nothing.
     */
    handleLateInit_(el) {
      if (el.networkState === 0 || el.networkState === 3) {
        // The video element hasn't started loading the source yet
        // or didn't find a source
        return;
      }
      if (el.readyState === 0) {
        // NetworkState is set synchronously BUT loadstart is fired at the
        // end of the current stack, usually before setInterval(fn, 0).
        // So at this point we know loadstart may have already fired or is
        // about to fire, and either way the player hasn't seen it yet.
        // We don't want to fire loadstart prematurely here and cause a
        // double loadstart so we'll wait and see if it happens between now
        // and the next loop, and fire it if not.
        // HOWEVER, we also want to make sure it fires before loadedmetadata
        // which could also happen between now and the next loop, so we'll
        // watch for that also.
        let loadstartFired = false;
        const setLoadstartFired = function () {
          loadstartFired = true;
        };
        this.on('loadstart', setLoadstartFired);
        const triggerLoadstart = function () {
          // We did miss the original loadstart. Make sure the player
          // sees loadstart before loadedmetadata
          if (!loadstartFired) {
            this.trigger('loadstart');
          }
        };
        this.on('loadedmetadata', triggerLoadstart);
        this.ready(function () {
          this.off('loadstart', setLoadstartFired);
          this.off('loadedmetadata', triggerLoadstart);
          if (!loadstartFired) {
            // We did miss the original native loadstart. Fire it now.
            this.trigger('loadstart');
          }
        });
        return;
      }

      // From here on we know that loadstart already fired and we missed it.
      // The other readyState events aren't as much of a problem if we double
      // them, so not going to go to as much trouble as loadstart to prevent
      // that unless we find reason to.
      const eventsToTrigger = ['loadstart'];

      // loadedmetadata: newly equal to HAVE_METADATA (1) or greater
      eventsToTrigger.push('loadedmetadata');

      // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater
      if (el.readyState >= 2) {
        eventsToTrigger.push('loadeddata');
      }

      // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater
      if (el.readyState >= 3) {
        eventsToTrigger.push('canplay');
      }

      // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)
      if (el.readyState >= 4) {
        eventsToTrigger.push('canplaythrough');
      }

      // We still need to give the player time to add event listeners
      this.ready(function () {
        eventsToTrigger.forEach(function (type) {
          this.trigger(type);
        }, this);
      });
    }

    /**
     * Set whether we are scrubbing or not.
     * This is used to decide whether we should use `fastSeek` or not.
     * `fastSeek` is used to provide trick play on Safari browsers.
     *
     * @param {boolean} isScrubbing
     *                  - true for we are currently scrubbing
     *                  - false for we are no longer scrubbing
     */
    setScrubbing(isScrubbing) {
      this.isScrubbing_ = isScrubbing;
    }

    /**
     * Get whether we are scrubbing or not.
     *
     * @return {boolean} isScrubbing
     *                  - true for we are currently scrubbing
     *                  - false for we are no longer scrubbing
     */
    scrubbing() {
      return this.isScrubbing_;
    }

    /**
     * Set current time for the `HTML5` tech.
     *
     * @param {number} seconds
     *        Set the current time of the media to this.
     */
    setCurrentTime(seconds) {
      try {
        if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {
          this.el_.fastSeek(seconds);
        } else {
          this.el_.currentTime = seconds;
        }
      } catch (e) {
        log(e, 'Video is not ready. (Video.js)');
        // this.warning(VideoJS.warnings.videoNotReady);
      }
    }

    /**
     * Get the current duration of the HTML5 media element.
     *
     * @return {number}
     *         The duration of the media or 0 if there is no duration.
     */
    duration() {
      // Android Chrome will report duration as Infinity for VOD HLS until after
      // playback has started, which triggers the live display erroneously.
      // Return NaN if playback has not started and trigger a durationupdate once
      // the duration can be reliably known.
      if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
        // Wait for the first `timeupdate` with currentTime > 0 - there may be
        // several with 0
        const checkProgress = () => {
          if (this.el_.currentTime > 0) {
            // Trigger durationchange for genuinely live video
            if (this.el_.duration === Infinity) {
              this.trigger('durationchange');
            }
            this.off('timeupdate', checkProgress);
          }
        };
        this.on('timeupdate', checkProgress);
        return NaN;
      }
      return this.el_.duration || NaN;
    }

    /**
     * Get the current width of the HTML5 media element.
     *
     * @return {number}
     *         The width of the HTML5 media element.
     */
    width() {
      return this.el_.offsetWidth;
    }

    /**
     * Get the current height of the HTML5 media element.
     *
     * @return {number}
     *         The height of the HTML5 media element.
     */
    height() {
      return this.el_.offsetHeight;
    }

    /**
     * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into
     * `fullscreenchange` event.
     *
     * @private
     * @fires fullscreenchange
     * @listens webkitendfullscreen
     * @listens webkitbeginfullscreen
     * @listens webkitbeginfullscreen
     */
    proxyWebkitFullscreen_() {
      if (!('webkitDisplayingFullscreen' in this.el_)) {
        return;
      }
      const endFn = function () {
        this.trigger('fullscreenchange', {
          isFullscreen: false
        });
        // Safari will sometimes set controls on the videoelement when existing fullscreen.
        if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {
          this.el_.controls = false;
        }
      };
      const beginFn = function () {
        if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {
          this.one('webkitendfullscreen', endFn);
          this.trigger('fullscreenchange', {
            isFullscreen: true,
            // set a flag in case another tech triggers fullscreenchange
            nativeIOSFullscreen: true
          });
        }
      };
      this.on('webkitbeginfullscreen', beginFn);
      this.on('dispose', () => {
        this.off('webkitbeginfullscreen', beginFn);
        this.off('webkitendfullscreen', endFn);
      });
    }

    /**
     * Check if fullscreen is supported on the video el.
     *
     * @return {boolean}
     *         - True if fullscreen is supported.
     *         - False if fullscreen is not supported.
     */
    supportsFullScreen() {
      return typeof this.el_.webkitEnterFullScreen === 'function';
    }

    /**
     * Request that the `HTML5` Tech enter fullscreen.
     */
    enterFullScreen() {
      const video = this.el_;
      if (video.paused && video.networkState <= video.HAVE_METADATA) {
        // attempt to prime the video element for programmatic access
        // this isn't necessary on the desktop but shouldn't hurt
        silencePromise(this.el_.play());

        // playing and pausing synchronously during the transition to fullscreen
        // can get iOS ~6.1 devices into a play/pause loop
        this.setTimeout(function () {
          video.pause();
          try {
            video.webkitEnterFullScreen();
          } catch (e) {
            this.trigger('fullscreenerror', e);
          }
        }, 0);
      } else {
        try {
          video.webkitEnterFullScreen();
        } catch (e) {
          this.trigger('fullscreenerror', e);
        }
      }
    }

    /**
     * Request that the `HTML5` Tech exit fullscreen.
     */
    exitFullScreen() {
      if (!this.el_.webkitDisplayingFullscreen) {
        this.trigger('fullscreenerror', new Error('The video is not fullscreen'));
        return;
      }
      this.el_.webkitExitFullScreen();
    }

    /**
     * Create a floating video window always on top of other windows so that users may
     * continue consuming media while they interact with other content sites, or
     * applications on their device.
     *
     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
     *
     * @return {Promise}
     *         A promise with a Picture-in-Picture window.
     */
    requestPictureInPicture() {
      return this.el_.requestPictureInPicture();
    }

    /**
     * Native requestVideoFrameCallback if supported by browser/tech, or fallback
     * Don't use rVCF on Safari when DRM is playing, as it doesn't fire
     * Needs to be checked later than the constructor
     * This will be a false positive for clear sources loaded after a Fairplay source
     *
     * @param {function} cb function to call
     * @return {number} id of request
     */
    requestVideoFrameCallback(cb) {
      if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
        return this.el_.requestVideoFrameCallback(cb);
      }
      return super.requestVideoFrameCallback(cb);
    }

    /**
     * Native or fallback requestVideoFrameCallback
     *
     * @param {number} id request id to cancel
     */
    cancelVideoFrameCallback(id) {
      if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
        this.el_.cancelVideoFrameCallback(id);
      } else {
        super.cancelVideoFrameCallback(id);
      }
    }

    /**
     * A getter/setter for the `Html5` Tech's source object.
     * > Note: Please use {@link Html5#setSource}
     *
     * @param {Tech~SourceObject} [src]
     *        The source object you want to set on the `HTML5` techs element.
     *
     * @return {Tech~SourceObject|undefined}
     *         - The current source object when a source is not passed in.
     *         - undefined when setting
     *
     * @deprecated Since version 5.
     */
    src(src) {
      if (src === undefined) {
        return this.el_.src;
      }

      // Setting src through `src` instead of `setSrc` will be deprecated
      this.setSrc(src);
    }

    /**
     * Reset the tech by removing all sources and then calling
     * {@link Html5.resetMediaElement}.
     */
    reset() {
      Html5.resetMediaElement(this.el_);
    }

    /**
     * Get the current source on the `HTML5` Tech. Falls back to returning the source from
     * the HTML5 media element.
     *
     * @return {Tech~SourceObject}
     *         The current source object from the HTML5 tech. With a fallback to the
     *         elements source.
     */
    currentSrc() {
      if (this.currentSource_) {
        return this.currentSource_.src;
      }
      return this.el_.currentSrc;
    }

    /**
     * Set controls attribute for the HTML5 media Element.
     *
     * @param {string} val
     *        Value to set the controls attribute to
     */
    setControls(val) {
      this.el_.controls = !!val;
    }

    /**
     * Create and returns a remote {@link TextTrack} object.
     *
     * @param {string} kind
     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
     *
     * @param {string} [label]
     *        Label to identify the text track
     *
     * @param {string} [language]
     *        Two letter language abbreviation
     *
     * @return {TextTrack}
     *         The TextTrack that gets created.
     */
    addTextTrack(kind, label, language) {
      if (!this.featuresNativeTextTracks) {
        return super.addTextTrack(kind, label, language);
      }
      return this.el_.addTextTrack(kind, label, language);
    }

    /**
     * Creates either native TextTrack or an emulated TextTrack depending
     * on the value of `featuresNativeTextTracks`
     *
     * @param {Object} options
     *        The object should contain the options to initialize the TextTrack with.
     *
     * @param {string} [options.kind]
     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
     *
     * @param {string} [options.label]
     *        Label to identify the text track
     *
     * @param {string} [options.language]
     *        Two letter language abbreviation.
     *
     * @param {boolean} [options.default]
     *        Default this track to on.
     *
     * @param {string} [options.id]
     *        The internal id to assign this track.
     *
     * @param {string} [options.src]
     *        A source url for the track.
     *
     * @return {HTMLTrackElement}
     *         The track element that gets created.
     */
    createRemoteTextTrack(options) {
      if (!this.featuresNativeTextTracks) {
        return super.createRemoteTextTrack(options);
      }
      const htmlTrackElement = document__default["default"].createElement('track');
      if (options.kind) {
        htmlTrackElement.kind = options.kind;
      }
      if (options.label) {
        htmlTrackElement.label = options.label;
      }
      if (options.language || options.srclang) {
        htmlTrackElement.srclang = options.language || options.srclang;
      }
      if (options.default) {
        htmlTrackElement.default = options.default;
      }
      if (options.id) {
        htmlTrackElement.id = options.id;
      }
      if (options.src) {
        htmlTrackElement.src = options.src;
      }
      return htmlTrackElement;
    }

    /**
     * Creates a remote text track object and returns an html track element.
     *
     * @param {Object} options The object should contain values for
     * kind, language, label, and src (location of the WebVTT file)
     * @param {boolean} [manualCleanup=false] if set to true, the TextTrack
     * will not be removed from the TextTrackList and HtmlTrackElementList
     * after a source change
     * @return {HTMLTrackElement} An Html Track Element.
     * This can be an emulated {@link HTMLTrackElement} or a native one.
     *
     */
    addRemoteTextTrack(options, manualCleanup) {
      const htmlTrackElement = super.addRemoteTextTrack(options, manualCleanup);
      if (this.featuresNativeTextTracks) {
        this.el().appendChild(htmlTrackElement);
      }
      return htmlTrackElement;
    }

    /**
     * Remove remote `TextTrack` from `TextTrackList` object
     *
     * @param {TextTrack} track
     *        `TextTrack` object to remove
     */
    removeRemoteTextTrack(track) {
      super.removeRemoteTextTrack(track);
      if (this.featuresNativeTextTracks) {
        const tracks = this.$$('track');
        let i = tracks.length;
        while (i--) {
          if (track === tracks[i] || track === tracks[i].track) {
            this.el().removeChild(tracks[i]);
          }
        }
      }
    }

    /**
     * Gets available media playback quality metrics as specified by the W3C's Media
     * Playback Quality API.
     *
     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
     *
     * @return {Object}
     *         An object with supported media playback quality metrics
     */
    getVideoPlaybackQuality() {
      if (typeof this.el().getVideoPlaybackQuality === 'function') {
        return this.el().getVideoPlaybackQuality();
      }
      const videoPlaybackQuality = {};
      if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {
        videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
        videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
      }
      if (window__default["default"].performance) {
        videoPlaybackQuality.creationTime = window__default["default"].performance.now();
      }
      return videoPlaybackQuality;
    }
  }

  /* HTML5 Support Testing ---------------------------------------------------- */

  /**
   * Element for testing browser HTML5 media capabilities
   *
   * @type {Element}
   * @constant
   * @private
   */
  defineLazyProperty(Html5, 'TEST_VID', function () {
    if (!isReal()) {
      return;
    }
    const video = document__default["default"].createElement('video');
    const track = document__default["default"].createElement('track');
    track.kind = 'captions';
    track.srclang = 'en';
    track.label = 'English';
    video.appendChild(track);
    return video;
  });

  /**
   * Check if HTML5 media is supported by this browser/device.
   *
   * @return {boolean}
   *         - True if HTML5 media is supported.
   *         - False if HTML5 media is not supported.
   */
  Html5.isSupported = function () {
    // IE with no Media Player is a LIAR! (#984)
    try {
      Html5.TEST_VID.volume = 0.5;
    } catch (e) {
      return false;
    }
    return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
  };

  /**
   * Check if the tech can support the given type
   *
   * @param {string} type
   *        The mimetype to check
   * @return {string} 'probably', 'maybe', or '' (empty string)
   */
  Html5.canPlayType = function (type) {
    return Html5.TEST_VID.canPlayType(type);
  };

  /**
   * Check if the tech can support the given source
   *
   * @param {Object} srcObj
   *        The source object
   * @param {Object} options
   *        The options passed to the tech
   * @return {string} 'probably', 'maybe', or '' (empty string)
   */
  Html5.canPlaySource = function (srcObj, options) {
    return Html5.canPlayType(srcObj.type);
  };

  /**
   * Check if the volume can be changed in this browser/device.
   * Volume cannot be changed in a lot of mobile devices.
   * Specifically, it can't be changed from 1 on iOS.
   *
   * @return {boolean}
   *         - True if volume can be controlled
   *         - False otherwise
   */
  Html5.canControlVolume = function () {
    // IE will error if Windows Media Player not installed #3315
    try {
      const volume = Html5.TEST_VID.volume;
      Html5.TEST_VID.volume = volume / 2 + 0.1;
      const canControl = volume !== Html5.TEST_VID.volume;

      // With the introduction of iOS 15, there are cases where the volume is read as
      // changed but reverts back to its original state at the start of the next tick.
      // To determine whether volume can be controlled on iOS,
      // a timeout is set and the volume is checked asynchronously.
      // Since `features` doesn't currently work asynchronously, the value is manually set.
      if (canControl && IS_IOS) {
        window__default["default"].setTimeout(() => {
          if (Html5 && Html5.prototype) {
            Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;
          }
        });

        // default iOS to false, which will be updated in the timeout above.
        return false;
      }
      return canControl;
    } catch (e) {
      return false;
    }
  };

  /**
   * Check if the volume can be muted in this browser/device.
   * Some devices, e.g. iOS, don't allow changing volume
   * but permits muting/unmuting.
   *
   * @return {boolean}
   *      - True if volume can be muted
   *      - False otherwise
   */
  Html5.canMuteVolume = function () {
    try {
      const muted = Html5.TEST_VID.muted;

      // in some versions of iOS muted property doesn't always
      // work, so we want to set both property and attribute
      Html5.TEST_VID.muted = !muted;
      if (Html5.TEST_VID.muted) {
        setAttribute(Html5.TEST_VID, 'muted', 'muted');
      } else {
        removeAttribute(Html5.TEST_VID, 'muted', 'muted');
      }
      return muted !== Html5.TEST_VID.muted;
    } catch (e) {
      return false;
    }
  };

  /**
   * Check if the playback rate can be changed in this browser/device.
   *
   * @return {boolean}
   *         - True if playback rate can be controlled
   *         - False otherwise
   */
  Html5.canControlPlaybackRate = function () {
    // Playback rate API is implemented in Android Chrome, but doesn't do anything
    // https://github.com/videojs/video.js/issues/3180
    if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
      return false;
    }
    // IE will error if Windows Media Player not installed #3315
    try {
      const playbackRate = Html5.TEST_VID.playbackRate;
      Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
      return playbackRate !== Html5.TEST_VID.playbackRate;
    } catch (e) {
      return false;
    }
  };

  /**
   * Check if we can override a video/audio elements attributes, with
   * Object.defineProperty.
   *
   * @return {boolean}
   *         - True if builtin attributes can be overridden
   *         - False otherwise
   */
  Html5.canOverrideAttributes = function () {
    // if we cannot overwrite the src/innerHTML property, there is no support
    // iOS 7 safari for instance cannot do this.
    try {
      const noop = () => {};
      Object.defineProperty(document__default["default"].createElement('video'), 'src', {
        get: noop,
        set: noop
      });
      Object.defineProperty(document__default["default"].createElement('audio'), 'src', {
        get: noop,
        set: noop
      });
      Object.defineProperty(document__default["default"].createElement('video'), 'innerHTML', {
        get: noop,
        set: noop
      });
      Object.defineProperty(document__default["default"].createElement('audio'), 'innerHTML', {
        get: noop,
        set: noop
      });
    } catch (e) {
      return false;
    }
    return true;
  };

  /**
   * Check to see if native `TextTrack`s are supported by this browser/device.
   *
   * @return {boolean}
   *         - True if native `TextTrack`s are supported.
   *         - False otherwise
   */
  Html5.supportsNativeTextTracks = function () {
    return IS_ANY_SAFARI || IS_IOS && IS_CHROME;
  };

  /**
   * Check to see if native `VideoTrack`s are supported by this browser/device
   *
   * @return {boolean}
   *        - True if native `VideoTrack`s are supported.
   *        - False otherwise
   */
  Html5.supportsNativeVideoTracks = function () {
    return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
  };

  /**
   * Check to see if native `AudioTrack`s are supported by this browser/device
   *
   * @return {boolean}
   *        - True if native `AudioTrack`s are supported.
   *        - False otherwise
   */
  Html5.supportsNativeAudioTracks = function () {
    return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
  };

  /**
   * An array of events available on the Html5 tech.
   *
   * @private
   * @type {Array}
   */
  Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];

  /**
   * Boolean indicating whether the `Tech` supports volume control.
   *
   * @type {boolean}
   * @default {@link Html5.canControlVolume}
   */
  /**
   * Boolean indicating whether the `Tech` supports muting volume.
   *
   * @type {boolean}
   * @default {@link Html5.canMuteVolume}
   */

  /**
   * Boolean indicating whether the `Tech` supports changing the speed at which the media
   * plays. Examples:
   *   - Set player to play 2x (twice) as fast
   *   - Set player to play 0.5x (half) as fast
   *
   * @type {boolean}
   * @default {@link Html5.canControlPlaybackRate}
   */

  /**
   * Boolean indicating whether the `Tech` supports the `sourceset` event.
   *
   * @type {boolean}
   * @default
   */
  /**
   * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.
   *
   * @type {boolean}
   * @default {@link Html5.supportsNativeTextTracks}
   */
  /**
   * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.
   *
   * @type {boolean}
   * @default {@link Html5.supportsNativeVideoTracks}
   */
  /**
   * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.
   *
   * @type {boolean}
   * @default {@link Html5.supportsNativeAudioTracks}
   */
  [['featuresMuteControl', 'canMuteVolume'], ['featuresPlaybackRate', 'canControlPlaybackRate'], ['featuresSourceset', 'canOverrideAttributes'], ['featuresNativeTextTracks', 'supportsNativeTextTracks'], ['featuresNativeVideoTracks', 'supportsNativeVideoTracks'], ['featuresNativeAudioTracks', 'supportsNativeAudioTracks']].forEach(function ([key, fn]) {
    defineLazyProperty(Html5.prototype, key, () => Html5[fn](), true);
  });
  Html5.prototype.featuresVolumeControl = Html5.canControlVolume();

  /**
   * Boolean indicating whether the `HTML5` tech currently supports the media element
   * moving in the DOM. iOS breaks if you move the media element, so this is set this to
   * false there. Everywhere else this should be true.
   *
   * @type {boolean}
   * @default
   */
  Html5.prototype.movingMediaElementInDOM = !IS_IOS;

  // TODO: Previous comment: No longer appears to be used. Can probably be removed.
  //       Is this true?
  /**
   * Boolean indicating whether the `HTML5` tech currently supports automatic media resize
   * when going into fullscreen.
   *
   * @type {boolean}
   * @default
   */
  Html5.prototype.featuresFullscreenResize = true;

  /**
   * Boolean indicating whether the `HTML5` tech currently supports the progress event.
   * If this is false, manual `progress` events will be triggered instead.
   *
   * @type {boolean}
   * @default
   */
  Html5.prototype.featuresProgressEvents = true;

  /**
   * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.
   * If this is false, manual `timeupdate` events will be triggered instead.
   *
   * @default
   */
  Html5.prototype.featuresTimeupdateEvents = true;

  /**
   * Whether the HTML5 el supports `requestVideoFrameCallback`
   *
   * @type {boolean}
   */
  Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback);
  Html5.disposeMediaElement = function (el) {
    if (!el) {
      return;
    }
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }

    // remove any child track or source nodes to prevent their loading
    while (el.hasChildNodes()) {
      el.removeChild(el.firstChild);
    }

    // remove any src reference. not setting `src=''` because that causes a warning
    // in firefox
    el.removeAttribute('src');

    // force the media element to update its loading state by calling load()
    // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
    if (typeof el.load === 'function') {
      // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
      (function () {
        try {
          el.load();
        } catch (e) {
          // not supported
        }
      })();
    }
  };
  Html5.resetMediaElement = function (el) {
    if (!el) {
      return;
    }
    const sources = el.querySelectorAll('source');
    let i = sources.length;
    while (i--) {
      el.removeChild(sources[i]);
    }

    // remove any src reference.
    // not setting `src=''` because that throws an error
    el.removeAttribute('src');
    if (typeof el.load === 'function') {
      // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
      (function () {
        try {
          el.load();
        } catch (e) {
          // satisfy linter
        }
      })();
    }
  };

  /* Native HTML5 element property wrapping ----------------------------------- */
  // Wrap native boolean attributes with getters that check both property and attribute
  // The list is as followed:
  // muted, defaultMuted, autoplay, controls, loop, playsinline
  [
  /**
   * Get the value of `muted` from the media element. `muted` indicates
   * that the volume for the media should be set to silent. This does not actually change
   * the `volume` attribute.
   *
   * @method Html5#muted
   * @return {boolean}
   *         - True if the value of `volume` should be ignored and the audio set to silent.
   *         - False if the value of `volume` should be used.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  'muted',
  /**
   * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
   * whether the media should start muted or not. Only changes the default state of the
   * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
   * current state.
   *
   * @method Html5#defaultMuted
   * @return {boolean}
   *         - The value of `defaultMuted` from the media element.
   *         - True indicates that the media should start muted.
   *         - False indicates that the media should not start muted
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  'defaultMuted',
  /**
   * Get the value of `autoplay` from the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#autoplay
   * @return {boolean}
   *         - The value of `autoplay` from the media element.
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  'autoplay',
  /**
   * Get the value of `controls` from the media element. `controls` indicates
   * whether the native media controls should be shown or hidden.
   *
   * @method Html5#controls
   * @return {boolean}
   *         - The value of `controls` from the media element.
   *         - True indicates that native controls should be showing.
   *         - False indicates that native controls should be hidden.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
   */
  'controls',
  /**
   * Get the value of `loop` from the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#loop
   * @return {boolean}
   *         - The value of `loop` from the media element.
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  'loop',
  /**
   * Get the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#playsinline
   * @return {boolean}
   *         - The value of `playsinline` from the media element.
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  'playsinline'].forEach(function (prop) {
    Html5.prototype[prop] = function () {
      return this.el_[prop] || this.el_.hasAttribute(prop);
    };
  });

  // Wrap native boolean attributes with setters that set both property and attribute
  // The list is as followed:
  // setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline
  // setControls is special-cased above
  [
  /**
   * Set the value of `muted` on the media element. `muted` indicates that the current
   * audio level should be silent.
   *
   * @method Html5#setMuted
   * @param {boolean} muted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  'muted',
  /**
   * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
   * audio level should be silent, but will only effect the muted level on initial playback..
   *
   * @method Html5.prototype.setDefaultMuted
   * @param {boolean} defaultMuted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  'defaultMuted',
  /**
   * Set the value of `autoplay` on the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#setAutoplay
   * @param {boolean} autoplay
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  'autoplay',
  /**
   * Set the value of `loop` on the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#setLoop
   * @param {boolean} loop
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  'loop',
  /**
   * Set the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#setPlaysinline
   * @param {boolean} playsinline
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  'playsinline'].forEach(function (prop) {
    Html5.prototype['set' + toTitleCase(prop)] = function (v) {
      this.el_[prop] = v;
      if (v) {
        this.el_.setAttribute(prop, prop);
      } else {
        this.el_.removeAttribute(prop);
      }
    };
  });

  // Wrap native properties with a getter
  // The list is as followed
  // paused, currentTime, buffered, volume, poster, preload, error, seeking
  // seekable, ended, playbackRate, defaultPlaybackRate, disablePictureInPicture
  // played, networkState, readyState, videoWidth, videoHeight, crossOrigin
  [
  /**
   * Get the value of `paused` from the media element. `paused` indicates whether the media element
   * is currently paused or not.
   *
   * @method Html5#paused
   * @return {boolean}
   *         The value of `paused` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
   */
  'paused',
  /**
   * Get the value of `currentTime` from the media element. `currentTime` indicates
   * the current second that the media is at in playback.
   *
   * @method Html5#currentTime
   * @return {number}
   *         The value of `currentTime` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
   */
  'currentTime',
  /**
   * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
   * object that represents the parts of the media that are already downloaded and
   * available for playback.
   *
   * @method Html5#buffered
   * @return {TimeRange}
   *         The value of `buffered` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
   */
  'buffered',
  /**
   * Get the value of `volume` from the media element. `volume` indicates
   * the current playback volume of audio for a media. `volume` will be a value from 0
   * (silent) to 1 (loudest and default).
   *
   * @method Html5#volume
   * @return {number}
   *         The value of `volume` from the media element. Value will be between 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  'volume',
  /**
   * Get the value of `poster` from the media element. `poster` indicates
   * that the url of an image file that can/will be shown when no media data is available.
   *
   * @method Html5#poster
   * @return {string}
   *         The value of `poster` from the media element. Value will be a url to an
   *         image.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
   */
  'poster',
  /**
   * Get the value of `preload` from the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#preload
   * @return {string}
   *         The value of `preload` from the media element. Will be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  'preload',
  /**
   * Get the value of the `error` from the media element. `error` indicates any
   * MediaError that may have occurred during playback. If error returns null there is no
   * current error.
   *
   * @method Html5#error
   * @return {MediaError|null}
   *         The value of `error` from the media element. Will be `MediaError` if there
   *         is a current error and null otherwise.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
   */
  'error',
  /**
   * Get the value of `seeking` from the media element. `seeking` indicates whether the
   * media is currently seeking to a new position or not.
   *
   * @method Html5#seeking
   * @return {boolean}
   *         - The value of `seeking` from the media element.
   *         - True indicates that the media is currently seeking to a new position.
   *         - False indicates that the media is not seeking to a new position at this time.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
   */
  'seeking',
  /**
   * Get the value of `seekable` from the media element. `seekable` returns a
   * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
   *
   * @method Html5#seekable
   * @return {TimeRange}
   *         The value of `seekable` from the media element. A `TimeRange` object
   *         indicating the current ranges of time that can be seeked to.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
   */
  'seekable',
  /**
   * Get the value of `ended` from the media element. `ended` indicates whether
   * the media has reached the end or not.
   *
   * @method Html5#ended
   * @return {boolean}
   *         - The value of `ended` from the media element.
   *         - True indicates that the media has ended.
   *         - False indicates that the media has not ended.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
   */
  'ended',
  /**
   * Get the value of `playbackRate` from the media element. `playbackRate` indicates
   * the rate at which the media is currently playing back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#playbackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  'playbackRate',
  /**
   * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
   * the rate at which the media is currently playing back. This value will not indicate the current
   * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
   *
   * Examples:
   *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
   *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.defaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  'defaultPlaybackRate',
  /**
   * Get the value of 'disablePictureInPicture' from the video element.
   *
   * @method Html5#disablePictureInPicture
   * @return {boolean} value
   *         - The value of `disablePictureInPicture` from the video element.
   *         - True indicates that the video can't be played in Picture-In-Picture mode
   *         - False indicates that the video can be played in Picture-In-Picture mode
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  'disablePictureInPicture',
  /**
   * Get the value of `played` from the media element. `played` returns a `TimeRange`
   * object representing points in the media timeline that have been played.
   *
   * @method Html5#played
   * @return {TimeRange}
   *         The value of `played` from the media element. A `TimeRange` object indicating
   *         the ranges of time that have been played.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
   */
  'played',
  /**
   * Get the value of `networkState` from the media element. `networkState` indicates
   * the current network state. It returns an enumeration from the following list:
   * - 0: NETWORK_EMPTY
   * - 1: NETWORK_IDLE
   * - 2: NETWORK_LOADING
   * - 3: NETWORK_NO_SOURCE
   *
   * @method Html5#networkState
   * @return {number}
   *         The value of `networkState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
   */
  'networkState',
  /**
   * Get the value of `readyState` from the media element. `readyState` indicates
   * the current state of the media element. It returns an enumeration from the
   * following list:
   * - 0: HAVE_NOTHING
   * - 1: HAVE_METADATA
   * - 2: HAVE_CURRENT_DATA
   * - 3: HAVE_FUTURE_DATA
   * - 4: HAVE_ENOUGH_DATA
   *
   * @method Html5#readyState
   * @return {number}
   *         The value of `readyState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
   */
  'readyState',
  /**
   * Get the value of `videoWidth` from the video element. `videoWidth` indicates
   * the current width of the video in css pixels.
   *
   * @method Html5#videoWidth
   * @return {number}
   *         The value of `videoWidth` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  'videoWidth',
  /**
   * Get the value of `videoHeight` from the video element. `videoHeight` indicates
   * the current height of the video in css pixels.
   *
   * @method Html5#videoHeight
   * @return {number}
   *         The value of `videoHeight` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  'videoHeight',
  /**
   * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#crossOrigin
   * @return {string}
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  'crossOrigin'].forEach(function (prop) {
    Html5.prototype[prop] = function () {
      return this.el_[prop];
    };
  });

  // Wrap native properties with a setter in this format:
  // set + toTitleCase(name)
  // The list is as follows:
  // setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate,
  // setDisablePictureInPicture, setCrossOrigin
  [
  /**
   * Set the value of `volume` on the media element. `volume` indicates the current
   * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
   * so on.
   *
   * @method Html5#setVolume
   * @param {number} percentAsDecimal
   *        The volume percent as a decimal. Valid range is from 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  'volume',
  /**
   * Set the value of `src` on the media element. `src` indicates the current
   * {@link Tech~SourceObject} for the media.
   *
   * @method Html5#setSrc
   * @param {Tech~SourceObject} src
   *        The source object to set as the current source.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
   */
  'src',
  /**
   * Set the value of `poster` on the media element. `poster` is the url to
   * an image file that can/will be shown when no media data is available.
   *
   * @method Html5#setPoster
   * @param {string} poster
   *        The url to an image that should be used as the `poster` for the media
   *        element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
   */
  'poster',
  /**
   * Set the value of `preload` on the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#setPreload
   * @param {string} preload
   *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  'preload',
  /**
   * Set the value of `playbackRate` on the media element. `playbackRate` indicates
   * the rate at which the media should play back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#setPlaybackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  'playbackRate',
  /**
   * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
   * the rate at which the media should play back upon initial startup. Changing this value
   * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
   *
   * Example Values:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.setDefaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
   */
  'defaultPlaybackRate',
  /**
   * Prevents the browser from suggesting a Picture-in-Picture context menu
   * or to request Picture-in-Picture automatically in some cases.
   *
   * @method Html5#setDisablePictureInPicture
   * @param {boolean} value
   *         The true value will disable Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  'disablePictureInPicture',
  /**
   * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#setCrossOrigin
   * @param {string} crossOrigin
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  'crossOrigin'].forEach(function (prop) {
    Html5.prototype['set' + toTitleCase(prop)] = function (v) {
      this.el_[prop] = v;
    };
  });

  // wrap native functions with a function
  // The list is as follows:
  // pause, load, play
  [
  /**
   * A wrapper around the media elements `pause` function. This will call the `HTML5`
   * media elements `pause` function.
   *
   * @method Html5#pause
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
   */
  'pause',
  /**
   * A wrapper around the media elements `load` function. This will call the `HTML5`s
   * media element `load` function.
   *
   * @method Html5#load
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
   */
  'load',
  /**
   * A wrapper around the media elements `play` function. This will call the `HTML5`s
   * media element `play` function.
   *
   * @method Html5#play
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
   */
  'play'].forEach(function (prop) {
    Html5.prototype[prop] = function () {
      return this.el_[prop]();
    };
  });
  Tech.withSourceHandlers(Html5);

  /**
   * Native source handler for Html5, simply passes the source to the media element.
   *
   * @property {Tech~SourceObject} source
   *        The source object
   *
   * @property {Html5} tech
   *        The instance of the HTML5 tech.
   */
  Html5.nativeSourceHandler = {};

  /**
   * Check if the media element can play the given mime type.
   *
   * @param {string} type
   *        The mimetype to check
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  Html5.nativeSourceHandler.canPlayType = function (type) {
    // IE without MediaPlayer throws an error (#519)
    try {
      return Html5.TEST_VID.canPlayType(type);
    } catch (e) {
      return '';
    }
  };

  /**
   * Check if the media element can handle a source natively.
   *
   * @param {Tech~SourceObject} source
   *         The source object
   *
   * @param {Object} [options]
   *         Options to be passed to the tech.
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string).
   */
  Html5.nativeSourceHandler.canHandleSource = function (source, options) {
    // If a type was provided we should rely on that
    if (source.type) {
      return Html5.nativeSourceHandler.canPlayType(source.type);

      // If no type, fall back to checking 'video/[EXTENSION]'
    } else if (source.src) {
      const ext = getFileExtension(source.src);
      return Html5.nativeSourceHandler.canPlayType(`video/${ext}`);
    }
    return '';
  };

  /**
   * Pass the source to the native media element.
   *
   * @param {Tech~SourceObject} source
   *        The source object
   *
   * @param {Html5} tech
   *        The instance of the Html5 tech
   *
   * @param {Object} [options]
   *        The options to pass to the source
   */
  Html5.nativeSourceHandler.handleSource = function (source, tech, options) {
    tech.setSrc(source.src);
  };

  /**
   * A noop for the native dispose function, as cleanup is not needed.
   */
  Html5.nativeSourceHandler.dispose = function () {};

  // Register the native source handler
  Html5.registerSourceHandler(Html5.nativeSourceHandler);
  Tech.registerTech('Html5', Html5);

  /**
   * @file player.js
   */

  /** @import { TimeRange } from './utils/time' */
  /** @import HtmlTrackElement from './tracks/html-track-element' */

  /**
   * @callback PlayerReadyCallback
   * @this     {Player}
   * @returns  {void}
   */

  // The following tech events are simply re-triggered
  // on the player when they happen
  const TECH_EVENTS_RETRIGGER = [
  /**
   * Fired while the user agent is downloading media data.
   *
   * @event Player#progress
   * @type {Event}
   */
  /**
   * Retrigger the `progress` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechProgress_
   * @fires Player#progress
   * @listens Tech#progress
   */
  'progress',
  /**
   * Fires when the loading of an audio/video is aborted.
   *
   * @event Player#abort
   * @type {Event}
   */
  /**
   * Retrigger the `abort` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechAbort_
   * @fires Player#abort
   * @listens Tech#abort
   */
  'abort',
  /**
   * Fires when the browser is intentionally not getting media data.
   *
   * @event Player#suspend
   * @type {Event}
   */
  /**
   * Retrigger the `suspend` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechSuspend_
   * @fires Player#suspend
   * @listens Tech#suspend
   */
  'suspend',
  /**
   * Fires when the current playlist is empty.
   *
   * @event Player#emptied
   * @type {Event}
   */
  /**
   * Retrigger the `emptied` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechEmptied_
   * @fires Player#emptied
   * @listens Tech#emptied
   */
  'emptied',
  /**
   * Fires when the browser is trying to get media data, but data is not available.
   *
   * @event Player#stalled
   * @type {Event}
   */
  /**
   * Retrigger the `stalled` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechStalled_
   * @fires Player#stalled
   * @listens Tech#stalled
   */
  'stalled',
  /**
   * Fires when the browser has loaded meta data for the audio/video.
   *
   * @event Player#loadedmetadata
   * @type {Event}
   */
  /**
   * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoadedmetadata_
   * @fires Player#loadedmetadata
   * @listens Tech#loadedmetadata
   */
  'loadedmetadata',
  /**
   * Fires when the browser has loaded the current frame of the audio/video.
   *
   * @event Player#loadeddata
   * @type {event}
   */
  /**
   * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoaddeddata_
   * @fires Player#loadeddata
   * @listens Tech#loadeddata
   */
  'loadeddata',
  /**
   * Fires when the current playback position has changed.
   *
   * @event Player#timeupdate
   * @type {event}
   */
  /**
   * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTimeUpdate_
   * @fires Player#timeupdate
   * @listens Tech#timeupdate
   */
  'timeupdate',
  /**
   * Fires when the video's intrinsic dimensions change
   *
   * @event Player#resize
   * @type {event}
   */
  /**
   * Retrigger the `resize` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechResize_
   * @fires Player#resize
   * @listens Tech#resize
   */
  'resize',
  /**
   * Fires when the volume has been changed
   *
   * @event Player#volumechange
   * @type {event}
   */
  /**
   * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechVolumechange_
   * @fires Player#volumechange
   * @listens Tech#volumechange
   */
  'volumechange',
  /**
   * Fires when the text track has been changed
   *
   * @event Player#texttrackchange
   * @type {event}
   */
  /**
   * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTexttrackchange_
   * @fires Player#texttrackchange
   * @listens Tech#texttrackchange
   */
  'texttrackchange'];

  // events to queue when playback rate is zero
  // this is a hash for the sole purpose of mapping non-camel-cased event names
  // to camel-cased function names
  const TECH_EVENTS_QUEUE = {
    canplay: 'CanPlay',
    canplaythrough: 'CanPlayThrough',
    playing: 'Playing',
    seeked: 'Seeked'
  };
  const BREAKPOINT_ORDER = ['tiny', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'huge'];
  const BREAKPOINT_CLASSES = {};

  // grep: vjs-layout-tiny
  // grep: vjs-layout-x-small
  // grep: vjs-layout-small
  // grep: vjs-layout-medium
  // grep: vjs-layout-large
  // grep: vjs-layout-x-large
  // grep: vjs-layout-huge
  BREAKPOINT_ORDER.forEach(k => {
    const v = k.charAt(0) === 'x' ? `x-${k.substring(1)}` : k;
    BREAKPOINT_CLASSES[k] = `vjs-layout-${v}`;
  });
  const DEFAULT_BREAKPOINTS = {
    tiny: 210,
    xsmall: 320,
    small: 425,
    medium: 768,
    large: 1440,
    xlarge: 2560,
    huge: Infinity
  };

  /**
   * An instance of the `Player` class is created when any of the Video.js setup methods
   * are used to initialize a video.
   *
   * After an instance has been created it can be accessed globally in three ways:
   * 1. By calling `videojs.getPlayer('example_video_1');`
   * 2. By calling `videojs('example_video_1');` (not recommended)
   * 2. By using it directly via `videojs.players.example_video_1;`
   *
   * @extends Component
   * @global
   */
  class Player extends Component {
    /**
     * Create an instance of this class.
     *
     * @param {Element} tag
     *        The original video DOM element used for configuring options.
     *
     * @param {Object} [options]
     *        Object of option names and values.
     *
     * @param {PlayerReadyCallback} [ready]
     *        Ready callback function.
     */
    constructor(tag, options, ready) {
      // Make sure tag ID exists
      // also here.. probably better
      tag.id = tag.id || options.id || `vjs_video_${newGUID()}`;

      // Set Options
      // The options argument overrides options set in the video tag
      // which overrides globally set options.
      // This latter part coincides with the load order
      // (tag must exist before Player)
      options = Object.assign(Player.getTagSettings(tag), options);

      // Delay the initialization of children because we need to set up
      // player properties first, and can't use `this` before `super()`
      options.initChildren = false;

      // Same with creating the element
      options.createEl = false;

      // don't auto mixin the evented mixin
      options.evented = false;

      // we don't want the player to report touch activity on itself
      // see enableTouchActivity in Component
      options.reportTouchActivity = false;

      // If language is not set, get the closest lang attribute
      if (!options.language) {
        const closest = tag.closest('[lang]');
        if (closest) {
          options.language = closest.getAttribute('lang');
        }
      }

      // Run base component initializing with new options
      super(null, options, ready);

      // Create bound methods for document listeners.
      this.boundDocumentFullscreenChange_ = e => this.documentFullscreenChange_(e);
      this.boundFullWindowOnEscKey_ = e => this.fullWindowOnEscKey(e);
      this.boundUpdateStyleEl_ = e => this.updateStyleEl_(e);
      this.boundApplyInitTime_ = e => this.applyInitTime_(e);
      this.boundUpdateCurrentBreakpoint_ = e => this.updateCurrentBreakpoint_(e);
      this.boundHandleTechClick_ = e => this.handleTechClick_(e);
      this.boundHandleTechDoubleClick_ = e => this.handleTechDoubleClick_(e);
      this.boundHandleTechTouchStart_ = e => this.handleTechTouchStart_(e);
      this.boundHandleTechTouchMove_ = e => this.handleTechTouchMove_(e);
      this.boundHandleTechTouchEnd_ = e => this.handleTechTouchEnd_(e);
      this.boundHandleTechTap_ = e => this.handleTechTap_(e);
      this.boundUpdatePlayerHeightOnAudioOnlyMode_ = e => this.updatePlayerHeightOnAudioOnlyMode_(e);

      // default isFullscreen_ to false
      this.isFullscreen_ = false;

      // create logger
      this.log = createLogger(this.id_);

      // Hold our own reference to fullscreen api so it can be mocked in tests
      this.fsApi_ = FullscreenApi;

      // Tracks when a tech changes the poster
      this.isPosterFromTech_ = false;

      // Holds callback info that gets queued when playback rate is zero
      // and a seek is happening
      this.queuedCallbacks_ = [];

      // Turn off API access because we're loading a new tech that might load asynchronously
      this.isReady_ = false;

      // Init state hasStarted_
      this.hasStarted_ = false;

      // Init state userActive_
      this.userActive_ = false;

      // Init debugEnabled_
      this.debugEnabled_ = false;

      // Init state audioOnlyMode_
      this.audioOnlyMode_ = false;

      // Init state audioPosterMode_
      this.audioPosterMode_ = false;

      // Init state audioOnlyCache_
      this.audioOnlyCache_ = {
        controlBarHeight: null,
        playerHeight: null,
        hiddenChildren: []
      };

      // if the global option object was accidentally blown away by
      // someone, bail early with an informative error
      if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {
        throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');
      }

      // Store the original tag used to set options
      this.tag = tag;

      // Store the tag attributes used to restore html5 element
      this.tagAttributes = tag && getAttributes(tag);

      // Update current language
      this.language(this.options_.language);

      // Update Supported Languages
      if (options.languages) {
        // Normalise player option languages to lowercase
        const languagesToLower = {};
        Object.getOwnPropertyNames(options.languages).forEach(function (name) {
          languagesToLower[name.toLowerCase()] = options.languages[name];
        });
        this.languages_ = languagesToLower;
      } else {
        this.languages_ = Player.prototype.options_.languages;
      }
      this.resetCache_();

      // Set poster
      /** @type string */
      this.poster_ = options.poster || '';

      // Set controls
      /** @type {boolean} */
      this.controls_ = !!options.controls;

      // Original tag settings stored in options
      // now remove immediately so native controls don't flash.
      // May be turned back on by HTML5 tech if nativeControlsForTouch is true
      tag.controls = false;
      tag.removeAttribute('controls');
      this.changingSrc_ = false;
      this.playCallbacks_ = [];
      this.playTerminatedQueue_ = [];

      // the attribute overrides the option
      if (tag.hasAttribute('autoplay')) {
        this.autoplay(true);
      } else {
        // otherwise use the setter to validate and
        // set the correct value.
        this.autoplay(this.options_.autoplay);
      }

      // check plugins
      if (options.plugins) {
        Object.keys(options.plugins).forEach(name => {
          if (typeof this[name] !== 'function') {
            throw new Error(`plugin "${name}" does not exist`);
          }
        });
      }

      /*
       * Store the internal state of scrubbing
       *
       * @private
       * @return {Boolean} True if the user is scrubbing
       */
      this.scrubbing_ = false;
      this.el_ = this.createEl();

      // Make this an evented object and use `el_` as its event bus.
      evented(this, {
        eventBusKey: 'el_'
      });

      // listen to document and player fullscreenchange handlers so we receive those events
      // before a user can receive them so we can update isFullscreen appropriately.
      // make sure that we listen to fullscreenchange events before everything else to make sure that
      // our isFullscreen method is updated properly for internal components as well as external.
      if (this.fsApi_.requestFullscreen) {
        on(document__default["default"], this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
        this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
      }
      if (this.fluid_) {
        this.on(['playerreset', 'resize'], this.boundUpdateStyleEl_);
      }
      // We also want to pass the original player options to each component and plugin
      // as well so they don't need to reach back into the player for options later.
      // We also need to do another copy of this.options_ so we don't end up with
      // an infinite loop.
      const playerOptionsCopy = merge(this.options_);

      // Load plugins
      if (options.plugins) {
        Object.keys(options.plugins).forEach(name => {
          this[name](options.plugins[name]);
        });
      }

      // Enable debug mode to fire debugon event for all plugins.
      if (options.debug) {
        this.debug(true);
      }
      this.options_.playerOptions = playerOptionsCopy;
      this.middleware_ = [];
      this.playbackRates(options.playbackRates);
      if (options.experimentalSvgIcons) {
        // Add SVG Sprite to the DOM
        const parser = new window__default["default"].DOMParser();
        const parsedSVG = parser.parseFromString(icons, 'image/svg+xml');
        const errorNode = parsedSVG.querySelector('parsererror');
        if (errorNode) {
          log.warn('Failed to load SVG Icons. Falling back to Font Icons.');
          this.options_.experimentalSvgIcons = null;
        } else {
          const sprite = parsedSVG.documentElement;
          sprite.style.display = 'none';
          this.el_.appendChild(sprite);
          this.addClass('vjs-svg-icons-enabled');
        }
      }
      this.initChildren();

      // Set isAudio based on whether or not an audio tag was used
      this.isAudio(tag.nodeName.toLowerCase() === 'audio');

      // Update controls className. Can't do this when the controls are initially
      // set because the element doesn't exist yet.
      if (this.controls()) {
        this.addClass('vjs-controls-enabled');
      } else {
        this.addClass('vjs-controls-disabled');
      }

      // Set ARIA label and region role depending on player type
      this.el_.setAttribute('role', 'region');
      if (this.isAudio()) {
        this.el_.setAttribute('aria-label', this.localize('Audio Player'));
      } else {
        this.el_.setAttribute('aria-label', this.localize('Video Player'));
      }
      if (this.isAudio()) {
        this.addClass('vjs-audio');
      }

      // Check if spatial navigation is enabled in the options.
      // If enabled, instantiate the SpatialNavigation class.
      if (options.spatialNavigation && options.spatialNavigation.enabled) {
        this.spatialNavigation = new SpatialNavigation(this);
        this.addClass('vjs-spatial-navigation-enabled');
      }

      // TODO: Make this smarter. Toggle user state between touching/mousing
      // using events, since devices can have both touch and mouse events.
      // TODO: Make this check be performed again when the window switches between monitors
      // (See https://github.com/videojs/video.js/issues/5683)
      if (TOUCH_ENABLED) {
        this.addClass('vjs-touch-enabled');
      }

      // iOS Safari has broken hover handling
      if (!IS_IOS) {
        this.addClass('vjs-workinghover');
      }

      // Make player easily findable by ID
      Player.players[this.id_] = this;

      // Add a major version class to aid css in plugins
      const majorVersion = version.split('.')[0];
      this.addClass(`vjs-v${majorVersion}`);

      // When the player is first initialized, trigger activity so components
      // like the control bar show themselves if needed
      this.userActive(true);
      this.reportUserActivity();
      this.one('play', e => this.listenForUserActivity_(e));
      this.on('keydown', e => this.handleKeyDown(e));
      this.on('languagechange', e => this.handleLanguagechange(e));
      this.breakpoints(this.options_.breakpoints);
      this.responsive(this.options_.responsive);

      // Calling both the audio mode methods after the player is fully
      // setup to be able to listen to the events triggered by them
      this.on('ready', () => {
        // Calling the audioPosterMode method first so that
        // the audioOnlyMode can take precedence when both options are set to true
        this.audioPosterMode(this.options_.audioPosterMode);
        this.audioOnlyMode(this.options_.audioOnlyMode);
      });
    }

    /**
     * Destroys the video player and does any necessary cleanup.
     *
     * This is especially helpful if you are dynamically adding and removing videos
     * to/from the DOM.
     *
     * @fires Player#dispose
     */
    dispose() {
      /**
       * Called when the player is being disposed of.
       *
       * @event Player#dispose
       * @type {Event}
       */
      this.trigger('dispose');
      // prevent dispose from being called twice
      this.off('dispose');

      // Make sure all player-specific document listeners are unbound. This is
      off(document__default["default"], this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
      off(document__default["default"], 'keydown', this.boundFullWindowOnEscKey_);
      if (this.styleEl_ && this.styleEl_.parentNode) {
        this.styleEl_.parentNode.removeChild(this.styleEl_);
        this.styleEl_ = null;
      }

      // Kill reference to this player
      Player.players[this.id_] = null;
      if (this.tag && this.tag.player) {
        this.tag.player = null;
      }
      if (this.el_ && this.el_.player) {
        this.el_.player = null;
      }
      if (this.tech_) {
        this.tech_.dispose();
        this.isPosterFromTech_ = false;
        this.poster_ = '';
      }
      if (this.playerElIngest_) {
        this.playerElIngest_ = null;
      }
      if (this.tag) {
        this.tag = null;
      }
      clearCacheForPlayer(this);

      // remove all event handlers for track lists
      // all tracks and track listeners are removed on
      // tech dispose
      ALL.names.forEach(name => {
        const props = ALL[name];
        const list = this[props.getterName]();

        // if it is not a native list
        // we have to manually remove event listeners
        if (list && list.off) {
          list.off();
        }
      });

      // the actual .el_ is removed here, or replaced if
      super.dispose({
        restoreEl: this.options_.restoreEl
      });
    }

    /**
     * Create the `Player`'s DOM element.
     *
     * @return {Element}
     *         The DOM element that gets created.
     */
    createEl() {
      let tag = this.tag;
      let el;
      let playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');
      const divEmbed = this.tag.tagName.toLowerCase() === 'video-js';
      if (playerElIngest) {
        el = this.el_ = tag.parentNode;
      } else if (!divEmbed) {
        el = this.el_ = super.createEl('div');
      }

      // Copy over all the attributes from the tag, including ID and class
      // ID will now reference player box, not the video tag
      const attrs = getAttributes(tag);
      if (divEmbed) {
        el = this.el_ = tag;
        tag = this.tag = document__default["default"].createElement('video');
        while (el.children.length) {
          tag.appendChild(el.firstChild);
        }
        if (!hasClass(el, 'video-js')) {
          addClass(el, 'video-js');
        }
        el.appendChild(tag);
        playerElIngest = this.playerElIngest_ = el;
        // move properties over from our custom `video-js` element
        // to our new `video` element. This will move things like
        // `src` or `controls` that were set via js before the player
        // was initialized.
        Object.keys(el).forEach(k => {
          try {
            tag[k] = el[k];
          } catch (e) {
            // we got a a property like outerHTML which we can't actually copy, ignore it
          }
        });
      }

      // set tabindex to -1 to remove the video element from the focus order
      tag.setAttribute('tabindex', '-1');
      attrs.tabindex = '-1';

      // Workaround for #4583 on Chrome (on Windows) with JAWS.
      // See https://github.com/FreedomScientific/VFO-standards-support/issues/78
      // Note that we can't detect if JAWS is being used, but this ARIA attribute
      // doesn't change behavior of Chrome if JAWS is not being used
      if (IS_CHROME && IS_WINDOWS) {
        tag.setAttribute('role', 'application');
        attrs.role = 'application';
      }

      // Remove width/height attrs from tag so CSS can make it 100% width/height
      tag.removeAttribute('width');
      tag.removeAttribute('height');
      if ('width' in attrs) {
        delete attrs.width;
      }
      if ('height' in attrs) {
        delete attrs.height;
      }
      Object.getOwnPropertyNames(attrs).forEach(function (attr) {
        // don't copy over the class attribute to the player element when we're in a div embed
        // the class is already set up properly in the divEmbed case
        // and we want to make sure that the `video-js` class doesn't get lost
        if (!(divEmbed && attr === 'class')) {
          el.setAttribute(attr, attrs[attr]);
        }
        if (divEmbed) {
          tag.setAttribute(attr, attrs[attr]);
        }
      });

      // Update tag id/class for use as HTML5 playback tech
      // Might think we should do this after embedding in container so .vjs-tech class
      // doesn't flash 100% width/height, but class only applies with .video-js parent
      tag.playerId = tag.id;
      tag.id += '_html5_api';
      tag.className = 'vjs-tech';

      // Make player findable on elements
      tag.player = el.player = this;
      // Default state of video is paused
      this.addClass('vjs-paused');
      const deviceClassNames = ['IS_SMART_TV', 'IS_TIZEN', 'IS_WEBOS', 'IS_ANDROID', 'IS_IPAD', 'IS_IPHONE', 'IS_CHROMECAST_RECEIVER'].filter(key => browser[key]).map(key => {
        return 'vjs-device-' + key.substring(3).toLowerCase().replace(/\_/g, '-');
      });
      this.addClass(...deviceClassNames);

      // Add a style element in the player that we'll use to set the width/height
      // of the player in a way that's still overridable by CSS, just like the
      // video element
      if (window__default["default"].VIDEOJS_NO_DYNAMIC_STYLE !== true) {
        this.styleEl_ = createStyleElement('vjs-styles-dimensions');
        const defaultsStyleEl = $('.vjs-styles-defaults');
        const head = $('head');
        head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
      }
      this.fill_ = false;
      this.fluid_ = false;

      // Pass in the width/height/aspectRatio options which will update the style el
      this.width(this.options_.width);
      this.height(this.options_.height);
      this.fill(this.options_.fill);
      this.fluid(this.options_.fluid);
      this.aspectRatio(this.options_.aspectRatio);
      // support both crossOrigin and crossorigin to reduce confusion and issues around the name
      this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);

      // Hide any links within the video/audio tag,
      // because IE doesn't hide them completely from screen readers.
      const links = tag.getElementsByTagName('a');
      for (let i = 0; i < links.length; i++) {
        const linkEl = links.item(i);
        addClass(linkEl, 'vjs-hidden');
        linkEl.setAttribute('hidden', 'hidden');
      }

      // insertElFirst seems to cause the networkState to flicker from 3 to 2, so
      // keep track of the original for later so we can know if the source originally failed
      tag.initNetworkState_ = tag.networkState;

      // Wrap video tag in div (el/box) container
      if (tag.parentNode && !playerElIngest) {
        tag.parentNode.insertBefore(el, tag);
      }

      // insert the tag as the first child of the player element
      // then manually add it to the children array so that this.addChild
      // will work properly for other components
      //
      // Breaks iPhone, fixed in HTML5 setup.
      prependTo(tag, el);
      this.children_.unshift(tag);

      // Set lang attr on player to ensure CSS :lang() in consistent with player
      // if it's been set to something different to the doc
      this.el_.setAttribute('lang', this.language_);
      this.el_.setAttribute('translate', 'no');
      this.el_ = el;
      return el;
    }

    /**
     * Get or set the `Player`'s crossOrigin option. For the HTML5 player, this
     * sets the `crossOrigin` property on the `<video>` tag to control the CORS
     * behavior.
     *
     * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}
     *
     * @param {string|null} [value]
     *        The value to set the `Player`'s crossOrigin to. If an argument is
     *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.
     *
     * @return {string|null|undefined}
     *         - The current crossOrigin value of the `Player` when getting.
     *         - undefined when setting
     */
    crossOrigin(value) {
      // `null` can be set to unset a value
      if (typeof value === 'undefined') {
        return this.techGet_('crossOrigin');
      }
      if (value !== null && value !== 'anonymous' && value !== 'use-credentials') {
        log.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${value}"`);
        return;
      }
      this.techCall_('setCrossOrigin', value);
      if (this.posterImage) {
        this.posterImage.crossOrigin(value);
      }
      return;
    }

    /**
     * A getter/setter for the `Player`'s width. Returns the player's configured value.
     * To get the current width use `currentWidth()`.
     *
     * @param {number|string} [value]
     *        CSS value to set the `Player`'s width to.
     *
     * @return {number|undefined}
     *         - The current width of the `Player` when getting.
     *         - Nothing when setting
     */
    width(value) {
      return this.dimension('width', value);
    }

    /**
     * A getter/setter for the `Player`'s height. Returns the player's configured value.
     * To get the current height use `currentheight()`.
     *
     * @param {number|string} [value]
     *        CSS value to set the `Player`'s height to.
     *
     * @return {number|undefined}
     *         - The current height of the `Player` when getting.
     *         - Nothing when setting
     */
    height(value) {
      return this.dimension('height', value);
    }

    /**
     * A getter/setter for the `Player`'s width & height.
     *
     * @param {string} dimension
     *        This string can be:
     *        - 'width'
     *        - 'height'
     *
     * @param {number|string} [value]
     *        Value for dimension specified in the first argument.
     *
     * @return {number}
     *         The dimension arguments value when getting (width/height).
     */
    dimension(dimension, value) {
      const privDimension = dimension + '_';
      if (value === undefined) {
        return this[privDimension] || 0;
      }
      if (value === '' || value === 'auto') {
        // If an empty string is given, reset the dimension to be automatic
        this[privDimension] = undefined;
        this.updateStyleEl_();
        return;
      }
      const parsedVal = parseFloat(value);
      if (isNaN(parsedVal)) {
        log.error(`Improper value "${value}" supplied for for ${dimension}`);
        return;
      }
      this[privDimension] = parsedVal;
      this.updateStyleEl_();
    }

    /**
     * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.
     *
     * Turning this on will turn off fill mode.
     *
     * @param {boolean} [bool]
     *        - A value of true adds the class.
     *        - A value of false removes the class.
     *        - No value will be a getter.
     *
     * @return {boolean|undefined}
     *         - The value of fluid when getting.
     *         - `undefined` when setting.
     */
    fluid(bool) {
      if (bool === undefined) {
        return !!this.fluid_;
      }
      this.fluid_ = !!bool;
      if (isEvented(this)) {
        this.off(['playerreset', 'resize'], this.boundUpdateStyleEl_);
      }
      if (bool) {
        this.addClass('vjs-fluid');
        this.fill(false);
        addEventedCallback(this, () => {
          this.on(['playerreset', 'resize'], this.boundUpdateStyleEl_);
        });
      } else {
        this.removeClass('vjs-fluid');
      }
      this.updateStyleEl_();
    }

    /**
     * A getter/setter/toggler for the vjs-fill `className` on the `Player`.
     *
     * Turning this on will turn off fluid mode.
     *
     * @param {boolean} [bool]
     *        - A value of true adds the class.
     *        - A value of false removes the class.
     *        - No value will be a getter.
     *
     * @return {boolean|undefined}
     *         - The value of fluid when getting.
     *         - `undefined` when setting.
     */
    fill(bool) {
      if (bool === undefined) {
        return !!this.fill_;
      }
      this.fill_ = !!bool;
      if (bool) {
        this.addClass('vjs-fill');
        this.fluid(false);
      } else {
        this.removeClass('vjs-fill');
      }
    }

    /**
     * Get/Set the aspect ratio
     *
     * @param {string} [ratio]
     *        Aspect ratio for player
     *
     * @return {string|undefined}
     *         returns the current aspect ratio when getting
     */

    /**
     * A getter/setter for the `Player`'s aspect ratio.
     *
     * @param {string} [ratio]
     *        The value to set the `Player`'s aspect ratio to.
     *
     * @return {string|undefined}
     *         - The current aspect ratio of the `Player` when getting.
     *         - undefined when setting
     */
    aspectRatio(ratio) {
      if (ratio === undefined) {
        return this.aspectRatio_;
      }

      // Check for width:height format
      if (!/^\d+\:\d+$/.test(ratio)) {
        throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');
      }
      this.aspectRatio_ = ratio;

      // We're assuming if you set an aspect ratio you want fluid mode,
      // because in fixed mode you could calculate width and height yourself.
      this.fluid(true);
      this.updateStyleEl_();
    }

    /**
     * Update styles of the `Player` element (height, width and aspect ratio).
     *
     * @private
     * @listens Tech#loadedmetadata
     */
    updateStyleEl_() {
      if (window__default["default"].VIDEOJS_NO_DYNAMIC_STYLE === true) {
        const width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;
        const height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;
        const techEl = this.tech_ && this.tech_.el();
        if (techEl) {
          if (width >= 0) {
            techEl.width = width;
          }
          if (height >= 0) {
            techEl.height = height;
          }
        }
        return;
      }
      let width;
      let height;
      let aspectRatio;
      let idClass;

      // The aspect ratio is either used directly or to calculate width and height.
      if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {
        // Use any aspectRatio that's been specifically set
        aspectRatio = this.aspectRatio_;
      } else if (this.videoWidth() > 0) {
        // Otherwise try to get the aspect ratio from the video metadata
        aspectRatio = this.videoWidth() + ':' + this.videoHeight();
      } else {
        // Or use a default. The video element's is 2:1, but 16:9 is more common.
        aspectRatio = '16:9';
      }

      // Get the ratio as a decimal we can use to calculate dimensions
      const ratioParts = aspectRatio.split(':');
      const ratioMultiplier = ratioParts[1] / ratioParts[0];
      if (this.width_ !== undefined) {
        // Use any width that's been specifically set
        width = this.width_;
      } else if (this.height_ !== undefined) {
        // Or calculate the width from the aspect ratio if a height has been set
        width = this.height_ / ratioMultiplier;
      } else {
        // Or use the video's metadata, or use the video el's default of 300
        width = this.videoWidth() || 300;
      }
      if (this.height_ !== undefined) {
        // Use any height that's been specifically set
        height = this.height_;
      } else {
        // Otherwise calculate the height from the ratio and the width
        height = width * ratioMultiplier;
      }

      // Ensure the CSS class is valid by starting with an alpha character
      if (/^[^a-zA-Z]/.test(this.id())) {
        idClass = 'dimensions-' + this.id();
      } else {
        idClass = this.id() + '-dimensions';
      }

      // Ensure the right class is still on the player for the style element
      this.addClass(idClass);
      setTextContent(this.styleEl_, `
      .${idClass} {
        width: ${width}px;
        height: ${height}px;
      }

      .${idClass}.vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: ${ratioMultiplier * 100}%;
      }
    `);
    }

    /**
     * Load/Create an instance of playback {@link Tech} including element
     * and API methods. Then append the `Tech` element in `Player` as a child.
     *
     * @param {string} techName
     *        name of the playback technology
     *
     * @param {string} source
     *        video source
     *
     * @private
     */
    loadTech_(techName, source) {
      // Pause and remove current playback technology
      if (this.tech_) {
        this.unloadTech_();
      }
      const titleTechName = toTitleCase(techName);
      const camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);

      // get rid of the HTML5 video tag as soon as we are using another tech
      if (titleTechName !== 'Html5' && this.tag) {
        Tech.getTech('Html5').disposeMediaElement(this.tag);
        this.tag.player = null;
        this.tag = null;
      }
      this.techName_ = titleTechName;

      // Turn off API access because we're loading a new tech that might load asynchronously
      this.isReady_ = false;
      let autoplay = this.autoplay();

      // if autoplay is a string (or `true` with normalizeAutoplay: true) we pass false to the tech
      // because the player is going to handle autoplay on `loadstart`
      if (typeof this.autoplay() === 'string' || this.autoplay() === true && this.options_.normalizeAutoplay) {
        autoplay = false;
      }

      // Grab tech-specific options from player options and add source and parent element to use.
      const techOptions = {
        source,
        autoplay,
        'nativeControlsForTouch': this.options_.nativeControlsForTouch,
        'playerId': this.id(),
        'techId': `${this.id()}_${camelTechName}_api`,
        'playsinline': this.options_.playsinline,
        'preload': this.options_.preload,
        'loop': this.options_.loop,
        'disablePictureInPicture': this.options_.disablePictureInPicture,
        'muted': this.options_.muted,
        'poster': this.poster(),
        'language': this.language(),
        'playerElIngest': this.playerElIngest_ || false,
        'vtt.js': this.options_['vtt.js'],
        'canOverridePoster': !!this.options_.techCanOverridePoster,
        'enableSourceset': this.options_.enableSourceset
      };
      ALL.names.forEach(name => {
        const props = ALL[name];
        techOptions[props.getterName] = this[props.privateName];
      });
      Object.assign(techOptions, this.options_[titleTechName]);
      Object.assign(techOptions, this.options_[camelTechName]);
      Object.assign(techOptions, this.options_[techName.toLowerCase()]);
      if (this.tag) {
        techOptions.tag = this.tag;
      }
      if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
        techOptions.startTime = this.cache_.currentTime;
      }

      // Initialize tech instance
      const TechClass = Tech.getTech(techName);
      if (!TechClass) {
        throw new Error(`No Tech named '${titleTechName}' exists! '${titleTechName}' should be registered using videojs.registerTech()'`);
      }
      this.tech_ = new TechClass(techOptions);

      // player.triggerReady is always async, so don't need this to be async
      this.tech_.ready(bind_(this, this.handleTechReady_), true);
      textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);

      // Listen to all HTML5-defined events and trigger them on the player
      TECH_EVENTS_RETRIGGER.forEach(event => {
        this.on(this.tech_, event, e => this[`handleTech${toTitleCase(event)}_`](e));
      });
      Object.keys(TECH_EVENTS_QUEUE).forEach(event => {
        this.on(this.tech_, event, eventObj => {
          if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {
            this.queuedCallbacks_.push({
              callback: this[`handleTech${TECH_EVENTS_QUEUE[event]}_`].bind(this),
              event: eventObj
            });
            return;
          }
          this[`handleTech${TECH_EVENTS_QUEUE[event]}_`](eventObj);
        });
      });
      this.on(this.tech_, 'loadstart', e => this.handleTechLoadStart_(e));
      this.on(this.tech_, 'sourceset', e => this.handleTechSourceset_(e));
      this.on(this.tech_, 'waiting', e => this.handleTechWaiting_(e));
      this.on(this.tech_, 'ended', e => this.handleTechEnded_(e));
      this.on(this.tech_, 'seeking', e => this.handleTechSeeking_(e));
      this.on(this.tech_, 'play', e => this.handleTechPlay_(e));
      this.on(this.tech_, 'pause', e => this.handleTechPause_(e));
      this.on(this.tech_, 'durationchange', e => this.handleTechDurationChange_(e));
      this.on(this.tech_, 'fullscreenchange', (e, data) => this.handleTechFullscreenChange_(e, data));
      this.on(this.tech_, 'fullscreenerror', (e, err) => this.handleTechFullscreenError_(e, err));
      this.on(this.tech_, 'enterpictureinpicture', e => this.handleTechEnterPictureInPicture_(e));
      this.on(this.tech_, 'leavepictureinpicture', e => this.handleTechLeavePictureInPicture_(e));
      this.on(this.tech_, 'error', e => this.handleTechError_(e));
      this.on(this.tech_, 'posterchange', e => this.handleTechPosterChange_(e));
      this.on(this.tech_, 'textdata', e => this.handleTechTextData_(e));
      this.on(this.tech_, 'ratechange', e => this.handleTechRateChange_(e));
      this.on(this.tech_, 'loadedmetadata', this.boundUpdateStyleEl_);
      this.usingNativeControls(this.techGet_('controls'));
      if (this.controls() && !this.usingNativeControls()) {
        this.addTechControlsListeners_();
      }

      // Add the tech element in the DOM if it was not already there
      // Make sure to not insert the original video element if using Html5
      if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {
        prependTo(this.tech_.el(), this.el());
      }

      // Get rid of the original video tag reference after the first tech is loaded
      if (this.tag) {
        this.tag.player = null;
        this.tag = null;
      }
    }

    /**
     * Unload and dispose of the current playback {@link Tech}.
     *
     * @private
     */
    unloadTech_() {
      // Save the current text tracks so that we can reuse the same text tracks with the next tech
      ALL.names.forEach(name => {
        const props = ALL[name];
        this[props.privateName] = this[props.getterName]();
      });
      this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);
      this.isReady_ = false;
      this.tech_.dispose();
      this.tech_ = false;
      if (this.isPosterFromTech_) {
        this.poster_ = '';
        this.trigger('posterchange');
      }
      this.isPosterFromTech_ = false;
    }

    /**
     * Return a reference to the current {@link Tech}.
     * It will print a warning by default about the danger of using the tech directly
     * but any argument that is passed in will silence the warning.
     *
     * @param {*} [safety]
     *        Anything passed in to silence the warning
     *
     * @return {Tech}
     *         The Tech
     */
    tech(safety) {
      if (safety === undefined) {
        log.warn('Using the tech directly can be dangerous. I hope you know what you\'re doing.\n' + 'See https://github.com/videojs/video.js/issues/2617 for more info.\n');
      }
      return this.tech_;
    }

    /**
     * An object that contains Video.js version.
     *
     * @typedef {Object} PlayerVersion
     *
     * @property {string} 'video.js' - Video.js version
     */

    /**
     * Returns an object with Video.js version.
     *
     * @return {PlayerVersion}
     *          An object with Video.js version.
     */
    version() {
      return {
        'video.js': version
      };
    }

    /**
     * Set up click and touch listeners for the playback element
     *
     * - On desktops: a click on the video itself will toggle playback
     * - On mobile devices: a click on the video toggles controls
     *   which is done by toggling the user state between active and
     *   inactive
     * - A tap can signal that a user has become active or has become inactive
     *   e.g. a quick tap on an iPhone movie should reveal the controls. Another
     *   quick tap should hide them again (signaling the user is in an inactive
     *   viewing state)
     * - In addition to this, we still want the user to be considered inactive after
     *   a few seconds of inactivity.
     *
     * > Note: the only part of iOS interaction we can't mimic with this setup
     * is a touch and hold on the video element counting as activity in order to
     * keep the controls showing, but that shouldn't be an issue. A touch and hold
     * on any controls will still keep the user active
     *
     * @private
     */
    addTechControlsListeners_() {
      // Make sure to remove all the previous listeners in case we are called multiple times.
      this.removeTechControlsListeners_();
      this.on(this.tech_, 'click', this.boundHandleTechClick_);
      this.on(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_);

      // If the controls were hidden we don't want that to change without a tap event
      // so we'll check if the controls were already showing before reporting user
      // activity
      this.on(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);
      this.on(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);
      this.on(this.tech_, 'touchend', this.boundHandleTechTouchEnd_);

      // The tap listener needs to come after the touchend listener because the tap
      // listener cancels out any reportedUserActivity when setting userActive(false)
      this.on(this.tech_, 'tap', this.boundHandleTechTap_);
    }

    /**
     * Remove the listeners used for click and tap controls. This is needed for
     * toggling to controls disabled, where a tap/touch should do nothing.
     *
     * @private
     */
    removeTechControlsListeners_() {
      // We don't want to just use `this.off()` because there might be other needed
      // listeners added by techs that extend this.
      this.off(this.tech_, 'tap', this.boundHandleTechTap_);
      this.off(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);
      this.off(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);
      this.off(this.tech_, 'touchend', this.boundHandleTechTouchEnd_);
      this.off(this.tech_, 'click', this.boundHandleTechClick_);
      this.off(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_);
    }

    /**
     * Player waits for the tech to be ready
     *
     * @private
     */
    handleTechReady_() {
      this.triggerReady();

      // Keep the same volume as before
      if (this.cache_.volume) {
        this.techCall_('setVolume', this.cache_.volume);
      }

      // Look if the tech found a higher resolution poster while loading
      this.handleTechPosterChange_();

      // Update the duration if available
      this.handleTechDurationChange_();
    }

    /**
     * Retrigger the `loadstart` event that was triggered by the {@link Tech}.
     *
     * @fires Player#loadstart
     * @listens Tech#loadstart
     * @private
     */
    handleTechLoadStart_() {
      // TODO: Update to use `emptied` event instead. See #1277.

      this.removeClass('vjs-ended', 'vjs-seeking');

      // reset the error state
      this.error(null);

      // Update the duration
      this.handleTechDurationChange_();
      if (!this.paused()) {
        /**
         * Fired when the user agent begins looking for media data
         *
         * @event Player#loadstart
         * @type {Event}
         */
        this.trigger('loadstart');
      } else {
        // reset the hasStarted state
        this.hasStarted(false);
        this.trigger('loadstart');
      }

      // autoplay happens after loadstart for the browser,
      // so we mimic that behavior
      this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? 'play' : this.autoplay());
    }

    /**
     * Handle autoplay string values, rather than the typical boolean
     * values that should be handled by the tech. Note that this is not
     * part of any specification. Valid values and what they do can be
     * found on the autoplay getter at Player#autoplay()
     */
    manualAutoplay_(type) {
      if (!this.tech_ || typeof type !== 'string') {
        return;
      }

      // Save original muted() value, set muted to true, and attempt to play().
      // On promise rejection, restore muted from saved value
      const resolveMuted = () => {
        const previouslyMuted = this.muted();
        this.muted(true);
        const restoreMuted = () => {
          this.muted(previouslyMuted);
        };

        // restore muted on play terminatation
        this.playTerminatedQueue_.push(restoreMuted);
        const mutedPromise = this.play();
        if (!isPromise(mutedPromise)) {
          return;
        }
        return mutedPromise.catch(err => {
          restoreMuted();
          throw new Error(`Rejection at manualAutoplay. Restoring muted value. ${err ? err : ''}`);
        });
      };
      let promise;

      // if muted defaults to true
      // the only thing we can do is call play
      if (type === 'any' && !this.muted()) {
        promise = this.play();
        if (isPromise(promise)) {
          promise = promise.catch(resolveMuted);
        }
      } else if (type === 'muted' && !this.muted()) {
        promise = resolveMuted();
      } else {
        promise = this.play();
      }
      if (!isPromise(promise)) {
        return;
      }
      return promise.then(() => {
        this.trigger({
          type: 'autoplay-success',
          autoplay: type
        });
      }).catch(() => {
        this.trigger({
          type: 'autoplay-failure',
          autoplay: type
        });
      });
    }

    /**
     * Update the internal source caches so that we return the correct source from
     * `src()`, `currentSource()`, and `currentSources()`.
     *
     * > Note: `currentSources` will not be updated if the source that is passed in exists
     *         in the current `currentSources` cache.
     *
     *
     * @param {Tech~SourceObject} srcObj
     *        A string or object source to update our caches to.
     */
    updateSourceCaches_(srcObj = '') {
      let src = srcObj;
      let type = '';
      if (typeof src !== 'string') {
        src = srcObj.src;
        type = srcObj.type;
      }

      // make sure all the caches are set to default values
      // to prevent null checking
      this.cache_.source = this.cache_.source || {};
      this.cache_.sources = this.cache_.sources || [];

      // try to get the type of the src that was passed in
      if (src && !type) {
        type = findMimetype(this, src);
      }

      // update `currentSource` cache always
      this.cache_.source = merge({}, srcObj, {
        src,
        type
      });
      const matchingSources = this.cache_.sources.filter(s => s.src && s.src === src);
      const sourceElSources = [];
      const sourceEls = this.$$('source');
      const matchingSourceEls = [];
      for (let i = 0; i < sourceEls.length; i++) {
        const sourceObj = getAttributes(sourceEls[i]);
        sourceElSources.push(sourceObj);
        if (sourceObj.src && sourceObj.src === src) {
          matchingSourceEls.push(sourceObj.src);
        }
      }

      // if we have matching source els but not matching sources
      // the current source cache is not up to date
      if (matchingSourceEls.length && !matchingSources.length) {
        this.cache_.sources = sourceElSources;
        // if we don't have matching source or source els set the
        // sources cache to the `currentSource` cache
      } else if (!matchingSources.length) {
        this.cache_.sources = [this.cache_.source];
      }

      // update the tech `src` cache
      this.cache_.src = src;
    }

    /**
     * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}
     * causing the media element to reload.
     *
     * It will fire for the initial source and each subsequent source.
     * This event is a custom event from Video.js and is triggered by the {@link Tech}.
     *
     * The event object for this event contains a `src` property that will contain the source
     * that was available when the event was triggered. This is generally only necessary if Video.js
     * is switching techs while the source was being changed.
     *
     * It is also fired when `load` is called on the player (or media element)
     * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}
     * says that the resource selection algorithm needs to be aborted and restarted.
     * In this case, it is very likely that the `src` property will be set to the
     * empty string `""` to indicate we do not know what the source will be but
     * that it is changing.
     *
     * *This event is currently still experimental and may change in minor releases.*
     * __To use this, pass `enableSourceset` option to the player.__
     *
     * @event Player#sourceset
     * @type {Event}
     * @prop {string} src
     *                The source url available when the `sourceset` was triggered.
     *                It will be an empty string if we cannot know what the source is
     *                but know that the source will change.
     */
    /**
     * Retrigger the `sourceset` event that was triggered by the {@link Tech}.
     *
     * @fires Player#sourceset
     * @listens Tech#sourceset
     * @private
     */
    handleTechSourceset_(event) {
      // only update the source cache when the source
      // was not updated using the player api
      if (!this.changingSrc_) {
        let updateSourceCaches = src => this.updateSourceCaches_(src);
        const playerSrc = this.currentSource().src;
        const eventSrc = event.src;

        // if we have a playerSrc that is not a blob, and a tech src that is a blob
        if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {
          // if both the tech source and the player source were updated we assume
          // something like @videojs/http-streaming did the sourceset and skip updating the source cache.
          if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {
            updateSourceCaches = () => {};
          }
        }

        // update the source to the initial source right away
        // in some cases this will be empty string
        updateSourceCaches(eventSrc);

        // if the `sourceset` `src` was an empty string
        // wait for a `loadstart` to update the cache to `currentSrc`.
        // If a sourceset happens before a `loadstart`, we reset the state
        if (!event.src) {
          this.tech_.any(['sourceset', 'loadstart'], e => {
            // if a sourceset happens before a `loadstart` there
            // is nothing to do as this `handleTechSourceset_`
            // will be called again and this will be handled there.
            if (e.type === 'sourceset') {
              return;
            }
            const techSrc = this.techGet_('currentSrc');
            this.lastSource_.tech = techSrc;
            this.updateSourceCaches_(techSrc);
          });
        }
      }
      this.lastSource_ = {
        player: this.currentSource().src,
        tech: event.src
      };
      this.trigger({
        src: event.src,
        type: 'sourceset'
      });
    }

    /**
     * Add/remove the vjs-has-started class
     *
     *
     * @param {boolean} request
     *        - true: adds the class
     *        - false: remove the class
     *
     * @return {boolean}
     *         the boolean value of hasStarted_
     */
    hasStarted(request) {
      if (request === undefined) {
        // act as getter, if we have no request to change
        return this.hasStarted_;
      }
      if (request === this.hasStarted_) {
        return;
      }
      this.hasStarted_ = request;
      if (this.hasStarted_) {
        this.addClass('vjs-has-started');
      } else {
        this.removeClass('vjs-has-started');
      }
    }

    /**
     * Fired whenever the media begins or resumes playback
     *
     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}
     * @fires Player#play
     * @listens Tech#play
     * @private
     */
    handleTechPlay_() {
      this.removeClass('vjs-ended', 'vjs-paused');
      this.addClass('vjs-playing');

      // hide the poster when the user hits play
      this.hasStarted(true);
      /**
       * Triggered whenever an {@link Tech#play} event happens. Indicates that
       * playback has started or resumed.
       *
       * @event Player#play
       * @type {Event}
       */
      this.trigger('play');
    }

    /**
     * Retrigger the `ratechange` event that was triggered by the {@link Tech}.
     *
     * If there were any events queued while the playback rate was zero, fire
     * those events now.
     *
     * @private
     * @method Player#handleTechRateChange_
     * @fires Player#ratechange
     * @listens Tech#ratechange
     */
    handleTechRateChange_() {
      if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
        this.queuedCallbacks_.forEach(queued => queued.callback(queued.event));
        this.queuedCallbacks_ = [];
      }
      this.cache_.lastPlaybackRate = this.tech_.playbackRate();
      /**
       * Fires when the playing speed of the audio/video is changed
       *
       * @event Player#ratechange
       * @type {event}
       */
      this.trigger('ratechange');
    }

    /**
     * Retrigger the `waiting` event that was triggered by the {@link Tech}.
     *
     * @fires Player#waiting
     * @listens Tech#waiting
     * @private
     */
    handleTechWaiting_() {
      this.addClass('vjs-waiting');
      /**
       * A readyState change on the DOM element has caused playback to stop.
       *
       * @event Player#waiting
       * @type {Event}
       */
      this.trigger('waiting');

      // Browsers may emit a timeupdate event after a waiting event. In order to prevent
      // premature removal of the waiting class, wait for the time to change.
      const timeWhenWaiting = this.currentTime();
      const timeUpdateListener = () => {
        if (timeWhenWaiting !== this.currentTime()) {
          this.removeClass('vjs-waiting');
          this.off('timeupdate', timeUpdateListener);
        }
      };
      this.on('timeupdate', timeUpdateListener);
    }

    /**
     * Retrigger the `canplay` event that was triggered by the {@link Tech}.
     * > Note: This is not consistent between browsers. See #1351
     *
     * @fires Player#canplay
     * @listens Tech#canplay
     * @private
     */
    handleTechCanPlay_() {
      this.removeClass('vjs-waiting');
      /**
       * The media has a readyState of HAVE_FUTURE_DATA or greater.
       *
       * @event Player#canplay
       * @type {Event}
       */
      this.trigger('canplay');
    }

    /**
     * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.
     *
     * @fires Player#canplaythrough
     * @listens Tech#canplaythrough
     * @private
     */
    handleTechCanPlayThrough_() {
      this.removeClass('vjs-waiting');
      /**
       * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the
       * entire media file can be played without buffering.
       *
       * @event Player#canplaythrough
       * @type {Event}
       */
      this.trigger('canplaythrough');
    }

    /**
     * Retrigger the `playing` event that was triggered by the {@link Tech}.
     *
     * @fires Player#playing
     * @listens Tech#playing
     * @private
     */
    handleTechPlaying_() {
      this.removeClass('vjs-waiting');
      /**
       * The media is no longer blocked from playback, and has started playing.
       *
       * @event Player#playing
       * @type {Event}
       */
      this.trigger('playing');
    }

    /**
     * Retrigger the `seeking` event that was triggered by the {@link Tech}.
     *
     * @fires Player#seeking
     * @listens Tech#seeking
     * @private
     */
    handleTechSeeking_() {
      this.addClass('vjs-seeking');
      /**
       * Fired whenever the player is jumping to a new time
       *
       * @event Player#seeking
       * @type {Event}
       */
      this.trigger('seeking');
    }

    /**
     * Retrigger the `seeked` event that was triggered by the {@link Tech}.
     *
     * @fires Player#seeked
     * @listens Tech#seeked
     * @private
     */
    handleTechSeeked_() {
      this.removeClass('vjs-seeking', 'vjs-ended');
      /**
       * Fired when the player has finished jumping to a new time
       *
       * @event Player#seeked
       * @type {Event}
       */
      this.trigger('seeked');
    }

    /**
     * Retrigger the `pause` event that was triggered by the {@link Tech}.
     *
     * @fires Player#pause
     * @listens Tech#pause
     * @private
     */
    handleTechPause_() {
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
      /**
       * Fired whenever the media has been paused
       *
       * @event Player#pause
       * @type {Event}
       */
      this.trigger('pause');
    }

    /**
     * Retrigger the `ended` event that was triggered by the {@link Tech}.
     *
     * @fires Player#ended
     * @listens Tech#ended
     * @private
     */
    handleTechEnded_() {
      this.addClass('vjs-ended');
      this.removeClass('vjs-waiting');
      if (this.options_.loop) {
        this.currentTime(0);
        this.play();
      } else if (!this.paused()) {
        this.pause();
      }

      /**
       * Fired when the end of the media resource is reached (currentTime == duration)
       *
       * @event Player#ended
       * @type {Event}
       */
      this.trigger('ended');
    }

    /**
     * Fired when the duration of the media resource is first known or changed
     *
     * @listens Tech#durationchange
     * @private
     */
    handleTechDurationChange_() {
      this.duration(this.techGet_('duration'));
    }

    /**
     * Handle a click on the media element to play/pause
     *
     * @param {Event} event
     *        the event that caused this function to trigger
     *
     * @listens Tech#click
     * @private
     */
    handleTechClick_(event) {
      // When controls are disabled a click should not toggle playback because
      // the click is considered a control
      if (!this.controls_) {
        return;
      }
      if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.click === undefined || this.options_.userActions.click !== false) {
        if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.click === 'function') {
          this.options_.userActions.click.call(this, event);
        } else if (this.paused()) {
          silencePromise(this.play());
        } else {
          this.pause();
        }
      }
    }

    /**
     * Handle a double-click on the media element to enter/exit fullscreen
     *
     * @param {Event} event
     *        the event that caused this function to trigger
     *
     * @listens Tech#dblclick
     * @private
     */
    handleTechDoubleClick_(event) {
      if (!this.controls_) {
        return;
      }

      // we do not want to toggle fullscreen state
      // when double-clicking inside a control bar or a modal
      const inAllowedEls = Array.prototype.some.call(this.$$('.vjs-control-bar, .vjs-modal-dialog'), el => el.contains(event.target));
      if (!inAllowedEls) {
        /*
         * options.userActions.doubleClick
         *
         * If `undefined` or `true`, double-click toggles fullscreen if controls are present
         * Set to `false` to disable double-click handling
         * Set to a function to substitute an external double-click handler
         */
        if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.doubleClick === undefined || this.options_.userActions.doubleClick !== false) {
          if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.doubleClick === 'function') {
            this.options_.userActions.doubleClick.call(this, event);
          } else if (this.isFullscreen()) {
            this.exitFullscreen();
          } else {
            this.requestFullscreen();
          }
        }
      }
    }

    /**
     * Handle a tap on the media element. It will toggle the user
     * activity state, which hides and shows the controls.
     *
     * @listens Tech#tap
     * @private
     */
    handleTechTap_() {
      this.userActive(!this.userActive());
    }

    /**
     * Handle touch to start
     *
     * @listens Tech#touchstart
     * @private
     */
    handleTechTouchStart_() {
      this.userWasActive = this.userActive();
    }

    /**
     * Handle touch to move
     *
     * @listens Tech#touchmove
     * @private
     */
    handleTechTouchMove_() {
      if (this.userWasActive) {
        this.reportUserActivity();
      }
    }

    /**
     * Handle touch to end
     *
     * @param {Event} event
     *        the touchend event that triggered
     *        this function
     *
     * @listens Tech#touchend
     * @private
     */
    handleTechTouchEnd_(event) {
      // Stop the mouse events from also happening
      if (event.cancelable) {
        event.preventDefault();
      }
    }

    /**
     * @private
     */
    toggleFullscreenClass_() {
      if (this.isFullscreen()) {
        this.addClass('vjs-fullscreen');
      } else {
        this.removeClass('vjs-fullscreen');
      }
    }

    /**
     * when the document fschange event triggers it calls this
     */
    documentFullscreenChange_(e) {
      const targetPlayer = e.target.player;

      // if another player was fullscreen
      // do a null check for targetPlayer because older firefox's would put document as e.target
      if (targetPlayer && targetPlayer !== this) {
        return;
      }
      const el = this.el();
      let isFs = document__default["default"][this.fsApi_.fullscreenElement] === el;
      if (!isFs && el.matches) {
        isFs = el.matches(':' + this.fsApi_.fullscreen);
      }
      this.isFullscreen(isFs);
    }

    /**
     * Handle Tech Fullscreen Change
     *
     * @param {Event} event
     *        the fullscreenchange event that triggered this function
     *
     * @param {Object} data
     *        the data that was sent with the event
     *
     * @private
     * @listens Tech#fullscreenchange
     * @fires Player#fullscreenchange
     */
    handleTechFullscreenChange_(event, data) {
      if (data) {
        if (data.nativeIOSFullscreen) {
          this.addClass('vjs-ios-native-fs');
          this.tech_.one('webkitendfullscreen', () => {
            this.removeClass('vjs-ios-native-fs');
          });
        }
        this.isFullscreen(data.isFullscreen);
      }
    }
    handleTechFullscreenError_(event, err) {
      this.trigger('fullscreenerror', err);
    }

    /**
     * @private
     */
    togglePictureInPictureClass_() {
      if (this.isInPictureInPicture()) {
        this.addClass('vjs-picture-in-picture');
      } else {
        this.removeClass('vjs-picture-in-picture');
      }
    }

    /**
     * Handle Tech Enter Picture-in-Picture.
     *
     * @param {Event} event
     *        the enterpictureinpicture event that triggered this function
     *
     * @private
     * @listens Tech#enterpictureinpicture
     */
    handleTechEnterPictureInPicture_(event) {
      this.isInPictureInPicture(true);
    }

    /**
     * Handle Tech Leave Picture-in-Picture.
     *
     * @param {Event} event
     *        the leavepictureinpicture event that triggered this function
     *
     * @private
     * @listens Tech#leavepictureinpicture
     */
    handleTechLeavePictureInPicture_(event) {
      this.isInPictureInPicture(false);
    }

    /**
     * Fires when an error occurred during the loading of an audio/video.
     *
     * @private
     * @listens Tech#error
     */
    handleTechError_() {
      const error = this.tech_.error();
      if (error) {
        this.error(error);
      }
    }

    /**
     * Retrigger the `textdata` event that was triggered by the {@link Tech}.
     *
     * @fires Player#textdata
     * @listens Tech#textdata
     * @private
     */
    handleTechTextData_() {
      let data = null;
      if (arguments.length > 1) {
        data = arguments[1];
      }

      /**
       * Fires when we get a textdata event from tech
       *
       * @event Player#textdata
       * @type {Event}
       */
      this.trigger('textdata', data);
    }

    /**
     * Get object for cached values.
     *
     * @return {Object}
     *         get the current object cache
     */
    getCache() {
      return this.cache_;
    }

    /**
     * Resets the internal cache object.
     *
     * Using this function outside the player constructor or reset method may
     * have unintended side-effects.
     *
     * @private
     */
    resetCache_() {
      this.cache_ = {
        // Right now, the currentTime is not _really_ cached because it is always
        // retrieved from the tech (see: currentTime). However, for completeness,
        // we set it to zero here to ensure that if we do start actually caching
        // it, we reset it along with everything else.
        currentTime: 0,
        initTime: 0,
        inactivityTimeout: this.options_.inactivityTimeout,
        duration: NaN,
        lastVolume: 1,
        lastPlaybackRate: this.defaultPlaybackRate(),
        media: null,
        src: '',
        source: {},
        sources: [],
        playbackRates: [],
        volume: 1
      };
    }

    /**
     * Pass values to the playback tech
     *
     * @param {string} [method]
     *        the method to call
     *
     * @param {Object} [arg]
     *        the argument to pass
     *
     * @private
     */
    techCall_(method, arg) {
      // If it's not ready yet, call method when it is

      this.ready(function () {
        if (method in allowedSetters) {
          return set(this.middleware_, this.tech_, method, arg);
        } else if (method in allowedMediators) {
          return mediate(this.middleware_, this.tech_, method, arg);
        }
        try {
          if (this.tech_) {
            this.tech_[method](arg);
          }
        } catch (e) {
          log(e);
          throw e;
        }
      }, true);
    }

    /**
     * Mediate attempt to call playback tech method
     * and return the value of the method called.
     *
     * @param {string} method
     *        Tech method
     *
     * @return {*}
     *         Value returned by the tech method called, undefined if tech
     *         is not ready or tech method is not present
     *
     * @private
     */
    techGet_(method) {
      if (!this.tech_ || !this.tech_.isReady_) {
        return;
      }
      if (method in allowedGetters) {
        return get(this.middleware_, this.tech_, method);
      } else if (method in allowedMediators) {
        return mediate(this.middleware_, this.tech_, method);
      }

      // Log error when playback tech object is present but method
      // is undefined or unavailable
      try {
        return this.tech_[method]();
      } catch (e) {
        // When building additional tech libs, an expected method may not be defined yet
        if (this.tech_[method] === undefined) {
          log(`Video.js: ${method} method not defined for ${this.techName_} playback technology.`, e);
          throw e;
        }

        // When a method isn't available on the object it throws a TypeError
        if (e.name === 'TypeError') {
          log(`Video.js: ${method} unavailable on ${this.techName_} playback technology element.`, e);
          this.tech_.isReady_ = false;
          throw e;
        }

        // If error unknown, just log and throw
        log(e);
        throw e;
      }
    }

    /**
     * Attempt to begin playback at the first opportunity.
     *
     * @return {Promise|undefined}
     *         Returns a promise if the browser supports Promises (or one
     *         was passed in as an option). This promise will be resolved on
     *         the return value of play. If this is undefined it will fulfill the
     *         promise chain otherwise the promise chain will be fulfilled when
     *         the promise from play is fulfilled.
     */
    play() {
      return new Promise(resolve => {
        this.play_(resolve);
      });
    }

    /**
     * The actual logic for play, takes a callback that will be resolved on the
     * return value of play. This allows us to resolve to the play promise if there
     * is one on modern browsers.
     *
     * @private
     * @param {Function} [callback]
     *        The callback that should be called when the techs play is actually called
     */
    play_(callback = silencePromise) {
      this.playCallbacks_.push(callback);
      const isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
      const isSafariOrIOS = Boolean(IS_ANY_SAFARI || IS_IOS);

      // treat calls to play_ somewhat like the `one` event function
      if (this.waitToPlay_) {
        this.off(['ready', 'loadstart'], this.waitToPlay_);
        this.waitToPlay_ = null;
      }

      // if the player/tech is not ready or the src itself is not ready
      // queue up a call to play on `ready` or `loadstart`
      if (!this.isReady_ || !isSrcReady) {
        this.waitToPlay_ = e => {
          this.play_();
        };
        this.one(['ready', 'loadstart'], this.waitToPlay_);

        // if we are in Safari, there is a high chance that loadstart will trigger after the gesture timeperiod
        // in that case, we need to prime the video element by calling load so it'll be ready in time
        if (!isSrcReady && isSafariOrIOS) {
          this.load();
        }
        return;
      }

      // If the player/tech is ready and we have a source, we can attempt playback.
      const val = this.techGet_('play');

      // For native playback, reset the progress bar if we get a play call from a replay.
      const isNativeReplay = isSafariOrIOS && this.hasClass('vjs-ended');
      if (isNativeReplay) {
        this.resetProgressBar_();
      }
      // play was terminated if the returned value is null
      if (val === null) {
        this.runPlayTerminatedQueue_();
      } else {
        this.runPlayCallbacks_(val);
      }
    }

    /**
     * These functions will be run when if play is terminated. If play
     * runPlayCallbacks_ is run these function will not be run. This allows us
     * to differentiate between a terminated play and an actual call to play.
     */
    runPlayTerminatedQueue_() {
      const queue = this.playTerminatedQueue_.slice(0);
      this.playTerminatedQueue_ = [];
      queue.forEach(function (q) {
        q();
      });
    }

    /**
     * When a callback to play is delayed we have to run these
     * callbacks when play is actually called on the tech. This function
     * runs the callbacks that were delayed and accepts the return value
     * from the tech.
     *
     * @param {undefined|Promise} val
     *        The return value from the tech.
     */
    runPlayCallbacks_(val) {
      const callbacks = this.playCallbacks_.slice(0);
      this.playCallbacks_ = [];
      // clear play terminatedQueue since we finished a real play
      this.playTerminatedQueue_ = [];
      callbacks.forEach(function (cb) {
        cb(val);
      });
    }

    /**
     * Pause the video playback
     */
    pause() {
      this.techCall_('pause');
    }

    /**
     * Check if the player is paused or has yet to play
     *
     * @return {boolean}
     *         - false: if the media is currently playing
     *         - true: if media is not currently playing
     */
    paused() {
      // The initial state of paused should be true (in Safari it's actually false)
      return this.techGet_('paused') === false ? false : true;
    }

    /**
     * Get a TimeRange object representing the current ranges of time that the user
     * has played.
     *
     * @return {TimeRange}
     *         A time range object that represents all the increments of time that have
     *         been played.
     */
    played() {
      return this.techGet_('played') || createTimeRanges(0, 0);
    }

    /**
     * Sets or returns whether or not the user is "scrubbing". Scrubbing is
     * when the user has clicked the progress bar handle and is
     * dragging it along the progress bar.
     *
     * @param {boolean} [isScrubbing]
     *        whether the user is or is not scrubbing
     *
     * @return {boolean|undefined}
     *         - The value of scrubbing when getting
     *         - Nothing when setting
     */
    scrubbing(isScrubbing) {
      if (typeof isScrubbing === 'undefined') {
        return this.scrubbing_;
      }
      this.scrubbing_ = !!isScrubbing;
      this.techCall_('setScrubbing', this.scrubbing_);
      if (isScrubbing) {
        this.addClass('vjs-scrubbing');
      } else {
        this.removeClass('vjs-scrubbing');
      }
    }

    /**
     * Get or set the current time (in seconds)
     *
     * @param {number|string} [seconds]
     *        The time to seek to in seconds
     *
     * @return {number|undefined}
     *         - the current time in seconds when getting
     *         - Nothing when setting
     */
    currentTime(seconds) {
      if (seconds === undefined) {
        // cache last currentTime and return. default to 0 seconds
        //
        // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
        // currentTime when scrubbing, but may not provide much performance benefit after all.
        // Should be tested. Also something has to read the actual current time or the cache will
        // never get updated.
        this.cache_.currentTime = this.techGet_('currentTime') || 0;
        return this.cache_.currentTime;
      }
      if (seconds < 0) {
        seconds = 0;
      }
      if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
        this.cache_.initTime = seconds;
        this.off('canplay', this.boundApplyInitTime_);
        this.one('canplay', this.boundApplyInitTime_);
        return;
      }
      this.techCall_('setCurrentTime', seconds);
      this.cache_.initTime = 0;
      if (isFinite(seconds)) {
        this.cache_.currentTime = Number(seconds);
      }
    }

    /**
     * Apply the value of initTime stored in cache as currentTime.
     *
     * @private
     */
    applyInitTime_() {
      this.currentTime(this.cache_.initTime);
    }

    /**
     * Normally gets the length in time of the video in seconds;
     * in all but the rarest use cases an argument will NOT be passed to the method
     *
     * > **NOTE**: The video must have started loading before the duration can be
     * known, and depending on preload behaviour may not be known until the video starts
     * playing.
     *
     * @fires Player#durationchange
     *
     * @param {number} [seconds]
     *        The duration of the video to set in seconds
     *
     * @return {number|undefined}
     *         - The duration of the video in seconds when getting
     *         - Nothing when setting
     */
    duration(seconds) {
      if (seconds === undefined) {
        // return NaN if the duration is not known
        return this.cache_.duration !== undefined ? this.cache_.duration : NaN;
      }
      seconds = parseFloat(seconds);

      // Standardize on Infinity for signaling video is live
      if (seconds < 0) {
        seconds = Infinity;
      }
      if (seconds !== this.cache_.duration) {
        // Cache the last set value for optimized scrubbing
        this.cache_.duration = seconds;
        if (seconds === Infinity) {
          this.addClass('vjs-live');
        } else {
          this.removeClass('vjs-live');
        }
        if (!isNaN(seconds)) {
          // Do not fire durationchange unless the duration value is known.
          // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}

          /**
           * @event Player#durationchange
           * @type {Event}
           */
          this.trigger('durationchange');
        }
      }
    }

    /**
     * Calculates how much time is left in the video. Not part
     * of the native video API.
     *
     * @return {number}
     *         The time remaining in seconds
     */
    remainingTime() {
      return this.duration() - this.currentTime();
    }

    /**
     * A remaining time function that is intended to be used when
     * the time is to be displayed directly to the user.
     *
     * @return {number}
     *         The rounded time remaining in seconds
     */
    remainingTimeDisplay() {
      return Math.floor(this.duration()) - Math.floor(this.currentTime());
    }

    //
    // Kind of like an array of portions of the video that have been downloaded.

    /**
     * Get a TimeRange object with an array of the times of the video
     * that have been downloaded. If you just want the percent of the
     * video that's been downloaded, use bufferedPercent.
     *
     * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}
     *
     * @return {TimeRange}
     *         A mock {@link TimeRanges} object (following HTML spec)
     */
    buffered() {
      let buffered = this.techGet_('buffered');
      if (!buffered || !buffered.length) {
        buffered = createTimeRanges(0, 0);
      }
      return buffered;
    }

    /**
     * Get the TimeRanges of the media that are currently available
     * for seeking to.
     *
     * @see [Seekable Spec]{@link https://html.spec.whatwg.org/multipage/media.html#dom-media-seekable}
     *
     * @return {TimeRange}
     *         A mock {@link TimeRanges} object (following HTML spec)
     */
    seekable() {
      let seekable = this.techGet_('seekable');
      if (!seekable || !seekable.length) {
        seekable = createTimeRanges(0, 0);
      }
      return seekable;
    }

    /**
     * Returns whether the player is in the "seeking" state.
     *
     * @return {boolean} True if the player is in the seeking state, false if not.
     */
    seeking() {
      return this.techGet_('seeking');
    }

    /**
     * Returns whether the player is in the "ended" state.
     *
     * @return {boolean} True if the player is in the ended state, false if not.
     */
    ended() {
      return this.techGet_('ended');
    }

    /**
     * Returns the current state of network activity for the element, from
     * the codes in the list below.
     * - NETWORK_EMPTY (numeric value 0)
     *   The element has not yet been initialised. All attributes are in
     *   their initial states.
     * - NETWORK_IDLE (numeric value 1)
     *   The element's resource selection algorithm is active and has
     *   selected a resource, but it is not actually using the network at
     *   this time.
     * - NETWORK_LOADING (numeric value 2)
     *   The user agent is actively trying to download data.
     * - NETWORK_NO_SOURCE (numeric value 3)
     *   The element's resource selection algorithm is active, but it has
     *   not yet found a resource to use.
     *
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
     * @return {number} the current network activity state
     */
    networkState() {
      return this.techGet_('networkState');
    }

    /**
     * Returns a value that expresses the current state of the element
     * with respect to rendering the current playback position, from the
     * codes in the list below.
     * - HAVE_NOTHING (numeric value 0)
     *   No information regarding the media resource is available.
     * - HAVE_METADATA (numeric value 1)
     *   Enough of the resource has been obtained that the duration of the
     *   resource is available.
     * - HAVE_CURRENT_DATA (numeric value 2)
     *   Data for the immediate current playback position is available.
     * - HAVE_FUTURE_DATA (numeric value 3)
     *   Data for the immediate current playback position is available, as
     *   well as enough data for the user agent to advance the current
     *   playback position in the direction of playback.
     * - HAVE_ENOUGH_DATA (numeric value 4)
     *   The user agent estimates that enough data is available for
     *   playback to proceed uninterrupted.
     *
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
     * @return {number} the current playback rendering state
     */
    readyState() {
      return this.techGet_('readyState');
    }

    /**
     * Get the percent (as a decimal) of the video that's been downloaded.
     * This method is not a part of the native HTML video API.
     *
     * @return {number}
     *         A decimal between 0 and 1 representing the percent
     *         that is buffered 0 being 0% and 1 being 100%
     */
    bufferedPercent() {
      return bufferedPercent(this.buffered(), this.duration());
    }

    /**
     * Get the ending time of the last buffered time range
     * This is used in the progress bar to encapsulate all time ranges.
     *
     * @return {number}
     *         The end of the last buffered time range
     */
    bufferedEnd() {
      const buffered = this.buffered();
      const duration = this.duration();
      let end = buffered.end(buffered.length - 1);
      if (end > duration) {
        end = duration;
      }
      return end;
    }

    /**
     * Get or set the current volume of the media
     *
     * @param  {number} [percentAsDecimal]
     *         The new volume as a decimal percent:
     *         - 0 is muted/0%/off
     *         - 1.0 is 100%/full
     *         - 0.5 is half volume or 50%
     *
     * @return {number|undefined}
     *         The current volume as a percent when getting
     */
    volume(percentAsDecimal) {
      let vol;
      if (percentAsDecimal !== undefined) {
        // Force value to between 0 and 1
        vol = Math.max(0, Math.min(1, percentAsDecimal));
        this.cache_.volume = vol;
        this.techCall_('setVolume', vol);
        if (vol > 0) {
          this.lastVolume_(vol);
        }
        return;
      }

      // Default to 1 when returning current volume.
      vol = parseFloat(this.techGet_('volume'));
      return isNaN(vol) ? 1 : vol;
    }

    /**
     * Get the current muted state, or turn mute on or off
     *
     * @param {boolean} [muted]
     *        - true to mute
     *        - false to unmute
     *
     * @return {boolean|undefined}
     *         - true if mute is on and getting
     *         - false if mute is off and getting
     *         - nothing if setting
     */
    muted(muted) {
      if (muted !== undefined) {
        this.techCall_('setMuted', muted);
        return;
      }
      return this.techGet_('muted') || false;
    }

    /**
     * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted
     * indicates the state of muted on initial playback.
     *
     * ```js
     *   var myPlayer = videojs('some-player-id');
     *
     *   myPlayer.src("http://www.example.com/path/to/video.mp4");
     *
     *   // get, should be false
     *   console.log(myPlayer.defaultMuted());
     *   // set to true
     *   myPlayer.defaultMuted(true);
     *   // get should be true
     *   console.log(myPlayer.defaultMuted());
     * ```
     *
     * @param {boolean} [defaultMuted]
     *        - true to mute
     *        - false to unmute
     *
     * @return {boolean|undefined}
     *         - true if defaultMuted is on and getting
     *         - false if defaultMuted is off and getting
     *         - Nothing when setting
     */
    defaultMuted(defaultMuted) {
      if (defaultMuted !== undefined) {
        this.techCall_('setDefaultMuted', defaultMuted);
      }
      return this.techGet_('defaultMuted') || false;
    }

    /**
     * Get the last volume, or set it
     *
     * @param  {number} [percentAsDecimal]
     *         The new last volume as a decimal percent:
     *         - 0 is muted/0%/off
     *         - 1.0 is 100%/full
     *         - 0.5 is half volume or 50%
     *
     * @return {number|undefined}
     *         - The current value of lastVolume as a percent when getting
     *         - Nothing when setting
     *
     * @private
     */
    lastVolume_(percentAsDecimal) {
      if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {
        this.cache_.lastVolume = percentAsDecimal;
        return;
      }
      return this.cache_.lastVolume;
    }

    /**
     * Check if current tech can support native fullscreen
     * (e.g. with built in controls like iOS)
     *
     * @return {boolean}
     *         if native fullscreen is supported
     */
    supportsFullScreen() {
      return this.techGet_('supportsFullScreen') || false;
    }

    /**
     * Check if the player is in fullscreen mode or tell the player that it
     * is or is not in fullscreen mode.
     *
     * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
     * property and instead document.fullscreenElement is used. But isFullscreen is
     * still a valuable property for internal player workings.
     *
     * @param  {boolean} [isFS]
     *         Set the players current fullscreen state
     *
     * @return {boolean|undefined}
     *         - true if fullscreen is on and getting
     *         - false if fullscreen is off and getting
     *         - Nothing when setting
     */
    isFullscreen(isFS) {
      if (isFS !== undefined) {
        const oldValue = this.isFullscreen_;
        this.isFullscreen_ = Boolean(isFS);

        // if we changed fullscreen state and we're in prefixed mode, trigger fullscreenchange
        // this is the only place where we trigger fullscreenchange events for older browsers
        // fullWindow mode is treated as a prefixed event and will get a fullscreenchange event as well
        if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {
          /**
             * @event Player#fullscreenchange
             * @type {Event}
             */
          this.trigger('fullscreenchange');
        }
        this.toggleFullscreenClass_();
        return;
      }
      return this.isFullscreen_;
    }

    /**
     * Increase the size of the video to full screen
     * In some browsers, full screen is not supported natively, so it enters
     * "full window mode", where the video fills the browser window.
     * In browsers and devices that support native full screen, sometimes the
     * browser's default controls will be shown, and not the Video.js custom skin.
     * This includes most mobile devices (iOS, Android) and older versions of
     * Safari.
     *
     * @param  {Object} [fullscreenOptions]
     *         Override the player fullscreen options
     *
     * @fires Player#fullscreenchange
     */
    requestFullscreen(fullscreenOptions) {
      if (this.isInPictureInPicture()) {
        this.exitPictureInPicture();
      }
      const self = this;
      return new Promise((resolve, reject) => {
        function offHandler() {
          self.off('fullscreenerror', errorHandler);
          self.off('fullscreenchange', changeHandler);
        }
        function changeHandler() {
          offHandler();
          resolve();
        }
        function errorHandler(e, err) {
          offHandler();
          reject(err);
        }
        self.one('fullscreenchange', changeHandler);
        self.one('fullscreenerror', errorHandler);
        const promise = self.requestFullscreenHelper_(fullscreenOptions);
        if (promise) {
          promise.then(offHandler, offHandler);
          promise.then(resolve, reject);
        }
      });
    }
    requestFullscreenHelper_(fullscreenOptions) {
      let fsOptions;

      // Only pass fullscreen options to requestFullscreen in spec-compliant browsers.
      // Use defaults or player configured option unless passed directly to this method.
      if (!this.fsApi_.prefixed) {
        fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};
        if (fullscreenOptions !== undefined) {
          fsOptions = fullscreenOptions;
        }
      }

      // This method works as follows:
      // 1. if a fullscreen api is available, use it
      //   1. call requestFullscreen with potential options
      //   2. if we got a promise from above, use it to update isFullscreen()
      // 2. otherwise, if the tech supports fullscreen, call `enterFullScreen` on it.
      //   This is particularly used for iPhone, older iPads, and non-safari browser on iOS.
      // 3. otherwise, use "fullWindow" mode
      if (this.fsApi_.requestFullscreen) {
        const promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);

        // Even on browsers with promise support this may not return a promise
        if (promise) {
          promise.then(() => this.isFullscreen(true), () => this.isFullscreen(false));
        }
        return promise;
      } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
        // we can't take the video.js controls fullscreen but we can go fullscreen
        // with native controls
        this.techCall_('enterFullScreen');
      } else {
        // fullscreen isn't supported so we'll just stretch the video element to
        // fill the viewport
        this.enterFullWindow();
      }
    }

    /**
     * Return the video to its normal size after having been in full screen mode
     *
     * @fires Player#fullscreenchange
     */
    exitFullscreen() {
      const self = this;
      return new Promise((resolve, reject) => {
        function offHandler() {
          self.off('fullscreenerror', errorHandler);
          self.off('fullscreenchange', changeHandler);
        }
        function changeHandler() {
          offHandler();
          resolve();
        }
        function errorHandler(e, err) {
          offHandler();
          reject(err);
        }
        self.one('fullscreenchange', changeHandler);
        self.one('fullscreenerror', errorHandler);
        const promise = self.exitFullscreenHelper_();
        if (promise) {
          promise.then(offHandler, offHandler);
          // map the promise to our resolve/reject methods
          promise.then(resolve, reject);
        }
      });
    }
    exitFullscreenHelper_() {
      if (this.fsApi_.requestFullscreen) {
        const promise = document__default["default"][this.fsApi_.exitFullscreen]();

        // Even on browsers with promise support this may not return a promise
        if (promise) {
          // we're splitting the promise here, so, we want to catch the
          // potential error so that this chain doesn't have unhandled errors
          silencePromise(promise.then(() => this.isFullscreen(false)));
        }
        return promise;
      } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
        this.techCall_('exitFullScreen');
      } else {
        this.exitFullWindow();
      }
    }

    /**
     * When fullscreen isn't supported we can stretch the
     * video container to as wide as the browser will let us.
     *
     * @fires Player#enterFullWindow
     */
    enterFullWindow() {
      this.isFullscreen(true);
      this.isFullWindow = true;

      // Storing original doc overflow value to return to when fullscreen is off
      this.docOrigOverflow = document__default["default"].documentElement.style.overflow;

      // Add listener for esc key to exit fullscreen
      on(document__default["default"], 'keydown', this.boundFullWindowOnEscKey_);

      // Hide any scroll bars
      document__default["default"].documentElement.style.overflow = 'hidden';

      // Apply fullscreen styles
      addClass(document__default["default"].body, 'vjs-full-window');

      /**
       * @event Player#enterFullWindow
       * @type {Event}
       */
      this.trigger('enterFullWindow');
    }

    /**
     * Check for call to either exit full window or
     * full screen on ESC key
     *
     * @param {string} event
     *        Event to check for key press
     */
    fullWindowOnEscKey(event) {
      if (event.key === 'Escape') {
        if (this.isFullscreen() === true) {
          if (!this.isFullWindow) {
            this.exitFullscreen();
          } else {
            this.exitFullWindow();
          }
        }
      }
    }

    /**
     * Exit full window
     *
     * @fires Player#exitFullWindow
     */
    exitFullWindow() {
      this.isFullscreen(false);
      this.isFullWindow = false;
      off(document__default["default"], 'keydown', this.boundFullWindowOnEscKey_);

      // Unhide scroll bars.
      document__default["default"].documentElement.style.overflow = this.docOrigOverflow;

      // Remove fullscreen styles
      removeClass(document__default["default"].body, 'vjs-full-window');

      // Resize the box, controller, and poster to original sizes
      // this.positionAll();
      /**
       * @event Player#exitFullWindow
       * @type {Event}
       */
      this.trigger('exitFullWindow');
    }

    /**
     * Get or set disable Picture-in-Picture mode.
     *
     * @param {boolean} [value]
     *                  - true will disable Picture-in-Picture mode
     *                  - false will enable Picture-in-Picture mode
     */
    disablePictureInPicture(value) {
      if (value === undefined) {
        return this.techGet_('disablePictureInPicture');
      }
      this.techCall_('setDisablePictureInPicture', value);
      this.options_.disablePictureInPicture = value;
      this.trigger('disablepictureinpicturechanged');
    }

    /**
     * Check if the player is in Picture-in-Picture mode or tell the player that it
     * is or is not in Picture-in-Picture mode.
     *
     * @param  {boolean} [isPiP]
     *         Set the players current Picture-in-Picture state
     *
     * @return {boolean|undefined}
     *         - true if Picture-in-Picture is on and getting
     *         - false if Picture-in-Picture is off and getting
     *         - nothing if setting
     */
    isInPictureInPicture(isPiP) {
      if (isPiP !== undefined) {
        this.isInPictureInPicture_ = !!isPiP;
        this.togglePictureInPictureClass_();
        return;
      }
      return !!this.isInPictureInPicture_;
    }

    /**
     * Create a floating video window always on top of other windows so that users may
     * continue consuming media while they interact with other content sites, or
     * applications on their device.
     *
     * This can use document picture-in-picture or element picture in picture
     *
     * Set `enableDocumentPictureInPicture` to `true` to use docPiP on a supported browser
     * Else set `disablePictureInPicture` to `false` to disable elPiP on a supported browser
     *
     *
     * @see [Spec]{@link https://w3c.github.io/picture-in-picture/}
     * @see [Spec]{@link https://wicg.github.io/document-picture-in-picture/}
     *
     * @fires Player#enterpictureinpicture
     *
     * @return {Promise}
     *         A promise with a Picture-in-Picture window.
     */
    requestPictureInPicture() {
      if (this.options_.enableDocumentPictureInPicture && window__default["default"].documentPictureInPicture) {
        const pipContainer = document__default["default"].createElement(this.el().tagName);
        pipContainer.classList = this.el().classList;
        pipContainer.classList.add('vjs-pip-container');
        if (this.posterImage) {
          pipContainer.appendChild(this.posterImage.el().cloneNode(true));
        }
        if (this.titleBar) {
          pipContainer.appendChild(this.titleBar.el().cloneNode(true));
        }
        pipContainer.appendChild(createEl('p', {
          className: 'vjs-pip-text'
        }, {}, this.localize('Playing in picture-in-picture')));
        return window__default["default"].documentPictureInPicture.requestWindow({
          // The aspect ratio won't be correct, Chrome bug https://crbug.com/1407629
          width: this.videoWidth(),
          height: this.videoHeight()
        }).then(pipWindow => {
          copyStyleSheetsToWindow(pipWindow);
          this.el_.parentNode.insertBefore(pipContainer, this.el_);
          pipWindow.document.body.appendChild(this.el_);
          pipWindow.document.body.classList.add('vjs-pip-window');
          this.player_.isInPictureInPicture(true);
          this.player_.trigger({
            type: 'enterpictureinpicture',
            pipWindow
          });

          // Listen for the PiP closing event to move the video back.
          pipWindow.addEventListener('pagehide', event => {
            const pipVideo = event.target.querySelector('.video-js');
            pipContainer.parentNode.replaceChild(pipVideo, pipContainer);
            this.player_.isInPictureInPicture(false);
            this.player_.trigger('leavepictureinpicture');
          });
          return pipWindow;
        });
      }
      if ('pictureInPictureEnabled' in document__default["default"] && this.disablePictureInPicture() === false) {
        /**
         * This event fires when the player enters picture in picture mode
         *
         * @event Player#enterpictureinpicture
         * @type {Event}
         */
        return this.techGet_('requestPictureInPicture');
      }
      return Promise.reject('No PiP mode is available');
    }

    /**
     * Exit Picture-in-Picture mode.
     *
     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
     *
     * @fires Player#leavepictureinpicture
     *
     * @return {Promise}
     *         A promise.
     */
    exitPictureInPicture() {
      if (window__default["default"].documentPictureInPicture && window__default["default"].documentPictureInPicture.window) {
        // With documentPictureInPicture, Player#leavepictureinpicture is fired in the pagehide handler
        window__default["default"].documentPictureInPicture.window.close();
        return Promise.resolve();
      }
      if ('pictureInPictureEnabled' in document__default["default"]) {
        /**
         * This event fires when the player leaves picture in picture mode
         *
         * @event Player#leavepictureinpicture
         * @type {Event}
         */
        return document__default["default"].exitPictureInPicture();
      }
    }

    /**
     * Called when this Player has focus and a key gets pressed down, or when
     * any Component of this player receives a key press that it doesn't handle.
     * This allows player-wide hotkeys (either as defined below, or optionally
     * by an external function).
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      const {
        userActions
      } = this.options_;

      // Bail out if hotkeys are not configured.
      if (!userActions || !userActions.hotkeys) {
        return;
      }

      // Function that determines whether or not to exclude an element from
      // hotkeys handling.
      const excludeElement = el => {
        const tagName = el.tagName.toLowerCase();

        // The first and easiest test is for `contenteditable` elements.
        if (el.isContentEditable) {
          return true;
        }

        // Inputs matching these types will still trigger hotkey handling as
        // they are not text inputs.
        const allowedInputTypes = ['button', 'checkbox', 'hidden', 'radio', 'reset', 'submit'];
        if (tagName === 'input') {
          return allowedInputTypes.indexOf(el.type) === -1;
        }

        // The final test is by tag name. These tags will be excluded entirely.
        const excludedTags = ['textarea'];
        return excludedTags.indexOf(tagName) !== -1;
      };

      // Bail out if the user is focused on an interactive form element.
      if (excludeElement(this.el_.ownerDocument.activeElement)) {
        return;
      }
      if (typeof userActions.hotkeys === 'function') {
        userActions.hotkeys.call(this, event);
      } else {
        this.handleHotkeys(event);
      }
    }

    /**
     * Called when this Player receives a hotkey keydown event.
     * Supported player-wide hotkeys are:
     *
     *   f          - toggle fullscreen
     *   m          - toggle mute
     *   k or Space - toggle play/pause
     *
     * @param {Event} event
     *        The `keydown` event that caused this function to be called.
     */
    handleHotkeys(event) {
      const hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};

      // set fullscreenKey, muteKey, playPauseKey from `hotkeys`, use defaults if not set
      const {
        fullscreenKey = keydownEvent => event.key.toLowerCase() === 'f',
        muteKey = keydownEvent => event.key.toLowerCase() === 'm',
        playPauseKey = keydownEvent => event.key.toLowerCase() === 'k' || event.key.toLowerCase() === ' '
      } = hotkeys;
      if (fullscreenKey.call(this, event)) {
        event.preventDefault();
        event.stopPropagation();
        const FSToggle = Component.getComponent('FullscreenToggle');
        if (document__default["default"][this.fsApi_.fullscreenEnabled] !== false) {
          FSToggle.prototype.handleClick.call(this, event);
        }
      } else if (muteKey.call(this, event)) {
        event.preventDefault();
        event.stopPropagation();
        const MuteToggle = Component.getComponent('MuteToggle');
        MuteToggle.prototype.handleClick.call(this, event);
      } else if (playPauseKey.call(this, event)) {
        event.preventDefault();
        event.stopPropagation();
        const PlayToggle = Component.getComponent('PlayToggle');
        PlayToggle.prototype.handleClick.call(this, event);
      }
    }

    /**
     * Check whether the player can play a given mimetype
     *
     * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype
     *
     * @param {string} type
     *        The mimetype to check
     *
     * @return {string}
     *         'probably', 'maybe', or '' (empty string)
     */
    canPlayType(type) {
      let can;

      // Loop through each playback technology in the options order
      for (let i = 0, j = this.options_.techOrder; i < j.length; i++) {
        const techName = j[i];
        let tech = Tech.getTech(techName);

        // Support old behavior of techs being registered as components.
        // Remove once that deprecated behavior is removed.
        if (!tech) {
          tech = Component.getComponent(techName);
        }

        // Check if the current tech is defined before continuing
        if (!tech) {
          log.error(`The "${techName}" tech is undefined. Skipped browser support check for that tech.`);
          continue;
        }

        // Check if the browser supports this technology
        if (tech.isSupported()) {
          can = tech.canPlayType(type);
          if (can) {
            return can;
          }
        }
      }
      return '';
    }

    /**
     * Select source based on tech-order or source-order
     * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,
     * defaults to tech-order selection
     *
     * @param {Array} sources
     *        The sources for a media asset
     *
     * @return {Object|boolean}
     *         Object of source and tech order or false
     */
    selectSource(sources) {
      // Get only the techs specified in `techOrder` that exist and are supported by the
      // current platform
      const techs = this.options_.techOrder.map(techName => {
        return [techName, Tech.getTech(techName)];
      }).filter(([techName, tech]) => {
        // Check if the current tech is defined before continuing
        if (tech) {
          // Check if the browser supports this technology
          return tech.isSupported();
        }
        log.error(`The "${techName}" tech is undefined. Skipped browser support check for that tech.`);
        return false;
      });

      // Iterate over each `innerArray` element once per `outerArray` element and execute
      // `tester` with both. If `tester` returns a non-falsy value, exit early and return
      // that value.
      const findFirstPassingTechSourcePair = function (outerArray, innerArray, tester) {
        let found;
        outerArray.some(outerChoice => {
          return innerArray.some(innerChoice => {
            found = tester(outerChoice, innerChoice);
            if (found) {
              return true;
            }
          });
        });
        return found;
      };
      let foundSourceAndTech;
      const flip = fn => (a, b) => fn(b, a);
      const finder = ([techName, tech], source) => {
        if (tech.canPlaySource(source, this.options_[techName.toLowerCase()])) {
          return {
            source,
            tech: techName
          };
        }
      };

      // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources
      // to select from them based on their priority.
      if (this.options_.sourceOrder) {
        // Source-first ordering
        foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
      } else {
        // Tech-first ordering
        foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
      }
      return foundSourceAndTech || false;
    }

    /**
     * Executes source setting and getting logic
     *
     * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
     *        A SourceObject, an array of SourceObjects, or a string referencing
     *        a URL to a media source. It is _highly recommended_ that an object
     *        or array of objects is used here, so that source selection
     *        algorithms can take the `type` into account.
     *
     *        If not provided, this method acts as a getter.
     * @param {boolean} [isRetry]
     *        Indicates whether this is being called internally as a result of a retry
     *
     * @return {string|undefined}
     *         If the `source` argument is missing, returns the current source
     *         URL. Otherwise, returns nothing/undefined.
     */
    handleSrc_(source, isRetry) {
      // getter usage
      if (typeof source === 'undefined') {
        return this.cache_.src || '';
      }

      // Reset retry behavior for new source
      if (this.resetRetryOnError_) {
        this.resetRetryOnError_();
      }

      // filter out invalid sources and turn our source into
      // an array of source objects
      const sources = filterSource(source);

      // if a source was passed in then it is invalid because
      // it was filtered to a zero length Array. So we have to
      // show an error
      if (!sources.length) {
        this.setTimeout(function () {
          this.error({
            code: 4,
            message: this.options_.notSupportedMessage
          });
        }, 0);
        return;
      }

      // initial sources
      this.changingSrc_ = true;

      // Only update the cached source list if we are not retrying a new source after error,
      // since in that case we want to include the failed source(s) in the cache
      if (!isRetry) {
        this.cache_.sources = sources;
      }
      this.updateSourceCaches_(sources[0]);

      // middlewareSource is the source after it has been changed by middleware
      setSource(this, sources[0], (middlewareSource, mws) => {
        this.middleware_ = mws;

        // since sourceSet is async we have to update the cache again after we select a source since
        // the source that is selected could be out of order from the cache update above this callback.
        if (!isRetry) {
          this.cache_.sources = sources;
        }
        this.updateSourceCaches_(middlewareSource);
        const err = this.src_(middlewareSource);
        if (err) {
          if (sources.length > 1) {
            return this.handleSrc_(sources.slice(1));
          }
          this.changingSrc_ = false;

          // We need to wrap this in a timeout to give folks a chance to add error event handlers
          this.setTimeout(function () {
            this.error({
              code: 4,
              message: this.options_.notSupportedMessage
            });
          }, 0);

          // we could not find an appropriate tech, but let's still notify the delegate that this is it
          // this needs a better comment about why this is needed
          this.triggerReady();
          return;
        }
        setTech(mws, this.tech_);
      });

      // Try another available source if this one fails before playback.
      if (sources.length > 1) {
        const retry = () => {
          // Remove the error modal
          this.error(null);
          this.handleSrc_(sources.slice(1), true);
        };
        const stopListeningForErrors = () => {
          this.off('error', retry);
        };
        this.one('error', retry);
        this.one('playing', stopListeningForErrors);
        this.resetRetryOnError_ = () => {
          this.off('error', retry);
          this.off('playing', stopListeningForErrors);
        };
      }
    }

    /**
     * Get or set the video source.
     *
     * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
     *        A SourceObject, an array of SourceObjects, or a string referencing
     *        a URL to a media source. It is _highly recommended_ that an object
     *        or array of objects is used here, so that source selection
     *        algorithms can take the `type` into account.
     *
     *        If not provided, this method acts as a getter.
     *
     * @return {string|undefined}
     *         If the `source` argument is missing, returns the current source
     *         URL. Otherwise, returns nothing/undefined.
     */
    src(source) {
      return this.handleSrc_(source, false);
    }

    /**
     * Set the source object on the tech, returns a boolean that indicates whether
     * there is a tech that can play the source or not
     *
     * @param {Tech~SourceObject} source
     *        The source object to set on the Tech
     *
     * @return {boolean}
     *         - True if there is no Tech to playback this source
     *         - False otherwise
     *
     * @private
     */
    src_(source) {
      const sourceTech = this.selectSource([source]);
      if (!sourceTech) {
        return true;
      }
      if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
        this.changingSrc_ = true;
        // load this technology with the chosen source
        this.loadTech_(sourceTech.tech, sourceTech.source);
        this.tech_.ready(() => {
          this.changingSrc_ = false;
        });
        return false;
      }

      // wait until the tech is ready to set the source
      // and set it synchronously if possible (#2326)
      this.ready(function () {
        // The setSource tech method was added with source handlers
        // so older techs won't support it
        // We need to check the direct prototype for the case where subclasses
        // of the tech do not support source handlers
        if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {
          this.techCall_('setSource', source);
        } else {
          this.techCall_('src', source.src);
        }
        this.changingSrc_ = false;
      }, true);
      return false;
    }

    /**
     * Begin loading the src data.
     */
    load() {
      // Workaround to use the load method with the VHS.
      // Does not cover the case when the load method is called directly from the mediaElement.
      if (this.tech_ && this.tech_.vhs) {
        this.src(this.currentSource());
        return;
      }
      this.techCall_('load');
    }

    /**
     * Reset the player. Loads the first tech in the techOrder,
     * removes all the text tracks in the existing `tech`,
     * and calls `reset` on the `tech`.
     */
    reset() {
      if (this.paused()) {
        this.doReset_();
      } else {
        const playPromise = this.play();
        silencePromise(playPromise.then(() => this.doReset_()));
      }
    }
    doReset_() {
      if (this.tech_) {
        this.tech_.clearTracks('text');
      }
      this.removeClass('vjs-playing');
      this.addClass('vjs-paused');
      this.resetCache_();
      this.poster('');
      this.loadTech_(this.options_.techOrder[0], null);
      this.techCall_('reset');
      this.resetControlBarUI_();
      this.error(null);
      if (this.titleBar) {
        this.titleBar.update({
          title: undefined,
          description: undefined
        });
      }
      if (isEvented(this)) {
        this.trigger('playerreset');
      }
    }

    /**
     * Reset Control Bar's UI by calling sub-methods that reset
     * all of Control Bar's components
     */
    resetControlBarUI_() {
      this.resetProgressBar_();
      this.resetPlaybackRate_();
      this.resetVolumeBar_();
    }

    /**
     * Reset tech's progress so progress bar is reset in the UI
     */
    resetProgressBar_() {
      this.currentTime(0);
      const {
        currentTimeDisplay,
        durationDisplay,
        progressControl,
        remainingTimeDisplay
      } = this.controlBar || {};
      const {
        seekBar
      } = progressControl || {};
      if (currentTimeDisplay) {
        currentTimeDisplay.updateContent();
      }
      if (durationDisplay) {
        durationDisplay.updateContent();
      }
      if (remainingTimeDisplay) {
        remainingTimeDisplay.updateContent();
      }
      if (seekBar) {
        seekBar.update();
        if (seekBar.loadProgressBar) {
          seekBar.loadProgressBar.update();
        }
      }
    }

    /**
     * Reset Playback ratio
     */
    resetPlaybackRate_() {
      this.playbackRate(this.defaultPlaybackRate());
      this.handleTechRateChange_();
    }

    /**
     * Reset Volume bar
     */
    resetVolumeBar_() {
      this.volume(1.0);
      this.trigger('volumechange');
    }

    /**
     * Returns all of the current source objects.
     *
     * @return {Tech~SourceObject[]}
     *         The current source objects
     */
    currentSources() {
      const source = this.currentSource();
      const sources = [];

      // assume `{}` or `{ src }`
      if (Object.keys(source).length !== 0) {
        sources.push(source);
      }
      return this.cache_.sources || sources;
    }

    /**
     * Returns the current source object.
     *
     * @return {Tech~SourceObject}
     *         The current source object
     */
    currentSource() {
      return this.cache_.source || {};
    }

    /**
     * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
     * Can be used in conjunction with `currentType` to assist in rebuilding the current source object.
     *
     * @return {string}
     *         The current source
     */
    currentSrc() {
      return this.currentSource() && this.currentSource().src || '';
    }

    /**
     * Get the current source type e.g. video/mp4
     * This can allow you rebuild the current source object so that you could load the same
     * source and tech later
     *
     * @return {string}
     *         The source MIME type
     */
    currentType() {
      return this.currentSource() && this.currentSource().type || '';
    }

    /**
     * Get or set the preload attribute
     *
     * @param {'none'|'auto'|'metadata'} [value]
     *        Preload mode to pass to tech
     *
     * @return {string|undefined}
     *         - The preload attribute value when getting
     *         - Nothing when setting
     */
    preload(value) {
      if (value !== undefined) {
        this.techCall_('setPreload', value);
        this.options_.preload = value;
        return;
      }
      return this.techGet_('preload');
    }

    /**
     * Get or set the autoplay option. When this is a boolean it will
     * modify the attribute on the tech. When this is a string the attribute on
     * the tech will be removed and `Player` will handle autoplay on loadstarts.
     *
     * @param {boolean|'play'|'muted'|'any'} [value]
     *        - true: autoplay using the browser behavior
     *        - false: do not autoplay
     *        - 'play': call play() on every loadstart
     *        - 'muted': call muted() then play() on every loadstart
     *        - 'any': call play() on every loadstart. if that fails call muted() then play().
     *        - *: values other than those listed here will be set `autoplay` to true
     *
     * @return {boolean|string|undefined}
     *         - The current value of autoplay when getting
     *         - Nothing when setting
     */
    autoplay(value) {
      // getter usage
      if (value === undefined) {
        return this.options_.autoplay || false;
      }
      let techAutoplay;

      // if the value is a valid string set it to that, or normalize `true` to 'play', if need be
      if (typeof value === 'string' && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {
        this.options_.autoplay = value;
        this.manualAutoplay_(typeof value === 'string' ? value : 'play');
        techAutoplay = false;

        // any falsy value sets autoplay to false in the browser,
        // lets do the same
      } else if (!value) {
        this.options_.autoplay = false;

        // any other value (ie truthy) sets autoplay to true
      } else {
        this.options_.autoplay = true;
      }
      techAutoplay = typeof techAutoplay === 'undefined' ? this.options_.autoplay : techAutoplay;

      // if we don't have a tech then we do not queue up
      // a setAutoplay call on tech ready. We do this because the
      // autoplay option will be passed in the constructor and we
      // do not need to set it twice
      if (this.tech_) {
        this.techCall_('setAutoplay', techAutoplay);
      }
    }

    /**
     * Set or unset the playsinline attribute.
     * Playsinline tells the browser that non-fullscreen playback is preferred.
     *
     * @param {boolean} [value]
     *        - true means that we should try to play inline by default
     *        - false means that we should use the browser's default playback mode,
     *          which in most cases is inline. iOS Safari is a notable exception
     *          and plays fullscreen by default.
     *
     * @return {string|undefined}
     *         - the current value of playsinline
     *         - Nothing when setting
     *
     * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
     */
    playsinline(value) {
      if (value !== undefined) {
        this.techCall_('setPlaysinline', value);
        this.options_.playsinline = value;
      }
      return this.techGet_('playsinline');
    }

    /**
     * Get or set the loop attribute on the video element.
     *
     * @param {boolean} [value]
     *        - true means that we should loop the video
     *        - false means that we should not loop the video
     *
     * @return {boolean|undefined}
     *         - The current value of loop when getting
     *         - Nothing when setting
     */
    loop(value) {
      if (value !== undefined) {
        this.techCall_('setLoop', value);
        this.options_.loop = value;
        return;
      }
      return this.techGet_('loop');
    }

    /**
     * Get or set the poster image source url
     *
     * @fires Player#posterchange
     *
     * @param {string} [src]
     *        Poster image source URL
     *
     * @return {string|undefined}
     *         - The current value of poster when getting
     *         - Nothing when setting
     */
    poster(src) {
      if (src === undefined) {
        return this.poster_;
      }

      // The correct way to remove a poster is to set as an empty string
      // other falsey values will throw errors
      if (!src) {
        src = '';
      }
      if (src === this.poster_) {
        return;
      }

      // update the internal poster variable
      this.poster_ = src;

      // update the tech's poster
      this.techCall_('setPoster', src);
      this.isPosterFromTech_ = false;

      // alert components that the poster has been set
      /**
       * This event fires when the poster image is changed on the player.
       *
       * @event Player#posterchange
       * @type {Event}
       */
      this.trigger('posterchange');
    }

    /**
     * Some techs (e.g. YouTube) can provide a poster source in an
     * asynchronous way. We want the poster component to use this
     * poster source so that it covers up the tech's controls.
     * (YouTube's play button). However we only want to use this
     * source if the player user hasn't set a poster through
     * the normal APIs.
     *
     * @fires Player#posterchange
     * @listens Tech#posterchange
     * @private
     */
    handleTechPosterChange_() {
      if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
        const newPoster = this.tech_.poster() || '';
        if (newPoster !== this.poster_) {
          this.poster_ = newPoster;
          this.isPosterFromTech_ = true;

          // Let components know the poster has changed
          this.trigger('posterchange');
        }
      }
    }

    /**
     * Get or set whether or not the controls are showing.
     *
     * @fires Player#controlsenabled
     *
     * @param {boolean} [bool]
     *        - true to turn controls on
     *        - false to turn controls off
     *
     * @return {boolean|undefined}
     *         - The current value of controls when getting
     *         - Nothing when setting
     */
    controls(bool) {
      if (bool === undefined) {
        return !!this.controls_;
      }
      bool = !!bool;

      // Don't trigger a change event unless it actually changed
      if (this.controls_ === bool) {
        return;
      }
      this.controls_ = bool;
      if (this.usingNativeControls()) {
        this.techCall_('setControls', bool);
      }
      if (this.controls_) {
        this.removeClass('vjs-controls-disabled');
        this.addClass('vjs-controls-enabled');
        /**
         * @event Player#controlsenabled
         * @type {Event}
         */
        this.trigger('controlsenabled');
        if (!this.usingNativeControls()) {
          this.addTechControlsListeners_();
        }
      } else {
        this.removeClass('vjs-controls-enabled');
        this.addClass('vjs-controls-disabled');
        /**
         * @event Player#controlsdisabled
         * @type {Event}
         */
        this.trigger('controlsdisabled');
        if (!this.usingNativeControls()) {
          this.removeTechControlsListeners_();
        }
      }
    }

    /**
     * Toggle native controls on/off. Native controls are the controls built into
     * devices (e.g. default iPhone controls) or other techs
     * (e.g. Vimeo Controls)
     * **This should only be set by the current tech, because only the tech knows
     * if it can support native controls**
     *
     * @fires Player#usingnativecontrols
     * @fires Player#usingcustomcontrols
     *
     * @param {boolean} [bool]
     *        - true to turn native controls on
     *        - false to turn native controls off
     *
     * @return {boolean|undefined}
     *         - The current value of native controls when getting
     *         - Nothing when setting
     */
    usingNativeControls(bool) {
      if (bool === undefined) {
        return !!this.usingNativeControls_;
      }
      bool = !!bool;

      // Don't trigger a change event unless it actually changed
      if (this.usingNativeControls_ === bool) {
        return;
      }
      this.usingNativeControls_ = bool;
      if (this.usingNativeControls_) {
        this.addClass('vjs-using-native-controls');

        /**
         * player is using the native device controls
         *
         * @event Player#usingnativecontrols
         * @type {Event}
         */
        this.trigger('usingnativecontrols');
      } else {
        this.removeClass('vjs-using-native-controls');

        /**
         * player is using the custom HTML controls
         *
         * @event Player#usingcustomcontrols
         * @type {Event}
         */
        this.trigger('usingcustomcontrols');
      }
    }

    /**
     * Set or get the current MediaError
     *
     * @fires Player#error
     *
     * @param  {MediaError|string|number} [err]
     *         A MediaError or a string/number to be turned
     *         into a MediaError
     *
     * @return {MediaError|null|undefined}
     *         - The current MediaError when getting (or null)
     *         - Nothing when setting
     */
    error(err) {
      if (err === undefined) {
        return this.error_ || null;
      }

      // allow hooks to modify error object
      hooks('beforeerror').forEach(hookFunction => {
        const newErr = hookFunction(this, err);
        if (!(isObject(newErr) && !Array.isArray(newErr) || typeof newErr === 'string' || typeof newErr === 'number' || newErr === null)) {
          this.log.error('please return a value that MediaError expects in beforeerror hooks');
          return;
        }
        err = newErr;
      });

      // Suppress the first error message for no compatible source until
      // user interaction
      if (this.options_.suppressNotSupportedError && err && err.code === 4) {
        const triggerSuppressedError = function () {
          this.error(err);
        };
        this.options_.suppressNotSupportedError = false;
        this.any(['click', 'touchstart'], triggerSuppressedError);
        this.one('loadstart', function () {
          this.off(['click', 'touchstart'], triggerSuppressedError);
        });
        return;
      }

      // restoring to default
      if (err === null) {
        this.error_ = null;
        this.removeClass('vjs-error');
        if (this.errorDisplay) {
          this.errorDisplay.close();
        }
        return;
      }
      this.error_ = new MediaError(err);

      // add the vjs-error classname to the player
      this.addClass('vjs-error');

      // log the name of the error type and any message
      // IE11 logs "[object object]" and required you to expand message to see error object
      log.error(`(CODE:${this.error_.code} ${MediaError.errorTypes[this.error_.code]})`, this.error_.message, this.error_);

      /**
       * @event Player#error
       * @type {Event}
       */
      this.trigger('error');

      // notify hooks of the per player error
      hooks('error').forEach(hookFunction => hookFunction(this, this.error_));
      return;
    }

    /**
     * Report user activity
     *
     * @param {Object} event
     *        Event object
     */
    reportUserActivity(event) {
      this.userActivity_ = true;
    }

    /**
     * Get/set if user is active
     *
     * @fires Player#useractive
     * @fires Player#userinactive
     *
     * @param {boolean} [bool]
     *        - true if the user is active
     *        - false if the user is inactive
     *
     * @return {boolean|undefined}
     *         - The current value of userActive when getting
     *         - Nothing when setting
     */
    userActive(bool) {
      if (bool === undefined) {
        return this.userActive_;
      }
      bool = !!bool;
      if (bool === this.userActive_) {
        return;
      }
      this.userActive_ = bool;
      if (this.userActive_) {
        this.userActivity_ = true;
        this.removeClass('vjs-user-inactive');
        this.addClass('vjs-user-active');
        /**
         * @event Player#useractive
         * @type {Event}
         */
        this.trigger('useractive');
        return;
      }

      // Chrome/Safari/IE have bugs where when you change the cursor it can
      // trigger a mousemove event. This causes an issue when you're hiding
      // the cursor when the user is inactive, and a mousemove signals user
      // activity. Making it impossible to go into inactive mode. Specifically
      // this happens in fullscreen when we really need to hide the cursor.
      //
      // When this gets resolved in ALL browsers it can be removed
      // https://code.google.com/p/chromium/issues/detail?id=103041
      if (this.tech_) {
        this.tech_.one('mousemove', function (e) {
          e.stopPropagation();
          e.preventDefault();
        });
      }
      this.userActivity_ = false;
      this.removeClass('vjs-user-active');
      this.addClass('vjs-user-inactive');
      /**
       * @event Player#userinactive
       * @type {Event}
       */
      this.trigger('userinactive');
    }

    /**
     * Listen for user activity based on timeout value
     *
     * @private
     */
    listenForUserActivity_() {
      let mouseInProgress;
      let lastMoveX;
      let lastMoveY;
      const handleActivity = bind_(this, this.reportUserActivity);
      const handleMouseMove = function (e) {
        // #1068 - Prevent mousemove spamming
        // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
        if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
          lastMoveX = e.screenX;
          lastMoveY = e.screenY;
          handleActivity();
        }
      };
      const handleMouseDown = function () {
        handleActivity();
        // For as long as the they are touching the device or have their mouse down,
        // we consider them active even if they're not moving their finger or mouse.
        // So we want to continue to update that they are active
        this.clearInterval(mouseInProgress);
        // Setting userActivity=true now and setting the interval to the same time
        // as the activityCheck interval (250) should ensure we never miss the
        // next activityCheck
        mouseInProgress = this.setInterval(handleActivity, 250);
      };
      const handleMouseUpAndMouseLeave = function (event) {
        handleActivity();
        // Stop the interval that maintains activity if the mouse/touch is down
        this.clearInterval(mouseInProgress);
      };

      // Any mouse movement will be considered user activity
      this.on('mousedown', handleMouseDown);
      this.on('mousemove', handleMouseMove);
      this.on('mouseup', handleMouseUpAndMouseLeave);
      this.on('mouseleave', handleMouseUpAndMouseLeave);
      const controlBar = this.getChild('controlBar');

      // Fixes bug on Android & iOS where when tapping progressBar (when control bar is displayed)
      // controlBar would no longer be hidden by default timeout.
      if (controlBar && !IS_IOS && !IS_ANDROID) {
        controlBar.on('mouseenter', function (event) {
          if (this.player().options_.inactivityTimeout !== 0) {
            this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;
          }
          this.player().options_.inactivityTimeout = 0;
        });
        controlBar.on('mouseleave', function (event) {
          this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
        });
      }

      // Listen for keyboard navigation
      // Shouldn't need to use inProgress interval because of key repeat
      this.on('keydown', handleActivity);
      this.on('keyup', handleActivity);

      // Run an interval every 250 milliseconds instead of stuffing everything into
      // the mousemove/touchmove function itself, to prevent performance degradation.
      // `this.reportUserActivity` simply sets this.userActivity_ to true, which
      // then gets picked up by this loop
      // http://ejohn.org/blog/learning-from-twitter/
      let inactivityTimeout;

      /** @this Player */
      const activityCheck = function () {
        // Check to see if mouse/touch activity has happened
        if (!this.userActivity_) {
          return;
        }

        // Reset the activity tracker
        this.userActivity_ = false;

        // If the user state was inactive, set the state to active
        this.userActive(true);

        // Clear any existing inactivity timeout to start the timer over
        this.clearTimeout(inactivityTimeout);
        const timeout = this.options_.inactivityTimeout;
        if (timeout <= 0) {
          return;
        }

        // In <timeout> milliseconds, if no more activity has occurred the
        // user will be considered inactive
        inactivityTimeout = this.setTimeout(function () {
          // Protect against the case where the inactivityTimeout can trigger just
          // before the next user activity is picked up by the activity check loop
          // causing a flicker
          if (!this.userActivity_) {
            this.userActive(false);
          }
        }, timeout);
      };
      this.setInterval(activityCheck, 250);
    }

    /**
     * Gets or sets the current playback rate. A playback rate of
     * 1.0 represents normal speed and 0.5 would indicate half-speed
     * playback, for instance.
     *
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
     *
     * @param {number} [rate]
     *       New playback rate to set.
     *
     * @return {number|undefined}
     *         - The current playback rate when getting or 1.0
     *         - Nothing when setting
     */
    playbackRate(rate) {
      if (rate !== undefined) {
        // NOTE: this.cache_.lastPlaybackRate is set from the tech handler
        // that is registered above
        this.techCall_('setPlaybackRate', rate);
        return;
      }
      if (this.tech_ && this.tech_.featuresPlaybackRate) {
        return this.cache_.lastPlaybackRate || this.techGet_('playbackRate');
      }
      return 1.0;
    }

    /**
     * Gets or sets the current default playback rate. A default playback rate of
     * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.
     * defaultPlaybackRate will only represent what the initial playbackRate of a video was, not
     * not the current playbackRate.
     *
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate
     *
     * @param {number} [rate]
     *       New default playback rate to set.
     *
     * @return {number|undefined}
     *         - The default playback rate when getting or 1.0
     *         - Nothing when setting
     */
    defaultPlaybackRate(rate) {
      if (rate !== undefined) {
        return this.techCall_('setDefaultPlaybackRate', rate);
      }
      if (this.tech_ && this.tech_.featuresPlaybackRate) {
        return this.techGet_('defaultPlaybackRate');
      }
      return 1.0;
    }

    /**
     * Gets or sets the audio flag
     *
     * @param {boolean} [bool]
     *        - true signals that this is an audio player
     *        - false signals that this is not an audio player
     *
     * @return {boolean|undefined}
     *         - The current value of isAudio when getting
     *         - Nothing when setting
     */
    isAudio(bool) {
      if (bool !== undefined) {
        this.isAudio_ = !!bool;
        return;
      }
      return !!this.isAudio_;
    }
    updatePlayerHeightOnAudioOnlyMode_() {
      const controlBar = this.getChild('ControlBar');
      if (!controlBar || this.audioOnlyCache_.controlBarHeight === controlBar.currentHeight()) {
        return;
      }
      this.audioOnlyCache_.controlBarHeight = controlBar.currentHeight();
      this.height(this.audioOnlyCache_.controlBarHeight);
    }
    enableAudioOnlyUI_() {
      // Update styling immediately to show the control bar so we can get its height
      this.addClass('vjs-audio-only-mode');
      const playerChildren = this.children();
      const controlBar = this.getChild('ControlBar');
      const controlBarHeight = controlBar && controlBar.currentHeight();

      // Hide all player components except the control bar. Control bar components
      // needed only for video are hidden with CSS
      playerChildren.forEach(child => {
        if (child === controlBar) {
          return;
        }
        if (child.el_ && !child.hasClass('vjs-hidden')) {
          child.hide();
          this.audioOnlyCache_.hiddenChildren.push(child);
        }
      });
      this.audioOnlyCache_.playerHeight = this.currentHeight();
      this.audioOnlyCache_.controlBarHeight = controlBarHeight;
      this.on('playerresize', this.boundUpdatePlayerHeightOnAudioOnlyMode_);

      // Set the player height the same as the control bar
      this.height(controlBarHeight);
      this.trigger('audioonlymodechange');
    }
    disableAudioOnlyUI_() {
      this.removeClass('vjs-audio-only-mode');
      this.off('playerresize', this.boundUpdatePlayerHeightOnAudioOnlyMode_);

      // Show player components that were previously hidden
      this.audioOnlyCache_.hiddenChildren.forEach(child => child.show());

      // Reset player height
      this.height(this.audioOnlyCache_.playerHeight);
      this.trigger('audioonlymodechange');
    }

    /**
     * Get the current audioOnlyMode state or set audioOnlyMode to true or false.
     *
     * Setting this to `true` will hide all player components except the control bar,
     * as well as control bar components needed only for video.
     *
     * @param {boolean} [value]
     *         The value to set audioOnlyMode to.
     *
     * @return {Promise|boolean}
     *        A Promise is returned when setting the state, and a boolean when getting
     *        the present state
     */
    audioOnlyMode(value) {
      if (typeof value !== 'boolean' || value === this.audioOnlyMode_) {
        return this.audioOnlyMode_;
      }
      this.audioOnlyMode_ = value;

      // Enable Audio Only Mode
      if (value) {
        const exitPromises = [];

        // Fullscreen and PiP are not supported in audioOnlyMode, so exit if we need to.
        if (this.isInPictureInPicture()) {
          exitPromises.push(this.exitPictureInPicture());
        }
        if (this.isFullscreen()) {
          exitPromises.push(this.exitFullscreen());
        }
        if (this.audioPosterMode()) {
          exitPromises.push(this.audioPosterMode(false));
        }
        return Promise.all(exitPromises).then(() => this.enableAudioOnlyUI_());
      }

      // Disable Audio Only Mode
      return Promise.resolve().then(() => this.disableAudioOnlyUI_());
    }
    enablePosterModeUI_() {
      // Hide the video element and show the poster image to enable posterModeUI
      const tech = this.tech_ && this.tech_;
      tech.hide();
      this.addClass('vjs-audio-poster-mode');
      this.trigger('audiopostermodechange');
    }
    disablePosterModeUI_() {
      // Show the video element and hide the poster image to disable posterModeUI
      const tech = this.tech_ && this.tech_;
      tech.show();
      this.removeClass('vjs-audio-poster-mode');
      this.trigger('audiopostermodechange');
    }

    /**
     * Get the current audioPosterMode state or set audioPosterMode to true or false
     *
     * @param {boolean} [value]
     *         The value to set audioPosterMode to.
     *
     * @return {Promise|boolean}
     *         A Promise is returned when setting the state, and a boolean when getting
     *        the present state
     */
    audioPosterMode(value) {
      if (typeof value !== 'boolean' || value === this.audioPosterMode_) {
        return this.audioPosterMode_;
      }
      this.audioPosterMode_ = value;
      if (value) {
        if (this.audioOnlyMode()) {
          const audioOnlyModePromise = this.audioOnlyMode(false);
          return audioOnlyModePromise.then(() => {
            // enable audio poster mode after audio only mode is disabled
            this.enablePosterModeUI_();
          });
        }
        return Promise.resolve().then(() => {
          // enable audio poster mode
          this.enablePosterModeUI_();
        });
      }
      return Promise.resolve().then(() => {
        // disable audio poster mode
        this.disablePosterModeUI_();
      });
    }

    /**
     * A helper method for adding a {@link TextTrack} to our
     * {@link TextTrackList}.
     *
     * In addition to the W3C settings we allow adding additional info through options.
     *
     * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
     *
     * @param {string} [kind]
     *        the kind of TextTrack you are adding
     *
     * @param {string} [label]
     *        the label to give the TextTrack label
     *
     * @param {string} [language]
     *        the language to set on the TextTrack
     *
     * @return {TextTrack|undefined}
     *         the TextTrack that was added or undefined
     *         if there is no tech
     */
    addTextTrack(kind, label, language) {
      if (this.tech_) {
        return this.tech_.addTextTrack(kind, label, language);
      }
    }

    /**
     * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}.
     *
     * @param {Object} options
     *        Options to pass to {@link HTMLTrackElement} during creation. See
     *        {@link HTMLTrackElement} for object properties that you should use.
     *
     * @param {boolean} [manualCleanup=false] if set to true, the TextTrack will not be removed
     *                                        from the TextTrackList and HtmlTrackElementList
     *                                        after a source change
     *
     * @return {HtmlTrackElement}
     *         the HTMLTrackElement that was created and added
     *         to the HtmlTrackElementList and the remote
     *         TextTrackList
     *
     */
    addRemoteTextTrack(options, manualCleanup) {
      if (this.tech_) {
        return this.tech_.addRemoteTextTrack(options, manualCleanup);
      }
    }

    /**
     * Remove a remote {@link TextTrack} from the respective
     * {@link TextTrackList} and {@link HtmlTrackElementList}.
     *
     * @param {Object} track
     *        Remote {@link TextTrack} to remove
     *
     * @return {undefined}
     *         does not return anything
     */
    removeRemoteTextTrack(obj = {}) {
      let {
        track
      } = obj;
      if (!track) {
        track = obj;
      }

      // destructure the input into an object with a track argument, defaulting to arguments[0]
      // default the whole argument to an empty object if nothing was passed in

      if (this.tech_) {
        return this.tech_.removeRemoteTextTrack(track);
      }
    }

    /**
     * Gets available media playback quality metrics as specified by the W3C's Media
     * Playback Quality API.
     *
     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
     *
     * @return {Object|undefined}
     *         An object with supported media playback quality metrics or undefined if there
     *         is no tech or the tech does not support it.
     */
    getVideoPlaybackQuality() {
      return this.techGet_('getVideoPlaybackQuality');
    }

    /**
     * Get video width
     *
     * @return {number}
     *         current video width
     */
    videoWidth() {
      return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
    }

    /**
     * Get video height
     *
     * @return {number}
     *         current video height
     */
    videoHeight() {
      return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
    }

    /**
     * Set or get the player's language code.
     *
     * Changing the language will trigger
     * [languagechange]{@link Player#event:languagechange}
     * which Components can use to update control text.
     * ClickableComponent will update its control text by default on
     * [languagechange]{@link Player#event:languagechange}.
     *
     * @fires Player#languagechange
     *
     * @param {string} [code]
     *        the language code to set the player to
     *
     * @return {string|undefined}
     *         - The current language code when getting
     *         - Nothing when setting
     */
    language(code) {
      if (code === undefined) {
        return this.language_;
      }
      if (this.language_ !== String(code).toLowerCase()) {
        this.language_ = String(code).toLowerCase();

        // during first init, it's possible some things won't be evented
        if (isEvented(this)) {
          /**
          * fires when the player language change
          *
          * @event Player#languagechange
          * @type {Event}
          */
          this.trigger('languagechange');
        }
      }
    }

    /**
     * Get the player's language dictionary
     * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time
     * Languages specified directly in the player options have precedence
     *
     * @return {Array}
     *         An array of of supported languages
     */
    languages() {
      return merge(Player.prototype.options_.languages, this.languages_);
    }

    /**
     * returns a JavaScript object representing the current track
     * information. **DOES not return it as JSON**
     *
     * @return {Object}
     *         Object representing the current of track info
     */
    toJSON() {
      const options = merge(this.options_);
      const tracks = options.tracks;
      options.tracks = [];
      for (let i = 0; i < tracks.length; i++) {
        let track = tracks[i];

        // deep merge tracks and null out player so no circular references
        track = merge(track);
        track.player = undefined;
        options.tracks[i] = track;
      }
      return options;
    }

    /**
     * Creates a simple modal dialog (an instance of the {@link ModalDialog}
     * component) that immediately overlays the player with arbitrary
     * content and removes itself when closed.
     *
     * @param {string|Function|Element|Array|null} content
     *        Same as {@link ModalDialog#content}'s param of the same name.
     *        The most straight-forward usage is to provide a string or DOM
     *        element.
     *
     * @param {Object} [options]
     *        Extra options which will be passed on to the {@link ModalDialog}.
     *
     * @return {ModalDialog}
     *         the {@link ModalDialog} that was created
     */
    createModal(content, options) {
      options = options || {};
      options.content = content || '';
      const modal = new ModalDialog(this, options);
      this.addChild(modal);
      modal.on('dispose', () => {
        this.removeChild(modal);
      });
      modal.open();
      return modal;
    }

    /**
     * Change breakpoint classes when the player resizes.
     *
     * @private
     */
    updateCurrentBreakpoint_() {
      if (!this.responsive()) {
        return;
      }
      const currentBreakpoint = this.currentBreakpoint();
      const currentWidth = this.currentWidth();
      for (let i = 0; i < BREAKPOINT_ORDER.length; i++) {
        const candidateBreakpoint = BREAKPOINT_ORDER[i];
        const maxWidth = this.breakpoints_[candidateBreakpoint];
        if (currentWidth <= maxWidth) {
          // The current breakpoint did not change, nothing to do.
          if (currentBreakpoint === candidateBreakpoint) {
            return;
          }

          // Only remove a class if there is a current breakpoint.
          if (currentBreakpoint) {
            this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);
          }
          this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);
          this.breakpoint_ = candidateBreakpoint;
          break;
        }
      }
    }

    /**
     * Removes the current breakpoint.
     *
     * @private
     */
    removeCurrentBreakpoint_() {
      const className = this.currentBreakpointClass();
      this.breakpoint_ = '';
      if (className) {
        this.removeClass(className);
      }
    }

    /**
     * Get or set breakpoints on the player.
     *
     * Calling this method with an object or `true` will remove any previous
     * custom breakpoints and start from the defaults again.
     *
     * @param  {Object|boolean} [breakpoints]
     *         If an object is given, it can be used to provide custom
     *         breakpoints. If `true` is given, will set default breakpoints.
     *         If this argument is not given, will simply return the current
     *         breakpoints.
     *
     * @param  {number} [breakpoints.tiny]
     *         The maximum width for the "vjs-layout-tiny" class.
     *
     * @param  {number} [breakpoints.xsmall]
     *         The maximum width for the "vjs-layout-x-small" class.
     *
     * @param  {number} [breakpoints.small]
     *         The maximum width for the "vjs-layout-small" class.
     *
     * @param  {number} [breakpoints.medium]
     *         The maximum width for the "vjs-layout-medium" class.
     *
     * @param  {number} [breakpoints.large]
     *         The maximum width for the "vjs-layout-large" class.
     *
     * @param  {number} [breakpoints.xlarge]
     *         The maximum width for the "vjs-layout-x-large" class.
     *
     * @param  {number} [breakpoints.huge]
     *         The maximum width for the "vjs-layout-huge" class.
     *
     * @return {Object}
     *         An object mapping breakpoint names to maximum width values.
     */
    breakpoints(breakpoints) {
      // Used as a getter.
      if (breakpoints === undefined) {
        return Object.assign(this.breakpoints_);
      }
      this.breakpoint_ = '';
      this.breakpoints_ = Object.assign({}, DEFAULT_BREAKPOINTS, breakpoints);

      // When breakpoint definitions change, we need to update the currently
      // selected breakpoint.
      this.updateCurrentBreakpoint_();

      // Clone the breakpoints before returning.
      return Object.assign(this.breakpoints_);
    }

    /**
     * Get or set a flag indicating whether or not this player should adjust
     * its UI based on its dimensions.
     *
     * @param  {boolean} [value]
     *         Should be `true` if the player should adjust its UI based on its
     *         dimensions; otherwise, should be `false`.
     *
     * @return {boolean|undefined}
     *         Will be `true` if this player should adjust its UI based on its
     *         dimensions; otherwise, will be `false`.
     *         Nothing if setting
     */
    responsive(value) {
      // Used as a getter.
      if (value === undefined) {
        return this.responsive_;
      }
      value = Boolean(value);
      const current = this.responsive_;

      // Nothing changed.
      if (value === current) {
        return;
      }

      // The value actually changed, set it.
      this.responsive_ = value;

      // Start listening for breakpoints and set the initial breakpoint if the
      // player is now responsive.
      if (value) {
        this.on('playerresize', this.boundUpdateCurrentBreakpoint_);
        this.updateCurrentBreakpoint_();

        // Stop listening for breakpoints if the player is no longer responsive.
      } else {
        this.off('playerresize', this.boundUpdateCurrentBreakpoint_);
        this.removeCurrentBreakpoint_();
      }
      return value;
    }

    /**
     * Get current breakpoint name, if any.
     *
     * @return {string}
     *         If there is currently a breakpoint set, returns a the key from the
     *         breakpoints object matching it. Otherwise, returns an empty string.
     */
    currentBreakpoint() {
      return this.breakpoint_;
    }

    /**
     * Get the current breakpoint class name.
     *
     * @return {string}
     *         The matching class name (e.g. `"vjs-layout-tiny"` or
     *         `"vjs-layout-large"`) for the current breakpoint. Empty string if
     *         there is no current breakpoint.
     */
    currentBreakpointClass() {
      return BREAKPOINT_CLASSES[this.breakpoint_] || '';
    }

    /**
     * An object that describes a single piece of media.
     *
     * Properties that are not part of this type description will be retained; so,
     * this can be viewed as a generic metadata storage mechanism as well.
     *
     * @see      {@link https://wicg.github.io/mediasession/#the-mediametadata-interface}
     * @typedef  {Object} Player~MediaObject
     *
     * @property {string} [album]
     *           Unused, except if this object is passed to the `MediaSession`
     *           API.
     *
     * @property {string} [artist]
     *           Unused, except if this object is passed to the `MediaSession`
     *           API.
     *
     * @property {Object[]} [artwork]
     *           Unused, except if this object is passed to the `MediaSession`
     *           API. If not specified, will be populated via the `poster`, if
     *           available.
     *
     * @property {string} [poster]
     *           URL to an image that will display before playback.
     *
     * @property {Tech~SourceObject|Tech~SourceObject[]|string} [src]
     *           A single source object, an array of source objects, or a string
     *           referencing a URL to a media source. It is _highly recommended_
     *           that an object or array of objects is used here, so that source
     *           selection algorithms can take the `type` into account.
     *
     * @property {string} [title]
     *           Unused, except if this object is passed to the `MediaSession`
     *           API.
     *
     * @property {Object[]} [textTracks]
     *           An array of objects to be used to create text tracks, following
     *           the {@link https://www.w3.org/TR/html50/embedded-content-0.html#the-track-element|native track element format}.
     *           For ease of removal, these will be created as "remote" text
     *           tracks and set to automatically clean up on source changes.
     *
     *           These objects may have properties like `src`, `kind`, `label`,
     *           and `language`, see {@link Tech#createRemoteTextTrack}.
     */

    /**
     * Populate the player using a {@link Player~MediaObject|MediaObject}.
     *
     * @param  {Player~MediaObject} media
     *         A media object.
     *
     * @param  {Function} ready
     *         A callback to be called when the player is ready.
     */
    loadMedia(media, ready) {
      if (!media || typeof media !== 'object') {
        return;
      }
      const crossOrigin = this.crossOrigin();
      this.reset();

      // Clone the media object so it cannot be mutated from outside.
      this.cache_.media = merge(media);
      const {
        artist,
        artwork,
        description,
        poster,
        src,
        textTracks,
        title
      } = this.cache_.media;

      // If `artwork` is not given, create it using `poster`.
      if (!artwork && poster) {
        this.cache_.media.artwork = [{
          src: poster,
          type: getMimetype(poster)
        }];
      }
      if (crossOrigin) {
        this.crossOrigin(crossOrigin);
      }
      if (src) {
        this.src(src);
      }
      if (poster) {
        this.poster(poster);
      }
      if (Array.isArray(textTracks)) {
        textTracks.forEach(tt => this.addRemoteTextTrack(tt, false));
      }
      if (this.titleBar) {
        this.titleBar.update({
          title,
          description: description || artist || ''
        });
      }
      this.ready(ready);
    }

    /**
     * Get a clone of the current {@link Player~MediaObject} for this player.
     *
     * If the `loadMedia` method has not been used, will attempt to return a
     * {@link Player~MediaObject} based on the current state of the player.
     *
     * @return {Player~MediaObject}
     */
    getMedia() {
      if (!this.cache_.media) {
        const poster = this.poster();
        const src = this.currentSources();
        const textTracks = Array.prototype.map.call(this.remoteTextTracks(), tt => ({
          kind: tt.kind,
          label: tt.label,
          language: tt.language,
          src: tt.src
        }));
        const media = {
          src,
          textTracks
        };
        if (poster) {
          media.poster = poster;
          media.artwork = [{
            src: media.poster,
            type: getMimetype(media.poster)
          }];
        }
        return media;
      }
      return merge(this.cache_.media);
    }

    /**
     * Gets tag settings
     *
     * @param {Element} tag
     *        The player tag
     *
     * @return {Object}
     *         An object containing all of the settings
     *         for a player tag
     */
    static getTagSettings(tag) {
      const baseOptions = {
        sources: [],
        tracks: []
      };
      const tagOptions = getAttributes(tag);
      const dataSetup = tagOptions['data-setup'];
      if (hasClass(tag, 'vjs-fill')) {
        tagOptions.fill = true;
      }
      if (hasClass(tag, 'vjs-fluid')) {
        tagOptions.fluid = true;
      }

      // Check if data-setup attr exists.
      if (dataSetup !== null) {
        // Parse options JSON
        try {
          // If empty string, make it a parsable json object.
          Object.assign(tagOptions, JSON.parse(dataSetup || '{}'));
        } catch (e) {
          log.error('data-setup', e);
        }
      }
      Object.assign(baseOptions, tagOptions);

      // Get tag children settings
      if (tag.hasChildNodes()) {
        const children = tag.childNodes;
        for (let i = 0, j = children.length; i < j; i++) {
          const child = children[i];
          // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
          const childName = child.nodeName.toLowerCase();
          if (childName === 'source') {
            baseOptions.sources.push(getAttributes(child));
          } else if (childName === 'track') {
            baseOptions.tracks.push(getAttributes(child));
          }
        }
      }
      return baseOptions;
    }

    /**
     * Set debug mode to enable/disable logs at info level.
     *
     * @param {boolean} enabled
     * @fires Player#debugon
     * @fires Player#debugoff
     * @return {boolean|undefined}
     */
    debug(enabled) {
      if (enabled === undefined) {
        return this.debugEnabled_;
      }
      if (enabled) {
        this.trigger('debugon');
        this.previousLogLevel_ = this.log.level;
        this.log.level('debug');
        this.debugEnabled_ = true;
      } else {
        this.trigger('debugoff');
        this.log.level(this.previousLogLevel_);
        this.previousLogLevel_ = undefined;
        this.debugEnabled_ = false;
      }
    }

    /**
     * Set or get current playback rates.
     * Takes an array and updates the playback rates menu with the new items.
     * Pass in an empty array to hide the menu.
     * Values other than arrays are ignored.
     *
     * @fires Player#playbackrateschange
     * @param {number[]} [newRates]
     *                   The new rates that the playback rates menu should update to.
     *                   An empty array will hide the menu
     * @return {number[]} When used as a getter will return the current playback rates
     */
    playbackRates(newRates) {
      if (newRates === undefined) {
        return this.cache_.playbackRates;
      }

      // ignore any value that isn't an array
      if (!Array.isArray(newRates)) {
        return;
      }

      // ignore any arrays that don't only contain numbers
      if (!newRates.every(rate => typeof rate === 'number')) {
        return;
      }
      this.cache_.playbackRates = newRates;

      /**
      * fires when the playback rates in a player are changed
      *
      * @event Player#playbackrateschange
      * @type {Event}
      */
      this.trigger('playbackrateschange');
    }

    /**
     * Reports whether or not a player has a plugin available.
     *
     * This does not report whether or not the plugin has ever been initialized
     * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.
     *
     * @method hasPlugin
     * @param  {string}  name
     *         The name of a plugin.
     *
     * @return {boolean}
     *         Whether or not this player has the requested plugin available.
     */

    /**
     * Reports whether or not a player is using a plugin by name.
     *
     * For basic plugins, this only reports whether the plugin has _ever_ been
     * initialized on this player.
     *
     * @method Player#usingPlugin
     * @param  {string} name
     *         The name of a plugin.
     *
     * @return {boolean}
     *         Whether or not this player is using the requested plugin.
     */
  }

  /**
   * Get the {@link VideoTrackList}
   *
   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist
   *
   * @return {VideoTrackList}
   *         the current video track list
   *
   * @method Player.prototype.videoTracks
   */

  /**
   * Get the {@link AudioTrackList}
   *
   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist
   *
   * @return {AudioTrackList}
   *         the current audio track list
   *
   * @method Player.prototype.audioTracks
   */

  /**
   * Get the {@link TextTrackList}
   *
   * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
   *
   * @return {TextTrackList}
   *         the current text track list
   *
   * @method Player.prototype.textTracks
   */

  /**
   * Get the remote {@link TextTrackList}
   *
   * @return {TextTrackList}
   *         The current remote text track list
   *
   * @method Player.prototype.remoteTextTracks
   */

  /**
   * Get the remote {@link HtmlTrackElementList} tracks.
   *
   * @return {HtmlTrackElementList}
   *         The current remote text track element list
   *
   * @method Player.prototype.remoteTextTrackEls
   */

  ALL.names.forEach(function (name) {
    const props = ALL[name];
    Player.prototype[props.getterName] = function () {
      if (this.tech_) {
        return this.tech_[props.getterName]();
      }

      // if we have not yet loadTech_, we create {video,audio,text}Tracks_
      // these will be passed to the tech during loading
      this[props.privateName] = this[props.privateName] || new props.ListClass();
      return this[props.privateName];
    };
  });

  /**
   * Get or set the `Player`'s crossorigin option. For the HTML5 player, this
   * sets the `crossOrigin` property on the `<video>` tag to control the CORS
   * behavior.
   *
   * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}
   *
   * @param {string} [value]
   *        The value to set the `Player`'s crossorigin to. If an argument is
   *        given, must be one of `anonymous` or `use-credentials`.
   *
   * @return {string|undefined}
   *         - The current crossorigin value of the `Player` when getting.
   *         - undefined when setting
   */
  Player.prototype.crossorigin = Player.prototype.crossOrigin;

  /**
   * Global enumeration of players.
   *
   * The keys are the player IDs and the values are either the {@link Player}
   * instance or `null` for disposed players.
   *
   * @type {Object}
   */
  Player.players = {};
  const navigator$1 = window__default["default"].navigator;

  /*
   * Player instance options, surfaced using options
   * options = Player.prototype.options_
   * Make changes in options, not here.
   *
   * @type {Object}
   * @private
   */
  Player.prototype.options_ = {
    // Default order of fallback technology
    techOrder: Tech.defaultTechOrder_,
    html5: {},
    // enable sourceset by default
    enableSourceset: true,
    // default inactivity timeout
    inactivityTimeout: 2000,
    // default playback rates
    playbackRates: [],
    // Add playback rate selection by adding rates
    // 'playbackRates': [0.5, 1, 1.5, 2],
    liveui: false,
    // Included control sets
    children: ['mediaLoader', 'posterImage', 'titleBar', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'liveTracker', 'controlBar', 'errorDisplay', 'textTrackSettings', 'resizeManager'],
    language: navigator$1 && (navigator$1.languages && navigator$1.languages[0] || navigator$1.userLanguage || navigator$1.language) || 'en',
    // locales and their language translations
    languages: {},
    // Default message to show when a video cannot be played.
    notSupportedMessage: 'No compatible source was found for this media.',
    normalizeAutoplay: false,
    fullscreen: {
      options: {
        navigationUI: 'hide'
      }
    },
    breakpoints: {},
    responsive: false,
    audioOnlyMode: false,
    audioPosterMode: false,
    spatialNavigation: {
      enabled: false,
      horizontalSeek: false
    },
    // Default smooth seeking to false
    enableSmoothSeeking: false
  };
  TECH_EVENTS_RETRIGGER.forEach(function (event) {
    Player.prototype[`handleTech${toTitleCase(event)}_`] = function () {
      return this.trigger(event);
    };
  });

  /**
   * Fired when the player has initial duration and dimension information
   *
   * @event Player#loadedmetadata
   * @type {Event}
   */

  /**
   * Fired when the player has downloaded data at the current playback position
   *
   * @event Player#loadeddata
   * @type {Event}
   */

  /**
   * Fired when the current playback position has changed *
   * During playback this is fired every 15-250 milliseconds, depending on the
   * playback technology in use.
   *
   * @event Player#timeupdate
   * @type {Event}
   */

  /**
   * Fired when the volume changes
   *
   * @event Player#volumechange
   * @type {Event}
   */

  Component.registerComponent('Player', Player);

  /**
   * @file plugin.js
   */

  /**
   * The base plugin name.
   *
   * @private
   * @constant
   * @type {string}
   */
  const BASE_PLUGIN_NAME = 'plugin';

  /**
   * The key on which a player's active plugins cache is stored.
   *
   * @private
   * @constant
   * @type     {string}
   */
  const PLUGIN_CACHE_KEY = 'activePlugins_';

  /**
   * Stores registered plugins in a private space.
   *
   * @private
   * @type    {Object}
   */
  const pluginStorage = {};

  /**
   * Reports whether or not a plugin has been registered.
   *
   * @private
   * @param   {string} name
   *          The name of a plugin.
   *
   * @return {boolean}
   *          Whether or not the plugin has been registered.
   */
  const pluginExists = name => pluginStorage.hasOwnProperty(name);

  /**
   * Get a single registered plugin by name.
   *
   * @private
   * @param   {string} name
   *          The name of a plugin.
   *
   * @return {typeof Plugin|Function|undefined}
   *          The plugin (or undefined).
   */
  const getPlugin = name => pluginExists(name) ? pluginStorage[name] : undefined;

  /**
   * Marks a plugin as "active" on a player.
   *
   * Also, ensures that the player has an object for tracking active plugins.
   *
   * @private
   * @param   {Player} player
   *          A Video.js player instance.
   *
   * @param   {string} name
   *          The name of a plugin.
   */
  const markPluginAsActive = (player, name) => {
    player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
    player[PLUGIN_CACHE_KEY][name] = true;
  };

  /**
   * Triggers a pair of plugin setup events.
   *
   * @private
   * @param  {Player} player
   *         A Video.js player instance.
   *
   * @param  {PluginEventHash} hash
   *         A plugin event hash.
   *
   * @param  {boolean} [before]
   *         If true, prefixes the event name with "before". In other words,
   *         use this to trigger "beforepluginsetup" instead of "pluginsetup".
   */
  const triggerSetupEvent = (player, hash, before) => {
    const eventName = (before ? 'before' : '') + 'pluginsetup';
    player.trigger(eventName, hash);
    player.trigger(eventName + ':' + hash.name, hash);
  };

  /**
   * Takes a basic plugin function and returns a wrapper function which marks
   * on the player that the plugin has been activated.
   *
   * @private
   * @param   {string} name
   *          The name of the plugin.
   *
   * @param   {Function} plugin
   *          The basic plugin.
   *
   * @return {Function}
   *          A wrapper function for the given plugin.
   */
  const createBasicPlugin = function (name, plugin) {
    const basicPluginWrapper = function () {
      // We trigger the "beforepluginsetup" and "pluginsetup" events on the player
      // regardless, but we want the hash to be consistent with the hash provided
      // for advanced plugins.
      //
      // The only potentially counter-intuitive thing here is the `instance` in
      // the "pluginsetup" event is the value returned by the `plugin` function.
      triggerSetupEvent(this, {
        name,
        plugin,
        instance: null
      }, true);
      const instance = plugin.apply(this, arguments);
      markPluginAsActive(this, name);
      triggerSetupEvent(this, {
        name,
        plugin,
        instance
      });
      return instance;
    };
    Object.keys(plugin).forEach(function (prop) {
      basicPluginWrapper[prop] = plugin[prop];
    });
    return basicPluginWrapper;
  };

  /**
   * Takes a plugin sub-class and returns a factory function for generating
   * instances of it.
   *
   * This factory function will replace itself with an instance of the requested
   * sub-class of Plugin.
   *
   * @private
   * @param   {string} name
   *          The name of the plugin.
   *
   * @param   {Plugin} PluginSubClass
   *          The advanced plugin.
   *
   * @return {Function}
   */
  const createPluginFactory = (name, PluginSubClass) => {
    // Add a `name` property to the plugin prototype so that each plugin can
    // refer to itself by name.
    PluginSubClass.prototype.name = name;
    return function (...args) {
      triggerSetupEvent(this, {
        name,
        plugin: PluginSubClass,
        instance: null
      }, true);
      const instance = new PluginSubClass(...[this, ...args]);

      // The plugin is replaced by a function that returns the current instance.
      this[name] = () => instance;
      triggerSetupEvent(this, instance.getEventHash());
      return instance;
    };
  };

  /**
   * Parent class for all advanced plugins.
   *
   * @mixes   module:evented~EventedMixin
   * @mixes   module:stateful~StatefulMixin
   * @fires   Player#beforepluginsetup
   * @fires   Player#beforepluginsetup:$name
   * @fires   Player#pluginsetup
   * @fires   Player#pluginsetup:$name
   * @listens Player#dispose
   * @throws  {Error}
   *          If attempting to instantiate the base {@link Plugin} class
   *          directly instead of via a sub-class.
   */
  class Plugin {
    /**
     * Creates an instance of this class.
     *
     * Sub-classes should call `super` to ensure plugins are properly initialized.
     *
     * @param {Player} player
     *        A Video.js player instance.
     */
    constructor(player) {
      if (this.constructor === Plugin) {
        throw new Error('Plugin must be sub-classed; not directly instantiated.');
      }
      this.player = player;
      if (!this.log) {
        this.log = this.player.log.createLogger(this.name);
      }

      // Make this object evented, but remove the added `trigger` method so we
      // use the prototype version instead.
      evented(this);
      delete this.trigger;
      stateful(this, this.constructor.defaultState);
      markPluginAsActive(player, this.name);

      // Auto-bind the dispose method so we can use it as a listener and unbind
      // it later easily.
      this.dispose = this.dispose.bind(this);

      // If the player is disposed, dispose the plugin.
      player.on('dispose', this.dispose);
    }

    /**
     * Get the version of the plugin that was set on <pluginName>.VERSION
     */
    version() {
      return this.constructor.VERSION;
    }

    /**
     * Each event triggered by plugins includes a hash of additional data with
     * conventional properties.
     *
     * This returns that object or mutates an existing hash.
     *
     * @param   {Object} [hash={}]
     *          An object to be used as event an event hash.
     *
     * @return {PluginEventHash}
     *          An event hash object with provided properties mixed-in.
     */
    getEventHash(hash = {}) {
      hash.name = this.name;
      hash.plugin = this.constructor;
      hash.instance = this;
      return hash;
    }

    /**
     * Triggers an event on the plugin object and overrides
     * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.
     *
     * @param   {string|Object} event
     *          An event type or an object with a type property.
     *
     * @param   {Object} [hash={}]
     *          Additional data hash to merge with a
     *          {@link PluginEventHash|PluginEventHash}.
     *
     * @return {boolean}
     *          Whether or not default was prevented.
     */
    trigger(event, hash = {}) {
      return trigger(this.eventBusEl_, event, this.getEventHash(hash));
    }

    /**
     * Handles "statechanged" events on the plugin. No-op by default, override by
     * subclassing.
     *
     * @abstract
     * @param    {Event} e
     *           An event object provided by a "statechanged" event.
     *
     * @param    {Object} e.changes
     *           An object describing changes that occurred with the "statechanged"
     *           event.
     */
    handleStateChanged(e) {}

    /**
     * Disposes a plugin.
     *
     * Subclasses can override this if they want, but for the sake of safety,
     * it's probably best to subscribe the "dispose" event.
     *
     * @fires Plugin#dispose
     */
    dispose() {
      const {
        name,
        player
      } = this;

      /**
       * Signals that a advanced plugin is about to be disposed.
       *
       * @event Plugin#dispose
       * @type  {Event}
       */
      this.trigger('dispose');
      this.off();
      player.off('dispose', this.dispose);

      // Eliminate any possible sources of leaking memory by clearing up
      // references between the player and the plugin instance and nulling out
      // the plugin's state and replacing methods with a function that throws.
      player[PLUGIN_CACHE_KEY][name] = false;
      this.player = this.state = null;

      // Finally, replace the plugin name on the player with a new factory
      // function, so that the plugin is ready to be set up again.
      player[name] = createPluginFactory(name, pluginStorage[name]);
    }

    /**
     * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).
     *
     * @param   {string|Function} plugin
     *          If a string, matches the name of a plugin. If a function, will be
     *          tested directly.
     *
     * @return {boolean}
     *          Whether or not a plugin is a basic plugin.
     */
    static isBasic(plugin) {
      const p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;
      return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);
    }

    /**
     * Register a Video.js plugin.
     *
     * @param   {string} name
     *          The name of the plugin to be registered. Must be a string and
     *          must not match an existing plugin or a method on the `Player`
     *          prototype.
     *
     * @param   {typeof Plugin|Function} plugin
     *          A sub-class of `Plugin` or a function for basic plugins.
     *
     * @return {typeof Plugin|Function}
     *          For advanced plugins, a factory function for that plugin. For
     *          basic plugins, a wrapper function that initializes the plugin.
     */
    static registerPlugin(name, plugin) {
      if (typeof name !== 'string') {
        throw new Error(`Illegal plugin name, "${name}", must be a string, was ${typeof name}.`);
      }
      if (pluginExists(name)) {
        log.warn(`A plugin named "${name}" already exists. You may want to avoid re-registering plugins!`);
      } else if (Player.prototype.hasOwnProperty(name)) {
        throw new Error(`Illegal plugin name, "${name}", cannot share a name with an existing player method!`);
      }
      if (typeof plugin !== 'function') {
        throw new Error(`Illegal plugin for "${name}", must be a function, was ${typeof plugin}.`);
      }
      pluginStorage[name] = plugin;

      // Add a player prototype method for all sub-classed plugins (but not for
      // the base Plugin class).
      if (name !== BASE_PLUGIN_NAME) {
        if (Plugin.isBasic(plugin)) {
          Player.prototype[name] = createBasicPlugin(name, plugin);
        } else {
          Player.prototype[name] = createPluginFactory(name, plugin);
        }
      }
      return plugin;
    }

    /**
     * De-register a Video.js plugin.
     *
     * @param  {string} name
     *         The name of the plugin to be de-registered. Must be a string that
     *         matches an existing plugin.
     *
     * @throws {Error}
     *         If an attempt is made to de-register the base plugin.
     */
    static deregisterPlugin(name) {
      if (name === BASE_PLUGIN_NAME) {
        throw new Error('Cannot de-register base plugin.');
      }
      if (pluginExists(name)) {
        delete pluginStorage[name];
        delete Player.prototype[name];
      }
    }

    /**
     * Gets an object containing multiple Video.js plugins.
     *
     * @param   {Array} [names]
     *          If provided, should be an array of plugin names. Defaults to _all_
     *          plugin names.
     *
     * @return {Object|undefined}
     *          An object containing plugin(s) associated with their name(s) or
     *          `undefined` if no matching plugins exist).
     */
    static getPlugins(names = Object.keys(pluginStorage)) {
      let result;
      names.forEach(name => {
        const plugin = getPlugin(name);
        if (plugin) {
          result = result || {};
          result[name] = plugin;
        }
      });
      return result;
    }

    /**
     * Gets a plugin's version, if available
     *
     * @param   {string} name
     *          The name of a plugin.
     *
     * @return {string}
     *          The plugin's version or an empty string.
     */
    static getPluginVersion(name) {
      const plugin = getPlugin(name);
      return plugin && plugin.VERSION || '';
    }
  }

  /**
   * Gets a plugin by name if it exists.
   *
   * @static
   * @method   getPlugin
   * @memberOf Plugin
   * @param    {string} name
   *           The name of a plugin.
   *
   * @returns  {typeof Plugin|Function|undefined}
   *           The plugin (or `undefined`).
   */
  Plugin.getPlugin = getPlugin;

  /**
   * The name of the base plugin class as it is registered.
   *
   * @type {string}
   */
  Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;
  Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);

  /**
   * Documented in player.js
   *
   * @ignore
   */
  Player.prototype.usingPlugin = function (name) {
    return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
  };

  /**
   * Documented in player.js
   *
   * @ignore
   */
  Player.prototype.hasPlugin = function (name) {
    return !!pluginExists(name);
  };

  /**
   * Signals that a plugin is about to be set up on a player.
   *
   * @event    Player#beforepluginsetup
   * @type     {PluginEventHash}
   */

  /**
   * Signals that a plugin is about to be set up on a player - by name. The name
   * is the name of the plugin.
   *
   * @event    Player#beforepluginsetup:$name
   * @type     {PluginEventHash}
   */

  /**
   * Signals that a plugin has just been set up on a player.
   *
   * @event    Player#pluginsetup
   * @type     {PluginEventHash}
   */

  /**
   * Signals that a plugin has just been set up on a player - by name. The name
   * is the name of the plugin.
   *
   * @event    Player#pluginsetup:$name
   * @type     {PluginEventHash}
   */

  /**
   * @typedef  {Object} PluginEventHash
   *
   * @property {string} instance
   *           For basic plugins, the return value of the plugin function. For
   *           advanced plugins, the plugin instance on which the event is fired.
   *
   * @property {string} name
   *           The name of the plugin.
   *
   * @property {string} plugin
   *           For basic plugins, the plugin function. For advanced plugins, the
   *           plugin class/constructor.
   */

  /**
   * @file deprecate.js
   * @module deprecate
   */

  /**
   * Decorate a function with a deprecation message the first time it is called.
   *
   * @param  {string}   message
   *         A deprecation message to log the first time the returned function
   *         is called.
   *
   * @param  {Function} fn
   *         The function to be deprecated.
   *
   * @return {Function}
   *         A wrapper function that will log a deprecation warning the first
   *         time it is called. The return value will be the return value of
   *         the wrapped function.
   */
  function deprecate(message, fn) {
    let warned = false;
    return function (...args) {
      if (!warned) {
        log.warn(message);
      }
      warned = true;
      return fn.apply(this, args);
    };
  }

  /**
   * Internal function used to mark a function as deprecated in the next major
   * version with consistent messaging.
   *
   * @param  {number}   major   The major version where it will be removed
   * @param  {string}   oldName The old function name
   * @param  {string}   newName The new function name
   * @param  {Function} fn      The function to deprecate
   * @return {Function}         The decorated function
   */
  function deprecateForMajor(major, oldName, newName, fn) {
    return deprecate(`${oldName} is deprecated and will be removed in ${major}.0; please use ${newName} instead.`, fn);
  }

  var VjsErrors = {
    NetworkBadStatus: 'networkbadstatus',
    NetworkRequestFailed: 'networkrequestfailed',
    NetworkRequestAborted: 'networkrequestaborted',
    NetworkRequestTimeout: 'networkrequesttimeout',
    NetworkBodyParserFailed: 'networkbodyparserfailed',
    StreamingHlsPlaylistParserError: 'streaminghlsplaylistparsererror',
    StreamingDashManifestParserError: 'streamingdashmanifestparsererror',
    StreamingContentSteeringParserError: 'streamingcontentsteeringparsererror',
    StreamingVttParserError: 'streamingvttparsererror',
    StreamingFailedToSelectNextSegment: 'streamingfailedtoselectnextsegment',
    StreamingFailedToDecryptSegment: 'streamingfailedtodecryptsegment',
    StreamingFailedToTransmuxSegment: 'streamingfailedtotransmuxsegment',
    StreamingFailedToAppendSegment: 'streamingfailedtoappendsegment',
    StreamingCodecsChangeError: 'streamingcodecschangeerror'
  };

  /**
   * @file video.js
   * @module videojs
   */

  /** @import { PlayerReadyCallback } from './player' */

  /**
   * Normalize an `id` value by trimming off a leading `#`
   *
   * @private
   * @param   {string} id
   *          A string, maybe with a leading `#`.
   *
   * @return {string}
   *          The string, without any leading `#`.
   */
  const normalizeId = id => id.indexOf('#') === 0 ? id.slice(1) : id;

  /**
   * The `videojs()` function doubles as the main function for users to create a
   * {@link Player} instance as well as the main library namespace.
   *
   * It can also be used as a getter for a pre-existing {@link Player} instance.
   * However, we _strongly_ recommend using `videojs.getPlayer()` for this
   * purpose because it avoids any potential for unintended initialization.
   *
   * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)
   * of our JSDoc template, we cannot properly document this as both a function
   * and a namespace, so its function signature is documented here.
   *
   * #### Arguments
   * ##### id
   * string|Element, **required**
   *
   * Video element or video element ID.
   *
   * ##### options
   * Object, optional
   *
   * Options object for providing settings.
   * See: [Options Guide](https://docs.videojs.com/tutorial-options.html).
   *
   * ##### ready
   * {@link Component~ReadyCallback}, optional
   *
   * A function to be called when the {@link Player} and {@link Tech} are ready.
   *
   * #### Return Value
   *
   * The `videojs()` function returns a {@link Player} instance.
   *
   * @namespace
   *
   * @borrows AudioTrack as AudioTrack
   * @borrows Component.getComponent as getComponent
   * @borrows module:events.on as on
   * @borrows module:events.one as one
   * @borrows module:events.off as off
   * @borrows module:events.trigger as trigger
   * @borrows EventTarget as EventTarget
   * @borrows module:middleware.use as use
   * @borrows Player.players as players
   * @borrows Plugin.registerPlugin as registerPlugin
   * @borrows Plugin.deregisterPlugin as deregisterPlugin
   * @borrows Plugin.getPlugins as getPlugins
   * @borrows Plugin.getPlugin as getPlugin
   * @borrows Plugin.getPluginVersion as getPluginVersion
   * @borrows Tech.getTech as getTech
   * @borrows Tech.registerTech as registerTech
   * @borrows TextTrack as TextTrack
   * @borrows VideoTrack as VideoTrack
   *
   * @param  {string|Element} id
   *         Video element or video element ID.
   *
   * @param  {Object} [options]
   *         Options object for providing settings.
   *         See: [Options Guide](https://docs.videojs.com/tutorial-options.html).
   *
   * @param  {PlayerReadyCallback} [ready]
   *         A function to be called when the {@link Player} and {@link Tech} are
   *         ready.
   *
   * @return {Player}
   *         The `videojs()` function returns a {@link Player|Player} instance.
   */
  function videojs(id, options, ready) {
    let player = videojs.getPlayer(id);
    if (player) {
      if (options) {
        log.warn(`Player "${id}" is already initialised. Options will not be applied.`);
      }
      if (ready) {
        player.ready(ready);
      }
      return player;
    }
    const el = typeof id === 'string' ? $('#' + normalizeId(id)) : id;
    if (!isEl(el)) {
      throw new TypeError('The element or ID supplied is not valid. (videojs)');
    }

    // document.body.contains(el) will only check if el is contained within that one document.
    // This causes problems for elements in iframes.
    // Instead, use the element's ownerDocument instead of the global document.
    // This will make sure that the element is indeed in the dom of that document.
    // Additionally, check that the document in question has a default view.
    // If the document is no longer attached to the dom, the defaultView of the document will be null.
    // If element is inside Shadow DOM (e.g. is part of a Custom element), ownerDocument.body
    // always returns false. Instead, use the Shadow DOM root.
    const inShadowDom = 'getRootNode' in el ? el.getRootNode() instanceof window__default["default"].ShadowRoot : false;
    const rootNode = inShadowDom ? el.getRootNode() : el.ownerDocument.body;
    if (!el.ownerDocument.defaultView || !rootNode.contains(el)) {
      log.warn('The element supplied is not included in the DOM');
    }
    options = options || {};

    // Store a copy of the el before modification, if it is to be restored in destroy()
    // If div ingest, store the parent div
    if (options.restoreEl === true) {
      options.restoreEl = (el.parentNode && el.parentNode.hasAttribute && el.parentNode.hasAttribute('data-vjs-player') ? el.parentNode : el).cloneNode(true);
    }
    hooks('beforesetup').forEach(hookFunction => {
      const opts = hookFunction(el, merge(options));
      if (!isObject(opts) || Array.isArray(opts)) {
        log.error('please return an object in beforesetup hooks');
        return;
      }
      options = merge(options, opts);
    });

    // We get the current "Player" component here in case an integration has
    // replaced it with a custom player.
    const PlayerComponent = Component.getComponent('Player');
    player = new PlayerComponent(el, options, ready);
    hooks('setup').forEach(hookFunction => hookFunction(player));
    return player;
  }
  videojs.hooks_ = hooks_;
  videojs.hooks = hooks;
  videojs.hook = hook;
  videojs.hookOnce = hookOnce;
  videojs.removeHook = removeHook;

  // Add default styles
  if (window__default["default"].VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
    let style = $('.vjs-styles-defaults');
    if (!style) {
      style = createStyleElement('vjs-styles-defaults');
      const head = $('head');
      if (head) {
        head.insertBefore(style, head.firstChild);
      }
      setTextContent(style, `
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: 56.25%
      }
    `);
    }
  }

  // Run Auto-load players
  // You have to wait at least once in case this script is loaded after your
  // video in the DOM (weird behavior only with minified version)
  autoSetupTimeout(1, videojs);

  /**
   * Current Video.js version. Follows [semantic versioning](https://semver.org/).
   *
   * @type {string}
   */
  videojs.VERSION = version;

  /**
   * The global options object. These are the settings that take effect
   * if no overrides are specified when the player is created.
   *
   * @type {Object}
   */
  videojs.options = Player.prototype.options_;

  /**
   * Get an object with the currently created players, keyed by player ID
   *
   * @return {Object}
   *         The created players
   */
  videojs.getPlayers = () => Player.players;

  /**
   * Get a single player based on an ID or DOM element.
   *
   * This is useful if you want to check if an element or ID has an associated
   * Video.js player, but not create one if it doesn't.
   *
   * @param   {string|Element} id
   *          An HTML element - `<video>`, `<audio>`, or `<video-js>` -
   *          or a string matching the `id` of such an element.
   *
   * @return {Player|undefined}
   *          A player instance or `undefined` if there is no player instance
   *          matching the argument.
   */
  videojs.getPlayer = id => {
    const players = Player.players;
    let tag;
    if (typeof id === 'string') {
      const nId = normalizeId(id);
      const player = players[nId];
      if (player) {
        return player;
      }
      tag = $('#' + nId);
    } else {
      tag = id;
    }
    if (isEl(tag)) {
      const {
        player,
        playerId
      } = tag;

      // Element may have a `player` property referring to an already created
      // player instance. If so, return that.
      if (player || players[playerId]) {
        return player || players[playerId];
      }
    }
  };

  /**
   * Returns an array of all current players.
   *
   * @return {Array}
   *         An array of all players. The array will be in the order that
   *         `Object.keys` provides, which could potentially vary between
   *         JavaScript engines.
   *
   */
  videojs.getAllPlayers = () =>
  // Disposed players leave a key with a `null` value, so we need to make sure
  // we filter those out.
  Object.keys(Player.players).map(k => Player.players[k]).filter(Boolean);
  videojs.players = Player.players;
  videojs.getComponent = Component.getComponent;

  /**
   * Register a component so it can referred to by name. Used when adding to other
   * components, either through addChild `component.addChild('myComponent')` or through
   * default children options  `{ children: ['myComponent'] }`.
   *
   * > NOTE: You could also just initialize the component before adding.
   * `component.addChild(new MyComponent());`
   *
   * @param {string} name
   *        The class name of the component
   *
   * @param {typeof Component} comp
   *        The component class
   *
   * @return {typeof Component}
   *         The newly registered component
   */
  videojs.registerComponent = (name, comp) => {
    if (Tech.isTech(comp)) {
      log.warn(`The ${name} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`);
    }
    return Component.registerComponent.call(Component, name, comp);
  };
  videojs.getTech = Tech.getTech;
  videojs.registerTech = Tech.registerTech;
  videojs.use = use;

  /**
   * An object that can be returned by a middleware to signify
   * that the middleware is being terminated.
   *
   * @type {object}
   * @property {object} middleware.TERMINATOR
   */
  Object.defineProperty(videojs, 'middleware', {
    value: {},
    writeable: false,
    enumerable: true
  });
  Object.defineProperty(videojs.middleware, 'TERMINATOR', {
    value: TERMINATOR,
    writeable: false,
    enumerable: true
  });

  /**
   * A reference to the {@link module:browser|browser utility module} as an object.
   *
   * @type {Object}
   * @see  {@link module:browser|browser}
   */
  videojs.browser = browser;

  /**
   * A reference to the {@link module:obj|obj utility module} as an object.
   *
   * @type {Object}
   * @see  {@link module:obj|obj}
   */
  videojs.obj = Obj;

  /**
   * Deprecated reference to the {@link module:obj.merge|merge function}
   *
   * @type {Function}
   * @see {@link module:obj.merge|merge}
   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.obj.merge instead.
   */
  videojs.mergeOptions = deprecateForMajor(9, 'videojs.mergeOptions', 'videojs.obj.merge', merge);

  /**
   * Deprecated reference to the {@link module:obj.defineLazyProperty|defineLazyProperty function}
   *
   * @type {Function}
   * @see {@link module:obj.defineLazyProperty|defineLazyProperty}
   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.obj.defineLazyProperty instead.
   */
  videojs.defineLazyProperty = deprecateForMajor(9, 'videojs.defineLazyProperty', 'videojs.obj.defineLazyProperty', defineLazyProperty);

  /**
   * Deprecated reference to the {@link module:fn.bind_|fn.bind_ function}
   *
   * @type {Function}
   * @see {@link module:fn.bind_|fn.bind_}
   * @deprecated Deprecated and will be removed in 9.0. Please use native Function.prototype.bind instead.
   */
  videojs.bind = deprecateForMajor(9, 'videojs.bind', 'native Function.prototype.bind', bind_);
  videojs.registerPlugin = Plugin.registerPlugin;
  videojs.deregisterPlugin = Plugin.deregisterPlugin;

  /**
   * Deprecated method to register a plugin with Video.js
   *
   * @deprecated Deprecated and will be removed in 9.0. Use videojs.registerPlugin() instead.
   *
   * @param {string} name
   *        The plugin name
  *
   * @param {typeof Plugin|Function} plugin
   *         The plugin sub-class or function
   *
   * @return {typeof Plugin|Function}
   */
  videojs.plugin = (name, plugin) => {
    log.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');
    return Plugin.registerPlugin(name, plugin);
  };
  videojs.getPlugins = Plugin.getPlugins;
  videojs.getPlugin = Plugin.getPlugin;
  videojs.getPluginVersion = Plugin.getPluginVersion;

  /**
   * Adding languages so that they're available to all players.
   * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`
   *
   * @param {string} code
   *        The language code or dictionary property
   *
   * @param {Object} data
   *        The data values to be translated
   *
   * @return {Object}
   *         The resulting language dictionary object
   */
  videojs.addLanguage = function (code, data) {
    code = ('' + code).toLowerCase();
    videojs.options.languages = merge(videojs.options.languages, {
      [code]: data
    });
    return videojs.options.languages[code];
  };

  /**
   * A reference to the {@link module:log|log utility module} as an object.
   *
   * @type {Function}
   * @see  {@link module:log|log}
   */
  videojs.log = log;
  videojs.createLogger = createLogger;

  /**
   * A reference to the {@link module:time|time utility module} as an object.
   *
   * @type {Object}
   * @see {@link module:time|time}
   */
  videojs.time = Time;

  /**
   * Deprecated reference to the {@link module:time.createTimeRanges|createTimeRanges function}
   *
   * @type {Function}
   * @see {@link module:time.createTimeRanges|createTimeRanges}
   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.createTimeRanges instead.
   */
  videojs.createTimeRange = deprecateForMajor(9, 'videojs.createTimeRange', 'videojs.time.createTimeRanges', createTimeRanges);

  /**
   * Deprecated reference to the {@link module:time.createTimeRanges|createTimeRanges function}
   *
   * @type {Function}
   * @see {@link module:time.createTimeRanges|createTimeRanges}
   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.createTimeRanges instead.
   */
  videojs.createTimeRanges = deprecateForMajor(9, 'videojs.createTimeRanges', 'videojs.time.createTimeRanges', createTimeRanges);

  /**
   * Deprecated reference to the {@link module:time.formatTime|formatTime function}
   *
   * @type {Function}
   * @see {@link module:time.formatTime|formatTime}
   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.format instead.
   */
  videojs.formatTime = deprecateForMajor(9, 'videojs.formatTime', 'videojs.time.formatTime', formatTime);

  /**
   * Deprecated reference to the {@link module:time.setFormatTime|setFormatTime function}
   *
   * @type {Function}
   * @see {@link module:time.setFormatTime|setFormatTime}
   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.setFormat instead.
   */
  videojs.setFormatTime = deprecateForMajor(9, 'videojs.setFormatTime', 'videojs.time.setFormatTime', setFormatTime);

  /**
   * Deprecated reference to the {@link module:time.resetFormatTime|resetFormatTime function}
   *
   * @type {Function}
   * @see {@link module:time.resetFormatTime|resetFormatTime}
   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.resetFormat instead.
   */
  videojs.resetFormatTime = deprecateForMajor(9, 'videojs.resetFormatTime', 'videojs.time.resetFormatTime', resetFormatTime);

  /**
   * Deprecated reference to the {@link module:url.parseUrl|Url.parseUrl function}
   *
   * @type {Function}
   * @see {@link module:url.parseUrl|parseUrl}
   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.url.parseUrl instead.
   */
  videojs.parseUrl = deprecateForMajor(9, 'videojs.parseUrl', 'videojs.url.parseUrl', parseUrl);

  /**
   * Deprecated reference to the {@link module:url.isCrossOrigin|Url.isCrossOrigin function}
   *
   * @type {Function}
   * @see {@link module:url.isCrossOrigin|isCrossOrigin}
   * @deprecated Deprecated and will be removed in 9.0. Please use videojs.url.isCrossOrigin instead.
   */
  videojs.isCrossOrigin = deprecateForMajor(9, 'videojs.isCrossOrigin', 'videojs.url.isCrossOrigin', isCrossOrigin);
  videojs.EventTarget = EventTarget;
  videojs.any = any;
  videojs.on = on;
  videojs.one = one;
  videojs.off = off;
  videojs.trigger = trigger;

  /**
   * A cross-browser XMLHttpRequest wrapper.
   *
   * @function
   * @param    {Object} options
   *           Settings for the request.
   *
   * @return   {XMLHttpRequest|XDomainRequest}
   *           The request object.
   *
   * @see      https://github.com/Raynos/xhr
   */
  videojs.xhr = XHR__default["default"];
  videojs.TextTrack = TextTrack;
  videojs.AudioTrack = AudioTrack;
  videojs.VideoTrack = VideoTrack;
  ['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(k => {
    videojs[k] = function () {
      log.warn(`videojs.${k}() is deprecated; use videojs.dom.${k}() instead`);
      return Dom[k].apply(null, arguments);
    };
  });
  videojs.computedStyle = deprecateForMajor(9, 'videojs.computedStyle', 'videojs.dom.computedStyle', computedStyle);

  /**
   * A reference to the {@link module:dom|DOM utility module} as an object.
   *
   * @type {Object}
   * @see {@link module:dom|dom}
   */
  videojs.dom = Dom;

  /**
   * A reference to the {@link module:fn|fn utility module} as an object.
   *
   * @type {Object}
   * @see {@link module:fn|fn}
   */
  videojs.fn = Fn;

  /**
   * A reference to the {@link module:num|num utility module} as an object.
   *
   * @type {Object}
   * @see {@link module:num|num}
   */
  videojs.num = Num;

  /**
   * A reference to the {@link module:str|str utility module} as an object.
   *
   * @type {Object}
   * @see {@link module:str|str}
   */
  videojs.str = Str;

  /**
   * A reference to the {@link module:url|URL utility module} as an object.
   *
   * @type {Object}
   * @see {@link module:url|url}
   */
  videojs.url = Url;

  // The list of possible error types to occur in video.js
  videojs.Error = VjsErrors;

  var core = videojs;

  var core$1 = /*@__PURE__*/getDefaultExportFromCjs$1(core);

  exports.$ = jquery;
  exports.Hls = Hls;
  exports.dom_utils = dom;
  exports.jQuery = jquery;
  exports.utils = utils;
  exports.videojs = core$1;

  return exports;

})({});
//# sourceMappingURL=core.js.map
